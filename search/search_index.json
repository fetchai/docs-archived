{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fetch.ai Ecosystem","text":""},{"location":"#what-is-fetchai","title":"What is Fetch.ai?","text":"<p>Our mission is to build the infrastructure required for developing modern, decentralized and peer-to-peer (P2P) applications that are free from centralized rent-seeking.</p> <p>We achieve this by providing open-source software tools which you can use together with our interoperable decentralized network, to harness the power of AI and automation, and carry out complex tasks in the digital economy.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>The fetch ecosystem is made up of various tools and frameworks that help you build and jump-start your very own decentralized applications. Select one below to dive right in!</p> <p>User facing tools</p> AEA Registry AEA Manager Fetch Wallet Explorer <p>Tools that use the chain</p>                      AEAFramework                      ACN \u03bcAgents <p>Tools to directly interact with the chain</p> CosmPy Jenesis <p>The chain</p>                      Ledger                      Cosmwasm <p>You can also jump straight into our GitHub repos:</p> <ul> <li>Fetch Wallet</li> <li>AEA Framework (&amp; ACN)</li> <li>\u03bcAgents</li> <li>CosmPy</li> <li>Jenesis</li> <li>Ledger (fetchd)</li> </ul>"},{"location":"#bug-reports-feature-requests","title":"Bug Reports &amp; Feature Requests","text":"<p>If you want to report a bug or request a feature:</p> <ul> <li>AEA Framework</li> <li>\u03bcAgents</li> <li>Cosmpy</li> <li>Jenesis</li> <li>Ledger (fetchd)</li> <li>Documentation</li> </ul> <p>Want to report a security vulnerability? Visit our Bug Bounty.</p>"},{"location":"#questions-general-discussions","title":"Questions &amp; General Discussions","text":"<p>Visit fetch.ai developer forums:</p> <ul> <li>Fetch Wallet</li> <li>AEA Framework</li> <li>\u03bcAgents</li> <li>CosmPy</li> <li>Jenesis</li> <li>Ledger (fetchd)</li> </ul> <p>Chat with Fetch.ai developers on discord.</p>"},{"location":"bug_bounty/","title":"Bug Bounty Program","text":"<p>The Fetch bug bounty program provides incentives for developers and security experts to report vulnerabilities in the Fetch ecosystem. </p> <p>The Fetch team has undertaken risk mitigation measures to limit the potential impacts of bugs or intentional misuse of the software and to ensure that all software has been internally audited and thoroughly tested. </p> <p>In addition to the implemented safety measures, we are offering a bug bounty for the core components of the Fetch ecosystem as outlined under the Scope section below. The bug bounty program ensures that the software lives up to the highest standards possible and that the risk of users losing funds is at a minimum.</p>"},{"location":"bug_bounty/#scope","title":"Scope","text":"<p>The scope of the bounty program extends to:</p> <ul> <li>FetchD: https://github.com/fetchai/fetchd</li> <li>Fetch Wallet: https://github.com/fetchai/fetch-wallet</li> <li>The Block Explorer: https://github.com/fetchai/cosmos-explorer</li> <li>Documentation:: https://github.com/fetchai/docs</li> <li>CosmPy: https://github.com/fetchai/cosmpy</li> <li>AEA Framework, including the ACN and packages authored by Fetchai: https://github.com/fetchai/agents-aea and https://pypi.org/project/aea</li> <li>AEA Manager Website: https://github.com/fetchai/agents-manager-app-site</li> </ul>"},{"location":"bug_bounty/#classification","title":"Classification","text":""},{"location":"bug_bounty/#critical-bugs-awards-up-to-20000-fet-tokens","title":"Critical Bugs (awards up to 20,000 FET tokens)","text":"<p>Critical bugs are those that result in loss of funds or lead to a lack of availability of the network. This may be as a result of vulnerabilities found in the deployed and supported versions of the blockchain client, smart contracts or any of the other software outlined within the Scope section.</p>"},{"location":"bug_bounty/#non-critical-bugs-awards-up-to-10000-fet-tokens","title":"Non-critical Bugs (awards up to 10,000 FET tokens)","text":"<p>Non-critical bugs are those that cannot cause loss of funds or any other type of economic loss. These types of bugs affect the experience of developers or users of the network and have a perceived or Fetch suggested workaround.</p> <p>Awards are issued subject to reclassification and verification by the Fetch team.</p>"},{"location":"bug_bounty/#how-to-report","title":"How to Report","text":"<p>Please follow the steps listed below to report your bug:</p> <ul> <li>In an email, describe the issue clearly with reference to the underlying source code and indicate whether the bug is Critical or Non-critical.</li> <li>Attach all relevant information that is required to reproduce the bug in a test environment.</li> <li>Include the relevant version information associated with the faulty software of the components along with any other relevant system information such as OS versions.</li> <li>Include suggested solutions and/or mitigations (if known).</li> <li>Send this email to bounty@fetch.ai and start the subject with your classification Critical or Non-critical followed by a short title of the bug.</li> </ul> <p>The Fetch team will review your information and your classification of the bug. After reviewing, one of the Fetch developers will set out to reply within 2 working days to confirm whether the bug meets the requirements of the bug bounty program or to request more time to complete this assessment. The Fetch team will also post updates on the #bugs channel on our Discord server: https://discord.gg/M9XmgyWzup.</p> <p>For non-critical bugs, the Fetch team will create an issue or a pull request allowing you to follow the progress on the bug fix.</p> <p>For critical bugs that can result in loss of funds, it is important that the Fetch team has an opportunity to deploy a patched version before the exploit is acknowledged publicly. Hence, critical bugs and their fixes will be shared after the code is patched to prevent the targeting of such exploits.</p>"},{"location":"bug_bounty/#terms-and-conditions","title":"Terms and Conditions","text":"<p>These include, but are not limited to:</p> <ul> <li>Bounty awards are made at the sole discretion of Fetch.ai and are subject to change and verification. </li> <li>We will make every attempt to respond to all submissions promptly and to provide rewards in a timely manner but do not make any guarantees as to how long the processing of claims will take. </li> <li>All users warrant that they are legally able to receive bounties. More specifically: they are of the appropriate age, the work they are submitting is their own and that they are resident in a territory that allows payment of such rewards. </li> <li>Submitters must be willing to undergo any Know Your Customer (KYC) or Anti-Money Laundering (AML) checks as required.</li> <li>This program is not open to Fetch.ai employees or contractors, past or present. </li> <li>Fetch.ai reserves the right to alter or discontinue the Bug Bounty Program without notice.</li> </ul>"},{"location":"decentralisation/","title":"Decentralization","text":""},{"location":"decentralisation/#what-are-decentralized-systems","title":"What are Decentralized Systems?","text":"<p>A decentralized system is an interconnected system if no single entity (individual, organization, or group) is the sole authority. In a decentralized system, control and decision-making is in the hands of those participating in the system and they have (more or less) equal standing in terms of influence. This is in contrast to a centralized system where a single authority is above all others in terms of rights and privileges.</p> <p>A good example of a decentralized system is an ant colony, where control is distributed among the colony's members. Without any form of central control, an ant colony successfully achieves its goals, performs all its required tasks, and effectively responds to the ever changing conditions on the colony's environment through the collective contribution of the individual ants. </p> <p>Another great example is when you fly internationally from one place to another. There are numerous participants working together and communicating efficiently to make that a seamless experience without there being a central unit that manages and plans it all.</p> <p>There are two key characteristics of decentralized systems:</p> <ul> <li> <p>Equality of participants: all participants contribute towards the system's decision-making and control, and each of them takes an active role in managing the system.</p> </li> <li> <p>Lack of central authorities: It is not that decentralized systems lack the authority to make changes to the management of the network, rather this authority is distributed among the participants. The system is run by the participants for the benefit of the participants.</p> </li> </ul>"},{"location":"decentralisation/#decentralized-vs-distributed","title":"Decentralized vs Distributed","text":"<p>These are very easy to get confused, and sometimes it seems they are used interchangeably but they are actually quite different.</p> <p>A decentralized system is one where there is a lack of central authorities.</p> <p>A distributed system is a system in which the physical location of the participants, the servers, the nodes, and whatever other components involved are in different places. So instead of the system being physically all in one place, different parts of the system are located on physically different places and the processing of tasks are shared between them.</p> <p>The most obvious example of a distributed system is cloud computing, where tasks are shared among numerous computers or a database hosted on more than one computer.</p> <p>What determines whether a system is decentralized or not is whether or not there are central authorities. What determines whether a system is distributed is whether the processing is done in one or multiple physical locations.</p>"},{"location":"decentralisation/#decentralized-vs-centralized","title":"Decentralized vs Centralized","text":"<p>In a centralized system, there is a central authority that manages the system, makes decisions about how it is run and exercises control over the other components of the system. </p> <p>Some examples of centralized systems:</p> <ul> <li>Expedia: Hotel owners and people looking for hotel rooms connect to each other through Expedia, rather than communicating and transacting directly together.</li> <li>Messaging services such as WhatsApp: People communicate with each other through a centrally controlled and owned messaging service.</li> <li>Amazon: Buyers and sellers interact commercially through Amazon.</li> <li>Client-server model: Clients interact with each other only through the server, a great example of this is email where communication between two users goes through a server.  </li> </ul>"},{"location":"decentralisation/#why-are-decentralized-systems-useful","title":"Why are Decentralized Systems Useful?","text":"<p>Decentralized systems are useful because they are open and democratic, more transparent, and they are run solely in the interests of their participants by their participants.  </p>"},{"location":"decentralisation/#positive-characteristics","title":"Positive Characteristics","text":"<p>These are some of the key benefits of decentralized systems:</p> <ul> <li> <p>Democratic: Decentralized systems require participation in order to successfully function, and therefore they are naturally democratic.</p> </li> <li> <p>Open: Participants can freely join or leave as they wish. The system is open to new participants and does not stop existing ones leaving.</p> </li> <li> <p>Public: Because decentralized systems need to be managed and run by their participants (democratic) and anyone can in principle join the system or leave (open), these systems are often public and their inner workings are not kept confidential.</p> </li> <li> <p>Transparent: In order for the participants of a decentralized system to contribute to its liveliness, they must be made aware of how the system works, how it is managed, and so on. Decentralized systems therefore tend to be quite transparent.</p> </li> <li> <p>Trust Minimisation: The fact that in decentralized systems, participants do not have to go through central authorities to interact with others and achieve their goals means there is no need to trust central entities to handle your needs. Any guarantees needed by the system has to be provided by the system itself and the way it is designed, and (due to transparency) this is typically well known.</p> </li> </ul>"},{"location":"decentralisation/#limitations","title":"Limitations","text":"<p>Some of the limitations of decentralized systems:</p> <ul> <li> <p>Speed: Decentralized systems are often slower than centralized systems. Because there is more than one decision maker, decisions have to be made by consensus in the group and arriving at that consensus takes more time than a single entity making the decision. </p> </li> <li> <p>Efficiency: In decentralized systems, decision making about the system requires participation. This makes it far slower to make changes to the system as it takes time for participants to agree to changes. Also because the system is open, so participants can leave/join as they wish, then the system has to be designed to cope with an often changing number of participants. All this added complexity inevitably affects the efficiency of the system's operation.</p> </li> <li> <p>Control: Because a decentralized system is often run collectively by its participants, controlling how the system is managed and the direction of its development is difficult.</p> </li> <li> <p>Simplicity: For any system, it is often more complex to engineer a decentralized version with more than one decisions maker than a centralized one that achieves the same goals via central decision-makers and enforcers.</p> </li> </ul>"},{"location":"fund_form/","title":"Developer Fund","text":"The Developer Fund <p>       Following the announcement of a new development fund for growing the Fetch.ai       ecosystem, we are accepting applications from prospective projects, either       from Cosmos or EVM, to build upon the Fetch.ai network or scale using it's tools.     </p> <p>       Please fill the form below to apply for the developer grant.     </p> Name * Project/Company Name [If available] * Contact Email (if you're applying on behalf of a project or a           company, please enter the email of the main point of contact) * Project links [Please provide Github, Website, Twitter if           available] * Which category does your project fall under? * dApps On-chain analytics Automation DeFi Infrastructure NFTs Other: Project description [Please outline in detail the project you're           seeking to receive a grant for] * Have you received any funding previously? * Yes: No Please share any details on the project tokenomics [if           available] * What do you want to achieve through your project? * Project development timelines * Project Milestones * What is the funding amount you are looking for? Less than $50,000 Between $50,000 to $150,000 More than $150,000 Funding request breakdown [Please describe how the funds will be           used] * Additional attachments [Please share links - e.g dropbox/google           drive] *          Submit"},{"location":"CosmPy/","title":"Getting started","text":"<p>Cosmpy is a Python library for interacting with Cosmos-based blockchains.</p> <ul> <li>A simplified command line tool for querying and sending transactions to Cosmos-SDK blockchains. </li> <li>Features an easy interface for deploying and interacting with Cosmwasm smart contracts.</li> <li>Provides access to lower-level ledger APIs for advanced use-cases. </li> </ul>"},{"location":"CosmPy/#to-install","title":"To install","text":"<pre><code>pip3 install cosmpy\n</code></pre>"},{"location":"CosmPy/#version","title":"Version","text":"<p>.</p>"},{"location":"CosmPy/#repository","title":"Repository","text":"<pre><code>https://github.com/fetchai/cosmpy\n</code></pre>"},{"location":"CosmPy/#to-contribute","title":"To contribute","text":"<p>Clone the repo:</p> <pre><code>git clone https://github.com/fetchai/cosmpy.git --recursive &amp;&amp; cd cosmpy\n</code></pre> <p>Set up development environment:</p> <pre><code>make new_env_dev\n</code></pre> <p>This creates a new <code>pipenv</code> virtual environment and installs the development dependencies.</p> <p>Enter the virtual environment: </p> <pre><code>pipenv shell\n</code></pre>"},{"location":"CosmPy/auto-compounder/","title":"Stake Auto-Compounder","text":"<p>When an account delegates tokens to a network's validator, it will start generating rewards proportional to the amount of <code>Stake</code> delegated. But since rewards aren't automatically added to your stake and therefore don't contribute to future rewards, we can perform a compounding strategy to generate exponential rewards.</p>"},{"location":"CosmPy/auto-compounder/#delegate","title":"Delegate","text":"<p>The first thing we need to do is delegate some tokens to a <code>validator</code>. You can do so by using a <code>Wallet</code> and specifying the validator address and amount.</p> <pre><code>validators = ledger_client.query_validators()\n# choose any validator\nvalidator = validators[0]\nkey = PrivateKey(\"FX5BZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV7=\")\nwallet = LocalWallet(key)\n# delegate some tokens to this validator\ntx = ledger_client.delegate_tokens(validator.address, 9000000000000000000, wallet)\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/auto-compounder/#auto-compounder","title":"Auto Compounder","text":"<p>Then we can construct a code that claims rewards and delegates the rewarded tokens back to the <code>validator</code>. This way we keep growing our <code>Stake</code> and therefore we generate compounded rewards. We first need to define the <code>time limit</code> and the compounding <code>period</code>.</p> <p>It is important to note that each time an account performs a claim or a delegate transaction it has to pay certain fees, therefore the compounding period has to be long enough to generate sufficient rewards to exceed the fees that will be paid in each transaction.</p> <p><pre><code># set time limit and compounding period in seconds\ntime_limit = 600\nperiod = 100\n</code></pre> Finally, we start a timer that claims rewards and delegates them in each time period. Notice that in the code below we constructed a while loop that will be running until the timer exceeds the <code>time limit</code>. Each loop will last the time specified in <code>period</code>. We query the balance before and after claiming rewards to get the value of the reward after any fees. If the true reward value is positive, we delegate those tokens to the validator, if it is negative, it means that the fees from claiming and delegating transactions exceeded the rewards, and therefore we won't delegate.</p> <pre><code>time_check = 0\nstart_time = time.monotonic()\ntime.sleep(period)\n# query, claim and delegate rewards after time period\nwhile time_check &lt; time_limit:\nbegin = time.monotonic()\nsummary = ledger_client.query_staking_summary(wallet.address())\nprint(f\"Staked: {summary.total_staked}\")\nbalance_before = ledger_client.query_bank_balance(wallet.address())\ntx = ledger_client.claim_rewards(validator.address, wallet)\ntx.wait_to_complete()\nbalance_after = ledger_client.query_bank_balance(wallet.address())\n# reward after any fees\ntrue_reward = balance_after - balance_before\nif true_reward &gt; 0:\nprint(f\"Staking {true_reward} (reward after fees)\")\ntx = ledger_client.delegate_tokens(validator.address, true_reward, wallet)\ntx.wait_to_complete()\nelse:\nprint(\"Fees from claim rewards transaction exceeded reward\")\nend = time.monotonic()\ntime.sleep(period-(end-begin))\ntime_check = time.monotonic() - start_time\n</code></pre> <p>You can view the full python example at staking auto-compounder</p>"},{"location":"CosmPy/connect-to-network/","title":"Connect to a network","text":"<p>To start interacting with a blockchain, you first need to establish a connection to a network node. You can use <code>LedgerClient</code> as a client object which takes a <code>NetworkConfig</code> as an argument.</p> <pre><code>from cosmpy.aerial.client import LedgerClient, NetworkConfig\nledger_client = LedgerClient(NetworkConfig.fetch_mainnet())\n</code></pre> <p>For convenience, some networks' configurations are provided automatically. For example, <code>NetworkConfig.fetch_mainnet()</code> is the configuration for the Fetch ledger. If you want to interact with other chains, you can customise <code>NetworkConfig</code> as shown in the example below:</p> <pre><code>cfg = NetworkConfig(\nchain_id=\"cosmoshub-4\",\nurl=\"grpc+https://grpc-cosmoshub.blockapsis.com:429\",\nfee_minimum_gas_price=1,\nfee_denomination=\"uatom\",\nstaking_denomination=\"uatom\",\n)\nledger_client = LedgerClient(cfg)\n</code></pre> <p>A full list of chain identifiers, denominations and end-points can be found at the Cosmos chain registry.</p>"},{"location":"CosmPy/deploy-a-contract/","title":"Deploy a contract","text":"<p>You can deploy smart contracts in CosmPy using <code>LedgerContract</code>. For this, you will need the path to where the contract is stored (in this case <code>simple.wasm</code>), a <code>LedgerClient</code> and a <code>Wallet</code>:</p> <pre><code>from cosmpy.aerial.contract import LedgerContract\nPATH = \"contracts/simple/simple.wasm\"\ncontract = LedgerContract(PATH, ledger_client)\ncontract.deploy({}, wallet)\n</code></pre> <p>You can now start interacting with the contract. To get the address of where the contract is deployed on the network:</p> <pre><code>print(f\"Contract deployed at: {contract.address}\")\n</code></pre> <p>You can query the values of the contract's state variables: </p> <pre><code>result = contract.query({\"get\": {\"owner\": wallet}})\nprint(\"Initial state:\", result)\n</code></pre> <p>You can also set these values. The following sets the state variable <code>value</code> to <code>foobar</code>:</p> <pre><code>contract.execute({\"set\": {\"value\": \"foobar\"}}, wallet).wait_to_complete()\n</code></pre> <p>Let's check if this was set correctly:</p> <pre><code>result = contract.query({\"get\": {\"owner\": wallet)}})\nprint(\"State after set:\", result)\n</code></pre> <p>Similarly, you can clear the state variables:</p> <pre><code>contract.execute({\"clear\": {}}, wallet).wait_to_complete()\nresult = contract.query({\"get\": {\"owner\": wallet}})\nprint(\"State after clear:\", result)\n</code></pre>"},{"location":"CosmPy/liquidity-pool/","title":"Liquidity Pool","text":""},{"location":"CosmPy/liquidity-pool/#swap-tokens","title":"Swap Tokens","text":"<p>You can interact with a liquidity pool by swapping atestfet for CW20 tokens or vice versa. First, perform all the necessary imports:</p> <p><pre><code>import base64\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import LedgerContract\nfrom cosmpy.aerial.faucet import FaucetApi\nfrom cosmpy.aerial.wallet import LocalWallet\n</code></pre> Set the network configuration, define a local wallet and add some tokens to it using the FaucetApi</p> <p><pre><code># Network configuration\nledger = LedgerClient(NetworkConfig.latest_stable_testnet())\n# Define any wallet\nwallet = LocalWallet.generate()\n# Add tokens to wallet\nfaucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())\nfaucet_api.get_wealth(wallet.address())\n</code></pre> Define the CW20, pair, and liquidity token contracts with the following addresses:</p> <pre><code># Define cw20, pair and liquidity token contracts\ntoken_contract_address = (\n\"fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl\"\n)\npair_contract_address = (\n\"fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a\"\n)\nliq_token_contract_address = (\n\"fetch1alzhf9yhghud3qhucdjs895f3aek2egfq44qm0mfvahkv4jukx4qd0ltxx\"\n)\ntoken_contract = LedgerContract(\npath=None, client=ledger, address=token_contract_address\n)\npair_contract = LedgerContract(\npath=None, client=ledger, address=pair_contract_address\n)\nliq_token_contract = LedgerContract(\npath=None, client=ledger, address=liq_token_contract_address\n)\n</code></pre> <p>Swap the defined <code>swap_amount</code>of atestfet for CW20 tokens</p> <pre><code># Swap atestfet for CW20 tokens\nswap_amount = \"10000\"\nnative_denom = \"atestfet\"\ntx = pair_contract.execute(\n{\n\"swap\": {\n\"offer_asset\": {\n\"info\": {\"native_token\": {\"denom\": native_denom}},\n\"amount\": swap_amount,\n}\n}\n},\nsender=wallet,\nfunds=swap_amount + native_denom,\n)\ntx.wait_to_complete()\n</code></pre> <p>You can query your CW20 balance using the following code:</p> <pre><code>token_contract.query({\"balance\": {\"address\": str(wallet.address())}})\n</code></pre> <p>To trade 10 CW20 tokens for atestfet you can use the following:</p> <pre><code>tx = token_contract.execute({\n\"send\": {\n\"contract\": pair_contract_address,\n\"amount\": \"10\",\n\"msg\": \"eyJzd2FwIjp7fX0=\"\n}\n},wallet)\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/liquidity-pool/#add-and-remove-liquidity","title":"Add and Remove Liquidity","text":"<p>You need to increase your wallet's allowance to provide CW20 tokens to the liquidity pool. You don't need to increase the allowance to provide atestfet</p> <p><pre><code># Set the amount of CW20 tokens to be added to liquidity pool\ncw20_liquidity_amount = \"100\"\n# Increase allowance\ntx = token_contract.execute(\n{\n\"increase_allowance\": {\n\"spender\": pair_contract_address,\n\"amount\": cw20_liquidity_amount,\n\"expires\": {\"never\": {}},\n}\n},\nwallet,\n)\ntx.wait_to_complete()\n</code></pre> To set the amount of atestfet to be added to the liquidity pool and not influence the existing token prices, we need to choose an amount that matches the atestfet:CW20 token ratio already existing in the pool. For this reason, we will query the <code>pair_contract</code> pool to observe the atestfet:CW20 token ratio</p> <pre><code># Query Liquidity Pool\npair_contract.query({\"pool\": {}})\n</code></pre> <p>At the moment the code was run, the ratio was close to 247:10 atestfet:CW20, and since we defined above the amount of CW20 tokens to provide to the liquidity pool as 100, we will match the LP pool ratio by setting the atestfet amount as 2470. It will be difficult to exactly match the current ratio of the pool, but when adding liquidity to the pool, there is a slippage_tolerance parameter that allows a certain percentage change in the price.</p> <pre><code># Set the amount of atestfet tokens to be added to liquidity pool\nnative_liquidity_amount = \"2470\"\n# Provide Liquidity\n# Liquidity should be added so that the slippage tolerance parameter isn't exceeded\ntx = pair_contract.execute(\n{\n\"provide_liquidity\": {\n\"assets\": [\n{\n\"info\": {\"token\": {\"contract_addr\": token_contract_address}},\n\"amount\": cw20_liquidity_amount,\n},\n{\n\"info\": {\"native_token\": {\"denom\": native_denom}},\n\"amount\": native_liquidity_amount,\n},\n],\n\"slippage_tolerance\":\"0.1\"\n}\n},\nsender=wallet,\nfunds=native_liquidity_amount + native_denom,\n)\ntx.wait_to_complete()\n</code></pre> <p>When providing liquidity, you are rewarded with newly minted LP tokens. LP tokens represent the liquidity provider's share in the pool. You can burn your LP tokens to withdraw your share from the liquidity pool, for more information visit <code>Terraswap</code>. The following code shows how to withdraw your share from the LP.</p> <pre><code># Query your LP token balance to burn it all\nLP_token_balance = liq_token_contract.query({\"balance\": {\"address\": str(wallet.address())}})[\"balance\"]\n# Convert the withdrawal msg to base64\nwithdraw_msg = '{\"withdraw_liquidity\": {}}'\nwithdraw_msg_bytes = withdraw_msg.encode(\"ascii\")\nwithdraw_msg_base64 = base64.b64encode(withdraw_msg_bytes)\nmsg = str(withdraw_msg_base64)[2:-1]\n# Withdraw Liquidity\ntx = liq_token_contract.execute(\n{\n\"send\": {\n\"contract\": pair_contract_address,\n\"amount\": LP_token_balance,\n\"msg\": msg,\n}\n},\nsender=wallet,\n)\ntx.wait_to_complete()\n</code></pre> <p>You can now query you LP token balance to observe that it has gone down to zero</p> <pre><code>liq_token_contract.query({\"balance\": {\"address\": str(wallet.address())}})\n</code></pre> <p>You can also check the full code example at <code>liquidity-pool</code></p>"},{"location":"CosmPy/low-level-api/","title":"Low-level API","text":"<p>The Cosmpy library provides a high-level API which greatly simplifies the most common use cases when interacting with Cosmos-based chains (e.g. sending tokens, staking, deploying and interacting with contracts). There are documentation and example code covering such use cases.</p> <p>However, cosmpy also provides low-level access to the entire Cosmos-SDK, enabling the full gamut of functionality to be accessed, albeit with a little more boilerplate.</p> <p>Here, we aim to help developers navigate the low-level, protobuf-based API functionality, provided by Cosmpy.</p>"},{"location":"CosmPy/low-level-api/#recap-high-level-api-aerial","title":"Recap: High Level API - Aerial","text":"<p>As a reminder, here is a quick example of using the high level functionality provided by Cosmpy. In this case, we connect to a testnet, create a wallet, stake some tokens with a validator, then claim our rewards:</p> <pre><code>from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.keypairs import PrivateKey\nclient = LedgerClient(NetworkConfig.fetchai_dorado_testnet())\nwallet = LocalWallet(PrivateKey(\"rBDA3Q0vK5T+JVQmXSoooqUY/mSO4mmhMHQJI31+h1o=\"))\ntx = client.delegate_tokens(\"fetchvaloper1rsane988vksrgp2mlqzclmt8wucxv0ej4hrn2k\", 20, wallet)\ntx.wait_to_complete()\ntx = client.claim_rewards(\"fetchvaloper1rsane988vksrgp2mlqzclmt8wucxv0ej4hrn2k\", wallet)\ntx.wait_to_complete()\n</code></pre> <p>The available high-level helper functions provided by cosmpy can be found by browsing for instance the aerial client package.</p>"},{"location":"CosmPy/low-level-api/#low-level-api","title":"Low Level API","text":""},{"location":"CosmPy/low-level-api/#simple-messages","title":"Simple Messages","text":"<p>Not all Cosmos-SDK functionality is encapsulated in the high level aerial packages. In which case, it is necessary to locate and use the definition of the relevant protobuf message.</p> <p>Analogous to the rewards claim example above, what if a validator operator wanted to claim their commission? At the time of writing, there is no high-level API to achieve this, so the low level API must be used.</p> <p>In the protos directory, there is a MsgWithdrawValidatorCommission message, which is what we need. It takes a single <code>validator_address</code> parameter which is a <code>utf-8</code> string.</p> <p>To send a transaction containing such a message:</p> <pre><code>from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction\nfrom cosmpy.protos.cosmos.distribution.v1beta1.tx_pb2 import MsgWithdrawValidatorCommission\nfrom cosmpy.crypto.keypairs import PrivateKey\nclient = LedgerClient(NetworkConfig.fetchai_dorado_testnet())\nwallet = LocalWallet(PrivateKey(\"&lt;redacted&gt;private key of dorado validator0\"))\ntx = Transaction()\ntx.add_message(\nMsgWithdrawValidatorCommission(\nvalidator_address=\"fetchvaloper1rsane988vksrgp2mlqzclmt8wucxv0ej4hrn2k\"\n)\n)\ntx = prepare_and_broadcast_basic_transaction(client, tx, wallet)\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/low-level-api/#nested-messages","title":"Nested messages","text":"<p>The above example creates and broadcasts a simple <code>MsgWithdrawValidatorCommission</code> message. However, sometimes it is necessary to include one message in another. For example, what if we wanted to use the above message but execute it from a different account using <code>authz</code> (i.e. use an account which holds minimal funds, whose keys need not be treated with the same level of care as those of the validator itself)?</p> <p>In this case, we'll need to send an <code>authz</code> MsgExec message, which can be found in tx_pb2.py under <code>cosmos/authz</code> area of <code>cosmpy/protos</code>. This message takes two parameters. The <code>grantee</code> is a simple string address similar to the above. But the <code>msgs</code> field needs to support multiple types of messages and not just <code>MsgWithdrawValidatorCommission</code>.</p> <p>Protobuf is strongly typed, so to facilitate this flexibility, it is necessary to first pack the nested message into a <code>protobuf.Any</code> message.</p> <p>Therefore, we arrive at the code looking like:</p> <pre><code>from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.protos.cosmos.distribution.v1beta1.tx_pb2 import MsgWithdrawValidatorCommission\nfrom cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgExec\nfrom google.protobuf import any_pb2\nclient = LedgerClient(NetworkConfig.fetchai_dorado_testnet())\nwallet = LocalWallet(PrivateKey(\"rBDA3Q0vK5T+JVQmXSoooqUY/mSO4mmhMHQJI31+h1o=\"))\nmsg = any_pb2.Any()\nmsg.Pack(\nMsgWithdrawValidatorCommission(\nvalidator_address=\"fetchvaloper1rsane988vksrgp2mlqzclmt8wucxv0ej4hrn2k\"\n),\n\"\",\n)\ntx = Transaction()\ntx.add_message(MsgExec(grantee=str(wallet.address()), msgs=[msg]))\ntx = prepare_and_broadcast_basic_transaction(client, tx, wallet)\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/low-level-api/#more-protobuf-examples","title":"More protobuf examples","text":"<p>Before running the above, the necessary <code>authz</code> grant must first be put in place. For Ledger Nano users (other hardware wallets are also available) that might mean an excursion to the command line. For the Fetchai network using FetchD:</p> <pre><code>fetchd tx authz grant $(fetchd keys show grantee --output json | jq -r .address) generic --msg-type \"/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission\" --from=$(fetchd keys show grantor --output json | jq -r .address) --gas auto --gas-adjustment 1.5 --gas-prices 5000000000atestfet\n</code></pre> <p>By default, the above provides one year's worth of authorization to withdraw validator commission using accounts already present in the keyring.</p> <p>For those with access to their keys in python:</p> <pre><code>from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.protos.cosmos.distribution.v1beta1.tx_pb2 import MsgWithdrawValidatorCommission\nfrom cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgGrant\nfrom cosmpy.protos.cosmos.authz.v1beta1.authz_pb2 import GenericAuthorization, Grant\nfrom google.protobuf import any_pb2, timestamp_pb2\nfrom datetime import datetime, timedelta\nclient = LedgerClient(NetworkConfig.fetchai_dorado_testnet())\nwallet = LocalWallet(PrivateKey(\"rBDA3Q0vK5T+JVQmXSoooqUY/mSO4mmhMHQJI31+h1o=\"))\nvalidator = LocalWallet(PrivateKey(\"&lt;redacted&gt;private key of dorado validator0\"))\nauthz_any = any_pb2.Any()\nauthz_any.Pack(\nGenericAuthorization(\nmsg=\"/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission\"\n),\n\"\",\n)\nexpiry = timestamp_pb2.Timestamp()\nexpiry.FromDatetime(datetime.now() + timedelta(seconds=60))\ngrant = Grant(authorization=authz_any, expiration=expiry)\nmsg = MsgGrant(\ngranter=str(validator.address()),\ngrantee=str(wallet.address()),\ngrant=grant,\n)\ntx = Transaction()\ntx.add_message(msg)\ntx = prepare_and_broadcast_basic_transaction(client, tx, validator)\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/oracles/","title":"Oracles","text":"<p>Oracles are entities that can update state variables in smart contracts and whose goal is usually to accurately estimate or predict some real world quantity or quantities. These quantities can then be used in the logic of other smart contracts.</p> <p>This guide shows how to write a CosmPy script that deploys and updates an oracle contract with a coin price, and another script that deploys a contract that queries this coin price.</p>"},{"location":"CosmPy/oracles/#preliminaries","title":"Preliminaries","text":"<p>We will need the binaries for both contracts, which can be downloaded as follows: <pre><code>wget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle/build/oracle.wasm\nwget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle_client/build/oracle_client.wasm\n</code></pre></p> <p>The scripts also require the following imports: <pre><code>from time import sleep\nimport requests\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import LedgerContract\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.address import Address\nfrom cosmpy.crypto.keypairs import PrivateKey\n</code></pre></p>"},{"location":"CosmPy/oracles/#oracle-deployer-and-updater","title":"Oracle deployer and updater","text":"<p>We first choose a data source for the coin price, the update interval, and the decimal precision for the oracle value: <pre><code>COIN_PRICE_URL = (\n\"https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&amp;vs_currencies=usd\"\n)\nUPDATE_INTERVAL_SECONDS = 10\nORACLE_VALUE_DECIMALS = 5\n</code></pre></p> <p>Next, we create a wallet and ledger interface to interact with the latest stable testnet: <pre><code>wallet = LocalWallet(PrivateKey(\"T7w1yHq1QIcQiSqV27YSwk+i1i+Y4JMKhkpawCQIh6s=\"))\nledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())\n</code></pre></p> <p>Create the <code>LedgerContract</code> object: <pre><code>contract = LedgerContract(\"oracle.wasm\", ledger)\n</code></pre></p> <p>To deploy the oracle contract, add the fee amount to the instantiation message and call the <code>deploy</code> function: <pre><code>instantiation_message = {\"fee\": \"100\"}\ncontract.deploy(instantiation_message, wallet, funds=\"1atestfet\")\nprint(f\"Oracle contract deployed at: {contract.address}\")\n</code></pre></p> <p>Save the oracle contract address to use for the oracle client script below (<code>ORACLE_CONTRACT_ADDRESS</code>).</p> <p>As the deployer of the contract, we have permission to grant the oracle to a particular address. In this case, we'll grant the oracle role to our own wallet: <pre><code>grant_role_message = {\"grant_oracle_role\": {\"address\": wallet)}}\ncontract.execute(grant_role_message, wallet).wait_to_complete()\n</code></pre></p> <p>Finally, start updating the contract with the coin price retrieved from the <code>COIN_PRICE_URL</code>: <pre><code>while True:\nresp = requests.get(COIN_PRICE_URL).json()\nprice = resp[\"fetch-ai\"][\"usd\"]\nvalue = int(price * 10**ORACLE_VALUE_DECIMALS)\nupdate_message = {\n\"update_oracle_value\": {\n\"value\": str(value),\n\"decimals\": str(ORACLE_VALUE_DECIMALS),\n}\n}\ncontract.execute(update_message, wallet).wait_to_complete()\nprint(f\"Oracle value updated to: {price} USD\")\nprint(f\"Next update in {UPDATE_INTERVAL_SECONDS} seconds...\")\nsleep(UPDATE_INTERVAL_SECONDS)\n</code></pre></p> <p>For the complete example script, see aerial_oracle.py.</p>"},{"location":"CosmPy/oracles/#oracle-client","title":"Oracle client","text":"<p>Now we'll write a script that deploys a contract that can request the oracle value in exchange for the required fee.</p> <p>We again start by creating a wallet and ledger interface in a new terminal session: <pre><code>wallet = LocalWallet(PrivateKey(\"CI5AZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV8=\"))\nledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())\n</code></pre></p> <p>Set <code>ORACLE_CONTRACT_ADDRESS</code> to the address of the contract deployed in the previous script: <pre><code>ORACLE_CONTRACT_ADDRESS = \"contract_address_goes_here\"\n</code></pre></p> <p>Next, we define the contract object, set the oracle contract address in the instantiation message, and deploy the contract: <pre><code>contract = LedgerContract(\"oracle_client.wasm\", ledger)\ninstantiation_message = {\"oracle_contract_address\": str(ORACLE_CONTRACT_ADDRESS)}\ncontract.deploy(instantiation_message, wallet)\n</code></pre></p> <p>Finally, define a request interval and start a loop that executes the function that requests the oracle value: <pre><code>REQUEST_INTERVAL_SECONDS = 10\nwhile True:\nrequest_message = {\"query_oracle_value\": {}}\ncontract.execute(\nrequest_message, wallet, funds=\"100atestfet\"\n).wait_to_complete()\nresult = contract.query({\"oracle_value\": {}})\nprint(f\"Oracle value successfully retrieved: {result}\")\nsleep(REQUEST_INTERVAL_SECONDS)\n</code></pre></p> <p>For the complete example script, see aerial_oracle_client.py.</p>"},{"location":"CosmPy/query-balance/","title":"Querying balances","text":"<p>A  <code>LedgerClient</code> object can be used to query the balances associated with a particular address:</p> <pre><code>address: str = 'fetch12q5gw9l9d0yyq2th77x6pjsesczpsly8h5089x'\nbalances = ledger_client.query_bank_all_balances(address)\n</code></pre> <p>This will return a <code>List</code> of <code>Coin</code> objects that contain <code>amount</code> and  <code>denom</code> variables that correspond to all the funds held at the address and their denominations. This list includes all natively defined coins along with any tokens transferred using the inter-blockchain communication (IBC) protocol.  </p> <pre><code>&gt;&gt;&gt; balances\n[Coin(amount='29263221445595384075', denom='afet')]\n</code></pre> <p>It's also possible to query the funds associated with a particular denomination by calling  </p> <pre><code>balance = ledger_client.query_bank_balance(address, denom='afet')\n</code></pre> <p>which will return the value of the (integer) funds held by the address with the specified denomination. If the <code>denom</code> argument is omitted the function will return the fee denomination specified in the <code>NetworkConfig</code> object used to initialise the <code>LedgerClient</code>.</p>"},{"location":"CosmPy/send-tokens/","title":"Send tokens","text":"<p>Once you have your <code>wallet</code> configured, you can send transactions to the network. The <code>LedgerClient</code> object provides useful utilities to do common operations. The following example shows how to send <code>10</code> <code>atestfet</code> to another address:</p> <pre><code>destination_address = 'fetch1h2l3cnu7e23whmd5yrfeunacez9tv0plv5rxqy'\ntx = ledger_client.send_tokens(destination_address, 10, \"atestfet\", wallet)\n# block until the transaction has been successful or failed\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/stake-optimizer/","title":"Stake Optimizer","text":"<p>When you delegate tokens to a validator for a determined period, you can use the <code>auto-compounder</code> to get increasing rewards. You can maximize your rewards for a given staking period by selecting an optimal compounding period. To do this, you will need to follow these steps:</p> <ul> <li>Set and Query Variables: When calculating staking rewards, you need to set and query variables such as staking parameters, transaction fees, and network parameters</li> <li>Calculate Reward Rate: After you select and query all the variables needed, you will calculate the reward rate</li> <li>Calculate Optimal Compounding Period: You will calculate the optimal compounding period that will maximize your rewards</li> </ul> <p>First, you need to define a network to work with.</p> <pre><code>from cosmpy.aerial.client import LedgerClient\nfrom cosmpy.aerial.config import NetworkConfig\nledger = LedgerClient(NetworkConfig.fetchai_stable_testnet())\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#set-and-query-variables","title":"Set and Query Variables","text":""},{"location":"CosmPy/stake-optimizer/#staking-variables","title":"Staking Variables","text":"<p>First, we need to define the desired amount and the total period that we would like to stake in: <code>initial_stake</code> and <code>total_period</code> variables. Here we will stake 50 TESTFET for 60000 minutes. For this guide, we will work with minutes as a time unit.</p> <pre><code>initial_stake = 50000000000000000000\ntotal_period = 60000\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#validator-selection-and-variables","title":"Validator Selection and Variables","text":"<p>We will now select a validator to delegate our tokens. We will do this by analyzing which one has the lowest <code>commission</code> and a reasonable amount of stake delegated compared to the total stake.</p> <pre><code>from cosmpy.protos.cosmos.staking.v1beta1.query_pb2 import QueryValidatorsRequest\nreq = QueryValidatorsRequest()\nresp = ledger.staking.Validators(req)\n# Calculate the total stake currently in the testnet\n# Status = 3 means that the validator is bonded\nvalidators_stake = [int(validator.tokens) for validator in resp.validators if validator.status == 3]\ntotal_stake = sum(validators_stake)\n# For every bonded validator, we print commission and percentage of total stake\nprint(\"MONIKER      COMISSION   % of TOTAL STAKE\")\nfor validator in resp.validators:\nif validator.status == 3:\nmoniker = validator.description.moniker\ncomission = int(validator.commission.commission_rates.rate)/1e18*100\nprint(moniker[:10],\" \", comission,\"%     \", round(int(validator.tokens)/total_stake*100,3),\"%\")\n</code></pre> <p>After running the code above, you will observe each validator commission rate and its percentage delegated of the total stake. The most important parameter to observe in each validator is the commission it will take from the rewards. We will always select a validator with the lower commission as long as it has a reasonable stake compared with the total stake. In this case, at the moment the code was run, all validators had the same commission, therefore, we simply selected the validator with the highest stake, which was validator0. Feel free to select the most convenient validator when you run the code above. We will save the variables <code>commission</code> and the fraction of our <code>initial_stake</code> to the total stake to use them later on.</p> <pre><code># get all the active validators on the network\nvalidators = ledger.query_validators()\n# Query info of selected validator\nselected_validator = \"validator0\"\nvalidator = [v for v in validators if v.moniker == selected_validator][0]\nquery_validator = [v for v in resp.validators if v.description.moniker == selected_validator][0]\n# Set the comission %\ncommission = int(query_validator.commission.commission_rates.rate)/1e18\n# Set percentage delegated of total stake\npct_delegated = initial_stake/total_stake\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#estimate-transaction-fees","title":"Estimate Transaction Fees","text":"<p>We need to know an estimate of the transaction fees it will cost every time we claim rewards and delegate tokens. For that, both claim rewards and delegate tokens transactions were combined into a single multi-msg transaction to simulate the total fees.</p> <p><pre><code>from cosmpy.aerial.client.distribution import create_withdraw_delegator_reward\nfrom cosmpy.aerial.client.staking import create_delegate_msg\nfrom cosmpy.aerial.tx import SigningCfg\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.crypto.address import Address\nfrom cosmpy.aerial.tx import Transaction\n# Use any address with at least the amount of initial_stake available\nkey = PrivateKey(\"XZ5BZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV7=\")\nalice = LocalWallet(key)\nalice_address = Address(key)._display\ntx = Transaction()\n# Add delegate msg\ntx.add_message(create_delegate_msg(alice_address,validator.address,initial_stake,\"atestfet\"))\n# Add claim reward msg\ntx.add_message(create_withdraw_delegator_reward(alice_address, validator.address))\naccount = ledger.query_account(alice.address())\ntx.seal(SigningCfg.direct(alice.public_key(), account.sequence),fee=\"\",gas_limit=0)\ntx.sign(alice.signer(), ledger.network_config.chain_id, account.number)\ntx.complete()\n# simulate the fee for the transaction\n_, str_tx_fee = ledger.estimate_gas_and_fee_for_tx(tx)\n</code></pre> Since the output of this function is a string, we will convert it to an int and round it up to get a more conservative estimate for the <code>fee</code></p> <pre><code>denom = \"atestfet\"\ntx_fee = str_tx_fee[:-len(denom)]\n# Add a 20% to the fee estimation to get a more conservative estimate\nfee = int(tx_fee) * 1.20\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#query-network-variables","title":"Query Network Variables","text":"<p>There are three network variables that we need to query since they will contribute to the staking rewards calculation: <code>total_supply</code>, <code>inflation</code> and <code>community_tax</code></p> <pre><code># Total Supply of tokens\nreq = QueryTotalSupplyRequest()\nresp = ledger.bank.TotalSupply(req)\ntotal_supply = float(json.loads(resp.supply[0].amount))\n# Inflation\nreq = QueryParamsRequest(subspace=\"mint\", key=\"InflationRate\") \nresp = ledger.params.Params(req)\ninflation = float(json.loads(resp.param.value))\n# Community Tax\nreq = QueryParamsRequest(subspace=\"distribution\", key=\"communitytax\") \nresp = ledger.params.Params(req)\ncommunity_tax = float(json.loads(resp.param.value))\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#calculate-reward-rate","title":"Calculate Reward Rate","text":"<p>We can now proceed to calculate a theoretical staking rewards rate using the variables gathered above. These are: <code>inflation</code>, <code>total_supply</code>, <code>pct_delegated</code>, <code>community_tax</code> and <code>commission</code></p> <pre><code># Calculate annual reward\nanual_reward = (inflation * total_supply) *pct_delegated* (1- community_tax)*(1- commission)\n# Convert from annual reward to minute reward\nminute_reward = anual_reward/360/24/60\n# Set the rate\nrate = minute_reward/initial_stake\n</code></pre>"},{"location":"CosmPy/stake-optimizer/#calculate-optimal-compounding-period","title":"Calculate Optimal Compounding Period","text":"<p>We can calculate the optimal compounding period that maximizes our staking rewards analytically by using the following formula.</p> <p></p> <p>Where:</p> <p>M  = Total stake at time D</p> <p>S= Initial Stake \\ f = Transaction Fee \\ k = Reward Rate</p> <p>m = Number Of Compounding Transactions \\ n = Compounding Period</p> <p>D = m x n = Total Staking Time</p> <p>We will now find the value that maximizes reward by taking the first derivative with respect to n and finding the root in the interval (0,D]</p> <p><pre><code>import numpy as np\nfrom sympy.utilities.lambdify import lambdify, implemented_function\nfrom sympy import *\nfrom scipy.optimize import brentq\nf = fee\nS = initial_stake\nk = rate\nD = total_period\n# x will represent n\nx = Symbol(\"x\")\n# Define the function\nM = (S*(1+(k*x))**(D/x))+((1-((1+(k*x))**(D/x)))/(k*x))*f\nMx = lambdify(x,M)\n# Take the first derivative with respect to x\nM_prime = M.diff(x)\nMx_prime = lambdify(x,M_prime)\n# Find the maximum reward value by finding the root of the function\noptimal_period = brentq(Mx_prime, 0.1, D)\nprint(\"optimal_period: \", analytical_optimal_period, \" minutes\")\n</code></pre> You can make use of the <code>optimal_period</code> value in the <code>staking auto-compounder</code> to maximize your rewards</p> <p>You can also plot the function along with the optimal period to observe the results</p> <pre><code>import matplotlib.pyplot as plt\nplot = plt.figure(0,figsize=(6,4), dpi=100)\ny = np.linspace(1,300, 100)\nplt.plot(y,Mx(y),\"k\", label = 'analytical function')\nplt.axvline(x = optimal_period, color = 'g', linewidth = 2, label = f'optimal period: {round(optimal_period)}')\nplt.legend()\nplt.xlabel(\"Compounding periods\")\nplt.ylabel('Total Reward')\nplt.title('Maximizing Rewards')\nplt.grid()\n</code></pre> <p></p> <p>Finally, we can compare the compounding staking rewards to a simple non-compounding strategy</p> <p><pre><code># Compounding Strategy\ncomp_rewards = []\nrewards = 0\nperiod = optimal_period\nS = initial_stake\nfor i in range(total_period):\nrewards = rewards + (S*rate)\nif i%period == 0:\nS = S + rewards - fee\nrewards = 0\ncomp_rewards.append(S)\nS = S + rewards - (fee/2)\ncomp_rewards.append(S)\n# Simple Strategy\ns_reward = initial_stake*rate\nsimple_rewards = [initial_stake+(s_reward*i) for i in range(comp_period)]\n# Plots\nplot = plt.figure(0,figsize=(12,4), dpi=100)\nplt.subplot(1,2,1)\nplt.plot(comp_rewards, label = \"Compounded Rewards\")\nplt.plot(simple_rewards, label = \"Simple Rewards\")\nplt.xlabel(\"time in minutes\")\nplt.ylabel('Reward')\nplt.title('Staking Rewards')\nplt.legend()\nplt.subplot(1,2,2)\nplt.plot(total_rewards, label = \"Compounded Rewards\")\nplt.plot(simple_rewards, label = \"Simple Rewards\")\nplt.xlabel(\"time in minutes\")\nplt.ylabel('Reward')\nplt.title('Staking Rewards (log scale)')\nplt.legend()\nplt.yscale('log')\n</code></pre> </p> <p>You can view an abbreviated version of the code at <code>stake optimizer</code></p>"},{"location":"CosmPy/staking/","title":"Staking","text":"<p>A big part of the cosmos networks is staking. Staking is the process where you delegate your tokens to the network's validators in order to secure the network. There are three main actions you can take when staking:</p> <ul> <li>Delegating: This is the process where you send your tokens to a chosen validator. They are applied immediately and you start earning rewards as soon as this transaction completes. The more tokens you stake, the more rewards you will earn.</li> <li>Redelegating: This is the process where you transfer your staked tokens from one validator to another. This can be for many reasons, such as better returns, more trustworthiness, etc.</li> <li>Undelegating: While your tokens are staked, you cannot spend them or send them to other users. To regain access to them, you must undelegate them. When you initiate this process, the funds will be removed from the validator they were delegated to, and must be left to cool down for a period of time (for example 21 days). After this period, the funds are automatically released into the user's wallet.</li> </ul>"},{"location":"CosmPy/staking/#actions","title":"Actions","text":"<p><code>LedgerClient</code> provides useful utilities for interacting with the staking component of the network.</p> <p>Note</p> <p>For simplicity, the staking methods do not have an option for specifying the <code>denom</code> field. This is because in almost all networks, there is only one staking denomination. Therefore, the denomination used is the one specified in the <code>NetworkConfig</code> supplied to the <code>LedgerClient</code> object.</p>"},{"location":"CosmPy/staking/#delegate","title":"Delegate","text":"<p>To stake <code>20</code> tokens with the specific validator using a <code>Wallet</code>:</p> <pre><code>validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'\ntx = ledger_client.delegate_tokens(validator_address, 20, wallet)\n# block until the transaction has been successful or failed\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/staking/#redelegate","title":"Redelegate","text":"<p>To redelegate <code>10</code> tokens from an existing validator (with the address <code>validator_address</code>) to another (with the address <code>alternate_validator_address</code>):</p> <pre><code>validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'\nalternate_validator_address = 'fetchvaloper1e4ykjwcwhwtasqxq50d4m7xz9hh7a86e9y8h87'\ntx = ledger_client.redelegate_tokens(validator_address, alternate_validator_address, 10, wallet)\n# block until the transaction has been successful or failed\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/staking/#undelegate","title":"Undelegate","text":"<p>To undelegate <code>5</code> tokens and start the cool down process:</p> <pre><code>tx = ledger_client.undelegate_tokens(validator_address, 5, wallet)\n# block until the transaction has been successful or failed\ntx.wait_to_complete()\n</code></pre> <p>Note</p> <p>The cool down is tracked for each invocation of undelegate action. So for example if you trigger 3 undelegate actions on 3 consecutive days. The first batch of tokens will become available 3 days before the final batch.</p>"},{"location":"CosmPy/staking/#claiming-rewards","title":"Claiming Rewards","text":"<p>While your funds are staked, you are earning rewards on them. Rewards can be collected at any time and unlike delegations, when collected they become immediately available.</p> <p>To claim rewards from a specific validator: </p> <pre><code>tx = ledger_client.claim_rewards(validator_address, wallet)\n# block until the transaction has been successful or failed\ntx.wait_to_complete()\n</code></pre>"},{"location":"CosmPy/staking/#queries","title":"Queries","text":""},{"location":"CosmPy/staking/#stake-summary","title":"Stake Summary","text":"<p>At any point you can query the stake information of any particular address. This can be done using the <code>LedgerClient</code> as shown in the example below:</p> <pre><code>address = 'fetch1h2l3cnu7e23whmd5yrfeunacez9tv0plv5rxqy'\ns = ledger_client.query_staking_summary(address)\nprint(f\"Summary: Staked: {s.total_staked} Unbonding: {s.total_unbonding} Rewards: {s.total_rewards}\")\n</code></pre>"},{"location":"CosmPy/swap-automation/","title":"Swap Automation","text":"<p>A mean-reversion strategy expects the prices to return to \u201cnormal\u201d levels or a certain moving average following a temporary price spike. We can construct a similar strategy using the Liquidity Pool, where we will set upper and lower bound prices that will trigger a sell and a buy transaction respectively. If the behavior of the LP prices works as expected always returning to a certain moving average, we could profit by selling high and buying low. We will do this by swapping atestfet and CW20 with the Liquidity Pool, we refer to a sell transaction when we sell atestfet and get CW20 tokens, a buy transaction would be exactly the opposite.</p> <p>The code will require the following imports:</p> <pre><code>from time import sleep\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import LedgerContract\nfrom cosmpy.aerial.faucet import FaucetApi\nfrom cosmpy.aerial.wallet import LocalWallet\n</code></pre> <p>We will define the swap_native_for_cw20 function that trades <code>swap_amount</code> of atestfet from <code>wallet</code> for CW20 tokens by executing a <code>pair_contract</code>:</p> <p><pre><code>def swap_native_for_cw20(swap_amount, pair_contract, wallet):\ntx = pair_contract.execute({\n\"swap\": {\n\"offer_asset\": {\n\"info\": {\n\"native_token\": {\n\"denom\": \"atestfet\"\n}\n},\n\"amount\": str(swap_amount)\n}\n}\n},sender= wallet, funds= str(swap_amount) + \"atestfet\")\nprint(\"swapping native for cw20 tokens\")\ntx.wait_to_complete()\n</code></pre> Now, we will define the swap_cw20_for_native function that does exactly the opposite of the function defined above: trades <code>swap_amount</code> of CW20 tokens from <code>wallet</code> for atestfet. This time the CW20 <code>token_contract</code> is executed using the <code>pair_contract_address</code>. Finally, you need to include the {\"swap\":{}} message in the \"msg\" field. However, this swap message has to be encoded into base64. When you encode {\"swap\":{}} message into base64 you get: eyJzd2FwIjp7fX0=</p> <p><pre><code>def swap_cw20_for_native(swap_amount, pair_contract_address, token_contract, wallet):\ntx = token_contract.execute({\n\"send\": {\n\"contract\": pair_contract_address,\n\"amount\": str(swap_amount),\n\"msg\": \"eyJzd2FwIjp7fX0=\"\n}\n},wallet)\nprint(\"swapping cw20 for native tokens\")\ntx.wait_to_complete()\n</code></pre> Set the network configuration, define a local wallet and add some tokens to it using the FaucetApi</p> <p><pre><code># Define any wallet\nwallet =  LocalWallet.generate()\n# Network configuration\nledger = LedgerClient(NetworkConfig.latest_stable_testnet())\n# Add tokens to wallet\nfaucet_api = FaucetApi(NetworkConfig.latest_stable_testnet())\nwallet_balance = ledger.query_bank_balance(wallet.address())\nwhile wallet_balance &lt; (10**18):\nprint(\"Providing wealth to wallet...\")\nfaucet_api.get_wealth(wallet.address())\nwallet_balance = ledger.query_bank_balance(wallet.address())\n</code></pre> Define the CW20, pair, and liquidity token contracts with the following addresses:</p> <pre><code># Define cw20, pair and liquidity token contracts\ntoken_contract_address = (\n\"fetch1qr8ysysnfxmqzu7cu7cq7dsq5g2r0kvkg5e2wl2fnlkqss60hcjsxtljxl\"\n)\npair_contract_address = (\n\"fetch1vgnx2d46uvyxrg9pc5mktkcvkp4uflyp3j86v68pq4jxdc8j4y0s6ulf2a\"\n)\nliq_token_contract_address = (\n\"fetch1alzhf9yhghud3qhucdjs895f3aek2egfq44qm0mfvahkv4jukx4qd0ltxx\"\n)\ntoken_contract = LedgerContract(\npath=None, client=ledger, address=token_contract_address\n)\npair_contract = LedgerContract(\npath=None, client=ledger, address=pair_contract_address\n)\nliq_token_contract = LedgerContract(\npath=None, client=ledger, address=liq_token_contract_address\n)\n</code></pre> <p>We will define a trading wallet named <code>tokens</code> that will keep track of the amount of atestfet or CW20 tokens we hold at each moment. The <code>currency</code> variable will keep track of the token type. We will never have a mixed trading wallet since in this strategy, every time we perform a swap, we sell all the current tokens.</p> <pre><code># Trading Wallet\ntokens = 1000000\ncurrency = \"atestfet\"\n</code></pre> <p>Now we will define the upper and lower price bounds (atestfet/CW20) that will trigger a buy and a sell transaction of atestfet. We also define the commission rate (0.3% in <code>Terraswap</code>) and the <code>interval</code> time step to query the pool's price.</p> <p><pre><code>upper_bound = 26\nlower_bound = 24\n# LP commission\ncommission = 0.003\n# Interval in seconds\ninterval = 5\n</code></pre> Finally, we will initialize a loop, in every step it will:</p> <ul> <li>Query the Liquidity Pool status</li> <li>Check if current trading wallet's <code>currency</code></li> <li>Calculate the atestfet/CW20 price using the tokens received <code>tokens_out</code> if the whole trading wallet's balance <code>tokens</code> was to be swapped with the liquidity pool</li> <li>If atestfet sell/buy price is equal or lower/higher than the lower/upper bound, it will trigger a sell/buy transaction of atestfet to buy/sell CW20 tokens.</li> <li>Update trading wallet <code>token</code> balance and <code>currency</code></li> <li>Sleep <code>interval</code> and repeat</li> </ul> <pre><code>while True:\n# Query LP status\npool = pair_contract.query({\"pool\": {}})\nnative_amount = int(pool[\"assets\"][1][\"amount\"])\ncw20_amount = int(pool[\"assets\"][0][\"amount\"])\nif currency == \"atestfet\":\n# Calculate received tokens if tokens amount is given to LP\ntokens_out = round(((cw20_amount*tokens)/(native_amount+tokens))*(1-commission))\n# Sell price of atestfet =&gt; give atestfet, get cw20\nsell_price = tokens/tokens_out\nprint(\"atestfet sell price: \", sell_price)\nif sell_price &lt;= lower_bound:\nswap_native_for_cw20(tokens, pair_contract, wallet)\ntokens = int(token_contract.query({\"balance\": {\"address\": str(wallet.address())}})[\"balance\"])\ncurrency = \"CW20\"\nelse:\n# Calculate received tokens if tokens amount is given to LP\ntokens_out = round(((native_amount*tokens)/(cw20_amount+tokens))*(1-commission))\n# Buy price of atestfet =&gt; give cw20, get atestfet\nbuy_price = tokens_out/tokens\nprint(\"atestfet buy price: \", buy_price)\nif buy_price &gt;= upper_bound:\nswap_cw20_for_native(tokens, pair_contract_address, token_contract, wallet)\ntokens = tokens_out\ncurrency = \"atestfet\"\nsleep(interval)\n</code></pre> <p>This code assumes other traders performing transactions with the Liquidity Pool that will generate price movements. You can check out the full example at <code>swap-automation</code></p>"},{"location":"CosmPy/wallet-topup/","title":"Wallet Top-up","text":"<p>In a case where you are performing multiple transactions from a certain task_wallet, you can set an algorithm to keep that wallet address topped-up. For this use case, we will use three different wallets: wallet, authz_wallet, and task_wallet. Wallet will be the main wallet address that we don't want to give full access to, therefore we will authorize authz_wallet to send a certain amount of tokens from wallet to task_wallet every time task_wallet balance falls below a certain <code>minimum_balance</code> threshold. This way, task_wallet can keep performing transactions using the main wallet's tokens by being topped-up by authz_wallet. Start by defining wallet, authz_wallet and task_wallet address.</p> <p><pre><code>from cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nledger = LedgerClient(NetworkConfig.latest_stable_testnet())\n# Define wallets with any private keys\nwallet = LocalWallet(PrivateKey(\"F7w1yHq1QIcQiSqV27YSwk+i1i+Y4JMKhkpawCQIh6s=\"))\nauthz_wallet = LocalWallet(\nPrivateKey(\"KI5AZQcr+FNl2usnSIQYpXsGWvBxKLRDkieUNIvMOV8=\")\n)\n# Define any task_wallet address\ntask_wallet_address = 'fetch1ay6grfwhlm00wydwa3nw0x2u44qz4hg2uku8dc'\n</code></pre> Wallet will need to have enough tokens available to top-up task_wallet, and authz_wallet will need enough tokens to pay for transaction fees. Now you will need to give authorization to authz_wallet to send tokens from wallet. You will define the expiration and the spend limit of the authorization in <code>total_authz_time</code> and <code>spend_amount</code>. The code below shows how to perform this kind of transaction:</p> <pre><code>from cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\nfrom cosmpy.aerial.client.utils import prepare_and_broadcast_basic_transaction\nfrom cosmpy.aerial.tx import Transaction\nfrom datetime import datetime, timedelta\nfrom google.protobuf import any_pb2, timestamp_pb2\nfrom cosmpy.protos.cosmos.authz.v1beta1.authz_pb2 import Grant\nfrom cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgGrant\nfrom cosmpy.protos.cosmos.bank.v1beta1.authz_pb2 import SendAuthorization\n# Set total authorization time and spend amount\ntotal_authz_time = 10000\namount = 1000000000000000000\nspend_amount = Coin(amount=str(amount), denom=\"atestfet\")\n# Authorize authz_wallet to send tokens from wallet\nauthz_any = any_pb2.Any()\nauthz_any.Pack(\nSendAuthorization(spend_limit=[spend_amount]),\n\"\",\n)\nexpiry = timestamp_pb2.Timestamp()\nexpiry.FromDatetime(datetime.now() + timedelta(seconds=total_authz_time * 60))\ngrant = Grant(authorization=authz_any, expiration=expiry)\nmsg = MsgGrant(\ngranter=str(wallet.address()),\ngrantee=str(authz_wallet.address()),\ngrant=grant,\n)\ntx = Transaction()\ntx.add_message(msg)\ntx = prepare_and_broadcast_basic_transaction(ledger, tx, wallet)\ntx.wait_to_complete()\n</code></pre> <p>Next, you will need to define the amount to top-up, the threshold that will trigger the top-up, and the interval time to query the task_wallet balance. We will define these amounts in the following variables: <code>top_up_amount</code>, <code>minimum_balance</code> and <code>interval_time</code>.</p> <pre><code># Top-up amount\namount = 10000000000000000\ntop_up_amount = Coin(amount=str(amount), denom=\"atestfet\")\n# Minimum balance for task_wallet\nminimum_balance = 1000000000000000\n# Interval to query task_wallet's balance in seconds\ninterval_time = 5\n</code></pre> <p>Finally, run a continuously running loop that will: * Check the main wallet's balance to make sure it has enough tokens to top up the task_wallet_address * Check task_wallet's balance, if it is lower than <code>minimum_balance</code> then authz_wallet will send <code>top_up_amount</code> of tokens from wallet to task_wallet * Sleep <code>interval_time</code> and repeat</p> <pre><code>import time\nfrom cosmpy.protos.cosmos.authz.v1beta1.tx_pb2 import MsgExec\nfrom cosmpy.protos.cosmos.bank.v1beta1.tx_pb2 import MsgSend\nwhile True:\nwallet_address = str(wallet.address())\nwallet_balance = ledger.query_bank_balance(wallet_address)\nif wallet_balance &lt; amount:\nprint(\"Wallet doesn't have enough balance to top-up task_wallet\")\nbreak\ntask_wallet_balance = ledger.query_bank_balance(task_wallet_address)\nif task_wallet_balance &lt; minimum_balance:\nprint(\"topping up task wallet\")\n# Top-up task_wallet\nmsg = any_pb2.Any()\nmsg.Pack(\nMsgSend(\nfrom_address=wallet_address,\nto_address=task_wallet_address,\namount=[top_up_amount],\n),\n\"\",\n)\ntx = Transaction()\ntx.add_message(MsgExec(grantee=str(authz_wallet.address()), msgs=[msg]))\ntx = prepare_and_broadcast_basic_transaction(ledger, tx, authz_wallet)\ntx.wait_to_complete()\ntime.sleep(interval_time)\n</code></pre> <p>While the code above keeps running, you can make sure that task_wallet is always topped-up as long as authz_wallet has authorization to send the required tokens and the main wallet has enough balance.</p> <p>You can also check out the authorization and top-up code examples at <code>authz</code> and <code>top-up</code> respectively.</p>"},{"location":"CosmPy/wallets-and-keys/","title":"Wallets and Keys","text":"<p>To make changes on a network, you will need to start sending transactions to it. This in tern involves managing private keys and addresses. Luckily, CosmPy makes this relatively straightforward.</p> <p>The following code outlines how to both generate a completely new private key and how to recover a previously generated one:</p> <pre><code>from cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.keypairs import PrivateKey\n# To create a random private key:\nprivate_key = PrivateKey()\n# To recover an existing private key:\nprivate_key = PrivateKey('&lt;base64 encoded private key&gt;')\n</code></pre> <p>The <code>PrivateKey</code> object is one of CosmPy's low level primitives. This is why it is generally paired with a <code>Wallet</code> object in most scenarios. Below, a <code>LocalWallet</code> (a kind of <code>Wallet</code>) is created using the private key:</p> <pre><code>wallet = LocalWallet(private_key)\n</code></pre> <p>Creating the wallet allows users to query useful information such as the address from the wallet directly.</p> <pre><code>print(wallet.address()) # will print the address for the wallet\n</code></pre>"},{"location":"CosmPy/wallets-and-keys/#existing-account","title":"Existing account","text":"<p>To use cosmpy with an existing account, extract the private key and convert it into a base64 encoded string.</p> <p>For example, to do this on macOS or Linux for the Fetch.ai network using its FetchD CLI:</p> <pre><code>fetchd keys export mykeyname --unsafe --unarmored-hex | xxd -r -p | base64\n</code></pre>"},{"location":"CosmPy/wallets-and-keys/#from-mnemonic","title":"From mnemonic","text":"<p>If you have the mnemonic phrase to an account, you can get the associated private key as follows:</p> <pre><code>from bip_utils import Bip39SeedGenerator, Bip44, Bip44Coins\nmnemonic = \"person knife december tail tortoise jewel warm when worry limit reward memory piece cool sphere kitchen knee embody soft own victory sauce silly page\"\nseed_bytes = Bip39SeedGenerator(mnemonic).Generate()\nbip44_def_ctx = Bip44.FromSeed(seed_bytes, Bip44Coins.COSMOS).DeriveDefaultPath()\nwallet = LocalWallet(PrivateKey(bip44_def_ctx.PrivateKey().Raw().ToBytes()))\n</code></pre> <p>Danger</p> <p>Of course in real applications, you should never include a mnemonic in public code.</p>"},{"location":"CosmPy/wallets-and-keys/#custom-prefix-network","title":"Custom prefix network:","text":"<p>In case you are using a network other than fetch.ai's, you can provide the custom prefix when creating the wallet:</p> <pre><code>alice = LocalWallet(PrivateKey(\"L1GsisFk+oaIug3XZlILWk2pJDVFS5aPJsrovvUEDrE=\"), prefix=\"custom_prefix\")\naddress = alice.address()\nprint(f\"Address: {address}\")\nbalance = client.query_bank_balance(address, \"uatom\")\n</code></pre>"},{"location":"CosmPy/api/aerial/coins/","title":"Parse the coins","text":""},{"location":"CosmPy/api/aerial/coins/#cosmpyaerialcoins","title":"cosmpy.aerial.coins","text":"<p>Parse the coins.</p> <p></p>"},{"location":"CosmPy/api/aerial/coins/#parse_coins","title":"parse<code>_</code>coins","text":"<pre><code>def parse_coins(value: str) -&gt; List[Coin]\n</code></pre> <p>Parse the coins.</p> <p>Arguments:</p> <ul> <li><code>value</code>: coins</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: If unable to parse the value</li> </ul> <p>Returns:</p> <p>coins</p>"},{"location":"CosmPy/api/aerial/config/","title":"Network configurations","text":""},{"location":"CosmPy/api/aerial/config/#cosmpyaerialconfig","title":"cosmpy.aerial.config","text":"<p>Network configurations.</p> <p></p>"},{"location":"CosmPy/api/aerial/config/#networkconfigerror-objects","title":"NetworkConfigError Objects","text":"<pre><code>class NetworkConfigError(RuntimeError)\n</code></pre> <p>Network config error.</p> <p>Arguments:</p> <ul> <li><code>RuntimeError</code>: Runtime error</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/config/#networkconfig-objects","title":"NetworkConfig Objects","text":"<pre><code>@dataclass\nclass NetworkConfig()\n</code></pre> <p>Network configurations.</p> <p>Raises:</p> <ul> <li><code>NetworkConfigError</code>: Network config error</li> <li><code>RuntimeError</code>: Runtime error</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/config/#validate","title":"validate","text":"<pre><code>def validate()\n</code></pre> <p>Validate the network configuration.</p> <p>Raises:</p> <ul> <li><code>NetworkConfigError</code>: Network config error</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetchai_dorado_testnet","title":"fetchai<code>_</code>dorado<code>_</code>testnet","text":"<pre><code>@classmethod\ndef fetchai_dorado_testnet(cls) -&gt; \"NetworkConfig\"\n</code></pre> <p>Fetchai dorado testnet.</p> <p>Returns:</p> <p>Network configuration</p> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetchai_alpha_testnet","title":"fetchai<code>_</code>alpha<code>_</code>testnet","text":"<pre><code>@classmethod\ndef fetchai_alpha_testnet(cls)\n</code></pre> <p>Get the fetchai alpha testnet.</p> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: No alpha testnet available</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetchai_beta_testnet","title":"fetchai<code>_</code>beta<code>_</code>testnet","text":"<pre><code>@classmethod\ndef fetchai_beta_testnet(cls)\n</code></pre> <p>Get the Fetchai beta testnet.</p> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: No beta testnet available</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetchai_stable_testnet","title":"fetchai<code>_</code>stable<code>_</code>testnet","text":"<pre><code>@classmethod\ndef fetchai_stable_testnet(cls)\n</code></pre> <p>Get the fetchai stable testnet.</p> <p>Returns:</p> <p>fetchai stable testnet. For now dorado is fetchai stable testnet.</p> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetchai_mainnet","title":"fetchai<code>_</code>mainnet","text":"<pre><code>@classmethod\ndef fetchai_mainnet(cls) -&gt; \"NetworkConfig\"\n</code></pre> <p>Get the fetchai mainnet configuration.</p> <p>Returns:</p> <p>fetch mainnet configuration</p> <p></p>"},{"location":"CosmPy/api/aerial/config/#fetch_mainnet","title":"fetch<code>_</code>mainnet","text":"<pre><code>@classmethod\ndef fetch_mainnet(cls) -&gt; \"NetworkConfig\"\n</code></pre> <p>Get the fetch mainnet.</p> <p>Returns:</p> <p>fetch mainnet configurations</p> <p></p>"},{"location":"CosmPy/api/aerial/config/#latest_stable_testnet","title":"latest<code>_</code>stable<code>_</code>testnet","text":"<pre><code>@classmethod\ndef latest_stable_testnet(cls) -&gt; \"NetworkConfig\"\n</code></pre> <p>Get the latest stable testnet.</p> <p>Returns:</p> <p>latest stable testnet</p>"},{"location":"CosmPy/api/aerial/exceptions/","title":"Exceptions","text":""},{"location":"CosmPy/api/aerial/exceptions/#cosmpyaerialexceptions","title":"cosmpy.aerial.exceptions","text":"<p>Exceptions.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#queryerror-objects","title":"QueryError Objects","text":"<pre><code>class QueryError(RuntimeError)\n</code></pre> <p>Invalid Query Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#notfounderror-objects","title":"NotFoundError Objects","text":"<pre><code>class NotFoundError(QueryError)\n</code></pre> <p>Not found Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#querytimeouterror-objects","title":"QueryTimeoutError Objects","text":"<pre><code>class QueryTimeoutError(QueryError)\n</code></pre> <p>Query timeout Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#broadcasterror-objects","title":"BroadcastError Objects","text":"<pre><code>class BroadcastError(RuntimeError)\n</code></pre> <p>Broadcast Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(tx_hash: str, message: str)\n</code></pre> <p>Init Broadcast error.</p> <p>Arguments:</p> <ul> <li><code>tx_hash</code>: transaction hash</li> <li><code>message</code>: message</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#outofgaserror-objects","title":"OutOfGasError Objects","text":"<pre><code>class OutOfGasError(BroadcastError)\n</code></pre> <p>Insufficient Fess Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(tx_hash: str, gas_wanted: int, gas_used: int)\n</code></pre> <p>Initialize.</p> <p>Arguments:</p> <ul> <li><code>tx_hash</code>: transaction hash</li> <li><code>gas_wanted</code>: gas required to complete the transaction</li> <li><code>gas_used</code>: gas used</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#insufficientfeeserror-objects","title":"InsufficientFeesError Objects","text":"<pre><code>class InsufficientFeesError(BroadcastError)\n</code></pre> <p>Insufficient Fess Error.</p> <p></p>"},{"location":"CosmPy/api/aerial/exceptions/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(tx_hash: str, minimum_required_fee: str)\n</code></pre> <p>Initialize.</p> <p>Arguments:</p> <ul> <li><code>tx_hash</code>: transaction hash</li> <li><code>minimum_required_fee</code>: Minimum required fee</li> </ul>"},{"location":"CosmPy/api/aerial/faucet/","title":"Ledger faucet API interface","text":""},{"location":"CosmPy/api/aerial/faucet/#cosmpyaerialfaucet","title":"cosmpy.aerial.faucet","text":"<p>Ledger faucet API interface.</p> <p></p>"},{"location":"CosmPy/api/aerial/faucet/#faucetapi-objects","title":"FaucetApi Objects","text":"<pre><code>class FaucetApi()\n</code></pre> <p>Faucet API.</p> <p></p>"},{"location":"CosmPy/api/aerial/faucet/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(net_config: NetworkConfig)\n</code></pre> <p>Init faucet API.</p> <p>Arguments:</p> <ul> <li><code>net_config</code>: Ledger network configuration.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: Network config has no faucet url set</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/faucet/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>def get_wealth(address: Union[Address, str]) -&gt; None\n</code></pre> <p>Get wealth from the faucet for the provided address.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to create faucet claim</li> <li><code>RuntimeError</code>: Failed to check faucet claim status</li> <li><code>RuntimeError</code>: Failed to get wealth for address</li> <li><code>ValueError</code>: Faucet claim check timed out</li> </ul>"},{"location":"CosmPy/api/aerial/gas/","title":"Transaction gas strategy","text":""},{"location":"CosmPy/api/aerial/gas/#cosmpyaerialgas","title":"cosmpy.aerial.gas","text":"<p>Transaction gas strategy.</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#gasstrategy-objects","title":"GasStrategy Objects","text":"<pre><code>class GasStrategy(ABC)\n</code></pre> <p>Transaction gas strategy.</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#estimate_gas","title":"estimate<code>_</code>gas","text":"<pre><code>@abstractmethod\ndef estimate_gas(tx: Transaction) -&gt; int\n</code></pre> <p>Estimate the transaction gas.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: Transaction</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#block_gas_limit","title":"block<code>_</code>gas<code>_</code>limit","text":"<pre><code>@abstractmethod\ndef block_gas_limit() -&gt; int\n</code></pre> <p>Get the block gas limit.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#simulationgasstrategy-objects","title":"SimulationGasStrategy Objects","text":"<pre><code>class SimulationGasStrategy(GasStrategy)\n</code></pre> <p>Simulation transaction gas strategy.</p> <p>Arguments:</p> <ul> <li><code>GasStrategy</code>: gas strategy</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/gas/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(client: \"LedgerClient\", multiplier: Optional[float] = None)\n</code></pre> <p>Init the Simulation transaction gas strategy.</p> <p>Arguments:</p> <ul> <li><code>client</code>: Ledger client</li> <li><code>multiplier</code>: multiplier, defaults to None</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/gas/#estimate_gas_1","title":"estimate<code>_</code>gas","text":"<pre><code>def estimate_gas(tx: Transaction) -&gt; int\n</code></pre> <p>Get estimated transaction gas.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Returns:</p> <p>Estimated transaction gas</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#block_gas_limit_1","title":"block<code>_</code>gas<code>_</code>limit","text":"<pre><code>def block_gas_limit() -&gt; int\n</code></pre> <p>Get the block gas limit.</p> <p>Returns:</p> <p>block gas limit</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#offlinemessagetablestrategy-objects","title":"OfflineMessageTableStrategy Objects","text":"<pre><code>class OfflineMessageTableStrategy(GasStrategy)\n</code></pre> <p>Offline message table strategy.</p> <p>Arguments:</p> <ul> <li><code>GasStrategy</code>: gas strategy</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/gas/#default_table","title":"default<code>_</code>table","text":"<pre><code>@staticmethod\ndef default_table() -&gt; \"OfflineMessageTableStrategy\"\n</code></pre> <p>offline message strategy default table.</p> <p>Returns:</p> <p>offline message default table strategy</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(fallback_gas_limit: Optional[int] = None,\nblock_limit: Optional[int] = None)\n</code></pre> <p>Init offline message table strategy.</p> <p>Arguments:</p> <ul> <li><code>fallback_gas_limit</code>: Fallback gas limit, defaults to None</li> <li><code>block_limit</code>: Block limit, defaults to None</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/gas/#update_entry","title":"update<code>_</code>entry","text":"<pre><code>def update_entry(transaction_type: str, gas_limit: int)\n</code></pre> <p>Update the entry of the transaction.</p> <p>Arguments:</p> <ul> <li><code>transaction_type</code>: transaction type</li> <li><code>gas_limit</code>: gas limit</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/gas/#estimate_gas_2","title":"estimate<code>_</code>gas","text":"<pre><code>def estimate_gas(tx: Transaction) -&gt; int\n</code></pre> <p>Get estimated transaction gas.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Returns:</p> <p>Estimated transaction gas</p> <p></p>"},{"location":"CosmPy/api/aerial/gas/#block_gas_limit_2","title":"block<code>_</code>gas<code>_</code>limit","text":"<pre><code>def block_gas_limit() -&gt; int\n</code></pre> <p>Get the block gas limit.</p> <p>Returns:</p> <p>block gas limit</p>"},{"location":"CosmPy/api/aerial/tx/","title":"Transaction","text":""},{"location":"CosmPy/api/aerial/tx/#cosmpyaerialtx","title":"cosmpy.aerial.tx","text":"<p>Transaction.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#txstate-objects","title":"TxState Objects","text":"<pre><code>class TxState(Enum)\n</code></pre> <p>Transaction state.</p> <p>Arguments:</p> <ul> <li><code>Enum</code>: Draft, Sealed, Final</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/tx/#signingmode-objects","title":"SigningMode Objects","text":"<pre><code>class SigningMode(Enum)\n</code></pre> <p>Signing mode.</p> <p>Arguments:</p> <ul> <li><code>Enum</code>: Direct</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/tx/#signingcfg-objects","title":"SigningCfg Objects","text":"<pre><code>@dataclass\nclass SigningCfg()\n</code></pre> <p>Transaction signing configuration.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#direct","title":"direct","text":"<pre><code>@staticmethod\ndef direct(public_key: PublicKey, sequence_num: int) -&gt; \"SigningCfg\"\n</code></pre> <p>Transaction signing configuration using direct mode.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: public key</li> <li><code>sequence_num</code>: sequence number</li> </ul> <p>Returns:</p> <p>Transaction signing configuration</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#transaction-objects","title":"Transaction Objects","text":"<pre><code>class Transaction()\n</code></pre> <p>Transaction.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__()\n</code></pre> <p>Init the Transactions with transaction message, state, fee and body.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#state","title":"state","text":"<pre><code>@property\ndef state() -&gt; TxState\n</code></pre> <p>Get the transaction state.</p> <p>Returns:</p> <p>current state of the transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#msgs","title":"msgs","text":"<pre><code>@property\ndef msgs()\n</code></pre> <p>Get the transaction messages.</p> <p>Returns:</p> <p>transaction messages</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#fee","title":"fee","text":"<pre><code>@property\ndef fee() -&gt; Optional[str]\n</code></pre> <p>Get the transaction fee.</p> <p>Returns:</p> <p>transaction fee</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#tx","title":"tx","text":"<pre><code>@property\ndef tx()\n</code></pre> <p>Initialize.</p> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: If the transaction has not been completed.</li> </ul> <p>Returns:</p> <p>transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#add_message","title":"add<code>_</code>message","text":"<pre><code>def add_message(msg: Any) -&gt; \"Transaction\"\n</code></pre> <p>Initialize.</p> <p>Arguments:</p> <ul> <li><code>msg</code>: transaction message (memo)</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: If the transaction is not in the draft state.</li> </ul> <p>Returns:</p> <p>transaction with message added</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#seal","title":"seal","text":"<pre><code>def seal(signing_cfgs: Union[SigningCfg, List[SigningCfg]],\nfee: str,\ngas_limit: int,\nmemo: Optional[str] = None) -&gt; \"Transaction\"\n</code></pre> <p>Seal the transaction.</p> <p>Arguments:</p> <ul> <li><code>signing_cfgs</code>: signing configs</li> <li><code>fee</code>: transaction fee</li> <li><code>gas_limit</code>: transaction gas limit</li> <li><code>memo</code>: transaction memo, defaults to None</li> </ul> <p>Returns:</p> <p>sealed transaction.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#sign","title":"sign","text":"<pre><code>def sign(signer: Signer,\nchain_id: str,\naccount_number: int,\ndeterministic: bool = False) -&gt; \"Transaction\"\n</code></pre> <p>Sign the transaction.</p> <p>Arguments:</p> <ul> <li><code>signer</code>: Signer</li> <li><code>chain_id</code>: chain id</li> <li><code>account_number</code>: account number</li> <li><code>deterministic</code>: deterministic, defaults to False</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: If transaction is not sealed</li> </ul> <p>Returns:</p> <p>signed transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/tx/#complete","title":"complete","text":"<pre><code>def complete() -&gt; \"Transaction\"\n</code></pre> <p>Update transaction state to Final.</p> <p>Returns:</p> <p>transaction with  updated state</p>"},{"location":"CosmPy/api/aerial/tx_helpers/","title":"Transaction helpers","text":""},{"location":"CosmPy/api/aerial/tx_helpers/#cosmpyaerialtx_helpers","title":"cosmpy.aerial.tx<code>_</code>helpers","text":"<p>Transaction helpers.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#messagelog-objects","title":"MessageLog Objects","text":"<pre><code>@dataclass\nclass MessageLog()\n</code></pre> <p>Message Log.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#txresponse-objects","title":"TxResponse Objects","text":"<pre><code>@dataclass\nclass TxResponse()\n</code></pre> <p>Transaction response.</p> <p>Raises:</p> <ul> <li><code>OutOfGasError</code>: Out of gas error</li> <li><code>InsufficientFeesError</code>: Insufficient fees</li> <li><code>BroadcastError</code>: Broadcast Exception</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#is_successful","title":"is<code>_</code>successful","text":"<pre><code>def is_successful() -&gt; bool\n</code></pre> <p>Check transaction is successful.</p> <p>Returns:</p> <p>transaction status</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#ensure_successful","title":"ensure<code>_</code>successful","text":"<pre><code>def ensure_successful()\n</code></pre> <p>Ensure transaction is successful.</p> <p>Raises:</p> <ul> <li><code>OutOfGasError</code>: Out of gas error</li> <li><code>InsufficientFeesError</code>: Insufficient fees</li> <li><code>BroadcastError</code>: Broadcast Exception</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#submittedtx-objects","title":"SubmittedTx Objects","text":"<pre><code>class SubmittedTx()\n</code></pre> <p>Submitted transaction.</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(client: \"LedgerClient\", tx_hash: str)\n</code></pre> <p>Init the Submitted transaction.</p> <p>Arguments:</p> <ul> <li><code>client</code>: Ledger client</li> <li><code>tx_hash</code>: transaction hash</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#tx_hash","title":"tx<code>_</code>hash","text":"<pre><code>@property\ndef tx_hash() -&gt; str\n</code></pre> <p>Get the transaction hash.</p> <p>Returns:</p> <p>transaction hash</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#response","title":"response","text":"<pre><code>@property\ndef response() -&gt; Optional[TxResponse]\n</code></pre> <p>Get the transaction response.</p> <p>Returns:</p> <p>response</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#contract_code_id","title":"contract<code>_</code>code<code>_</code>id","text":"<pre><code>@property\ndef contract_code_id() -&gt; Optional[int]\n</code></pre> <p>Get the contract code id.</p> <p>Returns:</p> <p>return contract code id if exist else None</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#contract_address","title":"contract<code>_</code>address","text":"<pre><code>@property\ndef contract_address() -&gt; Optional[Address]\n</code></pre> <p>Get the contract address.</p> <p>Returns:</p> <p>return contract address if exist else None</p> <p></p>"},{"location":"CosmPy/api/aerial/tx_helpers/#wait_to_complete","title":"wait<code>_</code>to<code>_</code>complete","text":"<pre><code>def wait_to_complete(\ntimeout: Optional[Union[int, float, timedelta]] = None,\npoll_period: Optional[Union[int, float,\ntimedelta]] = None) -&gt; \"SubmittedTx\"\n</code></pre> <p>Wait to complete the transaction.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout, defaults to None</li> <li><code>poll_period</code>: poll_period, defaults to None</li> </ul> <p>Returns:</p> <p>Submitted Transaction</p>"},{"location":"CosmPy/api/aerial/urls/","title":"Parsing the URL","text":""},{"location":"CosmPy/api/aerial/urls/#cosmpyaerialurls","title":"cosmpy.aerial.urls","text":"<p>Parsing the URL.</p> <p></p>"},{"location":"CosmPy/api/aerial/urls/#protocol-objects","title":"Protocol Objects","text":"<pre><code>class Protocol(Enum)\n</code></pre> <p>Protocol Enum.</p> <p>Arguments:</p> <ul> <li><code>Enum</code>: Enum</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/urls/#parsedurl-objects","title":"ParsedUrl Objects","text":"<pre><code>@dataclass\nclass ParsedUrl()\n</code></pre> <p>Parse URL.</p> <p>Returns:</p> <p>Parsed URL</p> <p></p>"},{"location":"CosmPy/api/aerial/urls/#host_and_port","title":"host<code>_</code>and<code>_</code>port","text":"<pre><code>@property\ndef host_and_port() -&gt; str\n</code></pre> <p>Get the host and port of the url.</p> <p>Returns:</p> <p>host and port</p> <p></p>"},{"location":"CosmPy/api/aerial/urls/#rest_url","title":"rest<code>_</code>url","text":"<pre><code>@property\ndef rest_url() -&gt; str\n</code></pre> <p>Get the rest url.</p> <p>Returns:</p> <p>rest url</p> <p></p>"},{"location":"CosmPy/api/aerial/urls/#parse_url","title":"parse<code>_</code>url","text":"<pre><code>def parse_url(url: str) -&gt; ParsedUrl\n</code></pre> <p>Initialize.</p> <p>Arguments:</p> <ul> <li><code>url</code>: url</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: If url scheme is unsupported</li> </ul> <p>Returns:</p> <p>Parsed URL</p>"},{"location":"CosmPy/api/aerial/wallet/","title":"Wallet Generation","text":""},{"location":"CosmPy/api/aerial/wallet/#cosmpyaerialwallet","title":"cosmpy.aerial.wallet","text":"<p>Wallet Generation.</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#wallet-objects","title":"Wallet Objects","text":"<pre><code>class Wallet(ABC, UserString)\n</code></pre> <p>Wallet Generation.</p> <p>Arguments:</p> <ul> <li><code>ABC</code>: ABC abstract method</li> <li><code>UserString</code>: user string</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#address","title":"address","text":"<pre><code>@abstractmethod\ndef address() -&gt; Address\n</code></pre> <p>get the address of the wallet.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#public_key","title":"public<code>_</code>key","text":"<pre><code>@abstractmethod\ndef public_key() -&gt; PublicKey\n</code></pre> <p>get the public key of the wallet.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#signer","title":"signer","text":"<pre><code>@abstractmethod\ndef signer() -&gt; Signer\n</code></pre> <p>get the signer of the wallet.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#data","title":"data","text":"<pre><code>@property\ndef data()\n</code></pre> <p>Get the address of the wallet.</p> <p>Returns:</p> <p>Address</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#__json__","title":"<code>__</code>json<code>__</code>","text":"<pre><code>def __json__()\n</code></pre> <p>Return the address in string format.</p> <p>Returns:</p> <p>address in string format</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#localwallet-objects","title":"LocalWallet Objects","text":"<pre><code>class LocalWallet(Wallet)\n</code></pre> <p>Generate local wallet.</p> <p>Arguments:</p> <ul> <li><code>Wallet</code>: wallet</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#generate","title":"generate","text":"<pre><code>@staticmethod\ndef generate(prefix: Optional[str] = None) -&gt; \"LocalWallet\"\n</code></pre> <p>generate the local wallet.</p> <p>Arguments:</p> <ul> <li><code>prefix</code>: prefix, defaults to None</li> </ul> <p>Returns:</p> <p>local wallet</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#from_mnemonic","title":"from<code>_</code>mnemonic","text":"<pre><code>@staticmethod\ndef from_mnemonic(mnemonic: str,\nprefix: Optional[str] = None) -&gt; \"LocalWallet\"\n</code></pre> <p>Generate local wallet from mnemonic.</p> <p>Arguments:</p> <ul> <li><code>mnemonic</code>: mnemonic</li> <li><code>prefix</code>: prefix, defaults to None</li> </ul> <p>Returns:</p> <p>local wallet</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#from_unsafe_seed","title":"from<code>_</code>unsafe<code>_</code>seed","text":"<pre><code>@staticmethod\ndef from_unsafe_seed(text: str,\nindex: Optional[int] = None,\nprefix: Optional[str] = None) -&gt; \"LocalWallet\"\n</code></pre> <p>Generate local wallet from unsafe seed.</p> <p>Arguments:</p> <ul> <li><code>text</code>: text</li> <li><code>index</code>: index, defaults to None</li> <li><code>prefix</code>: prefix, defaults to None</li> </ul> <p>Returns:</p> <p>Local wallet</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(private_key: PrivateKey, prefix: Optional[str] = None)\n</code></pre> <p>Init wallet with.</p> <p>Arguments:</p> <ul> <li><code>private_key</code>: private key of the wallet</li> <li><code>prefix</code>: prefix, defaults to None</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#address_1","title":"address","text":"<pre><code>def address() -&gt; Address\n</code></pre> <p>Get the wallet address.</p> <p>Returns:</p> <p>Wallet address.</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#public_key_1","title":"public<code>_</code>key","text":"<pre><code>def public_key() -&gt; PublicKey\n</code></pre> <p>Get the public key of the wallet.</p> <p>Returns:</p> <p>public key</p> <p></p>"},{"location":"CosmPy/api/aerial/wallet/#signer_1","title":"signer","text":"<pre><code>def signer() -&gt; PrivateKey\n</code></pre> <p>Get  the signer of the wallet.</p> <p>Returns:</p> <p>signer</p>"},{"location":"CosmPy/api/aerial/client/__init__/","title":"Client functionality","text":""},{"location":"CosmPy/api/aerial/client/__init__/#cosmpyaerialclient__init__","title":"cosmpy.aerial.client.<code>__</code>init<code>__</code>","text":"<p>Client functionality.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#account-objects","title":"Account Objects","text":"<pre><code>@dataclass\nclass Account()\n</code></pre> <p>Account.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#stakingposition-objects","title":"StakingPosition Objects","text":"<pre><code>@dataclass\nclass StakingPosition()\n</code></pre> <p>Staking positions.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#unbondingpositions-objects","title":"UnbondingPositions Objects","text":"<pre><code>@dataclass\nclass UnbondingPositions()\n</code></pre> <p>Unbonding positions.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#validator-objects","title":"Validator Objects","text":"<pre><code>@dataclass\nclass Validator()\n</code></pre> <p>Validator.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#coin-objects","title":"Coin Objects","text":"<pre><code>@dataclass\nclass Coin()\n</code></pre> <p>Coins.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#stakingsummary-objects","title":"StakingSummary Objects","text":"<pre><code>@dataclass\nclass StakingSummary()\n</code></pre> <p>Get the staking summary.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#total_staked","title":"total<code>_</code>staked","text":"<pre><code>@property\ndef total_staked() -&gt; int\n</code></pre> <p>Get the total staked amount.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#total_rewards","title":"total<code>_</code>rewards","text":"<pre><code>@property\ndef total_rewards() -&gt; int\n</code></pre> <p>Get the total rewards.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#total_unbonding","title":"total<code>_</code>unbonding","text":"<pre><code>@property\ndef total_unbonding() -&gt; int\n</code></pre> <p>total unbonding.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#ledgerclient-objects","title":"LedgerClient Objects","text":"<pre><code>class LedgerClient()\n</code></pre> <p>Ledger client.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(cfg: NetworkConfig,\nquery_interval_secs: int = DEFAULT_QUERY_INTERVAL_SECS,\nquery_timeout_secs: int = DEFAULT_QUERY_TIMEOUT_SECS)\n</code></pre> <p>Init ledger client.</p> <p>Arguments:</p> <ul> <li><code>cfg</code>: Network configurations</li> <li><code>query_interval_secs</code>: int. optional interval int seconds</li> <li><code>query_timeout_secs</code>: int. optional interval int seconds</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#network_config","title":"network<code>_</code>config","text":"<pre><code>@property\ndef network_config() -&gt; NetworkConfig\n</code></pre> <p>Get the network config.</p> <p>Returns:</p> <p>network config</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#gas_strategy","title":"gas<code>_</code>strategy","text":"<pre><code>@property\ndef gas_strategy() -&gt; GasStrategy\n</code></pre> <p>Get gas strategy.</p> <p>Returns:</p> <p>gas strategy</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#gas_strategy_1","title":"gas<code>_</code>strategy","text":"<pre><code>@gas_strategy.setter\ndef gas_strategy(strategy: GasStrategy)\n</code></pre> <p>Set gas strategy.</p> <p>Arguments:</p> <ul> <li><code>strategy</code>: strategy</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Invalid strategy must implement GasStrategy interface</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_account","title":"query<code>_</code>account","text":"<pre><code>def query_account(address: Address) -&gt; Account\n</code></pre> <p>Query account.</p> <p>Arguments:</p> <ul> <li><code>address</code>: address</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unexpected account type returned from query</li> </ul> <p>Returns:</p> <p>account details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_params","title":"query<code>_</code>params","text":"<pre><code>def query_params(subspace: str, key: str) -&gt; Any\n</code></pre> <p>Query Prams.</p> <p>Arguments:</p> <ul> <li><code>subspace</code>: subspace</li> <li><code>key</code>: key</li> </ul> <p>Returns:</p> <p>Query params</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_bank_balance","title":"query<code>_</code>bank<code>_</code>balance","text":"<pre><code>def query_bank_balance(address: Address, denom: Optional[str] = None) -&gt; int\n</code></pre> <p>Query bank balance.</p> <p>Arguments:</p> <ul> <li><code>address</code>: address</li> <li><code>denom</code>: denom, defaults to None</li> </ul> <p>Returns:</p> <p>bank balance</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_bank_all_balances","title":"query<code>_</code>bank<code>_</code>all<code>_</code>balances","text":"<pre><code>def query_bank_all_balances(address: Address) -&gt; List[Coin]\n</code></pre> <p>Query bank all balances.</p> <p>Arguments:</p> <ul> <li><code>address</code>: address</li> </ul> <p>Returns:</p> <p>bank all balances</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#send_tokens","title":"send<code>_</code>tokens","text":"<pre><code>def send_tokens(destination: Address,\namount: int,\ndenom: str,\nsender: Wallet,\nmemo: Optional[str] = None,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Send tokens.</p> <p>Arguments:</p> <ul> <li><code>destination</code>: destination address</li> <li><code>amount</code>: amount</li> <li><code>denom</code>: denom</li> <li><code>sender</code>: sender</li> <li><code>memo</code>: memo, defaults to None</li> <li><code>gas_limit</code>: gas limit, defaults to None</li> </ul> <p>Returns:</p> <p>prepare and broadcast the transaction and transaction details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_validators","title":"query<code>_</code>validators","text":"<pre><code>def query_validators(\nstatus: Optional[ValidatorStatus] = None) -&gt; List[Validator]\n</code></pre> <p>Query validators.</p> <p>Arguments:</p> <ul> <li><code>status</code>: validator status, defaults to None</li> </ul> <p>Returns:</p> <p>List of validators</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_staking_summary","title":"query<code>_</code>staking<code>_</code>summary","text":"<pre><code>def query_staking_summary(address: Address) -&gt; StakingSummary\n</code></pre> <p>Query staking summary.</p> <p>Arguments:</p> <ul> <li><code>address</code>: address</li> </ul> <p>Returns:</p> <p>staking summary</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#delegate_tokens","title":"delegate<code>_</code>tokens","text":"<pre><code>def delegate_tokens(validator: Address,\namount: int,\nsender: Wallet,\nmemo: Optional[str] = None,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Delegate tokens.</p> <p>Arguments:</p> <ul> <li><code>validator</code>: validator address</li> <li><code>amount</code>: amount</li> <li><code>sender</code>: sender</li> <li><code>memo</code>: memo, defaults to None</li> <li><code>gas_limit</code>: gas limit, defaults to None</li> </ul> <p>Returns:</p> <p>prepare and broadcast the transaction and transaction details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#redelegate_tokens","title":"redelegate<code>_</code>tokens","text":"<pre><code>def redelegate_tokens(current_validator: Address,\nnext_validator: Address,\namount: int,\nsender: Wallet,\nmemo: Optional[str] = None,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Redelegate tokens.</p> <p>Arguments:</p> <ul> <li><code>current_validator</code>: current validator address</li> <li><code>next_validator</code>: next validator address</li> <li><code>amount</code>: amount</li> <li><code>sender</code>: sender</li> <li><code>memo</code>: memo, defaults to None</li> <li><code>gas_limit</code>: gas limit, defaults to None</li> </ul> <p>Returns:</p> <p>prepare and broadcast the transaction and transaction details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#undelegate_tokens","title":"undelegate<code>_</code>tokens","text":"<pre><code>def undelegate_tokens(validator: Address,\namount: int,\nsender: Wallet,\nmemo: Optional[str] = None,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Undelegate tokens.</p> <p>Arguments:</p> <ul> <li><code>validator</code>: validator</li> <li><code>amount</code>: amount</li> <li><code>sender</code>: sender</li> <li><code>memo</code>: memo, defaults to None</li> <li><code>gas_limit</code>: gas limit, defaults to None</li> </ul> <p>Returns:</p> <p>prepare and broadcast the transaction and transaction details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#claim_rewards","title":"claim<code>_</code>rewards","text":"<pre><code>def claim_rewards(validator: Address,\nsender: Wallet,\nmemo: Optional[str] = None,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>claim rewards.</p> <p>Arguments:</p> <ul> <li><code>validator</code>: validator</li> <li><code>sender</code>: sender</li> <li><code>memo</code>: memo, defaults to None</li> <li><code>gas_limit</code>: gas limit, defaults to None</li> </ul> <p>Returns:</p> <p>prepare and broadcast the transaction and transaction details</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#estimate_gas_for_tx","title":"estimate<code>_</code>gas<code>_</code>for<code>_</code>tx","text":"<pre><code>def estimate_gas_for_tx(tx: Transaction) -&gt; int\n</code></pre> <p>Estimate gas for transaction.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Returns:</p> <p>Estimated gas for transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#estimate_fee_from_gas","title":"estimate<code>_</code>fee<code>_</code>from<code>_</code>gas","text":"<pre><code>def estimate_fee_from_gas(gas_limit: int) -&gt; str\n</code></pre> <p>Estimate fee from gas.</p> <p>Arguments:</p> <ul> <li><code>gas_limit</code>: gas limit</li> </ul> <p>Returns:</p> <p>Estimated fee for transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#estimate_gas_and_fee_for_tx","title":"estimate<code>_</code>gas<code>_</code>and<code>_</code>fee<code>_</code>for<code>_</code>tx","text":"<pre><code>def estimate_gas_and_fee_for_tx(tx: Transaction) -&gt; Tuple[int, str]\n</code></pre> <p>Estimate gas and fee for transaction.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Returns:</p> <p>estimate gas, fee for transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#wait_for_query_tx","title":"wait<code>_</code>for<code>_</code>query<code>_</code>tx","text":"<pre><code>def wait_for_query_tx(tx_hash: str,\ntimeout: Optional[timedelta] = None,\npoll_period: Optional[timedelta] = None) -&gt; TxResponse\n</code></pre> <p>Wait for query transaction.</p> <p>Arguments:</p> <ul> <li><code>tx_hash</code>: transaction hash</li> <li><code>timeout</code>: timeout, defaults to None</li> <li><code>poll_period</code>: poll_period, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>QueryTimeoutError</code>: timeout</li> </ul> <p>Returns:</p> <p>transaction response</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#query_tx","title":"query<code>_</code>tx","text":"<pre><code>def query_tx(tx_hash: str) -&gt; TxResponse\n</code></pre> <p>query transaction.</p> <p>Arguments:</p> <ul> <li><code>tx_hash</code>: transaction hash</li> </ul> <p>Raises:</p> <ul> <li><code>NotFoundError</code>: Tx details not found</li> <li><code>grpc.RpcError</code>: RPC connection issue</li> </ul> <p>Returns:</p> <p>query response</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#simulate_tx","title":"simulate<code>_</code>tx","text":"<pre><code>def simulate_tx(tx: Transaction) -&gt; int\n</code></pre> <p>simulate transaction.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to simulate non final transaction</li> </ul> <p>Returns:</p> <p>gas used in transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/client/__init__/#broadcast_tx","title":"broadcast<code>_</code>tx","text":"<pre><code>def broadcast_tx(tx: Transaction) -&gt; SubmittedTx\n</code></pre> <p>Broadcast transaction.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: transaction</li> </ul> <p>Returns:</p> <p>Submitted transaction</p>"},{"location":"CosmPy/api/aerial/client/bank/","title":"Bank send message","text":""},{"location":"CosmPy/api/aerial/client/bank/#cosmpyaerialclientbank","title":"cosmpy.aerial.client.bank","text":"<p>Bank send message.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/bank/#create_bank_send_msg","title":"create<code>_</code>bank<code>_</code>send<code>_</code>msg","text":"<pre><code>def create_bank_send_msg(from_address: Address, to_address: Address,\namount: int, denom: str) -&gt; MsgSend\n</code></pre> <p>Create bank send message.</p> <p>Arguments:</p> <ul> <li><code>from_address</code>: from address</li> <li><code>to_address</code>: to address</li> <li><code>amount</code>: amount</li> <li><code>denom</code>: denom</li> </ul> <p>Returns:</p> <p>bank send message</p>"},{"location":"CosmPy/api/aerial/client/distribution/","title":"Distribution","text":""},{"location":"CosmPy/api/aerial/client/distribution/#cosmpyaerialclientdistribution","title":"cosmpy.aerial.client.distribution","text":"<p>Distribution.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/distribution/#create_withdraw_delegator_reward","title":"create<code>_</code>withdraw<code>_</code>delegator<code>_</code>reward","text":"<pre><code>def create_withdraw_delegator_reward(delegator: Address, validator: Address)\n</code></pre> <p>Create withdraw delegator reward.</p> <p>Arguments:</p> <ul> <li><code>delegator</code>: delegator address</li> <li><code>validator</code>: validator address</li> </ul> <p>Returns:</p> <p>withdraw delegator reward message</p>"},{"location":"CosmPy/api/aerial/client/staking/","title":"Staking functionality","text":""},{"location":"CosmPy/api/aerial/client/staking/#cosmpyaerialclientstaking","title":"cosmpy.aerial.client.staking","text":"<p>Staking functionality.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/staking/#validatorstatus-objects","title":"ValidatorStatus Objects","text":"<pre><code>class ValidatorStatus(Enum)\n</code></pre> <p>Validator status.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/staking/#from_proto","title":"from<code>_</code>proto","text":"<pre><code>@classmethod\ndef from_proto(cls, value: int) -&gt; \"ValidatorStatus\"\n</code></pre> <p>Get the validator status from proto.</p> <p>Arguments:</p> <ul> <li><code>value</code>: value</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to decode validator status</li> </ul> <p>Returns:</p> <p>Validator status</p> <p></p>"},{"location":"CosmPy/api/aerial/client/staking/#create_delegate_msg","title":"create<code>_</code>delegate<code>_</code>msg","text":"<pre><code>def create_delegate_msg(delegator: Address, validator: Address, amount: int,\ndenom: str) -&gt; MsgDelegate\n</code></pre> <p>Create delegate message.</p> <p>Arguments:</p> <ul> <li><code>delegator</code>: delegator</li> <li><code>validator</code>: validator</li> <li><code>amount</code>: amount</li> <li><code>denom</code>: denom</li> </ul> <p>Returns:</p> <p>Delegate message</p> <p></p>"},{"location":"CosmPy/api/aerial/client/staking/#create_redelegate_msg","title":"create<code>_</code>redelegate<code>_</code>msg","text":"<pre><code>def create_redelegate_msg(delegator_address: Address,\nvalidator_src_address: Address,\nvalidator_dst_address: Address, amount: int,\ndenom: str) -&gt; MsgBeginRedelegate\n</code></pre> <p>Create redelegate message.</p> <p>Arguments:</p> <ul> <li><code>delegator_address</code>: delegator address</li> <li><code>validator_src_address</code>: source validation address</li> <li><code>validator_dst_address</code>: destination validation address</li> <li><code>amount</code>: amount</li> <li><code>denom</code>: denom</li> </ul> <p>Returns:</p> <p>Redelegate message</p> <p></p>"},{"location":"CosmPy/api/aerial/client/staking/#create_undelegate_msg","title":"create<code>_</code>undelegate<code>_</code>msg","text":"<pre><code>def create_undelegate_msg(delegator_address: Address,\nvalidator_address: Address, amount: int,\ndenom: str) -&gt; MsgUndelegate\n</code></pre> <p>Create undelegate message.</p> <p>Arguments:</p> <ul> <li><code>delegator_address</code>: delegator address</li> <li><code>validator_address</code>: validator address</li> <li><code>amount</code>: amount</li> <li><code>denom</code>: denom</li> </ul> <p>Returns:</p> <p>Undelegate message</p>"},{"location":"CosmPy/api/aerial/client/utils/","title":"Helper functions","text":""},{"location":"CosmPy/api/aerial/client/utils/#cosmpyaerialclientutils","title":"cosmpy.aerial.client.utils","text":"<p>Helper functions.</p> <p></p>"},{"location":"CosmPy/api/aerial/client/utils/#prepare_and_broadcast_basic_transaction","title":"prepare<code>_</code>and<code>_</code>broadcast<code>_</code>basic<code>_</code>transaction","text":"<pre><code>def prepare_and_broadcast_basic_transaction(\nclient: \"LedgerClient\",\ntx: \"Transaction\",\nsender: \"Wallet\",\naccount: Optional[\"Account\"] = None,\ngas_limit: Optional[int] = None,\nmemo: Optional[str] = None) -&gt; SubmittedTx\n</code></pre> <p>Prepare and broadcast basic transaction.</p> <p>Arguments:</p> <ul> <li><code>client</code>: Ledger client</li> <li><code>tx</code>: The transaction</li> <li><code>sender</code>: The transaction sender</li> <li><code>account</code>: The account</li> <li><code>gas_limit</code>: The gas limit</li> <li><code>memo</code>: Transaction memo, defaults to None</li> </ul> <p>Returns:</p> <p>broadcast transaction</p> <p></p>"},{"location":"CosmPy/api/aerial/client/utils/#ensure_timedelta","title":"ensure<code>_</code>timedelta","text":"<pre><code>def ensure_timedelta(interval: Union[int, float, timedelta]) -&gt; timedelta\n</code></pre> <p>Return timedelta for interval.</p> <p>Arguments:</p> <ul> <li><code>interval</code>: timedelta or seconds in int or float</li> </ul> <p>Returns:</p> <p>timedelta</p> <p></p>"},{"location":"CosmPy/api/aerial/client/utils/#get_paginated","title":"get<code>_</code>paginated","text":"<pre><code>def get_paginated(\ninitial_request: Any,\nrequest_method: Callable,\npages_limit: int = 0,\nper_page_limit: Optional[int] = DEFAULT_PER_PAGE_LIMIT) -&gt; List[Any]\n</code></pre> <p>Get pages for specific request.</p> <p>Arguments:</p> <ul> <li><code>initial_request</code>: request supports pagination</li> <li><code>request_method</code>: function to perform request</li> <li><code>pages_limit</code>: max number of pages to return. default - 0 unlimited</li> <li><code>per_page_limit</code>: Optional int: amount of records per one page. default is None, determined by server</li> </ul> <p>Returns:</p> <p>List of responses</p>"},{"location":"CosmPy/api/aerial/contract/__init__/","title":"Cosmwasm contract functionality","text":""},{"location":"CosmPy/api/aerial/contract/__init__/#cosmpyaerialcontract__init__","title":"cosmpy.aerial.contract.<code>__</code>init<code>__</code>","text":"<p>cosmwasm contract functionality.</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#ledgercontract-objects","title":"LedgerContract Objects","text":"<pre><code>class LedgerContract(UserString)\n</code></pre> <p>Ledger contract.</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(path: Optional[str],\nclient: LedgerClient,\naddress: Optional[Address] = None,\ndigest: Optional[bytes] = None,\nschema_path: Optional[str] = None,\ncode_id: Optional[int] = None)\n</code></pre> <p>Initialize the Ledger contract.</p> <p>Arguments:</p> <ul> <li><code>path</code>: Path</li> <li><code>client</code>: Ledger client</li> <li><code>address</code>: address, defaults to None</li> <li><code>digest</code>: digest, defaults to None</li> <li><code>schema_path</code>: path to contract schema, defaults to None</li> <li><code>code_id</code>: optional int. code id of the contract stored</li> </ul> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#path","title":"path","text":"<pre><code>@property\ndef path() -&gt; Optional[str]\n</code></pre> <p>Get contract path.</p> <p>Returns:</p> <p>contract path</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#digest","title":"digest","text":"<pre><code>@property\ndef digest() -&gt; Optional[bytes]\n</code></pre> <p>Get the contract digest.</p> <p>Returns:</p> <p>contract digest</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#code_id","title":"code<code>_</code>id","text":"<pre><code>@property\ndef code_id() -&gt; Optional[int]\n</code></pre> <p>Get the code id.</p> <p>Returns:</p> <p>code id</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; Optional[Address]\n</code></pre> <p>Get the contract address.</p> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#store","title":"store","text":"<pre><code>def store(sender: Wallet,\ngas_limit: Optional[int] = None,\nmemo: Optional[str] = None) -&gt; int\n</code></pre> <p>Store the contract.</p> <p>Arguments:</p> <ul> <li><code>sender</code>: sender wallet address</li> <li><code>gas_limit</code>: transaction gas limit, defaults to None</li> <li><code>memo</code>: transaction memo, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Runtime error</li> </ul> <p>Returns:</p> <p>code id</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#instantiate","title":"instantiate","text":"<pre><code>def instantiate(args: Any,\nsender: Wallet,\nlabel: Optional[str] = None,\ngas_limit: Optional[int] = None,\nadmin_address: Optional[Address] = None,\nfunds: Optional[str] = None) -&gt; Address\n</code></pre> <p>Instantiate the contract.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> <li><code>sender</code>: sender wallet address</li> <li><code>label</code>: label, defaults to None</li> <li><code>gas_limit</code>: transaction gas limit, defaults to None</li> <li><code>admin_address</code>: admin address, defaults to None</li> <li><code>funds</code>: funds, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to extract contract code id</li> </ul> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#upgrade","title":"upgrade","text":"<pre><code>def upgrade(args: Any,\nsender: Wallet,\nnew_path: str,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Store new contract code and migrate the current contract address.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> <li><code>sender</code>: sender wallet address</li> <li><code>new_path</code>: path to new contract</li> <li><code>gas_limit</code>: transaction gas limit, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to extract contract code id</li> </ul> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#migrate","title":"migrate","text":"<pre><code>def migrate(args: Any,\nsender: Wallet,\nnew_code_id: int,\ngas_limit: Optional[int] = None) -&gt; SubmittedTx\n</code></pre> <p>Migrate the current contract address to new code id.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> <li><code>sender</code>: sender wallet address</li> <li><code>new_code_id</code>: Code id of the newly deployed contract</li> <li><code>gas_limit</code>: transaction gas limit, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Unable to extract contract code id</li> </ul> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#deploy","title":"deploy","text":"<pre><code>def deploy(args: Any,\nsender: Wallet,\nlabel: Optional[str] = None,\nstore_gas_limit: Optional[int] = None,\ninstantiate_gas_limit: Optional[int] = None,\nadmin_address: Optional[Address] = None,\nfunds: Optional[str] = None) -&gt; Address\n</code></pre> <p>Deploy the contract.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> <li><code>sender</code>: sender address</li> <li><code>label</code>: label, defaults to None</li> <li><code>store_gas_limit</code>: store gas limit, defaults to None</li> <li><code>instantiate_gas_limit</code>: instantiate gas limit, defaults to None</li> <li><code>admin_address</code>: admin address, defaults to None</li> <li><code>funds</code>: funds, defaults to None</li> </ul> <p>Returns:</p> <p>instantiate contract details</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#execute","title":"execute","text":"<pre><code>def execute(args: Any,\nsender: Wallet,\ngas_limit: Optional[int] = None,\nfunds: Optional[str] = None) -&gt; SubmittedTx\n</code></pre> <p>execute the contract.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> <li><code>sender</code>: sender address</li> <li><code>gas_limit</code>: transaction gas limit, defaults to None</li> <li><code>funds</code>: funds, defaults to None</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Contract appears not to be deployed currently</li> </ul> <p>Returns:</p> <p>transaction details broadcast</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#query","title":"query","text":"<pre><code>def query(args: Any) -&gt; Any\n</code></pre> <p>Query on contract.</p> <p>Arguments:</p> <ul> <li><code>args</code>: args</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code>: Contract appears not to be deployed currently</li> </ul> <p>Returns:</p> <p>query result</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#data","title":"data","text":"<pre><code>@property\ndef data()\n</code></pre> <p>Get the contract address.</p> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/__init__/#__json__","title":"<code>__</code>json<code>__</code>","text":"<pre><code>def __json__()\n</code></pre> <p>Get the contract details in json.</p> <p>Returns:</p> <p>contract details in json</p>"},{"location":"CosmPy/api/aerial/contract/cosmwasm/","title":"Cosmwasm contract store, instantiate, execute messages","text":""},{"location":"CosmPy/api/aerial/contract/cosmwasm/#cosmpyaerialcontractcosmwasm","title":"cosmpy.aerial.contract.cosmwasm","text":"<p>Cosmwasm contract store, instantiate, execute messages.</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/cosmwasm/#create_cosmwasm_store_code_msg","title":"create<code>_</code>cosmwasm<code>_</code>store<code>_</code>code<code>_</code>msg","text":"<pre><code>def create_cosmwasm_store_code_msg(contract_path: str,\nsender_address: Address) -&gt; MsgStoreCode\n</code></pre> <p>Create cosmwasm store code message.</p> <p>Arguments:</p> <ul> <li><code>contract_path</code>: contract path</li> <li><code>sender_address</code>: sender address</li> </ul> <p>Returns:</p> <p>cosmwasm store code message</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/cosmwasm/#create_cosmwasm_instantiate_msg","title":"create<code>_</code>cosmwasm<code>_</code>instantiate<code>_</code>msg","text":"<pre><code>def create_cosmwasm_instantiate_msg(\ncode_id: int,\nargs: Any,\nlabel: str,\nsender_address: Address,\nfunds: Optional[str] = None,\nadmin_address: Optional[Address] = None) -&gt; MsgInstantiateContract\n</code></pre> <p>Create cosmwasm instantiate message.</p> <p>Arguments:</p> <ul> <li><code>code_id</code>: code id</li> <li><code>args</code>: args</li> <li><code>label</code>: label</li> <li><code>sender_address</code>: sender address</li> <li><code>funds</code>: funds, defaults to None</li> <li><code>admin_address</code>: admin address, defaults to None</li> </ul> <p>Returns:</p> <p>cosmwasm instantiate message</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/cosmwasm/#create_cosmwasm_migrate_msg","title":"create<code>_</code>cosmwasm<code>_</code>migrate<code>_</code>msg","text":"<pre><code>def create_cosmwasm_migrate_msg(code_id: int, args: Any,\ncontract_address: Address,\nsender_address: Address) -&gt; MsgMigrateContract\n</code></pre> <p>Create cosmwasm migrate message.</p> <p>Arguments:</p> <ul> <li><code>code_id</code>: code id</li> <li><code>args</code>: args</li> <li><code>contract_address</code>: sender address</li> <li><code>sender_address</code>: sender address</li> </ul> <p>Returns:</p> <p>cosmwasm migrate message</p> <p></p>"},{"location":"CosmPy/api/aerial/contract/cosmwasm/#create_cosmwasm_execute_msg","title":"create<code>_</code>cosmwasm<code>_</code>execute<code>_</code>msg","text":"<pre><code>def create_cosmwasm_execute_msg(\nsender_address: Address,\ncontract_address: Address,\nargs: Any,\nfunds: Optional[str] = None) -&gt; MsgExecuteContract\n</code></pre> <p>Create cosmwasm execute message.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: sender address</li> <li><code>contract_address</code>: contract address</li> <li><code>args</code>: args</li> <li><code>funds</code>: funds, defaults to None</li> </ul> <p>Returns:</p> <p>cosmwasm execute message</p>"},{"location":"Jenesis/","title":"Introduction","text":"<p>Jenesis is a command line tool for rapid contract and service development for the Fetch.ai blockchain ecosystem and other CosmWasm-enabled blockchains.</p>"},{"location":"Jenesis/#system-requirements","title":"System Requirements","text":"<p>Jenesis currently requires:</p> <ul> <li>OS: Linux, MacOS</li> <li>Python: 3.8 to 3.10</li> <li>Docker: 20.10.22 or higher recommended</li> <li>git: Any</li> </ul>"},{"location":"Jenesis/#installation","title":"Installation","text":"<p>Install via PyPI:</p> <pre><code>pip install jenesis\n</code></pre>"},{"location":"Jenesis/#getting-started","title":"Getting started","text":"<p>There are multiple commands integrated into jenesis that allow you to perform a variety of tasks these commands are:</p> <ul> <li><code>new</code> </li> <li><code>init</code></li> <li><code>add</code></li> <li><code>update</code></li> <li><code>attach</code></li> <li><code>compile</code></li> <li><code>keys</code></li> <li><code>deploy</code></li> <li><code>run</code></li> <li><code>shell</code></li> <li><code>network</code></li> </ul>"},{"location":"Jenesis/#create-a-new-project","title":"Create a new project","text":"<p>Create a project using the <code>new</code> command <pre><code>jenesis new my_project [--profile my_profile] [--network network_name]\n</code></pre></p> <p>This will create a new directory called <code>my_project</code>. You can use <code>--profile</code> and <code>--network</code> optional arguments; when they aren't used, profile and network will be set to <code>testing</code> and <code>fetchai-testnet</code> respectively. Inside this directory a <code>jenesis.toml</code> file will be created containing the following information:</p> <pre><code>[project]\nname = \"my_project\"\nauthors = [ \"Alice Tyler &lt;alice@mail.com&gt;\"]\nkeyring_backend = \"os\"\n[profile.my_profile]\ndefault = true\n[profile.my_profile.network]\nname = \"fetchai-testnet\"\nchain_id = \"dorado-1\"\nfee_minimum_gas_price = 5000000000\nfee_denomination = \"atestfet\"\nstaking_denomination = \"atestfet\"\nurl = \"grpc+https://grpc-dorado.fetch.ai\"\nfaucet_url = \"https://faucet-dorado.fetch.ai\"\nis_local = false\n[profile.my_profile.contracts]\n</code></pre> <p>The project name is the argument passed to the <code>new</code> command while the authors field is populated by querying the user's GitHub username and email address. The profile's network will be filled with the relevant configuration variables. The contracts field will remain empty until new contracts are added. This <code>my_profile</code> profile will be set as the default profile, this means that every time you use a jenesis command without specifying a profile, <code>my_profile</code> will be used.</p> <p>An empty <code>contracts</code> folder will also be created inside <code>my_project</code> directory that will eventually contain all the information needed to compile and deploy the desired contracts.</p> <p>The <code>init</code> command is similar to the <code>new</code> command, but in this case, you won't need a project name argument since this command is intended to run inside an existing project directory.</p> <pre><code>jenesis init [--profile my_profile] [--network network_name]\n</code></pre> <p>This command will create the same files and folders inside your project directory as the ones described for the <code>new</code> command.</p> <p>If using a cargo workspace, you just need to navigate to the top level of your project and run the <code>init</code> command shown above. This will create the <code>jenesis.toml</code> configuration file inside your workspace including all the relevant information from existing contracts.</p>"},{"location":"Jenesis/#configure-a-network","title":"Configure a network","text":"<p>By default, jenesis will configure the project to run on the latest stable Fetch.ai testnet. Use <code>fetchai-mainnet</code> to configure for the Fetch.ai mainnet or directly edit the <code>jenesis.toml</code> file to configure for other networks.</p> <p>To test on a local node, pass the argument <code>--network fetchai-localnode</code> when creating a project: <pre><code>jenesis new my_project --network fetchai-localnode\n</code></pre> or <pre><code>jenesis init --network fetchai-localnode\n</code></pre></p> <p>The configuration can be found under the <code>network</code> heading in the <code>jenesis.toml</code> file and can be changed as desired:</p> <p><pre><code>[profile.testing.network]\nname = \"fetchai-localnode\"\nchain_id = \"localnode\"\nfee_minimum_gas_price = 5000000000\nfee_denomination = \"atestfet\"\nstaking_denomination = \"atestfet\"\nurl = \"grpc+http://127.0.0.1:9090/\"\nis_local = true\nkeep_running = false\ncli_binary = \"fetchd\"\nvalidator_key_name = \"validator\"\nmnemonic = \"gap bomb bulk border original scare assault pelican resemble found laptop skin gesture height inflict clinic reject giggle hurdle bubble soldier hurt moon hint\"\npassword = \"12345678\"\nmoniker = \"test-node\"\ngenesis_accounts = [ \"fetch1vas6cc9650z0s08230ytqjphgzl5tcq9crqhhu\",]\ntimeout_commit = \"5s\"\ndebug_trace = true\n</code></pre> In particular, to fund some accounts for testing, replace the <code>genesis_accounts</code> field with the addresses to be funded.</p> <p>When running any of the commands <code>deploy</code>, <code>run</code>, <code>shell</code>, and <code>attach</code>, jenesis will check for a currently running local node, and if there is none, a new one will be created in a docker container. If you wish to keep a local node running, you need to set the <code>keep_running</code> parameter to <code>true</code>. Otherwise, nodes will be stopped after any of the command mentioned above finish running.</p> <p>At any time, you can start or stop a local node by running: <pre><code>jenesis network start [--profile my_profile]\n</code></pre> or <pre><code>jenesis network stop [--profile my_profile]\n</code></pre></p> <p>To view the logs from the local node, run: <pre><code>jenesis network logs [--profile my_profile]\n</code></pre></p>"},{"location":"Jenesis/add-contracts/","title":"Add contract templates","text":"<p>Once you have successfully created your project, you can add contract templates. You first need to navigate to your project's directory and run the following command:</p> <p><pre><code>jenesis add contract &lt;template&gt; &lt;contract_name&gt;\n</code></pre> You can find all the contract templates available in Jenesis Templates. An example of how to add the template cw20-base with the name <code>my_token</code> is given below:</p> <pre><code>jenesis add contract cw20-base my_token\n</code></pre> <p>If you need multiple deployments of the same contract, you can use the <code>--deployments</code> or <code>-d</code> flag to specify multiple deployments and name them.  <pre><code>jenesis add contract &lt;template&gt; &lt;contract_name&gt; [--deployments &lt;deployments&gt;]\n</code></pre> Jenesis will add the deployments to all profiles for the specified contract.  In the example below, <code>token_1</code> and <code>token_2</code> deployments have been added. This will allow you to deploy <code>my_token</code> contract with two different configurations. You can add as many deployments as you wish. <pre><code>jenesis add contract cw20-base my_token -d token_1 token_2\n</code></pre></p> <p>If no deployments are selected when adding a contract, the default deployment name will be equal to the contract name.</p> <p>This <code>add contract</code> command will add a contract template to your jenesis project inside <code>contracts/my_token/</code> folder. It will also update the <code>jenesis.toml</code> configuration file with the contract information.</p> <pre><code>[profile.testing.contracts.token_1]\nname = \"token_1\"\ncontract = \"my_token\"\nnetwork = \"fetchai-testnet\"\ndeployer_key = \"\"\ninit_funds = \"\"\n[profile.testing.contracts.token_2]\nname = \"token_2\"\ncontract = \"my_token\"\nnetwork = \"fetchai-testnet\"\ndeployer_key = \"\"\ninit_funds = \"\"\n[profile.testing.contracts.token_1.init]\n[profile.testing.contracts.token_2.init]\n</code></pre> <p>The <code>deployer_key</code> field can be manually specified, you can choose any private key locally available to deploy any specific contract. You can also leave this field empty since the <code>deploy</code> command has an optional argument to deploy all contracts inside a specified profile with the same key, overriding this <code>deployer_key</code> argument in the <code>jenesis.toml</code> file. See deploy contracts for more information. </p> <p>Finally, the <code>init</code> section contains the parameters needed in the instantiation message for this contract to be deployed. The required parameters are taken from the schema file inside the <code>contracts</code> directory. Since this contract template doesn't include a schema, it will be generated when compiling the <code>my_token</code> contract loading the init fields to the <code>jenesis.toml</code> file. You will need to manually add the values for these parameters in their correct variable type, which are listed on the schema file. For this  my_token contract, we need to fill the following init fields for each deployment after compiling. Here is an example:</p> <pre><code>[profile.testing.contracts.token_1.init]\ndecimals = 6\nname = \"my_token_name\"\nsymbol = \"SYMBOL\"\ninitial_balances = [{ address = \"fetch1d25ap9danl4726uk2nt307y630v87h3h2vq6pl\", amount =  \"5000\"}]\n\n[profile.testing.contracts.token_2.init]\ndecimals = 6\nname = \"my_token_name_2\"\nsymbol = \"SYMBOL\"\ninitial_balances = [{ address = \"fetch1d25ap9danl4726uk2nt307y630v87h3h2vq6pl\", amount =  \"2000\"}]\n</code></pre> <p>If your contract requires nested instantiation messages you may add fields following this structure:</p> <pre><code>[profile.testing.contracts.example-nested-contract.init]\nprice = {amount = 1000, denom = DLS}\ninfo = {performance = {max_speed = 200, unit = kph}, fuel = {consumption = 7, unit = kmpl}}\n</code></pre> <p>NOTE: Before editing the <code>jenesis.toml</code> configuration file with the desired <code>deployer_key</code> and <code>init</code> parameters, make sure to first compile your contract. All configuration parameters will restart every time a contract is compiled if the schema has changed.</p> <p>You can also add contracts manually by copying and pasting the contract directory from another project you may have, however, they need to follow the same directory structure as the starter template mentioned above.</p> <p>When you add a contract manually, you need to update the <code>jenesis.toml</code> file with the contract information by running:</p> <p><pre><code>jenesis update\n</code></pre> The <code>update</code> command will automatically detect which contract is missing in the <code>jenesis.toml</code> configuration file by revising the contracts directory.</p>"},{"location":"Jenesis/add-contracts/#add-contract-deployments","title":"Add contract deployments","text":"<p>You can also add further deployments for a given contract by specifying the contract name and the deployment name. If we want to add a third token called <code>token_3</code> using <code>my_token</code> contract, we can run:  </p> <p><pre><code>jenesis add deployment my_token token_3\n</code></pre> This will automatically create another deployment entry called <code>token_3</code>.</p>"},{"location":"Jenesis/add-contracts/#attach-deployed-contracts","title":"Attach deployed contracts","text":"<p>If you add a contract into the project's contract folder that has already been deployed in the network, you can attach the deployment to your project for future interaction using the <code>attach</code> command.</p> <p>To add a deployment to yout project you can run:</p> <pre><code>jenesis add contract cw20-base my_token -d token_1\n</code></pre> <p>Then compile the contract:</p> <pre><code>jenesis compile\n</code></pre> <p>To attach the contract, you will need to specify the deployment's name and address. You can optionally specify the profile where you wish to insert the contract into. If this is not specified, the deployment will be attached to the default profile, which is the first profile created in your project, unless the <code>default</code> settings are manually changed.</p> <pre><code>jenesis attach token_1 fetch18xs97q6h9zgh4sz730a42pp0dqa9sh4eef7eutfkv69q3v2y3x8s72pkua\n</code></pre> <p>This will add the relevant deployment information into a <code>jenesis.lock</code> file and you will now be able to interact with <code>token_1</code> using contract interactions.</p>"},{"location":"Jenesis/add-profile/","title":"Add profiles","text":"<p>You can add more profiles than the one specified using the <code>new</code> command by running the following <code>add profile</code> command:</p> <p><pre><code>jenesis add profile my_second_profile\n</code></pre> By default, the profile's network will be set to <code>fetchai-testnet</code>, but you can specify it using the <code>--network</code> optional argument. The following will be added to the existing information in your <code>jenesis.toml</code> file:</p> <pre><code>[profile.my_second_profile.network]\nname = \"fetchai-testnet\"\nchain_id = \"dorado-1\"\nfee_minimum_gas_price = 5000000000\nfee_denomination = \"atestfet\"\nstaking_denomination = \"atestfet\"\nurl = \"grpc+https://grpc-dorado.fetch.ai\"\nfaucet_url = \"https://faucet-dorado.fetch.ai\"\nis_local = false\n[profile.my_second_profile.contracts]\n</code></pre> <p>Currently available network configurations are <code>fetchai-testnet</code>, <code>fetchai-mainnet</code>, and <code>fetchai-localnode</code>, but Jenesis is easily configurable for other networks by directly editing the <code>jenesis.toml</code> file.</p>"},{"location":"Jenesis/compile-contracts/","title":"Compile contracts","text":""},{"location":"Jenesis/compile-contracts/#compile-contracts","title":"Compile contracts","text":"<p>Compile your contracts by running the following command inside your project directory:</p> <p><pre><code>jenesis compile [--optimize] [--rebuild] [--no-log]\n</code></pre> This will compile all packages in your project's contracts directory and output the wasm code under the artifacts directory. If using a cargo workspace, jenesis will automatically detect this and the compiled contracts will appear in the <code>contracts/artifacts/</code>. Otherwise, they will go to the <code>artifacts</code> directory under the individual contracts.</p> <p>By default, the contracts are simply compiled and not optimized. For an optimized build, use the flag <code>--optimize</code> or <code>-o</code>. To force a rebuild, use the flag <code>--rebuild</code> or <code>-r</code>. To suppress contract compilation logs, use the flag <code>--no-log</code>. In case of compilation failure, the logs will show by default.</p> <p>Note: <code>jenesis compile</code> requires that docker is running and configured with permissions for your user.</p>"},{"location":"Jenesis/deploy-contracts/","title":"Deploy contracts","text":"<p>Once you have successfully compiled your contracts, make sure to fill out the necessary instantiation message information under the <code>init</code> field in the <code>jenesis.toml</code> file.</p> <p>*Note: <code>jenesis deploy</code> currently requires that each contract's directory name matches the <code>.wasm</code> file name under the <code>artifacts</code> directory.</p> <p>To deploy all the contracts inside a profile you have two options: </p> <ol> <li>Fill the <code>deployer_key</code> field for each contract inside the <code>jenesis.toml</code> file (keys can be different for each contract) and run the following command:</li> </ol> <p><pre><code>jenesis deploy [--profile profile_name]\n</code></pre> Each contract inside the specified profile will be deployed with the specified key.</p> <ol> <li>Simply specify a certain key as an argument of the deploy command:</li> </ol> <pre><code>jenesis deploy key_name [--profile profile_name]\n</code></pre> <p>The <code>deployer_key</code> field will be ignored in this case and all contracts inside the specified profile will be deployed using the key <code>key_name</code>.</p> <p>After running either of the commands mentioned above, all the deployment information will be saved in the <code>jenesis.lock</code> file inside your project's directory</p> <pre><code>[profile.testing.my_first_contract]\nchecksum = \"ecf640a7512be3777c72ec42aff01fdb22897b71953011af3c41ee5dbf3d3bc5\"\ndigest = \"be4a4bdfeb4ed8f504c7b7ac84e31ad3876627398a6586b49cac586633af8b85\"\naddress = \"fetch16l239ggyr4z7pvsxec0ervlyw03mn6pz62l9ss6la94cf06awv0q36cq7u\"\ncode_id = 2594\n</code></pre>"},{"location":"Jenesis/deploy-contracts/#deploy-contracts-that-depend-on-other-deployments","title":"Deploy contracts that depend on other deployments","text":"<p>You can point to other contract addresses in any contract's instantiation message if required.  For example: if you have contracts <code>A</code>, <code>B</code>, and <code>C</code> within your project, but contract <code>A</code> requires contract's <code>B</code> deployment address in its instantiation message and contract <code>B</code> requires contract's <code>C</code> deployment address, they will need to be deployed in the following order: <code>C</code>, <code>B</code>, <code>A</code>. In order to provide this information to <code>Jenesis</code> you will need to specify where exactly these contract addresses need to be inserted inside the instantiation messages. You can do this by writing the <code>$</code> symbol followed by the contract name in the corresponding field in the init parameters:</p> <pre><code>[profile.testing.contracts.A.init]\nname = \"A\"\ntoken_contract_address = \"$B\"\n[profile.testing.contracts.B.init]\ntoken_name = \"my_token\"\nliquidity_contract_address = \"$C\"\n[profile.testing.contracts.C.init]\ncount = 5\n</code></pre> <p>Finally, <code>Jenesis</code> will detect this information and deploy the contracts in the correct order: <code>C</code>, <code>B</code>, <code>A</code>.</p>"},{"location":"Jenesis/keys/","title":"Keys","text":"<p>With the <code>keys</code> command you can either list all the locally available keys or show the address of a specific key. To list all the keys available run the following command: <pre><code>jenesis keys list\n</code></pre></p> <p>To look up the address for a specified key you can use the <code>show</code> command and pass the key name as an argument: <pre><code>jenesis keys show my_key\n</code></pre> To access other key functionalities such as adding new keys, looking up an address, and recovering keys you can use fetchd CLI - Managing Keys</p>"},{"location":"Jenesis/use-contracts/","title":"Contract Interaction","text":"<p>You can interact with your project's contracts by using the <code>shell</code> or <code>run</code> commands.</p>"},{"location":"Jenesis/use-contracts/#previous-steps","title":"Previous steps","text":"<p>To reproduce the examples in this document, add and compile a basic starter contract and a cw20 token contract to your project with the following commands:</p> <pre><code>jenesis add contract starter my_first_contract -d deployment_1\njenesis add contract cw20-base my_token -d token_1\njenesis compile\n</code></pre> <p>For more contract template examples visit Jenesis Templates</p>"},{"location":"Jenesis/use-contracts/#interactive-shell","title":"Interactive Shell","text":"<p>To open a shell where you can easily interact with your contracts, run: <pre><code>jenesis shell\n</code></pre> If a profile is not selected, the default profile will be selected automatically. You can specify any profile using the <code>--profile</code> optional argument:</p> <pre><code>jenesis shell --profile my_profile\n</code></pre> <p>You will observe the following text indicating the available contracts in your project.</p> <pre><code>Network: fetchai-testnet\nDetecting contracts...\nC deployment_1\nC token_1\nDetecting contracts...complete\n</code></pre> <p>NOTE: <code>jenesis shell</code> currently requires that contract names use accepted python variable names. For example, using <code>token-1</code> instead of <code>token_1</code> will generate an error when trying to interact with it.</p> <p>In this case, we can see that <code>deployment_1</code> and <code>token_1</code> deployments are available for this project. If these contracts have been already deployed you can directly interact with them by performing contract querys and executions such as:</p> <pre><code>&gt;&gt;&gt; deployment_1.query(args = {'msg_name': {...}}\n&gt;&gt;&gt; deployment_1.execute(args = {'msg_name': {...}}\n</code></pre> <p>A ledger client (<code>ledger</code>) and your locally stored wallet keys will also be available in the shell. For example, if you have a local key named <code>alice</code>, you will find this under <code>wallets['alice']</code> and you can query the balance as follows: <pre><code>&gt;&gt;&gt; ledger.query_bank_balance(wallets['alice'])\n10000000000000000000\n</code></pre></p> <p>If the ledger is a testnet with a faucet url, you can get funds using the <code>faucet</code>: <pre><code>&gt;&gt;&gt; faucet.get_wealth(wallets['alice'])\n</code></pre></p>"},{"location":"Jenesis/use-contracts/#dynamic-methods","title":"Dynamic Methods","text":"<p>Jenesis also attaches the contract query, execution and deploy messages as dynamic methods.</p> <p>For example, the following query</p> <p><pre><code>&gt;&gt;&gt; token_1.query({\"balance\": {\"address\": str(wallet.address())}}))\n</code></pre> can also be run with: <pre><code>&gt;&gt;&gt; token_1.balance(address=str(wallet.address()))\n{'balance': '4000'}\n</code></pre></p> <p>Similarly, instead of using <code>token_1.execute...</code> , a transfer can be executed with: <pre><code>&gt;&gt;&gt; token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)\n</code></pre></p> <p>Jensesis also has an autocompletion helper for query, execution and deployment arguments. It will show automatically when typing in the shell.</p> <p>We will now show an example assuming that the <code>token_1</code> deployment contract has only been compiled and not yet deployed, going through deployment, execution, and querying using dynamic methods.</p> <p>For this example, we will first generate two wallets. We provide wealth to the sender wallet in atestfet so it can pay for transaction fees.</p> <pre><code>&gt;&gt;&gt; wallet = LocalWallet.generate()\n&gt;&gt;&gt; wallet2 = LocalWallet.generate()\n&gt;&gt;&gt; faucet.get_wealth(wallet)\n</code></pre> <p>We now proceed to deploy <code>my_token</code> contract using <code>token_1</code> deployment configuration, we define the arguments for the cw20 token: name, symbol, decimal, and the addresses that will be funded with these cw20 tokens. In this case we will fund wallet's address with 5000 tokens.</p> <pre><code>&gt;&gt;&gt; token_1.deploy(name=\"Crab Coin\", symbol=\"CRAB\", decimals=6, initial_balances=[{ \"address\": str(wallet.address()), \"amount\" :  \"5000\"}], sender=wallet)\n</code></pre> <p>We can query wallet balance to make sure it has been funded with cw20 tokens</p> <pre><code>&gt;&gt;&gt; token_1.balance(address=str(wallet.address()))\n{'balance': '5000'}\n</code></pre> <p>We now execute a cw20 token transfer of 1000 tokens from wallet to wallet2</p> <pre><code>&gt;&gt;&gt; token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)\n</code></pre> <p>Finally, we query both wallet's balance</p> <p><pre><code>&gt;&gt;&gt; token_1.balance(address=str(wallet.address()))\n{'balance': '4000'}\n&gt;&gt;&gt; token_1.balance(address=str(wallet2.address()))\n{'balance': '1000'}\n</code></pre> We can observe that wallet has sent 1000 tokens to wallet2.</p>"},{"location":"Jenesis/use-contracts/#executing-scripts","title":"Executing Scripts","text":"<p>You can also assemble the above commands into a script that is executable by the  <code>run</code> command: <pre><code>from cosmpy.aerial.wallet import LocalWallet\nwallet = LocalWallet.generate()\nfaucet.get_wealth(wallet.address())\nwallet2 = LocalWallet.generate()\ntoken_1.deploy(name=\"Crab Coin\", symbol=\"CRAB\", decimals=6, initial_balances=[{ \"address\": str(wallet.address()), \"amount\" :  \"5000\"}], sender=wallet)\nprint(\"wallet initial cw20 MT balance: \", token_1.balance(address=str(wallet.address())))\ntx = token_1.transfer(amount='1000', recipient=str(wallet2.address()), sender=wallet)\nprint(\"transfering 1000 cw20 MT tokens from wallet to wallet2\")\ntx.wait_to_complete()\nprint(\"wallet final cw20 MT balance: \", token_1.balance(address=str(wallet.address())))\nprint(\"wallet2 final cw20 MT balance: \", token_1.balance(address=str(wallet2.address())))\n</code></pre></p> <p>If we paste the above code into the file script.py inside the project's directory, we can run it with:</p> <pre><code>jenesis run script.py\n</code></pre> <p>And you will observe the same output as before. You can also specify the profile as an optional argument using <code>--profile</code>.</p> <p>Finally, you can pass arguments to the script just as you would to a standard python script by placing all the arguments to the script after the <code>--</code> delimiter: <pre><code>jenesis run script.py [--profile profile_name] -- arg1 arg2 --key1 value1 --key2 value2\n</code></pre></p> <p>You can visit CosmPy for more contract interaction examples.</p>"},{"location":"aea-framework-documentation/","title":"AEA Framework Documentation","text":"<p>Vision</p> <p>Our aim with the AEA framework is to enable businesses of all sizes, from independent developers to large corporations and consortiums, to create and deploy agent-based solutions in various domains, thus contributing to and advancing a decentralized mixed-initiative economy: one whose actors are both humans and machines.</p>"},{"location":"aea-framework-documentation/#what-is-an-aea","title":"What is an AEA?","text":"<p>Definition</p> <p>An Autonomous Economic Agent (AEA) is an intelligent agent that acts on its owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner.</p> <p>Breaking it down:</p> <p>AGENT: An AEA represents an individual, organisation or object and looks after their interests.</p> <p>AUTONOMOUS: AEAs operate independently of constant input from their owners and act autonomously to achieve their goals.</p> <p>ECONOMIC: AEAs have a narrow and specific focus: creating economic value for their owner.</p>"},{"location":"aea-framework-documentation/#what-can-you-do-with-aeas","title":"What Can You Do with AEAs?","text":"<p>Some examples of the kinds of applications you can build with AEAs:</p> Automation <p>AEAs can automate well-defined processes in different domains, such as supply chain, mobility, finance, ...</p> Micro-transactions <p>AEAs make it economically viable to execute trade involving small values. An example is use-cases with many small sellers (e.g. of data) on the supply side.</p> Wallet <p>AEAs can simplify interactions with blockchains. By acting as \"smart wallets\", they can hide away the majority of the complexities involved in using blockchains for end users.</p> IoT <p>Agents representing objects in the IoT (Internet of Things) space. For example, AEAs paired with hardware devices such as drones, laptops, heat sensors, etc., providing control and receiving data from the device. An example is a thermometer agent.</p> Web 2.0 &lt;--&gt; Web 3.0 interface <p>Agents that interface and bridge the gap between existing (Web 2.0) and new (Web 3.0) economic models. An example is an  AEA that communicates with HTTP clients/servers.</p> Traders <p>Agents with access to some data sources that sell the data, access to the data, or access to the usage of the data. An example is an AEA that continuously sells data to another AEA, who in turn uses it to improve their reinforcement learning model.</p>"},{"location":"aea-framework-documentation/#who-is-this-for","title":"Who is This For?","text":"<p>The AEA technology is for anyone who wants to build or contribute to a \"mixed-initiative economy\": one whose actors are humans as well as machines. </p> <p>This includes (amongst others): developers, data scientists and machine learning experts, economists, students, academics and researchers (in Artificial Intelligence, Machine Learning, Multi-Agent Systems, etc), engineers, and so forth.</p>"},{"location":"aea-framework-documentation/#the-aea-framework","title":"The AEA Framework","text":"<p>The AEA framework is a development suite which equips you with an efficient and accessible set of tools for building and running AEAs and their components. </p> <p>The framework attempts to make agent development as straightforward an experience as possible, similar to what popular web frameworks enable for web development.</p> <p>Some of the characteristics of the AEA framework are:</p> <ul> <li>Python: Using Python as an approachable programming language improves the on-boarding for those who just want to get started with agent development.</li> <li>Open source: The framework is open source and licensed under Apache 2.0.</li> <li>Modular: Modularity is at the heart of the framework's design. This makes it easy to extend the framework, add new functionality, and re-use others' contributions, therefore reducing the development cost.</li> <li>Blockchain ready: Integration with blockchains is baked into the framework, enabling the creation of agents that take full advantage of the blockchain technology.</li> <li>Modern: The framework is built from and can be integrated with the latest technologies (e.g. asynchronous programming, blockchains and smart contracts, machine-learning ready, ...).</li> </ul>"},{"location":"aea-framework-documentation/#the-ecosystem","title":"The Ecosystem","text":"<p>Though they can work in isolation, AEAs are truly valuable when situated in a wider ecosystem consisting of tools and infrastructure that enable them to cooperate and compete, and interact with services as well as traditional or modern systems. These include:</p> <ul> <li>The Agent Communication Network (ACN): A peer-to-peer communication infrastructure that enables AEAs to directly communicate with one another without any intermediaries.</li> <li>The sOEF: A search and discovery system allowing AEAs to register themselves and the services they offer, and search for agents who offer specific services.</li> <li>The AEA Registry: A space to store and share AEAs or individual agent components for anyone to find and use.</li> <li>Blockchains: AEAs can use blockchains as a financial and commitment layer. Each ledger plug-in provided by the framework adds the ability for AEAs to interact with a specific ledger, such as the Fetch.ai blockchain or Ethereum.</li> <li>Smart Contracts: Contract packages are wrappers around smart contracts that allow AEAs to interact with them through a common interface.</li> </ul>"},{"location":"aea-framework-documentation/#how-to-get-involved","title":"How to get involved?","text":"<p>There are many ways for you to get involved. You can create agents, develop new agent components, extend existing components, and contribute to the development of the framework or other related tools. Please refer to the Contribution and Development guides.</p>"},{"location":"aea-framework-documentation/#next-steps","title":"Next Steps","text":"<p>To get started developing your own AEA, check out the getting started section.</p> <p>To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development.</p> <p>If you would like to develop an AEA in a language different to Python then check out our language agnostic AEA definition.</p> <p>If you want to run a demo, check out the demo guides.</p>"},{"location":"aea-framework-documentation/#help-us-improve","title":"Help us Improve","text":"<p>Note</p> <p>This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Discord channel.</p>"},{"location":"aea-framework-documentation/12-factor/","title":"Relationship with the Twelve-Factor App Methodology","text":"<p>The Twelve-Factor App is a set of best practices to build modern web applications, or software-as-a-service.</p> <p>In this section, we will see how the AEA framework facilitates the achievement of those in the development, release and deployment phases of an AEA project.</p> <p>Note that an AEA instance, as a software agent, can be seen as a more general case of a web app, as it not only shows reactive behaviour, but it is also proactive, depending on the goals assigned to it.</p>"},{"location":"aea-framework-documentation/12-factor/#codebase","title":"Codebase","text":"<p>Factor 1</p> <p>One codebase tracked in revision control, many deploys</p> <p>Support: Excellent</p> <p>The framework does not impose any particular requirement or convention on the type of version control software to be used to store an AEA project.</p>"},{"location":"aea-framework-documentation/12-factor/#dependencies","title":"Dependencies","text":"<p>Factor 2</p> <p>Explicitly declare and isolate dependencies</p> <p>Support: Good</p> <p>The framework allows an AEA project to explicitly declare the AEA package dependencies, and the PyPI dependencies needed to proper working.</p> <p>However, it does not provide built-in support for checking platform-specific dependencies, e.g. specific Python version, or needed system-wide available libraries. Nevertheless, this can be indirectly achieved by means of build scripts called on <code>aea build</code>, which can do the checks manually according to the specific requirements of the project.</p>"},{"location":"aea-framework-documentation/12-factor/#configuration","title":"Configuration","text":"<p>Factor 3</p> <p>Store configuration in the environment</p> <p>Support: Good</p> <p>An AEA project can specify an environment configuration file <code>.env</code>, stored in the project root, that the framework will use to update environment variables before the execution of the AEA instance.</p> <p>The CLI tool command <code>aea run</code> accepts the option <code>--env PATH</code> to change the default configuration file. However, the framework does not automatically switch between, nor allows to add, different types of configuration files, one for each deployment step (e.g. development, staging, production), without using the <code>--env</code> option.</p>"},{"location":"aea-framework-documentation/12-factor/#backing-services","title":"Backing Services","text":"<p>Factor 4</p> <p>Treat backing services as attached resources</p> <p>Support: Good</p> <p>A persistent storage of an AEA can be seen as an attached resource in the 12-factor terminology. The default storage is SQLite, but the interface <code>AbstractStorageBacked</code> allows to implement specific wrappers to other backing services, without changing the AEA project code. The support for integrating different storage back-end implementations in an AEA project by using a plug-in mechanism is currently missing.</p> <p>Moreover, new adapters to backing services can be implemented as custom connections, which can connect to attached resources. This does not usually require a change in the skill code, especially in the case when a custom protocol can abstract the details of the interaction with the specific resource.</p>"},{"location":"aea-framework-documentation/12-factor/#build-release-run","title":"Build, Release, Run","text":"<p>Factor 5</p> <p>Strictly separate build and run stages</p> <p>Support: Excellent</p> <p>The phases of build, release and run of an AEA project are neatly separated, both for programmatic usage and through the usage of the CLI tool, as each of them corresponds to different subcommands.</p>"},{"location":"aea-framework-documentation/12-factor/#processes","title":"Processes","text":"<p>Factor 6</p> <p>Execute the app as one or more stateless processes</p> <p>Support: Excellent</p> <p>Whether the process is stateless depends on the specific AEA. No strict enforcement is applied by the framework. Moreover, dialogue histories can be stored with persistent storage, if enabled by the developer.</p>"},{"location":"aea-framework-documentation/12-factor/#port-binding","title":"Port Binding","text":"<p>Factor 7</p> <p>Export services via port binding</p> <p>Support: Excellent</p> <p>An AEA project may not need to expose services via HTTP. This property depends on the specific choices of the project developer, and the framework does not impose any restriction.</p> <p>One of the provided package, the \"HTTP server\" connection, relies on <code>aiohttp</code>, which makes the connection completely self-contained\u2014therefore, it satisfies the requirement.</p> <p>Another relevant example is the ACN node, which exposes its service to the Libp2p AEA connection</p>"},{"location":"aea-framework-documentation/12-factor/#concurrency","title":"Concurrency","text":"<p>Factor 8</p> <p>Scale out via the process model</p> <p>Support: Not Supported</p> <p>The framework does not easily allow to scale up an AEA instance with multiple processes, as it is bound to a process. However, note that its attached services can live in a different process, which could give better scalability.</p>"},{"location":"aea-framework-documentation/12-factor/#disposability","title":"Disposability","text":"<p>Factor 9</p> <p>Maximize robustness with fast startup and graceful shutdown</p> <p>Support: Good</p> <p>Disposability of an AEA instance depends, in general, on the AEA itself; whether the connections can be quickly connected and disconnected, whether skills can be easily torn down or not, whether other resources can be detached successfully like the persistent storage, just to name a few examples.</p> <p>There has been put some effort into reducing startup time, and to ensure that a graceful shut-down can happen when the process receives a SIGTERM under normal circumstances, but robustness cannot be ensured for individual components, as it depends on their implementation.</p> <p>Additionally, the framework does provide some features to control some aspects of AEA disposability, e.g. the possibility to change execution timeout for behaviours or handlers, implementation of an effective exception propagation from a component code to the main agent loop.</p>"},{"location":"aea-framework-documentation/12-factor/#devprod-parity","title":"Dev/Prod Parity","text":"<p>Factor 10</p> <p>Keep development, staging, and production as similar as possible</p> <p>Support: Good</p> <p>This aspect mostly depends on the specific AEA project, and the framework does not impose particular restrictions on best deployment practices (e.g. continuous integration, same backing services between development and production stages).</p>"},{"location":"aea-framework-documentation/12-factor/#logs","title":"Logs","text":"<p>Factor 11</p> <p>Treat logs as event streams</p> <p>Support: Excellent</p> <p>Thanks to the seamless integration with the Python standard library <code>logging</code>, the developer or the deployer has great control on the routing and filtering of log records. The behaviour can be changed by providing a proper configuration in the AEA project configuration file, according to the standard library specification. The framework facilitates this by creating ad-hoc logger names that can be used for finer-grained routing or filtering; for example, each AEA instance uses its own logging namespace to send logging events. Integration with other log handlers is delegated to extensions of the standard library, hence not necessarily coupled with the AEA framework.</p>"},{"location":"aea-framework-documentation/12-factor/#admin-processes","title":"Admin Processes","text":"<p>Factor 12</p> <p>Run admin/management tasks as one-off processes</p> <p>Support: Good</p> <p>The CLI tool provides commands to manage private keys and ledger related operations, and it is possible to extend it with a plugin to manage databases of AEA's persistent storage for maintenance operations.</p> <p>Moreover, the Python programming language makes it easy to run one-off scripts or running a console (also known as REPL) to do management tasks. It follows that it is also easy to ensure dependency isolation and same configurations of the running AEA instance.</p>"},{"location":"aea-framework-documentation/acn-internals/","title":"ACN Internals","text":"<p>The aim of this document is to describe at a high-level the main implementation of the Agent Communication Network (ACN).</p> <p>In particular:</p> <ul> <li>the <code>libp2p_node</code> Golang library;</li> <li>the <code>p2p_libp2p</code> AEA connection written in Python, that implements the direct connection with an ACN peer;</li> <li>the <code>p2p_libp2p_client</code> AEA connection written in Python, which implements the delegate connection with an ACN peer.</li> </ul> <p>It is assumed the reader already knows what is the ACN and its purposes; if not, we suggest reading this page.</p> <p>This documentation page is structured as follows:</p> <ul> <li>Firstly, the ACN protocol is described: all the messages and data structures involved, as well as some example of interaction protocol with these messages;</li> <li>Then, it is explained how a peer can join an existing ACN network, and the message exchange involved;</li> <li>It follows the description of the journey of an envelope in the ACN network: from the agent connection to its contact peer, between ACN peers, and then from the contact peer of the destination agent to the target agent;</li> <li>The following section describes the functionalities of the AEA connections that allow to communicate through the ACN: <code>fetchai/p2p_libp2p</code> and <code>fetchia/p2p_libp2p_delegate</code>;</li> <li>The documentation ends with a section of known issues and limitations of the current implementation.</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#messages-and-data-structures","title":"Messages and Data Structures","text":"<p>At the foundation of the ACN there is the ACN protocol. The protocol messages and the reply structure are generated from this protocol specification, using the protocol generator. Therefore, it uses Protocol Buffers as a serialization format, and the definition of the data structures involved is defined in this <code>.proto</code> file.</p> <p>To know more about the protocol generator, refer to the relevant section of the documentation: Protocol Generator.</p>"},{"location":"aea-framework-documentation/acn-internals/#agent-record","title":"Agent Record","text":"<p>An agent record is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below).</p> <p>The <code>AgentRecord</code> data structure contains the following fields:</p> <ul> <li><code>service_id</code>: a string describing the service identifier.</li> <li><code>ledger_id</code>: a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are:<ul> <li><code>fetchai</code>, the identifier for the Fetch.AI ledger;</li> <li><code>ethereum</code>, the identifier for the Ethereum ledger;</li> <li><code>cosmos</code>, the identifier for the Cosmos ledger;</li> </ul> </li> <li><code>address</code>: a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes.</li> <li><code>public_key</code>: a string. The representative's public key. Used in case of (PoR).</li> <li><code>peer_public_key</code>: a string. The public key of the peer.</li> <li><code>signature</code>: a string. The signature for PoR.</li> <li><code>not_before</code>: a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: <code>YYYY-MM-DD</code>. It will be interpreted as time zone UTC-0</li> <li><code>not_after</code>: a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: <code>YYYY-MM-DD</code>. It will be interpreted as time zone UTC-0.</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#acn-message","title":"ACN Message","text":"<p>Entities in the ACN (i.e. either agents or peers) exchange ACN messages. An ACN message contains a <code>payload</code> field, which is the actual content of the message.</p> <p>There are different types of payloads:</p> <ul> <li><code>Status</code></li> <li><code>Register</code></li> <li><code>LookupRequest</code></li> <li><code>LookupResponse</code></li> <li><code>AeaEnvelope</code></li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#status","title":"Status","text":"<p>The <code>Status</code> payload is used as a response message to inform the sender about the handling of certain requests. The payload contains:</p> <ul> <li>the <code>status_code</code>, a positive integer among the ones in the Protobuf file.</li> <li>a list of error messages (string).</li> </ul> <p>A status code <code>0</code>, identified as <code>SUCCESS</code>, means that the request has been processed successfully. Status codes greater than <code>0</code> can be:</p> <ul> <li> <p>Generic errors: errors that occur under generic circumstances.</p> <ul> <li><code>ERROR_UNSUPPORTED_VERSION</code>, with integer value <code>1</code>: the receiver of the message does not support the protocol version of the sender;</li> <li><code>ERROR_UNEXPECTED_PAYLOAD</code>, with integer value <code>2</code>: the payload could not be deserialized on the receiver side;</li> <li><code>ERROR_GENERIC</code>, with integer value <code>3</code>: an internal error;</li> <li><code>ERROR_SERIALIZATION</code>, with integer value <code>4</code>: a serialization error occurred on the receiving end;</li> </ul> </li> <li> <p>Register errors: errors that occur during agent registration operations in the ACN.</p> <ul> <li><code>ERROR_WRONG_AGENT_ADDRESS</code>, with integer value <code>10</code>: the PoR by a peer from another peer does not match the destination address of the envelope to be routed by the receiving peer.</li> <li><code>ERROR_WRONG_PUBLIC_KEY</code>, with integer value <code>11</code>: the representative peer public key does not match the one in the agent record;</li> <li><code>ERROR_INVALID_PROOF</code>, with integer value <code>12</code>: the signature is invalid;</li> <li><code>ERROR_UNSUPPORTED_LEDGER</code>, with integer value <code>13</code>: the ledger of the PoR is not supported by the peer;</li> </ul> </li> <li> <p>Lookup and delivery errors: errors that occur during lookup to the DHT and envelope delivery operations in the ACN.</p> <ul> <li><code>ERROR_UNKNOWN_AGENT_ADDRESS</code>, with integer value <code>20</code>: the requested agent address has not been found in the local DHT of the peer;</li> <li><code>ERROR_AGENT_NOT_READY</code>, with integer value <code>21</code>: the agent is not ready for envelope delivery.</li> </ul> </li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#register","title":"Register","text":"<p>The <code>Register</code> payload is used to request a peer to register an agent among his known ones. The payload contains the field <code>record</code>, which is an instance of <code>AgentRecord</code>.</p>"},{"location":"aea-framework-documentation/acn-internals/#lookuprequest","title":"LookupRequest","text":"<p>The <code>LookupRequest</code> payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope.</p>"},{"location":"aea-framework-documentation/acn-internals/#lookupresponse","title":"LookupResponse","text":"<p>The <code>LookupResponse</code> payload is the response sent by a peer that received a <code>LookupRequest</code>. It contains the <code>AgentRecord</code> associated to the requested address.</p>"},{"location":"aea-framework-documentation/acn-internals/#aeaenvelope","title":"AeaEnvelope","text":"<p>The <code>AeaEnvelope</code> payload contains the envelope sent by an agent and to be delivered to another agent. It contains:</p> <ul> <li><code>envelope</code>: the envelope to be forwarded, in byte representation;</li> <li>an <code>AgentRecord</code> (see above).</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#acn-protocol-interactions","title":"ACN Protocol Interactions","text":"<p>The ACN protocol specifies three different possible interactions:</p> <ul> <li>the registration interaction</li> <li>the look-up interaction</li> <li>the routing interaction</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#registration-interaction","title":"\"Registration\" Interaction","text":"<p>The registration interaction is used by delegate agents or relayed peers to register themselves to another peer.</p> <pre><code>    sequenceDiagram\n        participant Agent/RelayedPeer\n        participant Peer\n        Agent/RelayedPeer-&gt;&gt;Peer: Register(AgentRecord)\n        alt success\n            note over Peer: check PoR\n            Peer-&gt;&gt;Agent/RelayedPeer: Status(SUCCESS)\n        else wrong agent address\n            Peer-&gt;&gt;Agent/RelayedPeer: Status(ERROR_WRONG_AGENT_ADDRESS)\n        else wrong public key\n            Peer-&gt;&gt;Agent/RelayedPeer: Status(ERROR_WRONG_PUBLIC_KEY)\n        else invalid proof of representation\n            Peer-&gt;&gt;Agent/RelayedPeer: Status(ERROR_INVALID_PROOF)\n        else unsupported ledger\n            Peer-&gt;&gt;Agent/RelayedPeer: Status(ERROR_UNSUPPORTED_LEDGER)\n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#look-up-interaction","title":"\"Look-up\" Interaction","text":"<p>The look-up interaction is used by a peer to request information to another peer about an agent address.</p> <pre><code>    sequenceDiagram\n        participant Peer1\n        participant Peer2\n        Peer1-&gt;&gt;Peer2: LookupRequest(address)\n        alt success\n            Peer2-&gt;&gt;Peer1: LookupResponse(AgentRecord)\n        else unknown agent address\n            Peer2-&gt;&gt;Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS)\n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#routing-interaction","title":"\"Routing\" Interaction","text":"<p>The routing interaction is used by agents and peers to route the envelope through the ACN.</p> <pre><code>    sequenceDiagram\n        participant Peer1\n        participant Peer2\n        Peer1-&gt;&gt;Peer2: AeaEnvelope(envelope, AgentRecord)\n        alt success\n            note over Peer2: check PoR\n            Peer2-&gt;&gt;Peer1: Status(SUCCESS)\n        else error on decoding of Envelope payload\n            Peer2-&gt;&gt;Peer1: Status(ERROR_SERIALIZATION)\n        else PoR errors\n            note over Peer1,Peer2: see above \n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#joining-the-acn-network","title":"Joining the ACN network","text":"<p>When an ACN peer wants to join the network, it has to start from a list of bootstrap peers, i.e. a list of ACN peers to connect with (at least one).</p> <p>Each node handles four different types of libp2p streams:</p> <ul> <li>the notification stream, identified by the URI <code>/aea-notif/</code>: this stream is used by new peers to notify their existence to</li> <li>the address stream, identified by the URI <code>/aea-address/</code>: used to send look-up requests and look-up responses;</li> <li>the envelope stream, identified by the URI <code>/aea/</code>: used to forward and to receive ACN envelopes;</li> <li>the register relay stream, identified by the URI <code>/aea-register/</code>: this is to receive messages from clients that want to register their agents addresses; this peer, and then it can register their addresses.</li> </ul> <p>To begin with, the node process initializes the transport connections with the bootstrap peers, the local copy of the Kademlia Distributed Hash Table (DHT), the persistent storage for agent records, and performs other non-functional operations like setting up the  Prometheus monitoring system. Optionally, can also start listening for relay connections and delegate connections.</p> <p>Then, it sets up the notification stream and notifies the bootstrap peers (if any).</p> <pre><code>    sequenceDiagram\n        participant Peer1\n        participant Peer2\n        participant Peer3\n        note over Peer1: notify&lt;br/&gt;bootstrap peers\n        Peer1-&gt;&gt;Peer2: notify\n        Peer2-&gt;&gt;Peer2: wait until notifying peer &lt;br/&gt;added to DHT\n        activate Peer2\n        Peer1-&gt;&gt;Peer3: notify\n        Peer3-&gt;&gt;Peer3: wait until notifying peer &lt;br/&gt;added to DHT\n        activate Peer3\n        note over Peer2,Peer3: Peer1 registered to DHT\n        deactivate Peer2\n        deactivate Peer3\n        loop for each local/relay/delegate address \n            Peer1-&gt;&gt;Peer1: compute CID from address\n            Peer1-&gt;&gt;Peer2: register address\n            Peer1-&gt;&gt;Peer3: register address\n        end\n        note over Peer1: set up:&lt;br/&gt;- address stream&lt;br/&gt;- envelope stream&lt;br/&gt;- register relay stream</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#relay-connections","title":"Relay Connections","text":"<p>If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests.</p> <p>The following diagram shows an example of the message exchanged during a registration request:</p> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer\n        Agent-&gt;&gt;Peer: Register\n        alt decoding error of ACN message\n            Peer-&gt;&gt;Agent: Status(ERROR_SERIALIZATION)\n        else wrong payload\n            Peer-&gt;&gt;Agent: Status(ERROR_UNEXPECTED_PAYLOAD)\n        else PoR check fails\n            alt wrong agent address\n                Peer-&gt;&gt;Agent: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else unsupported ledger\n                Peer-&gt;&gt;Agent: Status(ERROR_UNSUPPORTED_LEDGER)\n            else agent address and public key don't match\n                Peer-&gt;&gt;Agent: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else invalid proof\n                Peer-&gt;&gt;Agent: Status(ERROR_INVALID_PROOF)\n            end\n        else PoR check succeeds\n            Peer-&gt;&gt;Agent: Status(SUCCESS)\n            note over Peer: announce agent address&lt;br/&gt;to other peers\n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#delegate-connections","title":"Delegate Connections","text":"<p>If the ACN node is configured to run the delegate service, it starts listening from a TCP socket at a configurable URI.</p> <p>To see a diagram of the message exchanged during a registration request read this section.</p>"},{"location":"aea-framework-documentation/acn-internals/#acn-transport","title":"ACN Transport","text":"<p>In the following sections, we describe the main three steps of the routing of an envelope through the ACN:</p> <ul> <li>ACN entrance: when an envelope sent by an agent enters the peer-to-peer network via the peer the agent is connected to i.e. agent-to-peer communication;</li> <li>ACN routing: when an envelope gets routed through the peer-to-peer network, i.e. peer-to-peer communication;</li> <li>ACN exit: when an envelope gets delivered to the receiving agent through its representative peer, i.e. peer-to-agent communication.</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#acn-envelope-entrance-agent-peer","title":"ACN Envelope Entrance: Agent -&gt; Peer","text":"<p>In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent.</p> <p>The following diagram explains the exchange of messages on entering an envelope in the ACN.</p> <p>In the case of direct connection, <code>Agent</code> is a Python process, whereas <code>Peer</code> is in a separate (Golang) process. The logic of the Python Agent client is implemented in the AEA connection <code>fetchai/p2p_libp2p</code> The communication between <code>Agent</code> and <code>Peer</code> is done through an OS pipe for Inter-Process Communication (IPC) between the AEA's process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer.</p> <p>In the case of delegate connection, the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the <code>Agent</code> client connected with a delegate connection is implemented in the AEA connection <code>fetchai/p2p_libp2p_client</code></p> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer\n        loop until Status(success) received\n            Agent-&gt;&gt;Peer: AeaEnvelope\n            Agent-&gt;&gt;Agent: wait\n            note left of Agent: Wait until&lt;br/&gt;Status(success)\n            alt successful case\n                Peer-&gt;&gt;Agent: Status(success)\n                note over Agent: break loop\n            else ack-timeout OR conn-error\n                note left of Agent: continue: Try to&lt;br/&gt;resend/reconnect\n            else version not supported\n                Peer-&gt;&gt;Agent: Status(ERROR_UNSUPPORTED_VERSION)\n            else error on decoding of ACN message\n                Peer-&gt;&gt;Agent: Status(ERROR_SERIALIZATION)\n            else error on decoding of Envelope payload\n                Peer-&gt;&gt;Agent: Status(ERROR_SERIALIZATION)\n            else the payload cannot be handled\n                Peer-&gt;&gt;Agent: Status(ERROR_UNEXPECTED_PAYLOAD)\n            end\n        end\n        note over Peer: route envelope&lt;br/&gt;to next peer</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#acn-envelope-routing","title":"ACN Envelope Routing","text":"<p>In this section, we describe the interaction between peers when it comes to envelope routing.</p> <p>Assume an envelope arrives from an agent to peer <code>Peer1</code>, i.e. <code>Peer1</code> is the first hop of the routing. Let <code>Agent</code> be the local agent directly connected to <code>Peer1</code>, <code>Peer2</code> a direct peer of peer <code>Peer1</code>.</p> <p>When the envelope is leaving <code>Peer1</code>, we may have different scenario:</p> <ol> <li> <p>In case of direct connection, and the field <code>sender</code> of the envelope is not the local agent address: the message is considered invalid, and it is dropped.</p> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer1\n        participant Peer2\n        Agent-&gt;&gt;Peer1: AeaEnvelope\n        alt envelope sender not registered locally\n            note over Peer1: stop, log error\n        end</code></pre> </li> <li> <p>the <code>target</code> of the envelope is the local agent connected to the peer: the envelope is routed to the local agent.</p> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer1\n        participant Peer2\n        Agent-&gt;&gt;Peer1: AeaEnvelope\n        alt target == peer1.my_agent\n            note over Peer1: envelope destinated&lt;br/&gt; to local agent,&lt;br/&gt; not routing\n            loop agent not ready\n                note over Peer1: sleep for 100ms\n            end\n            Peer1-&gt;&gt;Agent: AeaEnvelope\n            Agent-&gt;&gt;Peer1: Status(Success)\n        end</code></pre> </li> <li> <p>the <code>target</code> is a delegate client. Send the envelope via TCP.</p> <pre><code>    sequenceDiagram\n        participant Delegate\n        participant Peer1\n        participant Peer2\n        Delegate-&gt;&gt;Peer1: AeaEnvelope\n        alt destination is a delegate\n            note over Peer1: send envelope&lt;br/&gt; to delegate via TCP\n            Peer1-&gt;&gt;Delegate: AeaEnvelope\n            Delegate-&gt;&gt;Peer1: Status(Success)\n        end</code></pre> </li> <li> <p>Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers.</p> </li> </ol> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer1\n        participant Peer2\n        Agent-&gt;&gt;Peer1: AeaEnvelope\n        alt address found in DHT\n            note over Peer1: destination is a&lt;br/&gt;relay client\n        else lookup address in DHT\n            note over Peer1: send lookup request&lt;br/&gt; to all peers\n            Peer1-&gt;&gt;Peer2: LookupRequest\n            alt generic error\n                Peer2-&gt;&gt;Peer1: Status(GENERIC_ERROR)\n            else look-up response\n                Peer2-&gt;&gt;Peer1: LookupResponse\n                note over Peer1: Check PoR\n            else not found\n                Peer2-&gt;&gt;Peer1:Status(UNKNOWN_AGENT_ADDRESS)\n            end\n        end\n        note over Peer1,Peer2: Now Peer1 knows the contact peer&lt;br/&gt;is PeerX</code></pre> <p>In particular, when a peer receives a LookupRequest message, it does the following:</p> <pre><code>    sequenceDiagram\n        participant Peer1\n        participant Peer2\n        Peer1-&gt;&gt;Peer2: LookupRequest\n        alt error\n            Peer2-&gt;&gt;Peer1: Status(Error)\n        else local agent/relay/delegate\n            note over Peer2: requested address is&lt;br/&gt;a local agent&lt;br/&gt;OR&lt;br/&gt;requested address is&lt;br/&gt;in my relay clients&lt;br/&gt;OR&lt;br/&gt;requested address is&lt;br/&gt;in my delegate clients\n            Peer2-&gt;&gt;Peer1: LookupResponse\n            note over Peer1: Check PoR\n        else not found locally\n            note over Peer2: send lookup request&lt;br/&gt;to other peers...\n            alt found\n                Peer2-&gt;&gt;Peer1: LookupResponse\n                note over Peer1: Check PoR\n            else not found\n                Peer2-&gt;&gt;Peer1:Status(UNKNOWN_AGENT_ADDRESS)\n            end\n        end</code></pre> <p>Let <code>Peer3</code> the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope:</p> <pre><code>    sequenceDiagram\n        participant Peer1\n        participant Peer3\n        Peer1-&gt;&gt;Peer3: AeaEnvelope\n        alt decoding error of ACN message\n            Peer3-&gt;&gt;Peer1: Status(ERROR_SERIALIZATION)\n        else unexpected payload\n            Peer3-&gt;&gt;Peer1: Status(ERROR_UNEXPECTED_PAYLOAD)\n        else decoding error of envelope payload\n            Peer3-&gt;&gt;Peer1: Status(ERROR_SERIALIZATION)        \n        else PoR check fails\n            alt wrong agent address\n                Peer3-&gt;&gt;Peer1: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else unsupported ledger\n                Peer3-&gt;&gt;Peer1: Status(ERROR_UNSUPPORTED_LEDGER)\n            else agent address and public key don't match\n                Peer3-&gt;&gt;Peer1: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else invalid proof\n                Peer3-&gt;&gt;Peer1: Status(ERROR_INVALID_PROOF)\n            end\n        else PoR check succeeds\n            alt target is delegate, not ready\n                Peer3-&gt;&gt;Peer1: Status(ERROR_AGENT_NOT_READY)\n            else exists delegate, ready\n                note over Peer3: forward envelope via&lt;br/&gt;delegate connection\n                Peer3-&gt;&gt;Peer1: Status(SUCCESS)\n            else target is local agent, not ready\n                Peer3-&gt;&gt;Peer1: Status(ERROR_AGENT_NOT_READY)\n            else target is local agent, ready\n                note over Peer3: forward envelope via&lt;br/&gt;direct connection\n                Peer3-&gt;&gt;Peer1: Status(SUCCESS)\n            else agent does not exist\n                Peer3-&gt;&gt;Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS)\n            end\n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#acn-envelope-exit-peer-agent","title":"ACN Envelope Exit: Peer -&gt; Agent","text":"<p>The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent.</p> <p>The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance (see above).</p> <pre><code>    sequenceDiagram\n        participant Agent\n        participant Peer\n        Peer-&gt;&gt;Agent: AeaEnvelope\n        alt successful case\n            Agent-&gt;&gt;Peer: Status(success)\n        else ack-timeout OR conn-error\n            note left of Peer: do nothing\n        else error on decoding of ACN message\n            Agent-&gt;&gt;Peer: Status(GENERIC_ERROR)\n        else error on decoding of Envelope payload\n            Agent-&gt;&gt;Peer: Status(GENERIC_ERROR)\n        else wrong payload\n            Agent-&gt;&gt;Peer: Status(GENERIC_ERROR)\n        end</code></pre>"},{"location":"aea-framework-documentation/acn-internals/#connect-your-aea-to-the-acn","title":"Connect your AEA to the ACN","text":"<p>To connect the AEA to the ACN network, there are two AEA connections available:</p> <ul> <li>the <code>fetchai/p2p_libp2p</code>, that implements a direct connection, and</li> <li>the <code>fetchai/p2p_libp2p_delegate</code> connection, that implements the delegate connection.</li> </ul> <p>For more information on the AEA connection package type, refer to this guide.</p>"},{"location":"aea-framework-documentation/acn-internals/#the-fetchaip2p_libp2p-connection","title":"The <code>fetchai/p2p_libp2p</code> Connection","text":"<p>The source code of the <code>fetchai/p2p_libp2p</code> connection can be downloaded from the AEA Registry, or from the main AEA framework repository.</p> <p>The package provides the connection class <code>P2PLibp2pConnection</code>, which implements the <code>Connection</code> interface and therefore can be used by the Multiplexer as any other connection.</p> <ul> <li>The <code>connect</code> method of this connection spawns a new instance of the <code>libp2p_node</code> program (i.e. an ACN peer node) and connects to it through OS pipes. Then, it sets up the message receiving loop, which enqueues messages in the input queue to be read by <code>read</code> method calls, and the message sending loop, which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library <code>asyncio</code>.  </li> </ul> <pre><code>    sequenceDiagram\n        participant Libp2p Connection\n        participant sending loop\n        participant receiving loop\n        participant Libp2p Node\n        Libp2p Connection-&gt;&gt;Libp2p Node: spawn process\n        activate Libp2p Node\n        Libp2p Connection-&gt;&gt;sending loop: start recv loop\n        sending loop-&gt;&gt;sending loop: wait messages from output queue\n        activate sending loop\n        Libp2p Connection-&gt;&gt;receiving loop: start send loop\n        receiving loop-&gt;&gt;receiving loop: wait messages from input queue\n        activate receiving loop\n        deactivate Libp2p Node\n        deactivate sending loop\n        deactivate receiving loop</code></pre> <ul> <li>The <code>send</code> method enqueues a message in the output queue. The message is then dequeued by the sending loop, and then sent to the Libp2p node.</li> </ul> <pre><code>    sequenceDiagram\n        participant Libp2p Connection\n        participant sending loop\n        participant Libp2p Node\n        activate sending loop\n        Libp2p Connection-&gt;&gt;Libp2p Connection: enqueue message to output queue\n        sending loop-&gt;&gt;sending loop: dequeue message from output queue\n        deactivate sending loop\n        sending loop-&gt;&gt;Libp2p Node: AeaEnvelope\n        sending loop-&gt;&gt;sending loop: wait for status\n        activate sending loop\n        alt success\n            note over Libp2p Node: route envelope\n            Libp2p Node-&gt;&gt;sending loop: Status(SUCCESS)\n            deactivate sending loop\n            note over sending loop: OK\n        else timed out\n            note over sending loop: raise with error\n        else acn message decoding error \n            Libp2p Node-&gt;&gt;sending loop: Status(ERROR_SERIALIZATION)\n        else unexpected payload\n            Libp2p Node-&gt;&gt;sending loop: Status(ERROR_UNEXPECTED_PAYLOAD)\n        else envelope decoding error \n            Libp2p Node-&gt;&gt;sending loop: Status(ERROR_SERIALIZATION)\n        end</code></pre> <ul> <li>The <code>receive</code> method dequeues a message from the input queue. The queue is populated by the receiving loop, which receives messages from the Libp2p node.</li> </ul> <pre><code>    sequenceDiagram\n        participant Libp2p Connection\n        participant receiving loop\n        participant Libp2p Node\n        activate receiving loop\n        Libp2p Node-&gt;&gt;receiving loop: AeaEnvelope\n        deactivate receiving loop\n        Libp2p Node-&gt;&gt;Libp2p Node: wait for status\n        activate Libp2p Node\n        alt success\n            note over receiving loop: enqueue envelope&lt;br/&gt;to input queue\n            receiving loop-&gt;&gt;Libp2p Node: Status(SUCCESS)\n            deactivate Libp2p Node\n            note over receiving loop: OK\n        else timed out\n            note over Libp2p Node: ignore\n        else acn message decoding error \n            receiving loop-&gt;&gt;Libp2p Node: Status(ERROR_SERIALIZATION)\n        else unexpected payload\n            receiving loop-&gt;&gt;Libp2p Node: Status(ERROR_UNEXPECTED_PAYLOAD)\n        else envelope decoding error \n            receiving loop-&gt;&gt;Libp2p Node: Status(ERROR_SERIALIZATION)\n        end\n        Libp2p Connection-&gt;&gt;receiving loop: read message from output queue\n        note over Libp2p Connection: return message&lt;br/&gt;to Multiplexer</code></pre> <ul> <li>the <code>disconnect</code> method stops both the receiving loop and the sending loop, and stops the Libp2p node.</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#the-fetchaip2p_libp2p_delegate-connection","title":"The <code>fetchai/p2p_libp2p_delegate</code> Connection","text":"<p>The source code of the <code>fetchai/p2p_libp2p_delegate</code> connection can be downloaded from the main AEA framework repository. or from the main AEA framework repository.</p> <p>The package provides the connection class <code>P2PLibp2pClientConnection</code>, which implements the <code>Connection</code> interface and therefore can be used by the Multiplexer as any other connection.</p> <ul> <li>The <code>connect</code> method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a <code>Register</code> request to register the agent among the peer's client connections. On registration success, it sets up the message receiving loop, which enqueues messages in the input queue to be read by read method calls, and the message sending loop, which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library <code>asyncio</code>.</li> </ul> <pre><code>    sequenceDiagram\n        participant Libp2p Client Connection\n        participant Libp2p Node\n        activate Libp2p Node\n        Libp2p Node-&gt;&gt;Libp2p Node: listening for TCP connections\n        Libp2p Client Connection-&gt;&gt;Libp2p Node: Register (via TCP)\n        deactivate Libp2p Node\n        alt decoding error of ACN message\n            Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_SERIALIZATION)\n        else wrong payload\n            Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_UNEXPECTED_PAYLOAD)\n        else PoR check fails\n            alt wrong agent address\n                Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else unsupported ledger\n                Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_UNSUPPORTED_LEDGER)\n            else agent address and public key don't match\n                Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS)\n            else invalid proof\n                Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(ERROR_INVALID_PROOF)\n            end\n        else PoR check succeeds\n            Libp2p Node-&gt;&gt;Libp2p Client Connection: Status(SUCCESS)\n            note over Libp2p Node: announce agent&lt;br/&gt;address to&lt;br/&gt;other peers\n            Libp2p Node-&gt;&gt;Libp2p Node: wait data from socket \n            activate Libp2p Node\n            deactivate Libp2p Node\n        end</code></pre> <ul> <li> <p>The <code>send</code> method and the <code>receive</code> methods behave similarly to the <code>send</code> and <code>receive</code> methods of the <code>p2p_libp2p connection</code>, in terms of message exchange; however, the communication is done via TCP rather than pipes.</p> </li> <li> <p>The <code>disconnect</code> method interrupts the connection with the delegate peer, without explicitly unregistering.</p> </li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#known-issues-and-limitations","title":"Known Issues and Limitations","text":"<p>In this section, we provide a list of known issues and limitations of the current implementation of the ACN, considering both the ACN nodes (written in Golang) and the AEA connections, for the Python AEA framework, to interact with them.</p>"},{"location":"aea-framework-documentation/acn-internals/#delegate-client-on-client-disconnectionreconnection","title":"Delegate Client on Client Disconnection/Reconnection","text":"<p>In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation.</p> <p>Possible solutions:</p> <ul> <li>Create more complicated structure for clients storage;</li> <li>Keep the delegate client record for longer;</li> <li>Clean up the record by timeout, per client queues.</li> </ul> <p>Code references:</p> <ul> <li>record removed: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L864</li> <li>send code: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L955</li> </ul>"},{"location":"aea-framework-documentation/acn-internals/#golang-node-python-client-libp2p-connection","title":"Golang Node &lt;&gt; Python Client <code>libp2p</code> Connection","text":"<p>In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the <code>libp2p</code> AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely.</p> <p>Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout.</p>"},{"location":"aea-framework-documentation/acn-internals/#what-a-peer-should-do-if-it-receives-an-acknowledgement-with-an-error","title":"What a Peer Should Do if it Receives an Acknowledgement with an Error?","text":"<p>If an ACN response is the <code>Status</code> with error code different from <code>SUCCESS</code>, the forwarding to other peers is not repeated.</p> <p>A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help.</p> <p>Discussion on GitHub: https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983</p>"},{"location":"aea-framework-documentation/acn-internals/#no-possibility-of-switching-peers","title":"No Possibility of Switching Peers","text":"<p>In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers.</p>"},{"location":"aea-framework-documentation/acn/","title":"Agent Communication Network","text":"<p>The agent communication network (ACN) provides a system for agents to find each other and communicate, solely based on their wallet addresses. It addresses the message delivery problem.</p>"},{"location":"aea-framework-documentation/acn/#message-delivery-problem","title":"Message Delivery Problem","text":"<p>Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties?</p> <p>The properties we would like to have, are:</p> <ul> <li>Reliability: with guarantees on message reception</li> <li>Authentication: to prevent impersonation</li> <li>Confidentiality: to prevent exposing sensitive information within the message</li> <li>Availability: some guarantees about the liveness of the service (tampering detection)</li> </ul> <p>The problem statement and the agent framework context impose a number of design constraints:</p> <ul> <li>Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet</li> <li>Decentralized environment: no trusted central authority</li> <li>Support for resource-constrained devices</li> </ul> <p>The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints.</p>"},{"location":"aea-framework-documentation/acn/#peers","title":"Peers","text":"<p>The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system.</p>"},{"location":"aea-framework-documentation/acn/#distributed-hash-table","title":"Distributed Hash Table","text":"<p>At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by:</p> <ul> <li>Consistent hashing: decide responsibility for assignment of the DHT key-value storage</li> <li>Structured overlays: organize the participating peers in a well-defined topology for efficient routing</li> </ul> <p></p> <p>For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer.</p>"},{"location":"aea-framework-documentation/acn/#n-tier-architecture","title":"N-Tier Architecture","text":"<p>To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different <code>Connections</code>:</p> <p></p> <p>Note</p> <p>The <code>p2p_libp2p_mailbox</code> connection is not available yet.</p>"},{"location":"aea-framework-documentation/acn/#trust-and-security","title":"Trust and Security","text":"<p>An agent can choose which connection to use depending on the resource and trust requirements:</p> <ul> <li><code>p2p_libp2p</code> connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity.</li> <li><code>p2p_libp2p_client</code> connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer.</li> </ul> <p>All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.</p> <p></p>"},{"location":"aea-framework-documentation/aea-vs-mvc/","title":"AEA and Web Frameworks","text":"<p>The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails.</p>"},{"location":"aea-framework-documentation/aea-vs-mvc/#mvc","title":"MVC","text":"<p>Both aforementioned web frameworks use the MVC (model-view-controller) architecture.</p> <ul> <li>Models: contain business logic and data representations</li> <li>View: contain the HTML templates</li> <li>Controller: deals with the request-response handling</li> </ul>"},{"location":"aea-framework-documentation/aea-vs-mvc/#comparison-with-the-aea-framework","title":"Comparison with the AEA Framework","text":"<p>The AEA framework is based on asynchronous messaging and other agent-oriented development assumptions. Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of <code>Skills</code>:</p> <ul> <li><code>Handler</code>: receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the <code>Controller</code> in MVC. They can also send new messages.</li> <li><code>Behaviour</code>: a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages.</li> <li><code>Task</code>: they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps.</li> <li><code>Model</code>: they implement business logic and data representation, and as such, they are similar to the <code>Model</code> in MVC.</li> </ul> <p></p> <p>The <code>View</code> concept is probably best compared to the <code>Message</code> of a given <code>Protocol</code> in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services.</p>"},{"location":"aea-framework-documentation/aea-vs-mvc/#next-steps","title":"Next Steps","text":"<p>We recommend you continue with the next step in the 'Getting Started' series:</p> <ul> <li>Build a skill for an AEA</li> </ul>"},{"location":"aea-framework-documentation/aeas/","title":"Autonomous Economic Agents (AEAs)","text":""},{"location":"aea-framework-documentation/aeas/#what-is-an-aea","title":"What is an AEA?","text":"<p>Definition</p> <p>An Autonomous Economic Agent (AEA) is an intelligent agent that acts on its owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner.</p> <p>Let's break down the term Autonomous Economic Agent (AEA): </p> <ul> <li>Agent: An AEA is first and foremost an agent, representing an individual, organisation or object (a.k.a. its \"owner\") in the digital world. An AEA looks after its owner's interests and has their preferences in mind when acting on their behalf.</li> <li>Autonomous: AEAs operate independently of constant input from their owners and act autonomously to achieve their goals.</li> <li>Economic: AEAs have a narrow and specific focus: creating economic value for their owner.</li> </ul> <p>Some of the other characteristics AEAs typically have:</p> <ul> <li>Proactive: AEAs are proactive; they take the initiative and perform actions that take them closer to their goals. </li> <li>Reactive: AEAs are also reactive; they are aware of the environment they are in, perceive changes in the environment, and react to these changes in accordance to their goals.</li> <li>Self-interested: An AEA primarily looks after its own interests (which is aligned with those of its owner) and not necessarily the interests of other agents or the larger system.</li> </ul>"},{"location":"aea-framework-documentation/aeas/#what-is-not-an-aea","title":"What is NOT an AEA?","text":"<ul> <li>Any agent: AEAs are NOT meant to address any needs their owners might have. They have a clear and well-defined focus, which is generating economic value for their owner and this is manifested in a variety of different ways in their design.</li> <li>Digital twins: An AEA is NOT it's owner's twin in the digital world; i.e. mirroring their preferences, values, and priorities. An AEA can be given whatever preference, value, and priority its owner wants them to have.</li> <li>APIs or Sensors: These do NOT have any agency, nor proactiveness. They just \"sit there\" and respond to requests or changes in the environment.</li> <li>Smart contracts: Similar to APIs and sensors, smart contracts do NOT display any proactiveness; they are purely reactive to external requests (in their case, contract calls and transactions).</li> <li>An agent with Artificial General Intelligence (AGI): AEAs have a well-defined, narrow, and goal directed focus that involves some economic gain. </li> </ul> <p>Agents and AEAs</p> <p>In the rest of the documentation, unless specified, we use the terms AEA and Agent interchangeably to mean AEA as defined above description.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/","title":"Agent-Oriented Development","text":"<p>In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#decentralisation","title":"Decentralisation","text":"<p>Multi-Agent Systems (MAS) are inherently decentralized. The vision is of an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on a third party acting as an intermediary or match-maker. This is in direct contrast to centralized systems in which a single entity is the central point of authority, through which all interactions happen. The conventional client-server model is an example of a centralized architecture where clients interact with one another regarding specific services (e.g. communication, commerce) only through a server.</p> <p>This is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the 'commanding reliance on middlemen' that MAS rejects.</p> <p>Division of responsibilities: In a decentralized system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of the peers that create the infrastructure. Therefore, in a decentralized system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralized system. Blockchain-based cryptocurrencies are a good example of this. A notable characteristic of cryptocurrencies is the absence of central trusted entities (e.g. banks). But this in turn means that most security precautions related to the handling of digital assets and the execution of transactions are the responsibility of individuals.</p> <p>Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do also tend to be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralized system, owned and operated by a single entity, may in fact be highly distributed. Google or Microsoft's cloud infrastructure are examples of this, where their components are distributed across the globe yet designed to work together harmoniously and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a. the diversity of ownership and control over a system's constituents, and b. the absence of central authorities between them.</p> <p>Example: To better illustrate the distinction between centralized and decentralized systems, consider another example: search and discoverability in a commerce environment. In a centralized system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However, in a decentralized system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#conflicting-environment","title":"Conflicting Environment","text":"<p>As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralized system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others.</p> <p>As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory.</p> <p>In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be:</p> <ul> <li>Incomplete: what is unrevealed may have been deemed private for strategic reasons.</li> <li>Uncertain: it may be the result of an inaccurate prediction.</li> <li>Incorrect: it could be an outright lie, due to the adversarial nature of the environment.</li> </ul> <p>Therefore, one can argue that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#asynchronization","title":"Asynchronization","text":"<p>The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronization as the preferred method of designing and managing processes and interactions.</p> <p>Synchronisation vs asynchronization: In general, asynchronization refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other.</p> <p>Asynchronization in MAS: In the context of multi-agent systems, the decentralized and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent <code>i</code> sends a message requesting some resources from an agent <code>j</code>. Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: <code>j</code> may never receive <code>i</code>'s request, or may receive it after a long delay. Furthermore, <code>j</code> could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, <code>j</code> may decide to reply much later, to the point that the resource is no longer useful to agent <code>i</code>, or <code>j</code> may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because <code>j</code> assigns a low priority to answering <code>i</code> over its other tasks. But that's beside the point. The takeaway is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system.</p> <p>Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether that method is executed.  </p> <p>We cannot take for granted that an agent <code>j</code> will execute an action (the equivalent of a method in object-oriented systems) just because another agent <code>i</code> wants it to; this action may not be in the best interests of agent <code>j</code>. So we do not think of agents as invoking methods on one another, rather as requesting actions. If <code>i</code> requests <code>j</code> to perform an action, then <code>j</code> may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge):</p> <p>objects do it for free; agents do it because they want to.</p> <p>All of this makes asynchronization the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision-making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#time","title":"Time","text":"<p>Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time <code>X</code>).</p> <p>Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another  - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","title":"Complex, Incomplete, Inconsistent and Uncertain","text":"<p>The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections.</p> <p>The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside.</p> <p>Consider an agent which represents a driver-less vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that.</p> <p>Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.</p>"},{"location":"aea-framework-documentation/agent-oriented-development/#further-reading","title":"Further Reading","text":"<ul> <li>Wooldridge, M. (2009). An Introduction to MultiAgent Systems. Wiley, Second edition.</li> <li>Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations. Cambridge University Press</li> </ul>"},{"location":"aea-framework-documentation/agent-vs-aea/","title":"AEAs vs Agents","text":"<p>AEAs are more than just agents.</p> <p></p> <p>In this guide, we show some of the differences in terms of code.</p> <p>The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the <code>Agent</code> class programmatically as well.</p> <p>First, import the python and application specific libraries. (Get the <code>packages</code> directory from the AEA repository <code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages</code>.)</p> <pre><code>import os\nimport time\nfrom threading import Thread\nfrom typing import List\nfrom aea.agent import Agent\nfrom aea.configurations.base import ConnectionConfig\nfrom aea.connections.base import Connection\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.identity.base import Identity\nfrom aea.mail.base import Envelope\nfrom packages.fetchai.connections.stub.connection import StubConnection\nfrom packages.fetchai.protocols.default.message import DefaultMessage\n</code></pre> <p>Unlike an <code>AEA</code>, an <code>Agent</code> does not require a <code>Wallet</code>, <code>LedgerApis</code> or <code>Resources</code> module.</p> <p>However, we need to implement 4 abstract methods:</p> <ul> <li><code>setup()</code></li> <li><code>act()</code></li> <li><code>handle_envelope()</code></li> <li><code>teardown()</code></li> </ul> <p>When we run an agent, <code>start()</code> calls <code>setup()</code> and then the main agent loop. The main agent loop calls <code>act()</code>, <code>react()</code> and <code>update()</code> on each tick. When the agent is stopped via <code>stop()</code> then <code>teardown()</code> is called.</p> <p>Such a lightweight agent can be used to implement simple logic.</p>"},{"location":"aea-framework-documentation/agent-vs-aea/#code-an-agent","title":"Code an <code>Agent</code>","text":"<p>We define our <code>Agent</code> which simply receives envelopes, prints the sender address and <code>protocol_id</code> and returns it unopened.</p> <pre><code>INPUT_FILE = \"input_file\"\nOUTPUT_FILE = \"output_file\"\nclass MyAgent(Agent):\n\"\"\"A simple agent.\"\"\"\ndef __init__(self, identity: Identity, connections: List[Connection]):\n\"\"\"Initialise the agent.\"\"\"\nsuper().__init__(identity, connections)\ndef setup(self):\n\"\"\"Setup the agent.\"\"\"\ndef act(self):\n\"\"\"Act implementation.\"\"\"\nprint(\"Act called for tick {}\".format(self.tick))\ndef handle_envelope(self, envelope: Envelope) -&gt; None:\n\"\"\"\n        Handle envelope.\n        :param envelope: the envelope received\n        :return: None\n        \"\"\"\nprint(\"React called for tick {}\".format(self.tick))\nif (\nenvelope is not None\nand envelope.protocol_specification_id\n== DefaultMessage.protocol_specification_id\n):\nsender = envelope.sender\nreceiver = envelope.to\nenvelope.to = sender\nenvelope.sender = receiver\nenvelope.message = DefaultMessage.serializer.decode(envelope.message_bytes)\nenvelope.message.sender = receiver\nenvelope.message.to = sender\nprint(\n\"Received envelope from {} with protocol_specification_id={}\".format(\nsender, envelope.protocol_specification_id\n)\n)\nself.outbox.put(envelope)\ndef teardown(self):\n\"\"\"Teardown the agent.\"\"\"\n</code></pre>"},{"location":"aea-framework-documentation/agent-vs-aea/#instantiate-an-agent","title":"Instantiate an <code>Agent</code>","text":"<pre><code>    # Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n# Create an addresses identity:\nidentity = Identity(\nname=\"my_agent\", address=\"some_address\", public_key=\"public_key\"\n)\n# Set up the stub connection\nconfiguration = ConnectionConfig(\ninput_file_path=INPUT_FILE,\noutput_file_path=OUTPUT_FILE,\nconnection_id=StubConnection.connection_id,\n)\nstub_connection = StubConnection(\nconfiguration=configuration, data_dir=\".\", identity=identity\n)\n# Create our Agent\nmy_agent = MyAgent(identity, [stub_connection])\n</code></pre>"},{"location":"aea-framework-documentation/agent-vs-aea/#start-the-agent","title":"Start the Agent","text":"<p>We run the agent from a different thread so that we can still use the main thread to pass it messages.</p> <pre><code>    # Set the agent running in a different thread\ntry:\nt = Thread(target=my_agent.start)\nt.start()\n# Wait for everything to start up\ntime.sleep(3)\n</code></pre>"},{"location":"aea-framework-documentation/agent-vs-aea/#send-and-receive-an-envelope","title":"Send and Receive an Envelope","text":"<p>We use the input and output text files to send an envelope to our agent and receive a response</p> <pre><code>        # Create a message inside an envelope and get the stub connection to pass it into the agent\nmessage_text = b\"my_agent,other_agent,fetchai/default:1.0.0,\\x12\\r\\x08\\x01*\\t*\\x07\\n\\x05hello,\"\nwith open(INPUT_FILE, \"wb\") as f:\nwrite_with_lock(f, message_text)\n# Wait for the envelope to get processed\ntime.sleep(2)\n# Read the output envelope generated by the agent\nwith open(OUTPUT_FILE, \"rb\") as f:\nprint(\"output message: \" + f.readline().decode(\"utf-8\"))\n</code></pre>"},{"location":"aea-framework-documentation/agent-vs-aea/#shutdown","title":"Shutdown","text":"<p>Finally, stop our agent and wait for it to finish</p> <pre><code>    finally:\n# Shut down the agent\nmy_agent.stop()\nt.join()\n</code></pre>"},{"location":"aea-framework-documentation/agent-vs-aea/#your-turn","title":"Your Turn","text":"<p>Now it is your turn to develop a simple agent with the <code>Agent</code> class.</p>"},{"location":"aea-framework-documentation/agent-vs-aea/#entire-code-listing","title":"Entire Code Listing","text":"<p>If you just want to copy and paste the entire script in you can find it here:</p> Click here to see full listing <pre><code>import os\nimport time\nfrom threading import Thread\nfrom typing import List\nfrom aea.agent import Agent\nfrom aea.configurations.base import ConnectionConfig\nfrom aea.connections.base import Connection\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.identity.base import Identity\nfrom aea.mail.base import Envelope\nfrom packages.fetchai.connections.stub.connection import StubConnection\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nINPUT_FILE = \"input_file\"\nOUTPUT_FILE = \"output_file\"\nclass MyAgent(Agent):\n\"\"\"A simple agent.\"\"\"\ndef __init__(self, identity: Identity, connections: List[Connection]):\n\"\"\"Initialise the agent.\"\"\"\nsuper().__init__(identity, connections)\ndef setup(self):\n\"\"\"Setup the agent.\"\"\"\ndef act(self):\n\"\"\"Act implementation.\"\"\"\nprint(\"Act called for tick {}\".format(self.tick))\ndef handle_envelope(self, envelope: Envelope) -&gt; None:\n\"\"\"\n        Handle envelope.\n        :param envelope: the envelope received\n        :return: None\n        \"\"\"\nprint(\"React called for tick {}\".format(self.tick))\nif (\nenvelope is not None\nand envelope.protocol_specification_id\n== DefaultMessage.protocol_specification_id\n):\nsender = envelope.sender\nreceiver = envelope.to\nenvelope.to = sender\nenvelope.sender = receiver\nenvelope.message = DefaultMessage.serializer.decode(envelope.message_bytes)\nenvelope.message.sender = receiver\nenvelope.message.to = sender\nprint(\n\"Received envelope from {} with protocol_specification_id={}\".format(\nsender, envelope.protocol_specification_id\n)\n)\nself.outbox.put(envelope)\ndef teardown(self):\n\"\"\"Teardown the agent.\"\"\"\ndef run():\n\"\"\"Run demo.\"\"\"\n# Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n# Create an addresses identity:\nidentity = Identity(\nname=\"my_agent\", address=\"some_address\", public_key=\"public_key\"\n)\n# Set up the stub connection\nconfiguration = ConnectionConfig(\ninput_file_path=INPUT_FILE,\noutput_file_path=OUTPUT_FILE,\nconnection_id=StubConnection.connection_id,\n)\nstub_connection = StubConnection(\nconfiguration=configuration, data_dir=\".\", identity=identity\n)\n# Create our Agent\nmy_agent = MyAgent(identity, [stub_connection])\n# Set the agent running in a different thread\ntry:\nt = Thread(target=my_agent.start)\nt.start()\n# Wait for everything to start up\ntime.sleep(3)\n# Create a message inside an envelope and get the stub connection to pass it into the agent\nmessage_text = b\"my_agent,other_agent,fetchai/default:1.0.0,\\x12\\r\\x08\\x01*\\t*\\x07\\n\\x05hello,\"\nwith open(INPUT_FILE, \"wb\") as f:\nwrite_with_lock(f, message_text)\n# Wait for the envelope to get processed\ntime.sleep(2)\n# Read the output envelope generated by the agent\nwith open(OUTPUT_FILE, \"rb\") as f:\nprint(\"output message: \" + f.readline().decode(\"utf-8\"))\nfinally:\n# Shut down the agent\nmy_agent.stop()\nt.join()\nif __name__ == \"__main__\":\nrun()\n</code></pre>"},{"location":"aea-framework-documentation/aggregation-demo/","title":"Aggregation Skill","text":"<p>This demo shows how AEAs can aggregate values over the peer-to-peer network.</p>"},{"location":"aea-framework-documentation/aggregation-demo/#discussion","title":"Discussion","text":"<p>This demonstration shows how to set up a simple aggregation network in which several AEAs take an average of values fetched from different sources for the same real-world quantity. For this particular example, we take an average of Bitcoin prices from four public APIs.</p>"},{"location":"aea-framework-documentation/aggregation-demo/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/aggregation-demo/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/aggregation-demo/#demo","title":"Demo","text":""},{"location":"aea-framework-documentation/aggregation-demo/#create-the-aeas","title":"Create the AEAs","text":"<p>Repeat the following process four times in four different terminals (for each {<code>i=0</code>, <code>i=1</code>, <code>i=2</code>, <code>i=3</code>}):</p> <p>Fetch the aggregator AEA:</p> <pre><code>agent_name=\"agg$i\"\naea fetch fetchai/simple_aggregator:0.5.5 --alias $agent_name\ncd $agent_name\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>Create the AEA:</p> <pre><code>agent_name=\"agg$i\"\naea create agent_name\ncd agent_name\naea add connection fetchai/http_client:0.24.6\naea add connection fetchai/http_server:0.23.6\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/prometheus:0.9.6\naea add skill fetchai/advanced_data_request:0.7.6\naea add skill fetchai/simple_aggregation:0.3.6\n\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea install\naea build\n</code></pre> <p>Set the desired decimal precision for the quantity:</p> <pre><code>aea config set --type int vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.decimals 0\n</code></pre> <p>Disable the http server since it is not used in this demo:</p> <pre><code>aea config set --type bool vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.use_http_server false\n</code></pre> <p>Set the cert requests for the peer-to-peer connection:</p> <pre><code>aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]'\n</code></pre> <p>Match the agent index <code>i</code> to the <code>COIN_URL</code> and <code>JSON_PATH</code> below:</p> <ul> <li><code>agg0</code>: <code>COIN_URL=\"https://api.coinbase.com/v2/prices/BTC-USD/buy\" &amp;&amp; JSON_PATH=\"data.amount\"</code></li> <li><code>agg1</code>: <code>COIN_URL=\"https://api.coinpaprika.com/v1/tickers/btc-bitcoin\" &amp;&amp; JSON_PATH=\"quotes.USD.price\"</code></li> <li><code>agg2</code>: <code>COIN_URL=\"https://api.cryptowat.ch/markets/kraken/btcusd/price\" &amp;&amp; JSON_PATH=\"result.price\"</code></li> <li><code>agg3</code>: <code>COIN_URL=\"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&amp;vs_currencies=usd\" &amp;&amp; JSON_PATH=\"bitcoin.usd\"</code></li> </ul> <p>Set the following configuration for the <code>advanced_data_request</code> skill:</p> <pre><code>aea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url $COIN_URL\naea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": '\"\\\"$JSON_PATH\\\"\"'}]'\n</code></pre> <p>Set the name of the quantity to aggregate and choose an aggregation function for the AEAs (the currently implemented options are <code>mean</code>, <code>median</code>, and <code>mode</code>):</p> <pre><code>aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.quantity_name price\naea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.aggregation_function mean\n</code></pre> <p>Specify a name for your aggregation service:</p> <pre><code>SERVICE_ID=my_btc_aggregation_service\naea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.service_id $SERVICE_ID\naea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.search_query.search_value $SERVICE_ID\n</code></pre> <p>Additionally, create private keys for use with the ledger and the peer-to-peer connection:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai\naea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the keys for use by the connections that request them:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/aggregation-demo/#configure-the-peer-to-peer-network","title":"Configure the Peer-to-Peer Network","text":"<p>Set the multiaddress of the first AEA as an initial peer to help the remaining AEAs find each other on the network. Also, if these AEAs are all running on the same machine, set different ports for their connections to ensure there are no conflicts (from the <code>agg1</code>, <code>agg2</code>, and <code>agg3</code> directories):</p> <pre><code>MULTIADDR=$(cd ../agg0 &amp;&amp; aea get-multiaddress fetchai --connection)\naea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n\"delegate_uri\": \"127.0.0.1:'$((11000+i))'\",\n\"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/'\"$MULTIADDR\\\"\"'],\n\"local_uri\": \"127.0.0.1:'$((9000+i))'\",\n\"log_file\": \"libp2p_node.log\",\n\"public_uri\": \"127.0.0.1:'$((9000+i))'\"\n}'\naea config set vendor.fetchai.connections.prometheus.config.port $((20000+i))\naea config set vendor.fetchai.connections.http_server.config.port $((8000+i))\n</code></pre>"},{"location":"aea-framework-documentation/aggregation-demo/#oracle-integration-optional","title":"Oracle Integration (optional)","text":"<p>To publish the aggregated value to an oracle smart contract, add the ledger connection and simple oracle skill to one of the aggregators:</p> <pre><code>aea add connection fetchai/ledger:0.21.5\naea add skill fetchai/simple_oracle:0.16.5\n</code></pre> <p>Configure the simple oracle skill for the <code>fetchai</code> ledger:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id fetchai\naea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value\n</code></pre> <p>Generate some wealth to use for transactions on the testnet ledger:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Set the name of the oracle value to match the value collected by the aggregators:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price_mean\n</code></pre>"},{"location":"aea-framework-documentation/aggregation-demo/#run-the-aeas","title":"Run the AEAs","text":"<p>Run each of the aggregator AEAs in separate terminals:</p> <pre><code>aea run\n</code></pre> <p>After a few moments, you should see the AEAs finding peers, making observations, sending them to peers, and taking the average of their observations:</p> <pre><code>info: [agg_i] found agents...\n...\ninfo: [agg_i] Fetching data from...\n...\ninfo: [agg_i] Observation: {'price': {'value':...\n...\ninfo: [agg_i] sending observation to peer...\n...\ninfo: [agg_i] received observation from sender...\n...\ninfo: [agg_i] Observations:...\n...\ninfo: [agg_i] Aggregation (mean):...\n</code></pre>"},{"location":"aea-framework-documentation/application/","title":"Application Areas","text":""},{"location":"aea-framework-documentation/application/#environments","title":"Environments","text":"<p>AEAs are most suited for environments which are:</p> <ul> <li>Decentralized: there isn't a central authority that controls, manages, or makes decisions.</li> <li>Multi-Stakeholder: the domain, problem, or solutions involve multiple distinct stakeholders.</li> <li>Peer-to-Peer: interactions are (or could be made) direct and peer-to-peer.</li> <li>Complex, Incomplete, and Uncertain: to the point that off-loading tasks to computational entities becomes valuable.</li> </ul>"},{"location":"aea-framework-documentation/application/#applications","title":"Applications","text":"<p>We identify a number of application areas for AEA-based solutions. This list is by no means comprehensive. In fact, we are most excited about applications which we have not thought of before.</p> Automation <p>AEAs can automate well-defined processes in different domains, such as supply chain, mobility, finance, ...</p> Micro-transactions <p>AEAs make it economically viable to execute trade involving small values. An example is use-cases with many small sellers (e.g. of data) on the supply side.</p> Wallet <p>AEAs can simplify interactions with blockchains. By acting as \"smart wallets\", they can hide away the majority of the complexities involved in using blockchains for end users.</p> IoT <p>Agents representing objects in the IoT (Internet of Things) space. For example, AEAs paired with hardware devices such as drones, laptops, heat sensors, etc., providing control and receiving data from the device. An example is a  thermometer agent.</p> Web 2.0 &lt;--&gt; Web 3.0 interface <p>Agents that interface and bridge the gap between existing (Web 2.0) and new (Web 3.0) economic models. An example is an  AEA that communicates with HTTP clients/servers.</p> Digital data sales <p>Agents with access to some data sources that sell the data, access to the data, or access to the usage of the data. An example is an AEA that continuously sells data to another AEA, who in turn uses it to improve their reinforcement learning model.</p>"},{"location":"aea-framework-documentation/application/#multi-agent-system-vs-agent-based-modelling","title":"Multi-Agent System VS Agent-Based Modelling","text":"<p>The AEA framework enables the creation of multi-agent systems as technological solutions to real world problems. </p> <p>Although there are some overlap, the framework is not designed from the outset as an agent-based modelling software, where the goal is scientific behavioural observation rather than practical economic gain.</p> <p>Moreover, there is no restriction to multi; single-agent applications are also supported.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/","title":"Aries Cloud Agents Demo","text":"<p>Note</p> <p>This demo is incomplete and will soon be updated.</p> <p>Demonstrating an entire decentralized identity scenario involving AEAs and instances of Aries Cloud Agents (ACAs).</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#discussion","title":"Discussion","text":"<p>This demo corresponds with the one here from  Aries cloud agent repository .</p> <p>The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs.</p> <pre><code>    sequenceDiagram\n        participant faea as Faber_AEA\n        participant faca as Faber_ACA\n        participant aaca as Alice_ACA\n        participant aaea as Alice_AEA\n\n        activate faea\n        activate faca\n        activate aaca\n        activate aaea\n\n        Note right of aaea: Shows P2P ID\n\n        faea-&gt;&gt;faca: Request status?\n        faca-&gt;&gt;faea: status\n        faea-&gt;&gt;faca: Register schema\n        faca-&gt;&gt;faea: schema_id\n        faea-&gt;&gt;faca: Register credential definition\n        faca-&gt;&gt;faea: credential_definition_id\n        faea-&gt;&gt;faca: create-invitation\n        faca-&gt;&gt;faea: connection inc. invitation\n        faea-&gt;&gt;aaea: invitation detail\n        aaea-&gt;&gt;aaca: receive-invitation\n\n        deactivate faea\n        deactivate faca\n        deactivate aaca\n        deactivate aaea</code></pre> <p>There are two AEAs:</p> <ul> <li>Alice_AEA</li> <li>Faber_AEA</li> </ul> <p>and two ACAs:</p> <ul> <li>Alice_ACA</li> <li>Faber_ACA</li> </ul> <p>Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA.</p> <p>The following lists the sequence of interactions between the four agents:</p> <ul> <li>Alice_AEA: starts</li> <li>Alice_AEA: shows its P2P address in the terminal and waits for an <code>invitation</code> detail from Faber_AEA.</li> <li>Alice_AEA: registers itself on the SOEF.</li> <li>Faber_AEA: starts</li> <li>Faber_AEA: searches the SOEF and finds Alice_AEA.</li> <li>Faber_AEA: tests its connection to Faber_ACA.</li> <li>Faber_ACA: responds to Faber_AEA.</li> <li>Faber_AEA: registers a DID on the ledger.</li> <li>Faber_AEA: request Faber_ACA to register a schema on the ledger.</li> <li>Faber_ACA: responds by sending back the <code>schema_id</code>.</li> <li>Faber_AEA: request Faber_ACA to register a credential definition on the ledger.</li> <li>Faber_ACA: responds by sending back the <code>credential_definition_id</code>.</li> <li>Faber_AEA: requests Faber_ACA to create an invitation.</li> <li>Faber_ACA: responds by sending back the <code>connection</code> detail, which contains an <code>invitation</code> field.</li> <li>Faber_AEA: sends the <code>invitation</code> detail to Alice_AEA.</li> <li>Alice_AEA: receives <code>invitation</code> detail from Faber_AEA.</li> <li>Alice_AEA: requests Alice_ACA to accept the invitation, by passing it the <code>invitation</code> detail it received in the last step.</li> </ul> <p>All messages from an AEA to an ACA are http requests (using <code>http_client</code> connection).</p> <p>All messages from an AEA to another AEA utilise the P2P communication network accessed via the <code>p2p_libp2p</code> connection.</p> <p>All messages initiated from an ACA to an AEA are webhooks (using <code>webhook</code> connection).</p> <p>This is the extent of the demo at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next.</p> <p>The rest of the interactions are broadly as follows:</p> <ul> <li>Alice_ACA: accepts the invitation.</li> <li>Alice_ACA: sends a matching invitation request to Faber_ACA.</li> <li>Faber_ACA: accepts</li> </ul> <p>At this point, the two ACAs are connected to each other.</p> <ul> <li>Faber_AEA: requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA, which Faber_ACA does via Alice_ACA.</li> <li>Faber_AEA: requests proof that Alice_AEA's age is above 18.</li> <li>Alice_AEA: presents proof that it's age is above 18, without presenting its credential.</li> </ul>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p> <p>Install Aries cloud-agents (for more info see here) if you do not have it on your machine:</p> <pre><code>pip install aries-cloudagent\n</code></pre> <p>This demo has been successfully tested with <code>aca-py</code> version <code>0.4.5</code>.</p> <p>This demo requires an instance of von network running in docker locally (for more info see here)</p> <p>This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number <code>ad1f84f64d4f4c106a81462f5fbff496c5fbf10e</code>).</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#terminals","title":"Terminals","text":"<p>Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#von-network","title":"VON Network","text":"<p>In the first terminal move to the <code>von-network</code> directory and run an instance of <code>von-network</code> locally in docker.</p> <p>This tutorial has information on starting (and stopping) the network locally.</p> <pre><code>./manage build\n./manage start --logs\n</code></pre> <p>Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to http://localhost:9000.  </p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#alice-and-faber-acas","title":"Alice and Faber ACAs","text":"<p>To learn about the command for starting an ACA and its various options:</p> <pre><code>aca-py start --help\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#faber_aca","title":"Faber_ACA","text":"<p>In the first terminal:</p> <pre><code>aca-py start --admin 127.0.0.1 8021 --admin-insecure-mode --inbound-transport http 0.0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks\n</code></pre> <p>Make sure the ports above are unused.</p> <p>Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names:</p> <ul> <li>Faber admin IP: 127.0.0.1</li> <li>Faber admin port: 8021</li> <li>Faber webhook port: 8022</li> </ul> <p>The admin IP and port will be used to send administrative commands to this ACA from an AEA.</p> <p>The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#alice_aca","title":"Alice_ACA","text":"<p>In the second terminal:</p> <pre><code>aca-py start --admin 127.0.0.1 8031 --admin-insecure-mode --inbound-transport http 0.0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks\n</code></pre> <p>Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case:</p> <ul> <li>Alice admin IP: 127.0.0.1</li> <li>Alice admin port: 8031</li> <li>Alice webhook port: 8032</li> </ul>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#alice-and-faber-aeas","title":"Alice and Faber AEAs","text":"<p>Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#alice_aea","title":"Alice_AEA","text":"<p>In the third terminal, fetch Alice_AEA and move into its project folder:</p> <pre><code>aea fetch fetchai/aries_alice:0.32.5\ncd aries_alice\n</code></pre> Alternatively, create from scratch: <p>The following steps create Alice_AEA from scratch:</p> <pre><code>aea create aries_alice\ncd aries_alice\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/http_client:0.24.6\naea add connection fetchai/webhook:0.20.6\naea add skill fetchai/aries_alice:0.26.6\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-aries_alice-skill","title":"Configure the <code>aries_alice</code> Skill","text":"<p>(configuration file: <code>alice/vendor/fetchai/skills/aries_alice/skill.yaml</code>)</p> <p>Ensure <code>admin_host</code> and <code>admin_port</code> values match with the values you noted above for Alice_ACA. You can use the framework's handy <code>config</code> CLI command to set these values:</p> <pre><code>aea config set vendor.fetchai.skills.aries_alice.models.strategy.args.admin_host 127.0.0.1\n</code></pre> <pre><code>aea config set --type int vendor.fetchai.skills.aries_alice.models.strategy.args.admin_port 8031\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-webhook-connection","title":"Configure the <code>webhook</code> Connection","text":"<p>(configuration file: <code>alice/vendor/fetchai/connections/webhook/connection.yaml</code>).</p> <p>First ensure the value of <code>webhook_port</code> matches with what you used above for Alice_ACA.</p> <pre><code>aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032\n</code></pre> <p>Next, make sure the value of <code>webhook_url_path</code> is <code>/webhooks/topic/{topic}/</code>.</p> <pre><code>aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/{topic}/\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection","title":"Configure the <code>p2p_libp2p</code> Connection","text":"<pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11000\",\n  \"entry_peers\": [],\n  \"local_uri\": \"127.0.0.1:7000\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:7000\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#install-the-dependencies-and-run-alice_aea","title":"Install the Dependencies and Run Alice_AEA","text":"<p>Now install all the dependencies:</p> <pre><code>aea install\naea build\n</code></pre> <p>Finally, run Alice_AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) We will refer to this as Alice_AEA's P2P address.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#faber_aea","title":"Faber_AEA","text":"<p>In the fourth terminal, fetch Faber_AEA and move into its project folder:</p> <pre><code>aea fetch fetchai/aries_faber:0.32.5\ncd aries_faber\n</code></pre> Alternatively, create from scratch: <p>The following steps create Faber_AEA from scratch:</p> <pre><code>aea create aries_faber\ncd aries_faber\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/http_client:0.24.6\naea add connection fetchai/webhook:0.20.6\naea add skill fetchai/aries_faber:0.24.5\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-aries_faber-skill","title":"Configure the <code>aries_faber</code> Skill","text":"<p>(configuration file: <code>faber/vendor/fetchai/skills/aries_alice/skill.yaml</code>)</p> <p>Ensure <code>admin_host</code> and <code>admin_port</code> values match with those you noted above for Faber_ACA.</p> <pre><code>aea config set vendor.fetchai.skills.aries_faber.models.strategy.args.admin_host 127.0.0.1\n</code></pre> <pre><code>aea config set --type int vendor.fetchai.skills.aries_faber.models.strategy.args.admin_port 8021\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-webhook-connection_1","title":"Configure the <code>webhook</code> Connection","text":"<p>(configuration file: <code>faber/vendor/fetchai/connections/webhook/connection.yaml</code>).</p> <p>First, ensure the value of <code>webhook_port</code> matches with what you used above for Faber_ACA.</p> <pre><code>aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022\n</code></pre> <p>Next, make sure the value of <code>webhook_url_path</code> is <code>/webhooks/topic/{topic}/</code>.</p> <pre><code>aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/{topic}/\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection_1","title":"Configure the <code>p2p_libp2p</code> Connection","text":"<pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:7001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:7001\"\n}'\n</code></pre> <p>where <code>SOME_ADDRESS</code> is Alice_AEA's P2P address as displayed in the third terminal.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#install-the-dependencies-and-run-faber_aea","title":"Install the Dependencies and Run Faber_AEA","text":"<p>Now install all the dependencies:</p> <pre><code>aea install\naea build\n</code></pre> <p>Finally run Faber_AEA:</p> <pre><code>aea run\n</code></pre> <p>You should see Faber_AEA running and showing logs of its activities. For example:</p> <p></p> <p>Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example:</p> <p></p> <p>The last error line in Alice_AEA's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved.</p>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#terminate-and-delete-the-agents","title":"Terminate and Delete the Agents","text":"<p>You can terminate each agent by pressing Ctrl+C.</p> <p>To delete the AEAs, go to the projects' parent directory and delete the AEAs:</p> <pre><code>aea delete aries_faber\naea delete aries_alice\n</code></pre>"},{"location":"aea-framework-documentation/aries-cloud-agent-demo/#further-developments","title":"Further Developments","text":"<p>In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means:</p> <ul> <li>An instance of Indy ledger must be installed and running. See here for more detail.</li> <li>The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger.</li> <li>The remaining interactions between the AEAs and ACAs as described here need to be implemented.</li> </ul>"},{"location":"aea-framework-documentation/build-aea-programmatically/","title":"Build an AEA Programmatically","text":"<p>These instructions detail the Python code you need for running an AEA outside the <code>cli</code> tool, using the code interface.</p>"},{"location":"aea-framework-documentation/build-aea-programmatically/#preparation","title":"Preparation","text":"<p>Get the <code>packages</code> directory from the AEA repository:</p> <pre><code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages\n</code></pre> <p>Also, install <code>aea-ledger-fetchai</code> plug-in:</p> <pre><code>pip install aea-ledger-fetchai\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#imports","title":"Imports","text":"<p>First, import the necessary common Python libraries and classes.</p> <pre><code>import os\nimport time\nfrom threading import Thread\n</code></pre> <p>Then, import the application specific libraries.</p> <pre><code>from aea_ledger_fetchai import FetchAICrypto\nfrom aea.aea_builder import AEABuilder\nfrom aea.configurations.base import SkillConfig\nfrom aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA, create_private_key\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.skills.base import Skill\n</code></pre> <p>Set up a variable pointing to where the <code>packages</code> directory is located - this should be our current directory - and where the input and output files are located.</p> <pre><code>ROOT_DIR = \"./\"\nINPUT_FILE = \"input_file\"\nOUTPUT_FILE = \"output_file\"\nFETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA.format(FetchAICrypto.identifier)\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#create-a-private-key","title":"Create a Private Key","text":"<p>We need a private key to populate the AEA's wallet.</p> <pre><code>    # Create a private key\ncreate_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE)\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#clearing-the-input-and-output-files","title":"Clearing the Input and Output Files","text":"<p>We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start.</p> <pre><code>    # Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#initialise-the-aea","title":"Initialise the AEA","text":"<p>We use the <code>AEABuilder</code> to readily build an AEA. By default, the <code>AEABuilder</code> adds the <code>fetchai/default:1.1.7</code>, <code>fetchai/state_update:1.1.7</code> and <code>fetchai/signing:1.1.7</code> protocols.</p> <pre><code>    # Instantiate the builder and build the AEA\n# By default, the default protocol, error skill and stub connection are added\nbuilder = AEABuilder()\n</code></pre> <p>We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use.</p> <pre><code>    builder.set_name(\"my_aea\")\nbuilder.add_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE)\n</code></pre> <p>Next, we add the <code>fetchai/stub:0.15.0</code> connection which will read/write messages from file:</p> <pre><code>    # Add the stub connection (assuming it is present in the local directory 'packages')\nbuilder.add_connection(\"./packages/fetchai/connections/stub\")\n</code></pre> <p>Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the <code>packages</code> directory from the AEA repo or by getting the package from the registry.</p> <pre><code>    # Add the echo skill (assuming it is present in the local directory 'packages')\nbuilder.add_skill(\"./packages/fetchai/skills/echo\")\n</code></pre> <p>Also, we can add a component that was instantiated programmatically. :</p> <pre><code>    # create skill and handler manually\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nclass DummyHandler(Handler):\n\"\"\"Dummy handler to handle messages.\"\"\"\nSUPPORTED_PROTOCOL = DefaultMessage.protocol_id\ndef setup(self) -&gt; None:\n\"\"\"Noop setup.\"\"\"\ndef teardown(self) -&gt; None:\n\"\"\"Noop teardown.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"Handle incoming message.\"\"\"\nself.context.logger.info(\"You got a message: {}\".format(str(message)))\nconfig = SkillConfig(name=\"test_skill\", author=\"fetchai\")\nskill = Skill(configuration=config)\ndummy_handler = DummyHandler(\nname=\"dummy_handler\", skill_context=skill.skill_context\n)\nskill.handlers.update({dummy_handler.name: dummy_handler})\nbuilder.add_component_instance(skill)\n</code></pre> <p>Finally, we can build our AEA:</p> <pre><code>    # Create our AEA\nmy_aea = builder.build()\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#start-the-aea","title":"Start the AEA","text":"<p>We run the AEA from a different thread so that we can still use the main thread to pass it messages.</p> <pre><code>    # Set the AEA running in a different thread\ntry:\nt = Thread(target=my_aea.start)\nt.start()\n# Wait for everything to start up\ntime.sleep(4)\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#send-and-receive-an-envelope","title":"Send and Receive an Envelope","text":"<p>We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill)</p> <pre><code>        # Create a message inside an envelope and get the stub connection to pass it on to the echo skill\nmessage_text = b\"my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,\"\nwith open(INPUT_FILE, \"wb\") as f:\nwrite_with_lock(f, message_text)\nprint(b\"input message: \" + message_text)\n# Wait for the envelope to get processed\ntime.sleep(4)\n# Read the output envelope generated by the echo skill\nwith open(OUTPUT_FILE, \"rb\") as f:\nprint(b\"output message: \" + f.readline())\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#shutdown","title":"Shutdown","text":"<p>Finally, stop our AEA and wait for it to finish</p> <pre><code>    finally:\n# Shut down the AEA\nmy_aea.stop()\nt.join()\nt = None\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#running-the-aea","title":"Running the AEA","text":"<p>If you now run this python script file, you should see this output:</p> <pre><code>input message: my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,\noutput message: other_agent,my_aea,fetchai/default:1.0.0,...\\x05hello\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-programmatically/#entire-code-listing","title":"Entire Code Listing","text":"<p>If you just want to copy and past the entire script in you can find it here:</p> Click here to see full listing: <pre><code>import os\nimport time\nfrom threading import Thread\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.aea_builder import AEABuilder\nfrom aea.configurations.base import SkillConfig\nfrom aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA, create_private_key\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.skills.base import Skill\nROOT_DIR = \"./\"\nINPUT_FILE = \"input_file\"\nOUTPUT_FILE = \"output_file\"\nFETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA.format(FetchAICrypto.identifier)\ndef run():\n\"\"\"Run demo.\"\"\"\n# Create a private key\ncreate_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE)\n# Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n# Instantiate the builder and build the AEA\n# By default, the default protocol, error skill and stub connection are added\nbuilder = AEABuilder()\nbuilder.set_name(\"my_aea\")\nbuilder.add_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE)\n# Add the stub connection (assuming it is present in the local directory 'packages')\nbuilder.add_connection(\"./packages/fetchai/connections/stub\")\n# Add the echo skill (assuming it is present in the local directory 'packages')\nbuilder.add_skill(\"./packages/fetchai/skills/echo\")\n# create skill and handler manually\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nclass DummyHandler(Handler):\n\"\"\"Dummy handler to handle messages.\"\"\"\nSUPPORTED_PROTOCOL = DefaultMessage.protocol_id\ndef setup(self) -&gt; None:\n\"\"\"Noop setup.\"\"\"\ndef teardown(self) -&gt; None:\n\"\"\"Noop teardown.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"Handle incoming message.\"\"\"\nself.context.logger.info(\"You got a message: {}\".format(str(message)))\nconfig = SkillConfig(name=\"test_skill\", author=\"fetchai\")\nskill = Skill(configuration=config)\ndummy_handler = DummyHandler(\nname=\"dummy_handler\", skill_context=skill.skill_context\n)\nskill.handlers.update({dummy_handler.name: dummy_handler})\nbuilder.add_component_instance(skill)\n# Create our AEA\nmy_aea = builder.build()\n# Set the AEA running in a different thread\ntry:\nt = Thread(target=my_aea.start)\nt.start()\n# Wait for everything to start up\ntime.sleep(4)\n# Create a message inside an envelope and get the stub connection to pass it on to the echo skill\nmessage_text = b\"my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,\"\nwith open(INPUT_FILE, \"wb\") as f:\nwrite_with_lock(f, message_text)\nprint(b\"input message: \" + message_text)\n# Wait for the envelope to get processed\ntime.sleep(4)\n# Read the output envelope generated by the echo skill\nwith open(OUTPUT_FILE, \"rb\") as f:\nprint(b\"output message: \" + f.readline())\nfinally:\n# Shut down the AEA\nmy_aea.stop()\nt.join()\nt = None\nif __name__ == \"__main__\":\nrun()\n</code></pre>"},{"location":"aea-framework-documentation/build-aea-step-by-step/","title":"Build an AEA with the CLI","text":"<p>Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first):</p> <ol> <li>Set up your AEA project with the CLI: <code>aea create my_aea &amp;&amp; cd my_aea</code></li> <li>Look at, then add the right connections for your use case:     <code>aea search connections</code>, then <code>aea add connection [public_id]</code></li> <li>Look for, then add or generate the protocols you require: <code>aea search protocols</code>, then <code>aea add protocol [public_id]</code> or <code>aea generate protocol [path_to_specification]</code></li> <li>Look for, then add or code the skills you need: <code>aea search skills</code>, then <code>aea add skill [public_id]</code>. This guide shows you step by step how to develop a skill.</li> <li>Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator.</li> <li>Now, run your AEA: <code>aea run --connections [public_id]</code></li> </ol> <p>See information on the CLI tool here for all the available commands.</p>"},{"location":"aea-framework-documentation/car-park-skills/","title":"Car park skills","text":"<p>The AEA car-park skills demonstrate an interaction between two AEAs.</p> <ul> <li>The <code>carpark_detection</code> AEA provides information on the number of car parking spaces available in a given vicinity.</li> <li>The <code>carpark_client</code> AEA is interested in purchasing information on available car parking spaces in the same vicinity.</li> </ul>"},{"location":"aea-framework-documentation/car-park-skills/#discussion","title":"Discussion","text":"<p>The full Fetch.ai car park AEA demo is documented in its own repo here. This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic.</p> <p>It demonstrates how the AEAs trade car park information.</p>"},{"location":"aea-framework-documentation/car-park-skills/#communication","title":"Communication","text":"<p>This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Car_Data_Buyer_AEA\n        participant Car_Park_AEA\n        participant Blockchain\n\n        activate Search\n        activate Car_Data_Buyer_AEA\n        activate Car_Park_AEA\n        activate Blockchain\n\n        Car_Park_AEA-&gt;&gt;Search: register_service\n        Car_Data_Buyer_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Car_Data_Buyer_AEA: list_of_agents\n        Car_Data_Buyer_AEA-&gt;&gt;Car_Park_AEA: call_for_proposal\n        Car_Park_AEA-&gt;&gt;Car_Data_Buyer_AEA: propose\n        Car_Data_Buyer_AEA-&gt;&gt;Car_Park_AEA: accept\n        Car_Park_AEA-&gt;&gt;Car_Data_Buyer_AEA: match_accept\n        Car_Data_Buyer_AEA-&gt;&gt;Blockchain: transfer_funds\n        Car_Data_Buyer_AEA-&gt;&gt;Car_Park_AEA: send_transaction_hash\n        Car_Park_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Car_Park_AEA-&gt;&gt;Car_Data_Buyer_AEA: send_data\n\n        deactivate Search\n        deactivate Car_Data_Buyer_AEA\n        deactivate Car_Park_AEA\n        deactivate Blockchain</code></pre>"},{"location":"aea-framework-documentation/car-park-skills/#option-1-aea-manager-approach","title":"Option 1: AEA Manager Approach","text":"<p>Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.</p>"},{"location":"aea-framework-documentation/car-park-skills/#preparation-instructions","title":"Preparation Instructions","text":"<p>Install the AEA Manager.</p>"},{"location":"aea-framework-documentation/car-park-skills/#demo-instructions","title":"Demo Instructions","text":"<p>The following steps assume you have launched the AEA Manager Desktop app.</p> <ol> <li> <p>Add a new AEA called <code>car_detector</code> with public id <code>fetchai/car_detector:0.32.5</code>.</p> </li> <li> <p>Add another new AEA called <code>car_data_buyer</code> with public id <code>fetchai/car_data_buyer:0.33.5</code>.</p> </li> <li> <p>Copy the address from the <code>car_data_buyer</code> into your clip board. Then go to the Dorado block explorer and request some test tokens via <code>Get Funds</code>.</p> </li> <li> <p>Run the <code>car_detector</code> AEA. Navigate to its logs and copy the multiaddress displayed.</p> </li> <li> <p>Navigate to the settings of the <code>car_data_buyer</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}\n</code></pre> </li> <li> <p>Run the <code>car_data_buyer</code>.</p> </li> </ol> <p>In the AEA's logs, you should see the agent trading successfully.</p>"},{"location":"aea-framework-documentation/car-park-skills/#option-2-cli-approach","title":"Option 2: CLI Approach","text":"<p>Follow this approach when using the <code>aea</code> CLI.</p>"},{"location":"aea-framework-documentation/car-park-skills/#preparation-instructions_1","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/car-park-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/car-park-skills/#demo-instructions_1","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/car-park-skills/#create-car-detector-aea","title":"Create Car Detector AEA","text":"<p>First, fetch the car detector AEA:</p> <pre><code>aea fetch fetchai/car_detector:0.32.5\ncd car_detector\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the car detector from scratch:</p> <pre><code>aea create car_detector\ncd car_detector\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/carpark_detection:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/car-park-skills/#create-car-data-buyer-aea","title":"Create Car Data Buyer AEA","text":"<p>Then, fetch the car data client AEA:</p> <pre><code>aea fetch fetchai/car_data_buyer:0.33.5\ncd car_data_buyer\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the car data client from scratch:</p> <pre><code>aea create car_data_buyer\ncd car_data_buyer\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/carpark_client:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/car-park-skills/#add-keys-for-the-car-data-seller-aea","title":"Add Keys for the Car Data Seller AEA","text":"<p>First, create the private key for the car data seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/car-park-skills/#add-keys-and-generate-wealth-for-the-car-data-buyer-aea","title":"Add Keys and Generate Wealth for the Car Data Buyer AEA","text":"<p>The buyer needs to have some wealth to purchase the service from the seller.</p> <p>First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai <code>Dorado</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/car-park-skills/#run-the-aeas","title":"Run the AEAs","text":"<p>Run both AEAs from their respective terminals.</p> <p>First, run the car data seller AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the car data seller.</p> <p>Then, in the car data buyer, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>This allows the car data buyer to connect to the same local agent communication network as the car data seller.</p> <p>Then run the buyer AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.</p>"},{"location":"aea-framework-documentation/car-park-skills/#cleaning-up","title":"Cleaning up","text":"<p>When you're finished, delete your AEAs:</p> <pre><code>cd ..\naea delete car_detector\naea delete car_data_buyer\n</code></pre>"},{"location":"aea-framework-documentation/cli-commands/","title":"CLI Commands","text":"Command Description <code>add [package_type] [public_id]</code> Add a <code>package_type</code> connection, contract, protocol, or skill, with <code>[public_id]</code>, to the AEA. <code>add --local</code> to add from local <code>packages</code> directory. <code>add-key [ledger_id] file [--connection]</code> Add a private key from a file for <code>ledger_id</code>. <code>build</code> Build the agent and its components. <code>config get [path]</code> Reads the configuration specified in <code>path</code> and prints its target. <code>config set [path] [--type TYPE]</code> Sets a new value for the target of the <code>path</code>. Optionally cast to type. <code>create [name]</code> Create a new AEA project called <code>name</code>. <code>delete [name]</code> Delete an AEA project. See below for disabling a resource. <code>eject [package_type] [public_id]</code> Move a package of <code>package_type</code> and <code>package_id</code> from vendor to project working directory. <code>fetch [public_id]</code> Fetch an AEA project with <code>public_id</code>. <code>fetch --local</code> to fetch from local <code>packages</code> directory. <code>fingerprint [package_type] [public_id]</code> Fingerprint connection, contract, protocol, or skill, with <code>public_id</code>. <code>freeze</code> Get all the dependencies needed for the AEA project and its components. <code>generate protocol [protocol_spec_path]</code> Generate a protocol from the specification. <code>generate-key [ledger_id]</code> Generate private keys. The AEA uses a private key to derive the associated public key and address. <code>generate-wealth [ledger_id]</code> Generate wealth for address on test network. <code>get-address [ledger_id]</code> Get the address associated with the private key. <code>get-multiaddress [ledger_id]...</code> Get the multiaddress associated with a private key or connection. <code>get-public-key [ledger_id]...</code> Get the public key associated with a private key of the agent. <code>get-wealth [ledger_id]</code> Get the wealth associated with the private key. <code>init</code> Initialize your AEA configurations. (With <code>--author</code> to define author.) <code>install [-r &lt;requirements_file&gt;]</code> Install the dependencies. (With <code>--install-deps</code> to install dependencies.) <code>interact</code> Interact with a running AEA via the stub connection. <code>ipfs</code> IPFS Commands <code>issue-certificates</code> Issue the connection certificates. <code>launch [path_to_agent_project]...</code> Launch many agents at the same time. <code>list [package_type]</code> List the installed resources. <code>local-registry-sync</code> Upgrade the local package registry. <code>login USERNAME [--password password]</code> Login to a registry account with credentials. <code>logout</code> Logout from registry account. <code>publish</code> Publish the AEA to registry. Needs to be executed from an AEA project.<code>publish --local</code> to publish to local <code>packages</code> directory. <code>push [package_type] [public_id]</code> Push connection, protocol, or skill with <code>public_id</code> to registry. <code>push --local</code> to push to local <code>packages</code> directory. <code>register</code> Create a new registry account. <code>remove [package_type] [name]</code> Remove connection, protocol, or skill, called <code>name</code>, from AEA. <code>remove-key [ledger_id] [name]</code> Remove a private key registered with id <code>ledger_id</code>. <code>reset_password EMAIL</code> Reset the password of the registry account. <code>run {using [connections, ...]}</code> Run the AEA on the Fetch.ai network with default or specified connections. <code>scaffold [package_type] [name]</code> Scaffold a new connection, protocol, or skill called <code>name</code>. <code>search [package_type]</code> Search for components in the registry. <code>search --local [package_type] [--query searching_query]</code> to search in local <code>packages</code> directory. <code>transfer [type] [address] [amount]</code> Transfer wealth associated with a private key of the agent to another account. <code>upgrade [package_type] [public_id]</code> Upgrade the packages of the agent. <code>-v DEBUG run</code> Run with debugging. <p>Tip</p> <p>You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the <code>skills</code> namespace.</p> <p>Tip</p> <p>You can skip the consistency checks on the AEA project by using the flag <code>--skip-consistency-check</code>. E.g. <code>aea --skip-consistency-check run</code> will bypass the fingerprint checks.</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/","title":"CLI vs Programmatic AEAs","text":"<p>The AEA framework enables us to create agents either from the CLI tool or programmatically.</p> <p>The following demo demonstrates an interaction between two AEAs.</p> <p>The provider of weather data (managed with the CLI). The buyer of weather data (managed programmatically).</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#discussion","title":"Discussion","text":"<p>The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction.</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#get-required-packages","title":"Get Required Packages","text":"<p>Copy the <code>packages</code> directory into your local working directory:</p> <pre><code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages\n</code></pre> <p>Also, install <code>aea-ledger-fetchai</code> plug-in:</p> <pre><code>pip install aea-ledger-fetchai\n</code></pre>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#demo-instructions","title":"Demo Instructions","text":"<p>If you want to create the weather station AEA step by step you can follow this guide here</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#create-the-weather-station-aea","title":"Create the Weather Station AEA","text":"<p>Fetch the weather station AEA with the following command :</p> <pre><code>aea fetch fetchai/weather_station:0.32.5\ncd weather_station\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#update-the-aea-configurations","title":"Update the AEA Configurations","text":"<p>In the terminal change the configuration:</p> <pre><code>aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool\n</code></pre> <p>The <code>is_ledger_tx</code> will prevent the AEA to communicate with a ledger.</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#add-keys","title":"Add Keys","text":"<p>Add a private key for the weather station.</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#run-the-weather-station-aea","title":"Run the Weather Station AEA","text":"<pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr: ['SOME_ADDRESS']</code> take note of the address.</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#create-the-weather-client-aea","title":"Create the Weather Client AEA","text":"<p>Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client.</p> <p>Create a new python file and name it <code>weather_client.py</code> and add the following code</p> Weather client full code: <pre><code>import logging\nimport os\nimport sys\nfrom typing import cast\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.aea import AEA\nfrom aea.aea_builder import AEABuilder\nfrom aea.configurations.base import ConnectionConfig\nfrom aea.crypto.helpers import (\nPRIVATE_KEY_PATH_SCHEMA,\ncreate_private_key,\nmake_certificate,\n)\nfrom aea.crypto.wallet import Wallet\nfrom aea.helpers.base import CertRequest\nfrom aea.identity.base import Identity\nfrom aea.protocols.base import Protocol\nfrom aea.registries.resources import Resources\nfrom aea.skills.base import Skill\nimport packages.fetchai.connections.p2p_libp2p.connection\nfrom packages.fetchai.connections.ledger.connection import LedgerConnection\nfrom packages.fetchai.connections.p2p_libp2p.connection import P2PLibp2pConnection\nfrom packages.fetchai.connections.soef.connection import SOEFConnection\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.weather_client.strategy import Strategy\nAPI_KEY = \"TwiCIriSl0mLahw17pyqoA\"\nSOEF_ADDR = \"s-oef.fetch.ai\"\nSOEF_PORT = 443\nENTRY_PEER_ADDRESS = (\n\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAmLBCAqHL8SuFosyDhAKYsLKXBZBWXBsB9oFw2qU4Kckun\"\n)\nFETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA.format(FetchAICrypto.identifier)\nFETCHAI_PRIVATE_KEY_FILE_CONNECTION = PRIVATE_KEY_PATH_SCHEMA.format(\n\"fetchai_connection\"\n)\nROOT_DIR = os.getcwd()\nlogger = logging.getLogger(\"aea\")\nlogging.basicConfig(stream=sys.stdout, level=logging.INFO)\ndef run():\n\"\"\"Run demo.\"\"\"\n# Create a private key\ncreate_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE)\ncreate_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE_CONNECTION)\n# Set up the wallet, identity and (empty) resources\nwallet = Wallet(\nprivate_key_paths={FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE},\nconnection_private_key_paths={\nFetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_CONNECTION\n},\n)\nidentity = Identity(\n\"my_aea\",\naddress=wallet.addresses.get(FetchAICrypto.identifier),\npublic_key=wallet.public_keys.get(FetchAICrypto.identifier),\n)\nresources = Resources()\ndata_dir = os.getcwd()\n# specify the default routing for some protocols\ndefault_routing = {\nLedgerApiMessage.protocol_id: LedgerConnection.connection_id,\nOefSearchMessage.protocol_id: SOEFConnection.connection_id,\n}\ndefault_connection = P2PLibp2pConnection.connection_id\nstate_update_protocol = Protocol.from_dir(\nos.path.join(os.getcwd(), \"packages\", \"fetchai\", \"protocols\", \"state_update\")\n)\nresources.add_protocol(state_update_protocol)\n# Add the default protocol (which is part of the AEA distribution)\ndefault_protocol = Protocol.from_dir(\nos.path.join(os.getcwd(), \"packages\", \"fetchai\", \"protocols\", \"default\")\n)\nresources.add_protocol(default_protocol)\n# Add the signing protocol (which is part of the AEA distribution)\nsigning_protocol = Protocol.from_dir(\nos.path.join(os.getcwd(), \"packages\", \"fetchai\", \"protocols\", \"signing\")\n)\nresources.add_protocol(signing_protocol)\n# Add the ledger_api protocol\nledger_api_protocol = Protocol.from_dir(\nos.path.join(\nos.getcwd(),\n\"packages\",\n\"fetchai\",\n\"protocols\",\n\"ledger_api\",\n)\n)\nresources.add_protocol(ledger_api_protocol)\n# Add the oef_search protocol\noef_protocol = Protocol.from_dir(\nos.path.join(\nos.getcwd(),\n\"packages\",\n\"fetchai\",\n\"protocols\",\n\"oef_search\",\n)\n)\nresources.add_protocol(oef_protocol)\n# Add the fipa protocol\nfipa_protocol = Protocol.from_dir(\nos.path.join(\nos.getcwd(),\n\"packages\",\n\"fetchai\",\n\"protocols\",\n\"fipa\",\n)\n)\nresources.add_protocol(fipa_protocol)\n# Add the LedgerAPI connection\nconfiguration = ConnectionConfig(connection_id=LedgerConnection.connection_id)\nledger_api_connection = LedgerConnection(\nconfiguration=configuration, data_dir=data_dir, identity=identity\n)\nresources.add_connection(ledger_api_connection)\n# Add the P2P connection\ncert_path = \".certs/conn_cert.txt\"\ncert_request = CertRequest(\nidentifier=\"acn\",\nledger_id=FetchAICrypto.identifier,\nnot_after=\"2022-01-01\",\nnot_before=\"2021-01-01\",\npublic_key=\"fetchai\",\nmessage_format=\"{public_key}\",\nsave_path=cert_path,\n)\npublic_key = wallet.connection_cryptos.public_keys.get(FetchAICrypto.identifier)\nmessage = cert_request.get_message(public_key)\nmake_certificate(\nFetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE, message, cert_path\n)\nconfiguration = ConnectionConfig(\nconnection_id=P2PLibp2pConnection.connection_id,\ndelegate_uri=\"127.0.0.1:11001\",\nentry_peers=[ENTRY_PEER_ADDRESS],\nlocal_uri=\"127.0.0.1:9001\",\nlog_file=\"libp2p_node.log\",\npublic_uri=\"127.0.0.1:9001\",\nbuild_directory=os.getcwd(),\nbuild_entrypoint=\"check_dependencies.py\",\ncert_requests=[cert_request],\n)\nconfiguration.directory = os.path.dirname(\npackages.fetchai.connections.p2p_libp2p.connection.__file__\n)\nAEABuilder.run_build_for_component_configuration(configuration)\np2p_connection = P2PLibp2pConnection(\nconfiguration=configuration,\ndata_dir=data_dir,\nidentity=identity,\ncrypto_store=wallet.connection_cryptos,\n)\nresources.add_connection(p2p_connection)\n# Add the SOEF connection\nconfiguration = ConnectionConfig(\napi_key=API_KEY,\nsoef_addr=SOEF_ADDR,\nsoef_port=SOEF_PORT,\nrestricted_to_protocols={OefSearchMessage.protocol_id},\nconnection_id=SOEFConnection.connection_id,\n)\nsoef_connection = SOEFConnection(\nconfiguration=configuration, data_dir=data_dir, identity=identity\n)\nresources.add_connection(soef_connection)\n# create the AEA\nmy_aea = AEA(\nidentity,\nwallet,\nresources,\ndata_dir,\ndefault_connection=default_connection,\ndefault_routing=default_routing,\n)\n# Add the error and weather_client skills\nerror_skill = Skill.from_dir(\nos.path.join(ROOT_DIR, \"packages\", \"fetchai\", \"skills\", \"error\"),\nagent_context=my_aea.context,\n)\nweather_skill = Skill.from_dir(\nos.path.join(ROOT_DIR, \"packages\", \"fetchai\", \"skills\", \"weather_client\"),\nagent_context=my_aea.context,\n)\nstrategy = cast(Strategy, weather_skill.models.get(\"strategy\"))\nstrategy._is_ledger_tx = False\nfor skill in [error_skill, weather_skill]:\nresources.add_skill(skill)\n# Run the AEA\ntry:\nlogger.info(\"STARTING AEA NOW!\")\nmy_aea.start()\nexcept KeyboardInterrupt:\nlogger.info(\"STOPPING AEA NOW!\")\nmy_aea.stop()\nif __name__ == \"__main__\":\nrun()\n</code></pre> <p>Now replace <code>ENTRY_PEER_ADDRESS</code> with the peer address (<code>SOME_ADDRESS</code>) noted above.</p> <p>For more details on how to create an agent programmatically follow this guide here.</p>"},{"location":"aea-framework-documentation/cli-vs-programmatic-aeas/#run-the-weather-client-aea","title":"Run the Weather Client AEA","text":"<p>In a new terminal window, navigate to the folder that you created the script and run:</p> <pre><code>python weather_client.py\n</code></pre> <p>You should see both AEAs interacting now.</p>"},{"location":"aea-framework-documentation/config/","title":"Configurations","text":"<p>This document describes the configuration files of the different packages.</p>"},{"location":"aea-framework-documentation/config/#aea-configuration-yaml","title":"AEA Configuration YAML","text":"<p>The following provides a list of the relevant regex used:</p> <pre><code>PACKAGE_REGEX: \"[a-zA-Z_][a-zA-Z0-9_]*\"\nAUTHOR_REGEX: \"[a-zA-Z_][a-zA-Z0-9_]*\"\nPUBLIC_ID_REGEX: \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\nLEDGER_ID_REGEX: \"^[^\\\\d\\\\W]\\\\w*\\\\Z\"\n</code></pre> <p>The <code>aea-config.yaml</code> defines the AEA project. The compulsory components are listed below:</p> <pre><code>agent_name: my_agent                            # Name of the AEA project (must satisfy PACKAGE_REGEX)\nauthor: fetchai                                 # Author handle of the project's author (must satisfy AUTHOR_REGEX)\nversion: 0.1.0                                  # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\")\ndescription: A demo project                     # Description of the AEA project\nlicense: Apache-2.0                             # License of the AEA project\naea_version: '&gt;=1.0.0, &lt;2.0.0'               # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers)\nfingerprint: {}                                 # Fingerprint of AEA project components.\nfingerprint_ignore_patterns: []                 # Ignore pattern for the fingerprinting tool.\nconnections:                                    # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX)\n- fetchai/stub:0.21.3\ncontracts: []                                   # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX).\nprotocols:                                      # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX).\n- fetchai/default:1.1.7\nskills:                                         # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX).\n- fetchai/error:0.18.6\ndefault_connection: fetchai/p2p_libp2p:0.27.5   # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX).\ndefault_ledger: fetchai                         # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX)\nrequired_ledgers: [fetchai]                            # the list of identifiers of ledgers that the AEA project requires key pairs for (each item must satisfy LEDGER_ID_REGEX)\ndefault_routing: {}                             # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX)\nconnection_private_key_paths:                   # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths)\nfetchai: fetchai_private_key.txt\nprivate_key_paths:                              # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths)\nfetchai: fetchai_private_key.txt\nlogging_config:                                 # The logging configurations the AEA project uses\ndisable_existing_loggers: false\nversion: 1\ndependencies: {}                                # The python dependencies the AEA relies on (e.g. plugins). They will be installed when `aea install` is run.\n</code></pre> <p>The <code>aea-config.yaml</code> can be extended with a number of optional fields:</p> <pre><code>period: 0.05                                    # The period to call agent's act\nexecution_timeout: 0                            # The execution time limit on each call to `react` and `act` (0 disables the feature)\ntimeout: 0.05                                   # The sleep time on each AEA loop spin (only relevant for the `sync` mode)\nmax_reactions: 20                               # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode)\nskill_exception_policy: propagate               # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\")\nconnection_exception_policy: propagate          # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\")\nloop_mode: async                                # The agent loop mode (must be one of \"sync\" or \"async\")\nruntime_mode: threaded                          # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run\nerror_handler: None                             # The error handler to be used.\ndecision_maker_handler: None                    # The decision maker handler to be used.\nstorage_uri: None                               # The URI to the storage.\ndata_dir: None                                  # The path to the directory for local files. Defaults to current working directory.\n</code></pre> <p>The <code>aea-config.yaml</code> can further be extended with component configuration overrides.</p> <p>For custom connection configurations:</p> <pre><code>public_id: some_author/some_package:0.1.0       # The public id of the connection (must satisfy PUBLIC_ID_REGEX).\ntype: connection                                # for connections, this must be \"connection\".\nconfig: ...                                     # a dictionary to overwrite the `config` field (see below)\n</code></pre> <p>For custom skill configurations:</p> <pre><code>public_id: some_author/some_package:0.1.0       # The public id of the connection (must satisfy PUBLIC_ID_REGEX).\ntype: skill                                     # for skills, this must be \"skill\".\nbehaviours:                                     # override configurations for behaviours\nbehaviour_1:                                  # override configurations for \"behaviour_1\"\nargs:                                       # arguments for a specific behaviour (see below)\nfoo: bar\nhandlers:                                       # override configurations for handlers\nhandler_1:                                    # override configurations for \"handler_1\"\nargs:                                       # arguments for a specific handler (see below)\nfoo: bar\nmodels:                                         # override configurations for models\nmodel_1:                                      # override configurations for \"model_1\"\nargs:                                       # arguments for a specific model (see below)\nfoo: bar\n</code></pre>"},{"location":"aea-framework-documentation/config/#connection-configuration-yaml","title":"Connection Configuration YAML","text":"<p>The <code>connection.yaml</code>, which is present in each connection package, has the following required fields:</p> <pre><code>name: scaffold                                  # Name of the package (must satisfy PACKAGE_REGEX)\nauthor: fetchai                                 # Author handle of the package's author (must satisfy AUTHOR_REGEX)\nversion: 0.1.0                                  # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\")\ntype: connection                                # The type of the package; for connections, it must be \"connection\"\ndescription: A scaffold connection              # Description of the package\nlicense: Apache-2.0                             # License of the package\naea_version: '&gt;=1.0.0, &lt;2.0.0'               # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers)\nfingerprint:                                    # Fingerprint of package components.\n__init__.py: QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj\nconnection.py: QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze\nfingerprint_ignore_patterns: []                 # Ignore pattern for the fingerprinting tool.\nconnections: []                                 # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX).\nprotocols: []                                   # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX).\nclass_name: MyScaffoldConnection                # The class name of the class implementing the connection interface.\nconfig:                                         # A dictionary containing the kwargs for the connection instantiation.\nfoo: bar\nexcluded_protocols: []                          # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX).\nrestricted_to_protocols: []                     # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX).\ndependencies: {}                                # The python dependencies the package relies on. They will be installed when `aea install` is run.\nis_abstract: false                              # An optional boolean that if `true` makes the connection\n</code></pre>"},{"location":"aea-framework-documentation/config/#contract-configuration-yaml","title":"Contract Configuration YAML","text":"<p>The <code>contract.yaml</code>, which is present in each contract package, has the following required fields:</p> <pre><code>name: scaffold                                  # Name of the package (must satisfy PACKAGE_REGEX)\nauthor: fetchai                                 # Author handle of the package's author (must satisfy AUTHOR_REGEX)\nversion: 0.1.0                                  # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\")\ntype: contract                                  # The type of the package; for contracts, it must be \"contract\"\ndescription: A scaffold contract                # Description of the package\nlicense: Apache-2.0                             # License of the package\naea_version: '&gt;=1.0.0, &lt;2.0.0'               # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers)\nfingerprint:                                    # Fingerprint of package components.\n__init__.py: QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6\ncontract.py: QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G\nfingerprint_ignore_patterns: []                 # Ignore pattern for the fingerprinting tool.\nclass_name: MyScaffoldContract                  # The class name of the class implementing the contract interface.\ncontract_interface_paths: {}                    # The paths to the contract interfaces (one for each ledger identifier).\nconfig:                                         # A dictionary containing the kwargs for the contract instantiation.\nfoo: bar\ndependencies: {}                                # The python dependencies the package relies on. They will be installed when `aea install` is run.\n</code></pre>"},{"location":"aea-framework-documentation/config/#protocol-configuration-yaml","title":"Protocol Configuration YAML","text":"<p>The <code>protocol.yaml</code>, which is present in each protocol package, has the following required fields:</p> <pre><code>name: scaffold                                  # Name of the package (must satisfy PACKAGE_REGEX)\nauthor: fetchai                                 # Author handle of the package's author (must satisfy AUTHOR_REGEX)\nversion: 0.1.0                                  # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\")\ntype: protocol                                  # The type of the package; for protocols, it must be \"protocol\" \ndescription: A scaffold protocol                # Description of the package\nlicense: Apache-2.0                             # License of the package\naea_version: '&gt;=1.0.0, &lt;2.0.0'               # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers)\nfingerprint:                                    # Fingerprint of package components.\n__init__.py: Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ\nmessage.py: QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4\nserialization.py: QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv\nfingerprint_ignore_patterns: []                 # Ignore pattern for the fingerprinting tool.\ndependencies: {}                                # The python dependencies the package relies on. They will be installed when `aea install` is run.\n</code></pre>"},{"location":"aea-framework-documentation/config/#skill-configuration-yaml","title":"Skill Configuration YAML","text":"<p>The <code>skill.yaml</code>, which is present in each protocol package, has the following required fields:</p> <pre><code>name: scaffold                                  # Name of the package (must satisfy PACKAGE_REGEX)\nauthor: fetchai                                 # Author handle of the package's author (must satisfy AUTHOR_REGEX)\nversion: 0.1.0                                  # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\")\ntype: skill                                     # The type of the package; for skills, it must be \"skill\"\ndescription: A scaffold skill                   # Description of the package\nlicense: Apache-2.0                             # License of the package\naea_version: '&gt;=1.0.0, &lt;2.0.0'               # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers)\nfingerprint:                                    # Fingerprint of package components.\n__init__.py: QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta\nbehaviours.py: QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy\nhandlers.py: QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn\nmy_model.py: QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V\nfingerprint_ignore_patterns: []                 # Ignore pattern for the fingerprinting tool.\ncontracts: []                                   # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX).\nprotocols: []                                   # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX).\nskills: []                                      # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX).\nis_abstract: false                              # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. \nbehaviours:                                     # The dictionary describing the behaviours immplemented in the package (including their configuration)\nscaffold:                                     # Name of the behaviour under which it is made available on the skill context.\nargs:                                       # Keyword arguments provided to the skill component on instantiation.\nfoo: bar\nclass_name: MyScaffoldBehaviour             # The class name of the class implementing the behaviour interface.\nhandlers:                                       # The dictionary describing the handlers immplemented in the package (including their configuration)\nscaffold:                                     # Name of the handler under which it is made available on the skill\nargs:                                       # Keyword arguments provided to the skill component on instantiation.\nfoo: bar\nclass_name: MyScaffoldHandler               # The class name of the class implementing the handler interface.\nmodels:                                         # The dictionary describing the models immplemented in the package (including their configuration)\nscaffold:                                     # Name of the model under which it is made available on the skill\nargs:                                       # Keyword arguments provided to the skill component on instantiation.\nfoo: bar\nclass_name: MyModel                         # The class name of the class implementing the model interface.\ndependencies: {}                                # The python dependencies the package relies on. They will be installed when `aea install` is run.\n</code></pre>"},{"location":"aea-framework-documentation/connect-a-frontend/","title":"Front-End Integration","text":"<p>This page lays out two options for connecting a front-end to an AEA. The following diagram illustrates these two options.</p> <p></p>"},{"location":"aea-framework-documentation/connect-a-frontend/#case-1","title":"Case 1","text":"<p>The first option is to create a <code>HTTP Server</code> connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the <code>HTTP Server</code> connection package. The REST API should send CRUD requests to the <code>HTTP Server</code> connection (<code>fetchai/http_server:0.23.6</code>) which translates these into Envelopes to be consumed by the correct skill.</p>"},{"location":"aea-framework-documentation/connect-a-frontend/#case-2","title":"Case 2","text":"<p>The second option is to create a front-end comprising a stand-alone <code>Multiplexer</code> with a <code>P2P</code> connection (<code>fetchai/p2p_libp2p:0.27.5</code>). In this scenario the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.</p>"},{"location":"aea-framework-documentation/connection/","title":"Connections","text":"<p>A <code>Connection</code> provides an interface for the agent to connect with entities in the outside world. Connections wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. As such, a connection is concerned with I/O bound and continuously connected operations. Where necessary, a connection is responsible for translating between the framework specific protocol (an <code>Envelope</code> with its contained <code>Message</code>) and the external service or third-party protocol (e.g. <code>HTTP</code>). Hence, there are two roles for connections: wrapper and transport connection. The transport connection is responsible to delivering AEA envelopes.</p> <p>The messages constructed or received by a connection are eventually processed by one or several skills which deal with handling and generating messages related to a specific business objective.</p> <p></p> <p>An <code>AEA</code> can interact with multiple connections at the same time via the <code>Multiplexer</code>. Connections are passive in terms of multiplexer interactions (its methods are called by the Multiplexer), but they can run their own asynchronous or threaded tasks.</p> <p>The <code>Multiplexer</code> maintains an <code>InBox</code> and <code>OutBox</code>, which are, respectively, queues for incoming and outgoing envelopes and their contained messages.</p>"},{"location":"aea-framework-documentation/connection/#developing-your-connection","title":"Developing your Connection","text":"<p>The easiest way to get started developing your own connection is by using the scaffold command:</p> <pre><code>aea scaffold connection my_new_connection\n</code></pre> <p>This will scaffold a connection package called <code>my_new_connection</code> with three files:</p> <ul> <li><code>__init__.py</code></li> <li><code>connection.py</code> containing the scaffolded connection class</li> <li><code>connection.yaml</code> containing the scaffolded configuration file</li> </ul> <p>As a developer you have the choice between implementing a sync or asynchronous interface. The scaffolded <code>connection.py</code> file contains two classes: the <code>MyScaffoldAsyncConnection</code> inherited from the <code>Connection</code> base class and the <code>MyScaffoldSyncConnection</code> inherited from the <code>BaseSyncConnection</code>. Remove the unused class.</p>"},{"location":"aea-framework-documentation/connection/#primary-methods-to-develop-asynchronous-connection-interface","title":"Primary Methods to Develop - Asynchronous Connection Interface","text":"<p>The developer needs to implement four public coroutines:</p> <ul> <li> <p>The <code>connect</code> coroutine implements the setup logic required to be performed for the connection when it is initially launched. The <code>connect</code> coroutine is called by the AEA framework once when the agent is being started.</p> </li> <li> <p>The <code>disconnect</code> coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The <code>disconnect</code> coroutine is called by the AEA framework once when the agent is being stopped.</p> </li> <li> <p>The <code>send</code> coroutine is called by the AEA framework each time the <code>Multiplexer</code> handles an outgoing envelope specified to be handled by this connection. The <code>send</code> coroutine must implement the processing of the envelope leaving the agent.</p> </li> <li> <p>The <code>receive</code> coroutine is continuously called by the AEA framework. It either returns <code>None</code> or an envelope. The <code>receive</code> coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol.</p> </li> </ul> <p>The framework provides a demo <code>stub</code> connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out <code>fetchai/stub:0.21.3</code>, <code>fetchai/http_server:0.23.6</code> or <code>fetchai/http_client:0.24.6</code> connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively.</p>"},{"location":"aea-framework-documentation/connection/#primary-methods-to-develop-sync-connection-interface","title":"Primary Methods to Develop - Sync Connection Interface","text":"<p>The <code>BaseSyncConnection</code> uses executors to execute synchronous code from the asynchronous context of the <code>Multiplexer</code> in executors/threads, which are limited by the amount of configured workers.</p> <p>The asynchronous methods <code>connect</code>, <code>disconnect</code> and <code>send</code> are converted to callbacks which the developer implements:</p> <ul> <li><code>on_connect</code></li> <li><code>on_disconnect</code></li> <li><code>on_send</code></li> </ul> <p>All of these methods will be executed in the executor pool.</p> <p>Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the <code>Multiplexer</code>.</p> <p>The <code>receive</code> coroutine has no direct equivalent. Instead, the developer implements a <code>main</code> method which runs synchronously in the background.</p>"},{"location":"aea-framework-documentation/connection/#configuration","title":"Configuration","text":"<p>Every connection must have a configuration file in <code>connection.yaml</code>, containing meta-information about the connection as well as all the required configuration details. For more details, have a look here.</p>"},{"location":"aea-framework-documentation/connection/#configuration-options","title":"Configuration Options","text":"<p>The <code>connection.yaml</code> file contains a number of fields that must be edited by the developer of the connection:</p> <pre><code>connections: []\nprotocols: []\nclass_name: MyScaffoldConnection\nconfig:\nfoo: bar\nexcluded_protocols: []\nrestricted_to_protocols: []\ndependencies: {}\nis_abstract: false\ncert_requests: []\n</code></pre> <ul> <li><code>connections</code> specifies the list of other connection this connection depends on</li> <li><code>protocols</code> specifies the list of protocols this connection depends on</li> <li><code>class_name</code> needs to match the name of the connection class in <code>connection.py</code></li> <li><code>config</code> can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments (<code>**kwargs</code>)</li> <li><code>excluded_protocols</code> lists the protocols which cannot be used in this connection</li> <li><code>restricted_to_protocols</code> lists the protocols which this connection is restricted to be used by</li> <li><code>dependencies</code> lists any Python dependencies of the connection package</li> <li><code>is_abstract</code> specifies whether this connection is only used as an abstract base class</li> <li><code>cert_requests</code> lists certification requests of the connection (see proof of representation for details)</li> </ul>"},{"location":"aea-framework-documentation/contract/","title":"Contracts","text":"<p><code>Contracts</code> wrap smart contracts for Fetch.ai and third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract and its byte code. They implement a translation between framework messages (in the <code>fetchai/contract_api:1.0.0</code> protocol) and the implementation specifics of the ABI.</p> <p>Contracts usually implement four types of methods:</p> <ul> <li>a method to create a smart contract deployment transaction,</li> <li>methods to create transactions to modify state in the deployed smart contract,</li> <li>methods to create contract calls to execute static methods on the deployed smart contract, and</li> <li>methods to query the state of the deployed smart contract.</li> </ul> <p>Contracts can be added as packages which means they become reusable across AEA projects.</p> <p>The smart contract wrapped in an AEA contract package might be a third-party smart contract or your own smart contract potentially interacting with a third-party contract on-chain.</p>"},{"location":"aea-framework-documentation/contract/#interacting-with-contracts-from-skills","title":"Interacting with Contracts from Skills","text":"<p>Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection.</p> <p></p> <p>In particular, the <code>fetchai/ledger:0.21.5</code> connection can be used to execute contract related logic. The skills communicate with the <code>fetchai/ledger:0.21.5</code> connection via the <code>fetchai/contract_api:1.0.0</code> protocol. This protocol implements a request-response pattern to serve the four types of methods listed above:</p> <ul> <li>the <code>get_deploy_transaction</code> message is used to request a <code>deploy</code> transaction for a specific contract. For instance, to request a <code>deploy</code> transaction for the deployment of the smart contract wrapped in the <code>fetchai/erc1155:0.23.3</code> package, we send the following message to the <code>fetchai/ledger:0.21.5</code>:</li> </ul> <pre><code>contract_api_msg = ContractApiMessage(\nperformative=ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION,\ndialogue_reference=contract_api_dialogues.new_self_initiated_dialogue_reference(),\nledger_id=strategy.ledger_id,\ncontract_id=\"fetchai/erc1155:0.23.3\",\ncallable=\"get_deploy_transaction\",\nkwargs=ContractApiMessage.Kwargs(\n{\"deployer_address\": self.context.agent_address}\n),\n)\n</code></pre> <p>Any additional arguments needed by the contract's constructor method should be added to <code>kwargs</code>.</p> <p>This message will be handled by the <code>fetchai/ledger:0.21.5</code> connection and then a <code>raw_transaction</code> message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the <code>fetchai/ledger:0.21.5</code> connection using the <code>fetchai/ledger_api:1.0.0</code> protocol. For details on how to implement the message handling, see the handlers in the <code>erc1155_deploy</code> skill.</p> <p>CosmWasm based smart contract deployments</p> <p>When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times.</p> <p>Both the <code>store</code> and <code>init</code> messages use the <code>ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION</code> performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an <code>init</code> transaction requires the keyword arguments <code>code_id</code> (integer), <code>label</code> (string), <code>amount</code> (integer) and <code>init_msg</code> (JSON).</p> <p>For an example look at the <code>fetchai/erc1155:0.23.3</code> package.</p> <ul> <li>the <code>get_raw_transaction</code> message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed <code>erc1155</code> smart contract wrapped in the <code>fetchai/erc1155:0.23.3</code> package, we send the following message to the <code>fetchai/ledger:0.21.5</code>:</li> </ul> <pre><code>contract_api_msg = ContractApiMessage(\nperformative=ContractApiMessage.Performative.GET_RAW_TRANSACTION,\ndialogue_reference=contract_api_dialogues.new_self_initiated_dialogue_reference(),\nledger_id=strategy.ledger_id,\ncontract_id=\"fetchai/erc1155:0.23.3\",\ncontract_address=strategy.contract_address,\ncallable=\"get_create_batch_transaction\",\nkwargs=ContractApiMessage.Kwargs(\n{\n\"deployer_address\": self.context.agent_address,\n\"token_ids\": strategy.token_ids,\n}\n),\n)\n</code></pre> <p>This message will be handled by the <code>fetchai/ledger:0.21.5</code> connection and then a <code>raw_transaction</code> message will be returned with the matching raw transaction. For this to be executed correctly, the <code>fetchai/erc1155:0.23.3</code> contract package needs to implement the <code>get_create_batch_transaction</code> method with the specified key word arguments (see example in Deploy your own, below). Similar to the above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the <code>fetchai/ledger:0.21.5</code> connection using the <code>fetchai/ledger_api:1.0.0</code> protocol.</p> <ul> <li>the <code>get_raw_message</code> message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed <code>erc1155</code> smart contract wrapped in the <code>fetchai/erc1155:0.23.3</code> package, we send the following message to the <code>fetchai/ledger:0.21.5</code>:</li> </ul> <pre><code>contract_api_msg = ContractApiMessage(\nperformative=ContractApiMessage.Performative.GET_RAW_MESSAGE,\ndialogue_reference=contract_api_dialogues.new_self_initiated_dialogue_reference(),\nledger_id=strategy.ledger_id,\ncontract_id=\"fetchai/erc1155:0.23.3\",\ncontract_address=strategy.contract_address,\ncallable=\"get_hash_single\",\nkwargs=ContractApiMessage.Kwargs(\n{\n\"from_address\": from_address,\n\"to_address\": to_address,\n\"token_id\": token_id,\n\"from_supply\": from_supply,\n\"to_supply\": to_supply,\n\"value\": value,\n\"trade_nonce\": trade_nonce,\n}\n),\n)\n</code></pre> <p>This message will be handled by the <code>fetchai/ledger:0.21.5</code> connection and then a <code>raw_message</code> message will be returned with the matching raw message. For this to be executed correctly, the <code>fetchai/erc1155:0.23.3</code> contract package needs to implement the <code>get_hash_single</code> method with the specified key word arguments. We can then send the raw message to the <code>fetchai/ledger:0.21.5</code> connection using the <code>fetchai/ledger_api:1.0.0</code> protocol. In this case, signing is not required.</p> <ul> <li>the <code>get_state</code> message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed <code>erc1155</code> smart contract wrapped in the <code>fetchai/erc1155:0.23.3</code> package, we send the following message to the <code>fetchai/ledger:0.21.5</code>:</li> </ul> <pre><code>contract_api_msg = ContractApiMessage(\nperformative=ContractApiMessage.Performative.GET_STATE,\ndialogue_reference=contract_api_dialogues.new_self_initiated_dialogue_reference(),\nledger_id=strategy.ledger_id,\ncontract_id=\"fetchai/erc1155:0.23.3\",\ncontract_address=strategy.contract_address,\ncallable=\"get_balance\",\nkwargs=ContractApiMessage.Kwargs(\n{\"agent_address\": address, \"token_id\": token_id}\n),\n)\n</code></pre> <p>This message will be handled by the <code>fetchai/ledger:0.21.5</code> connection and then a <code>state</code> message will be returned with the matching state. For this to be executed correctly, the <code>fetchai/erc1155:0.23.3</code> contract package needs to implement the <code>get_balance</code> method with the specified key word arguments. We can then send the raw message to the <code>fetchai/ledger:0.21.5</code> connection using the <code>fetchai/ledger_api:1.0.0</code> protocol. In this case, signing is not required.</p>"},{"location":"aea-framework-documentation/contract/#developing-your-own","title":"Developing your own","text":"<p>The easiest way to get started developing your own contract is by using the scaffold command:</p> <pre><code>aea scaffold contract my_new_contract\n</code></pre> <p>This will scaffold a contract package called <code>my_new_contract</code> with three files:</p> <ul> <li><code>__init__.py</code></li> <li><code>contract.py</code>, containing the scaffolded contract class</li> <li><code>contract.yaml</code> containing the scaffolded configuration file</li> </ul> <p>Once your scaffold is in place, you can create a <code>build</code> folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the <code>contract.yaml</code>. For instance, if you use Ethereum, then you might specify the following:</p> <pre><code>contract_interface_paths:\nethereum: build/my_contract.json\n</code></pre> <p>where <code>ethereum</code> is the ledger id and <code>my_contract.json</code> is the file containing the byte code and ABI.</p> <p>Finally, you will want to implement the part of the contract interface you need in <code>contract.py</code>:</p> <pre><code>from aea.contracts.base import Contract\nfrom aea.crypto.base import LedgerApi\nclass MyContract(Contract):\n\"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\"\n@classmethod\ndef get_create_batch_transaction(\ncls,\nledger_api: LedgerApi,\ncontract_address: str,\ndeployer_address: str,\ntoken_ids: List[int],\ndata: Optional[bytes] = b\"\",\ngas: int = 300000,\n) -&gt; Dict[str, Any]:\n\"\"\"\n        Get the transaction to create a batch of tokens.\n        :param ledger_api: the ledger API\n        :param contract_address: the address of the contract\n        :param deployer_address: the address of the deployer\n        :param token_ids: the list of token ids for creation\n        :param data: the data to include in the transaction\n        :param gas: the gas to be used\n        :return: the transaction object\n        \"\"\"\n# create the transaction dict\nnonce = ledger_api.api.eth.getTransactionCount(deployer_address)\ninstance = cls.get_instance(ledger_api, contract_address)\ntx = instance.functions.createBatch(\ndeployer_address, token_ids\n).buildTransaction(\n{\n\"gas\": gas,\n\"gasPrice\": ledger_api.api.toWei(\"50\", \"gwei\"),\n\"nonce\": nonce,\n}\n)\ntx = cls._try_estimate_gas(ledger_api, tx)\nreturn tx\n</code></pre> <p>Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the <code>fetchai/ledger:0.21.5</code> connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the <code>deployer_address</code>, then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction.</p> <p>It helps to look at existing contract packages, like <code>fetchai/erc1155:0.23.3</code>, and skills using them, like <code>fetchai/erc1155_client:0.11.0</code> and <code>fetchai/erc1155_deploy:0.31.6</code>, for inspiration and guidance.</p>"},{"location":"aea-framework-documentation/core-components-1/","title":"Core Components - Part 1","text":"<p>The AEA framework consists of several core components, some required to run an AEA and others optional.</p> <p>The following sections discuss the inner workings of the AEA framework and how it calls the code in custom packages (see inversion of control and a helpful comparison here). Whilst it is in principle possible to use parts of the framework as a library, we do not recommend it.</p>"},{"location":"aea-framework-documentation/core-components-1/#the-elements-each-aea-uses","title":"The Elements Each AEA Uses","text":""},{"location":"aea-framework-documentation/core-components-1/#envelope","title":"Envelope","text":"<p><code>AEA</code> objects communicate asynchronously via <code>Envelopes</code>.</p> <p>An <code>Envelope</code> is the core object with which agents communicate. It is a vehicle for <code>Messages</code> with five attributes:</p> <ul> <li><code>to</code>: defines the destination address.</li> <li><code>sender</code>: defines the sender address.</li> <li><code>protocol_id</code>: defines the id of the <code>Protocol</code>.</li> <li><code>message</code>: is a bytes field which holds the <code>Message</code> in serialized form.</li> <li><code>Optional[context]</code>: an optional field to specify routing information in a URI.</li> </ul> <p><code>Messages</code>  must adhere to a <code>Protocol</code>.</p>"},{"location":"aea-framework-documentation/core-components-1/#protocol","title":"Protocol","text":"<p><code>Protocols</code> define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include:</p> <ul> <li><code>Messages</code> defining the syntax of messages;</li> <li><code>Serialization</code> defining how a <code>Message</code> is encoded for transport; and, optionally</li> <li><code>Dialogues</code>, which define rules over <code>Message</code> sequences.</li> </ul> <p>The framework provides one default <code>Protocol</code>, called <code>default</code> (current version <code>fetchai/default:1.1.7</code>). This <code>Protocol</code> provides a bare-bones implementation for an AEA <code>Protocol</code> which includes a <code>DefaultMessage</code>  class and associated <code>DefaultSerializer</code> and <code>DefaultDialogue</code> classes.</p> <p>Additional <code>Protocols</code>, for new types of interactions, can be added as packages. For more details on <code>Protocols</code> you can read the protocol guide. To learn how you can easily automate protocol definition, head to the guide for the protocol generator.</p> <p>Protocol specific <code>Messages</code>, wrapped in <code>Envelopes</code>, are sent and received to other agents, agent components and services via <code>Connections</code>.</p>"},{"location":"aea-framework-documentation/core-components-1/#connection","title":"Connection","text":"<p>A <code>Connection</code> wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a <code>Connection</code> is responsible for translating between the framework specific <code>Envelope</code> with its contained <code>Message</code> and the external service or third-party protocol (e.g. <code>HTTP</code>).</p> <p>The framework provides one default <code>Connection</code>, called <code>stub</code> (current version <code>fetchai/stub:0.21.3</code>). It implements an I/O reader and writer to send <code>Messages</code> to the agent from a local file.</p> <p>Additional <code>Connections</code> can be added as packages. For more details on <code>Connections</code> read the  <code>Connection</code> guide .</p> <p>An AEA runs and manages <code>Connections</code> via a <code>Multiplexer</code>.</p>"},{"location":"aea-framework-documentation/core-components-1/#multiplexer","title":"Multiplexer","text":"<p>The <code>Multiplexer</code> is responsible for maintaining (potentially multiple) <code>Connections</code>.</p> <p>It maintains an <code>InBox</code> and <code>OutBox</code>, which are, respectively, queues for incoming and outgoing <code>Envelopes</code> from the perspective of <code>Skills</code>.</p>"},{"location":"aea-framework-documentation/core-components-1/#skill","title":"Skill","text":"<p><code>Skills</code> are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations.</p> <p>A <code>Skill</code> encapsulates implementations of the three abstract base classes <code>Handler</code>, <code>Behaviour</code>, <code>Model</code>, and is closely related with the abstract base class <code>Task</code>:</p> <ul> <li><code>Handler</code>: each <code>Skill</code> has zero, one or more <code>Handler</code> objects. There is a one-to-one correspondence between <code>Handlers</code> and the protocols in an AEA (also known as the registered protocols). Handlers implement AEAs' reactive behaviour. If an AEA understands a <code>Protocol</code> referenced in a received <code>Envelope</code> (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding <code>Handler</code> which executes the AEA's reaction to this <code>Message</code>.</li> <li><code>Behaviour</code>: a <code>skill</code> can have zero, one or more <code>Behaviours</code>, each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' pro-activeness. The framework provides a number of abstract base classes implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed.</li> <li><code>Model</code>: zero, one or more <code>Models</code> that inherit from the <code>Model</code> abstract base class and are accessible via the <code>SkillContext</code>.</li> <li><code>Task</code>: zero, one or more <code>Tasks</code> encapsulate background work internal to the AEA. <code>Task</code> differs from the other three in that it is not a part of <code>Skills</code>, but <code>Tasks</code> are declared in or from <code>Skills</code> if a packaging approach for AEA creation is used.</li> </ul> <p>A <code>Skill</code> can read (parts of) an AEA's state (as summarised in the <code>AgentContext</code>), and propose actions to the AEA according to its specific logic. As such, more than one <code>Skill</code> could exist per <code>Protocol</code>, competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means <code>Skills</code> are horizontally arranged.</p> <p>For instance, an AEA which is trading goods, could subscribe to more than one <code>Skill</code>, where each corresponds to a different trading strategy.</p> <p>The framework places no limits on the complexity of <code>Skills</code>. They can implement simple (e.g. <code>if-this-then-that</code>) logic or be complex (e.g. a deep learning model or reinforcement learning agent).</p> <p>The framework provides one default <code>Skill</code>, called <code>error</code>. Additional <code>Skills</code> can be added as packages. For more details on <code>Skills</code> head over to the  <code>Skill</code> guide .</p>"},{"location":"aea-framework-documentation/core-components-1/#agent-loop","title":"Agent Loop","text":"<p>The <code>AgentLoop</code> performs a series of activities while the <code>AEA</code> state is not <code>stopped</code>.</p> <ul> <li>it calls the <code>act()</code> function of all active registered <code>Behaviours</code> at their respective tick rate.</li> <li>it grabs all Envelopes waiting in the <code>InBox</code> queue and calls the <code>handle()</code> function for the <code>Handlers</code> currently registered against the <code>Protocol</code> of the <code>Envelope</code>.</li> <li>it dispatches the internal <code>Messages</code> from the decision maker (described below) to the handler in the relevant <code>Skill</code>.</li> </ul> <p>The <code>AgentLoop</code> and <code>Multiplexer</code> are decoupled via the <code>InBox</code> and <code>OutBox</code>, and both are maintained by the <code>Runtime</code>.</p>"},{"location":"aea-framework-documentation/core-components-1/#next-steps","title":"Next Steps","text":""},{"location":"aea-framework-documentation/core-components-1/#recommended","title":"Recommended","text":"<p>We recommend you continue with the next step in the 'Getting Started' series:</p> <ul> <li>AEA and web frameworks</li> </ul>"},{"location":"aea-framework-documentation/core-components-1/#relevant-deep-dives","title":"Relevant Deep-Dives","text":"<p>Most AEA development focuses on developing the <code>Skills</code> and <code>Protocols</code> necessary for an AEA to deliver against its economic objectives.</p> <p>Understanding <code>Protocols</code> is core to developing your own agent. You can learn more about the <code>Protocols</code> agents use to communicate with each other and how they are created in the following section:</p> <ul> <li>Protocols</li> </ul> <p>Most of an AEA developer's time is spent on <code>Skill</code> development. <code>Skills</code> are the core business logic components of an AEA. Check out the following guide to learn more:</p> <ul> <li>Skills</li> </ul> <p>In most cases, one of the available <code>Connection</code> packages can be used. Occasionally, you might develop your own <code>Connection</code>:</p> <ul> <li>Connections</li> </ul>"},{"location":"aea-framework-documentation/core-components-2/","title":"Core components - Part 2","text":"<p>The AEA framework consists of several core components, some required to run an AEA and others optional.</p> <p>In Core Components - Part 1 we described the common components each AEA uses. In this page, we will look at more advanced components.</p>"},{"location":"aea-framework-documentation/core-components-2/#required-components-used-by-aeas","title":"Required Components Used by AEAs","text":""},{"location":"aea-framework-documentation/core-components-2/#decision-maker","title":"Decision Maker","text":"<p>The <code>DecisionMaker</code> can be thought of as a <code>Wallet</code> manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the <code>Wallet</code>'s private keys.</p> <p>You can learn more about the decision maker here. In its simplest form, the decision maker acts like a <code>Wallet</code> with <code>Handler</code> that reacts to the messages it receives from the skills.</p>"},{"location":"aea-framework-documentation/core-components-2/#wallet","title":"Wallet","text":"<p>The <code>Wallet</code> contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does.</p> <p>The agent has two sets of private keys, as configured in the <code>aea-config.yaml</code>:</p> <ul> <li><code>private_key_paths</code>: This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. <code>fetchai</code>, the AEA can have one private key. The private keys listed here are available in the <code>Decision Maker</code> and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds.</li> <li><code>connection_private_key_paths</code>: This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. <code>fetchai</code>, the <code>Multiplexer</code> can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance.</li> </ul> <p>It is the responsibility of the AEA's user to safeguard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes.</p> <p>Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption.</p>"},{"location":"aea-framework-documentation/core-components-2/#identity","title":"Identity","text":"<p>The <code>Identity</code> is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name.</p> <p>The identity can be accessed in a <code>Skill</code> via the <code>AgentContext</code>.</p>"},{"location":"aea-framework-documentation/core-components-2/#optional-components-used-by-aeas","title":"Optional Components Used by AEAs","text":""},{"location":"aea-framework-documentation/core-components-2/#contracts","title":"Contracts","text":"<p><code>Contracts</code> wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the <code>Skills</code>.</p> <p><code>Contracts</code> usually contain the logic to create contract transactions and make contract calls.</p> <p><code>Contracts</code> can be added as packages. For more details on <code>Contracts</code> also read the <code>Contract</code> guide here.</p>"},{"location":"aea-framework-documentation/core-components-2/#putting-it-together","title":"Putting it Together","text":"<p>Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA:</p> <p></p>"},{"location":"aea-framework-documentation/core-components-2/#next-steps","title":"Next Steps","text":""},{"location":"aea-framework-documentation/core-components-2/#recommended","title":"Recommended","text":"<p>We recommend you continue with the next step in the 'Getting Started' series:</p> <ul> <li>How AEAs talk to each other - Interaction protocols</li> </ul>"},{"location":"aea-framework-documentation/core-components-2/#relevant-deep-dives","title":"Relevant Deep-Dives","text":"<p>Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the <code>DecisionMaker</code> in the following section:</p> <ul> <li>Decision Maker</li> </ul> <p>Understanding <code>Contracts</code> is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the <code>Contracts</code> agents use in the following section:</p> <ul> <li>Contracts</li> </ul>"},{"location":"aea-framework-documentation/core-components/","title":"Core Components","text":"<p>AEAs can be made from various components, much like legos, and these components can be of differing types. Below are some of the more important types of components an agent can have.   </p>"},{"location":"aea-framework-documentation/core-components/#skill","title":"Skill","text":"<p>A Skill is an isolated, self-contained, (and preferably atomic) functionality that AEAs can take on board to expand their capability. Skills contain the proactive and reactive behaviour that ultimately makes it possible for an AEA to deliver economic value to its owner.  </p> <p>A Skill encapsulates implementations of three base classes <code>Handler</code>, <code>Behaviour</code>, <code>Model</code>, and is closely related with <code>Task</code>:</p> <ul> <li>Handler: Handlers implement AEAs' reactive behaviour. If an AEA understands a protocol referenced in a received <code>Envelope</code>, this envelope is sent to the corresponding handler which executes the AEA's reaction to this message.</li> <li>Behaviour: Behaviours implement AEAs' proactiveness, encapsulating actions which further an AEA's goals, and are initiated by internals of the AEA rather than external events. </li> <li>Model: Encapsulate arbitrary objects and is made available to all components of the skill.</li> <li>Task: Tasks encapsulate background work internal to the AEA. </li> </ul> <p>A skill can read (parts of) an AEA's state and propose actions to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. </p> <p>For instance, an AEA which is trading goods, could subscribe to more than one skill, where each corresponds to a different trading strategy.</p> <p>The framework places no limits on the complexity of <code>Skills</code>. They can implement simple (e.g. if-this-then-that) logic or be complex (e.g. a deep learning model or reinforcement learning agent).</p> <p>The framework provides one default <code>error</code> skill. Additional <code>Skills</code> can be added as packages. For more details on skills, head over to the  <code>Skill</code> guide .</p>"},{"location":"aea-framework-documentation/core-components/#protocol","title":"Protocol","text":"<p>A Protocol defines the structure and nature of an interaction that can happen between agents, or between components of an agent. You can think of a protocol as the language that two agents speak and a skill for this protocol as a particular way of speaking this language. From a game-theoretic viewpoint, a protocol defines the rules of a game and a skill for this protocol defines a particular strategy for playing this game. </p> <p>Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include:</p> <ul> <li><code>Messages</code>: defining the syntax of messages.</li> <li><code>Serialization</code>: defining how a message is encoded for transport.</li> <li><code>Dialogues</code>: defines rules over sequences of messages.</li> </ul> <p>The framework provides one <code>default</code> protocol. This protocol provides a bare-bones implementation which includes a <code>DefaultMessage</code>  class and associated <code>DefaultSerializer</code> and <code>DefaultDialogue</code> classes.</p> <p>Additional protocols for new types of interactions, can be added as packages. For more details on protocols, you can read the protocol guide. To learn how you can easily automate protocol definition, head to the guide for the protocol generator.</p> <p>Protocol specific messages, wrapped in <code>Envelopes</code>, are sent and received to other agents, agent components and services via Connections.</p>"},{"location":"aea-framework-documentation/core-components/#connection","title":"Connection","text":"<p>Connections act as interfaces between an agent and the outside world. As such, a connection allows the agent to communicate with some entity outside of it, for example, another agent, a traditional HTTP server, a database, a reinforcement learning training environment, a blockchain, etc.</p> <p>Where necessary, a Connection is responsible for translating between the framework specific <code>Envelope</code> with its contained message and the external service or third-party protocol (e.g. HTTP).</p> <p>The framework provides one default <code>stub</code> connection. It implements an I/O reader and writer to send messages to the agent from a local file.</p> <p>Additional connections can be added as packages. For more details on <code>Connections</code> read the <code>Connection</code> guide.</p>"},{"location":"aea-framework-documentation/debug/","title":"Debugging","text":"<p>There are multiple ways in which to configure your AEA for debugging during development. We focus on the standard Python approach here.</p>"},{"location":"aea-framework-documentation/debug/#using-pdb-stdlib","title":"Using <code>pdb</code> stdlib","text":"<p>You can add a debugger anywhere in your code:</p> <pre><code>import pdb; pdb.set_trace()\n</code></pre> <p>Then simply run you AEA with the <code>--skip-consistency-check</code> mode:</p> <pre><code>aea -s run\n</code></pre> <p>For more guidance on how to use <code>pdb</code> check out the documentation.</p>"},{"location":"aea-framework-documentation/debug/#using-an-ide","title":"Using an IDE","text":"<ul> <li>For VSCode modify the <code>launch.json</code> to include the following information:</li> </ul> <pre><code>{\n\"version\": \"0.2.0\",\n\"configurations\": [\n{\n\"name\": \"aea run\",\n\"type\": \"python\",\n\"request\": \"launch\",\n\"program\": \"PATH_TO_VIRTUAL_ENV/bin/aea\",\n\"args\": [\"-v\",\"DEBUG\",\"--skip-consistency-check\",\"run\"],\n\"cwd\": \"CWD\",\n\"console\": \"integratedTerminal\"\n}\n]\n}\n</code></pre> <p>where <code>PATH_TO_VIRTUAL_ENV</code> should be replaced with the path to the virtual environment and <code>CWD</code> with the working directory for the agent to debug (where the <code>aea-config.yaml</code> file is).</p>"},{"location":"aea-framework-documentation/decision-maker-transaction/","title":"Create Decision-Maker Transaction","text":"<p>This guide can be considered as a part 2 of the the stand-alone transaction demo. The main difference is that now we are going to use the decision-maker to sign the transaction.</p> <p>First, import the libraries and the set the constant values. (Get the <code>packages</code> directory from the AEA repository <code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages</code>.)</p> <pre><code>import logging\nimport time\nfrom threading import Thread\nfrom typing import Optional, cast\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.aea_builder import AEABuilder\nfrom aea.configurations.base import PublicId, SkillConfig\nfrom aea.crypto.helpers import create_private_key\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.crypto.wallet import Wallet\nfrom aea.helpers.transaction.base import RawTransaction, Terms\nfrom aea.identity.base import Identity\nfrom aea.protocols.base import Address, Message\nfrom aea.protocols.dialogue.base import Dialogue\nfrom aea.skills.base import Handler, Model, Skill, SkillContext\nfrom packages.fetchai.protocols.signing.dialogues import SigningDialogue\nfrom packages.fetchai.protocols.signing.dialogues import (\nSigningDialogues as BaseSigningDialogues,\n)\nfrom packages.fetchai.protocols.signing.message import SigningMessage\nfrom tests.conftest import get_wealth_if_needed\nlogger = logging.getLogger(\"aea\")\nlogging.basicConfig(level=logging.INFO)\nFETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\"\nFETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\"\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker-transaction/#create-a-private-key-and-an-aea","title":"Create a Private Key and an AEA","text":"<p>To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create an AEA with the builder, providing it with a private key we generate first.</p> <pre><code>    # Create a private key\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_1\n)\n# Instantiate the builder and build the AEA\n# By default, the default protocol, error skill and stub connection are added\nbuilder = AEABuilder()\nbuilder.set_name(\"my_aea\")\nbuilder.add_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE_1)\n# Create our AEA\nmy_aea = builder.build()\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker-transaction/#add-a-simple-skill","title":"Add a Simple Skill","text":"<p>Add a simple skill with a signing handler and the signing dialogues.</p> <pre><code>    # add a simple skill with handler\nskill_context = SkillContext(my_aea.context)\nskill_config = SkillConfig(name=\"simple_skill\", author=\"fetchai\", version=\"0.1.0\")\nsigning_handler = SigningHandler(\nskill_context=skill_context, name=\"signing_handler\"\n)\nsigning_dialogues_model = SigningDialogues(\nskill_context=skill_context,\nname=\"signing_dialogues\",\nself_address=str(skill_config.public_id),\n)\nsimple_skill = Skill(\nskill_config,\nskill_context,\nhandlers={signing_handler.name: signing_handler},\nmodels={signing_dialogues_model.name: signing_dialogues_model},\n)\nmy_aea.resources.add_skill(simple_skill)\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker-transaction/#create-a-second-identity","title":"Create a Second Identity","text":"<pre><code>    # create a second identity\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_2\n)\ncounterparty_wallet = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_2})\nget_wealth_if_needed(counterparty_wallet.addresses[\"fetchai\"])\ncounterparty_identity = Identity(\nname=\"counterparty_aea\",\naddresses=counterparty_wallet.addresses,\npublic_keys=counterparty_wallet.public_keys,\ndefault_address_key=FetchAICrypto.identifier,\n)\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker-transaction/#create-the-signing-message","title":"Create the Signing Message","text":"<p>Next, we are creating the signing message and sending it to the decision-maker.</p> <pre><code>    # create signing message for decision maker to sign\nterms = Terms(\nledger_id=FetchAICrypto.identifier,\nsender_address=my_aea.identity.address,\ncounterparty_address=counterparty_identity.address,\namount_by_currency_id={\"FET\": -1},\nquantities_by_good_id={\"some_service\": 1},\nnonce=\"some_nonce\",\nfee_by_currency_id={\"FET\": 0},\n)\nget_wealth_if_needed(terms.sender_address)\nsigning_dialogues = cast(SigningDialogues, skill_context.signing_dialogues)\nstub_transaction = LedgerApis.get_transfer_transaction(\nterms.ledger_id,\nterms.sender_address,\nterms.counterparty_address,\nterms.sender_payable_amount,\nterms.sender_fee,\nterms.nonce,\n)\nsigning_msg = SigningMessage(\nperformative=SigningMessage.Performative.SIGN_TRANSACTION,\ndialogue_reference=signing_dialogues.new_self_initiated_dialogue_reference(),\nraw_transaction=RawTransaction(FetchAICrypto.identifier, stub_transaction),\nterms=terms,\n)\nsigning_dialogue = cast(\nOptional[SigningDialogue],\nsigning_dialogues.create_with_message(\"decision_maker\", signing_msg),\n)\nassert signing_dialogue is not None\nmy_aea.context.decision_maker_message_queue.put_nowait(signing_msg)\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker-transaction/#run-the-agent","title":"Run the Agent","text":"<p>Finally, we are running the agent and expect the signed transaction to be printed in the terminal.</p> <pre><code>    # Set the AEA running in a different thread\ntry:\nlogger.info(\"STARTING AEA NOW!\")\nt = Thread(target=my_aea.start)\nt.start()\n# Let it run long enough to interact with the decision maker\ntime.sleep(1)\nfinally:\n# Shut down the AEA\nlogger.info(\"STOPPING AEA NOW!\")\nmy_aea.stop()\nt.join()\n</code></pre> <p>After the completion of the signing, we get the signed transaction.</p>"},{"location":"aea-framework-documentation/decision-maker-transaction/#more-details","title":"More Details","text":"<p>To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages.</p> <pre><code>class SigningDialogues(Model, BaseSigningDialogues):\n\"\"\"Signing dialogues model.\"\"\"\ndef __init__(self, self_address: Address, **kwargs) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :return: None\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; Dialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn SigningDialogue.Role.SKILL\nBaseSigningDialogues.__init__(\nself,\nself_address=self_address,\nrole_from_first_message=role_from_first_message,\n)\nclass SigningHandler(Handler):\n\"\"\"Implement the signing handler.\"\"\"\nSUPPORTED_PROTOCOL = SigningMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        :return: None\n        \"\"\"\nsigning_msg = cast(SigningMessage, message)\n# recover dialogue\nsigning_dialogues = cast(SigningDialogues, self.context.signing_dialogues)\nsigning_dialogue = cast(\nOptional[SigningDialogue], signing_dialogues.update(signing_msg)\n)\nif signing_dialogue is None:\nself._handle_unidentified_dialogue(signing_msg)\nreturn\n# handle message\nif signing_msg.performative is SigningMessage.Performative.SIGNED_TRANSACTION:\nself._handle_signed_transaction(signing_msg, signing_dialogue)\nelif signing_msg.performative is SigningMessage.Performative.ERROR:\nself._handle_error(signing_msg, signing_dialogue)\nelse:\nself._handle_invalid(signing_msg, signing_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Implement the handler teardown.\n        :return: None\n        \"\"\"\ndef _handle_unidentified_dialogue(self, signing_msg: SigningMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid signing message={}, unidentified dialogue.\".format(\nsigning_msg\n)\n)\ndef _handle_signed_transaction(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle a signing message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\"transaction signing was successful.\")\nlogger.info(signing_msg.signed_transaction)\ndef _handle_error(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"transaction signing was not successful. Error_code={} in dialogue={}\".format(\nsigning_msg.error_code, signing_dialogue\n)\n)\ndef _handle_invalid(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle signing message of performative={} in dialogue={}.\".format(\nsigning_msg.performative, signing_dialogue\n)\n)\n</code></pre> <p>You can find the full code for this example below:</p> Transaction via decision-maker full code: <pre><code>import logging\nimport time\nfrom threading import Thread\nfrom typing import Optional, cast\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.aea_builder import AEABuilder\nfrom aea.configurations.base import PublicId, SkillConfig\nfrom aea.crypto.helpers import create_private_key\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.crypto.wallet import Wallet\nfrom aea.helpers.transaction.base import RawTransaction, Terms\nfrom aea.identity.base import Identity\nfrom aea.protocols.base import Address, Message\nfrom aea.protocols.dialogue.base import Dialogue\nfrom aea.skills.base import Handler, Model, Skill, SkillContext\nfrom packages.fetchai.protocols.signing.dialogues import SigningDialogue\nfrom packages.fetchai.protocols.signing.dialogues import (\nSigningDialogues as BaseSigningDialogues,\n)\nfrom packages.fetchai.protocols.signing.message import SigningMessage\nfrom tests.conftest import get_wealth_if_needed\nlogger = logging.getLogger(\"aea\")\nlogging.basicConfig(level=logging.INFO)\nFETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\"\nFETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\"\ndef run():\n\"\"\"Run demo.\"\"\"\n# Create a private key\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_1\n)\n# Instantiate the builder and build the AEA\n# By default, the default protocol, error skill and stub connection are added\nbuilder = AEABuilder()\nbuilder.set_name(\"my_aea\")\nbuilder.add_private_key(FetchAICrypto.identifier, FETCHAI_PRIVATE_KEY_FILE_1)\n# Create our AEA\nmy_aea = builder.build()\n# add a simple skill with handler\nskill_context = SkillContext(my_aea.context)\nskill_config = SkillConfig(name=\"simple_skill\", author=\"fetchai\", version=\"0.1.0\")\nsigning_handler = SigningHandler(\nskill_context=skill_context, name=\"signing_handler\"\n)\nsigning_dialogues_model = SigningDialogues(\nskill_context=skill_context,\nname=\"signing_dialogues\",\nself_address=str(skill_config.public_id),\n)\nsimple_skill = Skill(\nskill_config,\nskill_context,\nhandlers={signing_handler.name: signing_handler},\nmodels={signing_dialogues_model.name: signing_dialogues_model},\n)\nmy_aea.resources.add_skill(simple_skill)\n# create a second identity\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_2\n)\ncounterparty_wallet = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_2})\nget_wealth_if_needed(counterparty_wallet.addresses[\"fetchai\"])\ncounterparty_identity = Identity(\nname=\"counterparty_aea\",\naddresses=counterparty_wallet.addresses,\npublic_keys=counterparty_wallet.public_keys,\ndefault_address_key=FetchAICrypto.identifier,\n)\n# create signing message for decision maker to sign\nterms = Terms(\nledger_id=FetchAICrypto.identifier,\nsender_address=my_aea.identity.address,\ncounterparty_address=counterparty_identity.address,\namount_by_currency_id={\"FET\": -1},\nquantities_by_good_id={\"some_service\": 1},\nnonce=\"some_nonce\",\nfee_by_currency_id={\"FET\": 0},\n)\nget_wealth_if_needed(terms.sender_address)\nsigning_dialogues = cast(SigningDialogues, skill_context.signing_dialogues)\nstub_transaction = LedgerApis.get_transfer_transaction(\nterms.ledger_id,\nterms.sender_address,\nterms.counterparty_address,\nterms.sender_payable_amount,\nterms.sender_fee,\nterms.nonce,\n)\nsigning_msg = SigningMessage(\nperformative=SigningMessage.Performative.SIGN_TRANSACTION,\ndialogue_reference=signing_dialogues.new_self_initiated_dialogue_reference(),\nraw_transaction=RawTransaction(FetchAICrypto.identifier, stub_transaction),\nterms=terms,\n)\nsigning_dialogue = cast(\nOptional[SigningDialogue],\nsigning_dialogues.create_with_message(\"decision_maker\", signing_msg),\n)\nassert signing_dialogue is not None\nmy_aea.context.decision_maker_message_queue.put_nowait(signing_msg)\n# Set the AEA running in a different thread\ntry:\nlogger.info(\"STARTING AEA NOW!\")\nt = Thread(target=my_aea.start)\nt.start()\n# Let it run long enough to interact with the decision maker\ntime.sleep(1)\nfinally:\n# Shut down the AEA\nlogger.info(\"STOPPING AEA NOW!\")\nmy_aea.stop()\nt.join()\nclass SigningDialogues(Model, BaseSigningDialogues):\n\"\"\"Signing dialogues model.\"\"\"\ndef __init__(self, self_address: Address, **kwargs) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :return: None\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; Dialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn SigningDialogue.Role.SKILL\nBaseSigningDialogues.__init__(\nself,\nself_address=self_address,\nrole_from_first_message=role_from_first_message,\n)\nclass SigningHandler(Handler):\n\"\"\"Implement the signing handler.\"\"\"\nSUPPORTED_PROTOCOL = SigningMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        :return: None\n        \"\"\"\nsigning_msg = cast(SigningMessage, message)\n# recover dialogue\nsigning_dialogues = cast(SigningDialogues, self.context.signing_dialogues)\nsigning_dialogue = cast(\nOptional[SigningDialogue], signing_dialogues.update(signing_msg)\n)\nif signing_dialogue is None:\nself._handle_unidentified_dialogue(signing_msg)\nreturn\n# handle message\nif signing_msg.performative is SigningMessage.Performative.SIGNED_TRANSACTION:\nself._handle_signed_transaction(signing_msg, signing_dialogue)\nelif signing_msg.performative is SigningMessage.Performative.ERROR:\nself._handle_error(signing_msg, signing_dialogue)\nelse:\nself._handle_invalid(signing_msg, signing_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Implement the handler teardown.\n        :return: None\n        \"\"\"\ndef _handle_unidentified_dialogue(self, signing_msg: SigningMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid signing message={}, unidentified dialogue.\".format(\nsigning_msg\n)\n)\ndef _handle_signed_transaction(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle a signing message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\"transaction signing was successful.\")\nlogger.info(signing_msg.signed_transaction)\ndef _handle_error(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"transaction signing was not successful. Error_code={} in dialogue={}\".format(\nsigning_msg.error_code, signing_dialogue\n)\n)\ndef _handle_invalid(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle signing message of performative={} in dialogue={}.\".format(\nsigning_msg.performative, signing_dialogue\n)\n)\nif __name__ == \"__main__\":\nrun()\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker/","title":"Decision Maker","text":"<p>The <code>DecisionMaker</code> can be thought of like a wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the wallet's private keys.</p>"},{"location":"aea-framework-documentation/decision-maker/#interaction-with-skills","title":"Interaction with Skills","text":"<p>Skills communicate with the decision maker via <code>Messages</code>. At present, the decision maker processes messages of two protocols:</p> <ul> <li> <p><code>SigningMessage</code>: it is used by skills to propose a transaction to the decision-maker for signing.</p> </li> <li> <p><code>StateUpdateMessage</code>: it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place.</p> </li> </ul> <p>A message, say <code>msg</code>, is sent to the decision maker like so from any skill:</p> <pre><code>self.context.decision_maker_message_queue.put_nowait(msg)\n</code></pre> <p>The decision maker processes messages and can accept or reject them.</p> <p>To process <code>Messages</code> from the decision maker in a given skill you need to create a <code>Handler</code>, in particular a <code>SigningHandler</code> like so:</p> <pre><code>class SigningHandler(Handler):\nprotocol_id = SigningMessage.protocol_id\ndef handle(self, message: Message):\n\"\"\"\n        Handle a signing message.\n        :param message: the signing message from the decision maker.\n        \"\"\"\n# code to handle the message\n</code></pre>"},{"location":"aea-framework-documentation/decision-maker/#custom-decisionmaker","title":"Custom <code>DecisionMaker</code>","text":"<p>The framework implements a default <code>DecisionMakerHandler</code> and an advanced <code>DecisionMakerHandler</code>. You can also implement your own and mount it.</p> <p>No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the <code>aea-config.yaml</code> of your AEA (on page 1):</p> <pre><code>decision_maker_handler:\nconfig: {}\ndotted_path: \"aea.decision_maker.gop:DecisionMakerHandler\"\nfile_path: null\n</code></pre> <p>The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom <code>DecisionMakerHandler</code>:</p> <pre><code>aea scaffold decision-maker-handler\n</code></pre> <p>You can then implement your own custom logic to process messages and interact with the <code>Wallet</code>.</p> <p>Note</p> <p>For examples how to use these concepts have a look at the <code>tac_</code> skills. These functionalities are experimental and subject to change.</p>"},{"location":"aea-framework-documentation/defining-data-models/","title":"Defining Data Models","text":"<p>In this section, we explain how to define data models, an important component of the OEF Search &amp; Discovery. It allows agents to describe themselves and to discover the services/resources they are interested in.</p> <p>In a sentence, a <code>DataModel</code> is a set of <code>attributes</code>, and a <code>Description</code> of a service/resource is an assignment of those attributes.</p> <p>All you need to specify data models and descriptions (that is, instances of the data model) can be found in the <code>aea.helpers.search</code> module.</p>"},{"location":"aea-framework-documentation/defining-data-models/#attributes","title":"Attributes","text":"<p>At the lowest level of our data model language, we have the <code>Attribute</code>. An attribute is an abstract definition of a property.</p> <p>It is identified by a <code>name</code>, that must be unique in a given data model (that is, we can't have two attributes that share the same name).</p> <p>Every attribute has a <code>type</code>, that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes:</p> <ul> <li>strings</li> <li>integers</li> <li>booleans</li> <li>floats</li> <li>locations, i.e. instances of <code>Location</code> (pairs of (latitude, longitude))</li> </ul> <p>An attribute can be <code>optional</code>, in the sense that instantiation of the attribute is not mandatory by the instances of the data model.</p> <p>Finally, every attribute might have a <code>description</code> that explains the purpose of the attribute.</p> <p>Example: suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books:</p> <ul> <li>The <code>title</code></li> <li>The <code>author</code></li> <li>The <code>genre</code> (e.g. science fiction, horror)</li> <li>The <code>year of publication</code></li> <li>The <code>average rating</code> (average of the ratings between 0 and 5)</li> <li>The <code>ISBN</code> code</li> <li>If it can be sold as an e-book.</li> </ul> <p>For each of these fields, we can define an attribute by using <code>Attribute</code>:</p> <pre><code>from aea.helpers.search.models import Attribute, Location\nattr_title   = Attribute(\"title\", str, True, \"The title of the book.\")\nattr_author  = Attribute(\"author\", str, True, \"The author of the book.\")\nattr_genre   = Attribute(\"genre\", str, True, \"The genre of the book.\")\nattr_year    = Attribute(\"year\", int, True, \"The year of publication of the book.\")\nattr_avg_rat = Attribute(\"average_rating\",  float,    False, \"The average rating of the book.\")\nattr_isbn    = Attribute(\"ISBN\", str, True, \"The ISBN.\")\nattr_ebook   = Attribute(\"ebook_available\", bool, False, \"If the book can be sold as an e-book.\")\nattr_bookshop = Attribute(\"bookshop_pos\", Location, False, \"The location of the bookshop where you can find the book\")\n</code></pre> <p>Let's focus on the parameters of the <code>Attribute</code> constructor:</p> <ol> <li>the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it.</li> <li>the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume.    E.g. the attribute <code>year</code> can only be an integer, whereas the <code>average_rating</code> can only be a floating-point number.    The supported types are: <code>str</code>, <code>int</code>, <code>bool</code>, <code>float</code> and <code>Location</code>.</li> <li>the third one is a boolean that specifies whether the attribute is always required or it can be omitted. For example, we might not be able to specify the <code>ebook_available</code> attribute, maybe because it's not applicable to some kind of books.</li> <li>the fourth parameter is the description, that is a short description of the purpose of the attribute.</li> </ol>"},{"location":"aea-framework-documentation/defining-data-models/#data-models","title":"Data Models","text":"<p>A data model is just a set of attributes. The class that implements the data model is <code>DataModel</code>.</p> <p>Example: let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way:</p> <pre><code>from aea.helpers.search.models import DataModel\nbook_model = DataModel(\"book\", [\nattr_title,\nattr_author,\nattr_genre,\nattr_year,\nattr_avg_rat,\nattr_isbn,\nattr_ebook,\nattr_bookshop\n], \"A data model to describe books.\")\n</code></pre> <p>A <code>DataModel</code> requires:</p> <ol> <li>a name (in the example the name is <code>\"book\"</code>) used to refer to the data model.</li> <li>a list of attributes, that constitutes the abstract data model.</li> <li>an (optional) description about the purpose of the data model.</li> </ol>"},{"location":"aea-framework-documentation/defining-data-models/#description","title":"Description","text":"<p>A <code>Description</code> is just an instantiation of a data model. That is, we specify a value to every attribute belonging to the data model we are interested in.</p> <p>The class that implements the description is <code>Description</code>.</p> <p>Example: now we have all we need to create a little catalogue about our books:</p> <pre><code>from aea.helpers.search.models import Description\nIt = Description({\n\"title\" :           \"It\",\n\"author\":           \"Stephen King\",\n\"genre\":            \"horror\",\n\"year\":             1986,\n\"average_rating\":   4.5,\n\"ISBN\":             \"0-670-81302-8\",\n\"ebook_available\":  True,\n\"bookshop_pos\":     Location(52.2057092, 0.1183431)\n}, book_model)\n_1984 = Description({\n\"title\" :           \"1984\",\n\"author\":           \"George Orwell\",\n\"genre\":            \"novel\",\n\"year\":             1949,\n\"ISBN\":             \"978-0451524935\",\n\"ebook_available\":  False\n}, book_model)\n</code></pre> <p>We defined the descriptions for two books, namely <code>It</code> and <code>_1984</code>, that refers to a data model.</p> <p>The attributes are instantiated with a dictionary that has:</p> <ul> <li>as keys, the name of the attributes.</li> <li>as values, the values associated with the attributes.</li> </ul> <p>Notice that in the latter book we omitted the <code>average_rating</code> field. We are allowed to do that because of the <code>average_rating</code> attribute is not mandatory.</p>"},{"location":"aea-framework-documentation/demos/","title":"Demos","text":"<p>We provide demo guides for multiple use-cases, each one involving several AEAs interacting in a different scenario.</p> <p>These demos serve to highlight the concept of AEAs as well as provide inspiration for developers. Demos should not be taken as production ready software, although every care is taken to fix bugs when reported.</p> <p>Demos are alphabetically sorted, we recommend you start with the weather skills demo.</p>"},{"location":"aea-framework-documentation/deployment/","title":"Deployment","text":"<p>The easiest way to run an AEA is using your development environment.</p> <p>If you would like to run an AEA from a browser you can use Google Colab. This gist can be opened in Colab and implements the quick start.</p> <p>For deployment, we recommend you use Docker.</p>"},{"location":"aea-framework-documentation/deployment/#deployment-using-a-docker-image","title":"Deployment using a Docker Image","text":"<p>First, we fetch a directory containing a Dockerfile and some dependencies:</p> <pre><code>svn export https://github.com/fetchai/agents-aea/branches/main/deploy-image\ncd deploy-image\n</code></pre> <p>Then follow the <code>README.md</code> contained in the folder.</p>"},{"location":"aea-framework-documentation/deployment/#deployment-using-kubernetes","title":"Deployment using Kubernetes","text":"<p>For an example of how to use Kubernetes navigate to our TAC deployment example.</p>"},{"location":"aea-framework-documentation/design-principles/","title":"Design Principles","text":"<p>The AEA framework development is guided by the following 8 principles:</p> <ul> <li>Accessibility: ease of use.</li> <li>Modularity: encourages module creation, sharing and reuse.</li> <li>Openness: easily extensible with third-party libraries.</li> <li>Conciseness: conceptually simple.</li> <li>Value-driven: drives immediate value.</li> <li>Low entry barriers: leverages existing programming languages and web protocols.</li> <li>Safety: safe for the user (economically speaking).</li> <li>Goal-alignment: seamless facilitation of users' preferences and goals.</li> </ul>"},{"location":"aea-framework-documentation/development-setup/","title":"Development Setup","text":"<p>An AEA consists of packages . When developing, it helps to be able to save packages in a local package registry, rather than pushing them to remote registry. This guide helps you set up a local package registry and configure the working directory for development.</p> <p>There are two ways to write code for an AEA:</p> <ol> <li> <p>independent of a concrete AEA project, write individual packages</p> </li> <li> <p>from within an AEA project, write packages for that AEA</p> </li> </ol>"},{"location":"aea-framework-documentation/development-setup/#approach-1","title":"Approach 1","text":"<p>To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps:</p> <ul> <li>Either, manually:<ul> <li>Ensure you start with an empty working directory to avoid any unnecessary side effects.</li> <li>In your working directory, create an empty folder called <code>packages</code>. This folder will act as the local registry for packages.</li> <li>In your working directory, create a <code>.env</code> file with the constant <code>PYTHONPATH=$PYTHONPATH:path_to_packages_dir</code> where <code>path_to_packages_dir</code> is the path to the <code>packages</code> folder in your working directory.</li> </ul> </li> <li>Or, automated:<ul> <li>Fork our template repo for AEA development. Then clone it to your machine.</li> </ul> </li> <li>Depending on your editor, you might take further steps:<ul> <li>VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for <code>python.envFile</code> which specifies the path to a file containing environment variable definitions. The default is set to <code>\"python.envFile\": \"${workspaceFolder}/.env\"</code>. Provide the path to the <code>.env</code> file in the above settings. In the <code>.env</code> file, add the <code>PYTHONPATH</code> constant defined above. Then close VS Code and re-open it for the settings to take effect.</li> </ul> </li> </ul> <p>After developing a package, you can add it to an AEA project in the working directory (e.g. <code>aea create AGENT_NAME &amp;&amp; cd AGENT_NAME &amp;&amp; aea add --local PACKAGE_TYPE PUBLIC_ID</code> will create a new AEA project <code>AGENT_NAME</code> and add the package of type <code>PACKAGE_TYPE</code> with public id <code>PUBLIC_ID</code> to it.)</p>"},{"location":"aea-framework-documentation/development-setup/#approach-2","title":"Approach 2","text":"<p>It is also possible to develop directly in an AEA project:</p> <ul> <li>Prepare a directory (henceforth working directory) for development.</li> <li>Create a new project <code>aea create AGENT_NAME &amp;&amp; cd AGENT_NAME</code></li> <li>Scaffold a new package <code>aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME</code>. This will create the package scaffold under the directory <code>{PACKAGE_TYPE}s</code> and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE.</li> <li>In your working directory, create a <code>.env</code> file with the constant <code>PYTHONPATH=$PYTHONPATH:path_to_project_dir</code> where <code>path_to_project_dir</code> is the path to the AEA project contained in your working directory.</li> <li>Depending on your editor, you might take further steps:<ul> <li>VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for <code>python.envFile</code> which specifies the path to a file containing environment variable definitions. The default is set to <code>\"python.envFile\": \"${workspaceFolder}/.env\"</code>. Provide the path to the <code>.env</code> file in the above settings. In the <code>.env</code> file, add the <code>PYTHONPATH</code> constant defined above. Then close VS Code and re-open it for the settings to take effect.</li> </ul> </li> </ul>"},{"location":"aea-framework-documentation/development-setup/#general-advice","title":"General Advice","text":"<p>This advice partially overlaps with the previous two sections:</p> <ul> <li>When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the <code>packages</code> directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag <code>--local</code> or <code>--remote</code> to only point to remote registry (see here for more details on CLI commands).</li> <li>When working on an AEA, it may help to provide a symbolic link to the <code>packages</code> directory, so that the import paths are detected by your editor. Simply create an empty file with <code>touch packages</code> in your AEA project, then create a symbolic link to the <code>packages</code> directory with <code>ln -s ../packages packages</code>.</li> <li>Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with <code>touch packages</code> in your AEA project, then create a symbolic link to <code>ln -s vendor packages</code>.</li> </ul>"},{"location":"aea-framework-documentation/diagram/","title":"Architectural Diagram","text":"<p>The framework has two distinctive parts.</p> <ul> <li>A core that is developed by the Fetch.ai team as well as external contributors.</li> <li>Extensions (also known as packages) developed by any developer.</li> </ul> <p>Currently, the framework supports four types of packages which can be added to the core as modules:</p> <ul> <li>Skills encapsulate logic that deliver economic value to the AEA. Skills are the main focus of the framework's extensibility.</li> <li>Protocols define the structure of agent-to-agent and component-to-component interactions (messages and dialogues) for agents.</li> <li>Connections provide interfaces for the agent to connect with the outside world. They wrap SDKs or APIs and provide interfaces to networks, ledgers and other services.</li> <li>Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers.</li> </ul> <p>The following figure illustrates the framework's architecture:</p> <p></p> <p>The execution is broken down in more detail below:</p> <p></p> <p>The agent operation breaks down into three parts:</p> <ul> <li>Setup: calls the <code>setup()</code> method of all registered resources</li> <li>Operation:<ul> <li>Agent loop (Thread 1 - Asynchronous agent loop):<ul> <li><code>react()</code>: this function grabs all Envelopes waiting in the <code>InBox</code> queue and calls the <code>handle()</code> method on the Handler(s) responsible for them.</li> <li><code>act()</code>: this function calls the <code>act()</code> method of all registered Behaviours.</li> <li><code>update()</code>: this function enqueues scheduled tasks for execution with the <code>TaskManager</code> and executes the decision maker.</li> </ul> </li> <li>Task loop (Thread 2- Synchronous): executes available tasks</li> <li>Decision maker loop (Thread 3- Synchronous): processes internal messages</li> <li>Multiplexer (Thread 4 - Asynchronous event loop): processes incoming and outgoing messages across several connections asynchronously.</li> </ul> </li> <li>Teardown: calls the <code>teardown()</code> method of all registered resources</li> </ul> <p>To prevent a developer from blocking the main loop with custom skill code, an execution time limit is  applied to every <code>Behaviour.act</code> and <code>Handler.handle</code> call.</p> <p>By default, the execution limit is set to <code>0</code> seconds, which disables the feature. You can set the limit to a strictly positive value (e.g. <code>0.1</code> seconds) to test your AEA for production readiness. If the <code>act</code> or <code>handle</code> time exceed this limit, the call will be terminated.</p> <p>An appropriate message is added to the logs in the case of some code execution being terminated.</p>"},{"location":"aea-framework-documentation/ecosystem/","title":"Agent Ecosystem","text":"<p>AEAs are situated within a larger ecosystem comprised of various other systems and technology layers.</p> <p></p>"},{"location":"aea-framework-documentation/ecosystem/#agent-communication-network-acn","title":"Agent Communication Network (ACN)","text":"<p>ACN is a peer-to-peer communication network for agents. It allows AEAs to send and receive envelopes between each other.</p> <p>The implementation builds on the open-source libp2p library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses.</p> <p>Agents can receive messages from other agents if they are both connected to the ACN (see here for an example).</p>"},{"location":"aea-framework-documentation/ecosystem/#search-and-discovery","title":"Search and Discovery","text":"<p>An sOEF node allows agents to discover each other. In particular, agents can register themselves and the services they offer, and can search for agents who offer specific services.</p> <p>For two agents to be able to find each other, at least one must register itself on the sOEF and the other must query the sOEF node for it. Detailed documentation is provided here.</p>"},{"location":"aea-framework-documentation/ecosystem/#ledgers","title":"Ledgers","text":"<p>Ledgers enable AEAs to store transactions, for example involving the transfer of funds to each other, or the execution of smart contracts. They optionally ensure the truth and integrity of agent to agent interactions.</p> <p>Although a ledger can, in principle, be used to store structured data (e.g. training data in a machine learning model), in most cases the resulting costs and privacy implications do not make this sustainable. Instead, usually only references to structured data - often in the form of hashes - are stored on a ledger, and the actual data is stored off-chain.</p> <p>The Python implementation of the AEA Framework currently integrates with three ledgers:</p> <ul> <li>Fetch.ai ledger</li> <li>Ethereum ledger</li> <li>Cosmos ledger</li> </ul> <p>Furthermore, the framework makes it straightforward for any developer to create a ledger plugin, adding support for another ledger.</p>"},{"location":"aea-framework-documentation/ecosystem/#aeas-as-second-layer-technology","title":"AEAs as Second Layer Technology","text":"<p>The following presentation discusses how AEAs can be seen as second layer technology to ledgers.</p>"},{"location":"aea-framework-documentation/erc1155-skills/","title":"Contract Deploy and Interact","text":"<p>The AEA <code>erc1155_deploy</code> and <code>erc1155_client</code> skills demonstrate an interaction between two AEAs which use a smart contract.</p> <ul> <li>The <code>erc1155_deploy</code> skill deploys the smart contract, creates and mints items.</li> <li>The <code>erc1155_client</code> skill signs a transaction to complete a trustless trade with its counterparty.</li> </ul>"},{"location":"aea-framework-documentation/erc1155-skills/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/erc1155-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/erc1155-skills/#discussion","title":"Discussion","text":"<p>The scope of this guide is demonstrating how you can deploy a smart contract and interact with it using AEAs. In this specific demo, you create two AEAs. One deploys and creates tokens inside a smart contract. The other signs a transaction to complete an atomic swap. The smart contract used is ERC1155 with a one-step atomic swap functionality. This means the trade between the two AEAs can be trustless.</p> <p>Note</p> <p>This is only for demonstrative purposes since the AEA deploying the contract also has the ability to mint tokens. In reality, the transfer of tokens from the AEA signing the transaction is worthless.</p>"},{"location":"aea-framework-documentation/erc1155-skills/#demo","title":"Demo","text":""},{"location":"aea-framework-documentation/erc1155-skills/#create-the-deployer-aea","title":"Create the Deployer AEA","text":"<p>Fetch the AEA that will deploy the contract:</p> <pre><code>aea fetch fetchai/erc1155_deployer:0.34.5\ncd erc1155_deployer\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>Create the AEA that will deploy the contract.</p> <pre><code>aea create erc1155_deployer\ncd erc1155_deployer\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/erc1155_deploy:0.31.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-cosmos\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'\naea install\naea build\n</code></pre> <p>And change the default ledger:</p> <pre><code>aea config set agent.default_ledger ethereum\n</code></pre> <p>Create a private key for the deployer AEA and add it for Ethereum use:</p> <pre><code>aea generate-key ethereum\naea add-key ethereum ethereum_private_key.txt\n</code></pre> <p>Create a private key for the P2P connection:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/erc1155-skills/#create-the-client-aea","title":"Create the Client AEA","text":"<p>In another terminal, fetch the client AEA which will receive some tokens from the deployer.</p> <pre><code>aea fetch fetchai/erc1155_client:0.34.5\ncd erc1155_client\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>Create the AEA that will get some tokens from the deployer.</p> <pre><code>aea create erc1155_client\ncd erc1155_client\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/erc1155_client:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-cosmos\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'\naea install\naea build\n</code></pre> <p>And change the default ledger:</p> <pre><code>aea config set agent.default_ledger ethereum\n</code></pre> <p>Create a private key for the client AEA and add it for Ethereum use:</p> <pre><code>aea generate-key ethereum\naea add-key ethereum ethereum_private_key.txt\n</code></pre> <p>Create a private key for the P2P connection:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/erc1155-skills/#run-ganache","title":"Run Ganache","text":"<p>Execute the following command to run Ganache:</p> <pre><code>docker run -p 8545:8545 trufflesuite/ganache-cli:latest --verbose --gasPrice=0 --gasLimit=0x1fffffffffffff --account=\"$(cat erc1155_deployer/ethereum_private_key.txt),1000000000000000000000\" --account=\"$(cat erc1155_client/ethereum_private_key.txt),1000000000000000000000\"\n</code></pre> <p>Wait some time for the wealth creation to be mined on Ropsten.</p> <p>Check your wealth:</p> <pre><code>aea get-wealth ethereum\n</code></pre> <p>You should get <code>1000000000000000000000</code>.</p> <p>Note</p> <p>If no wealth appears after a while, then try funding the private key directly using a web faucet.</p>"},{"location":"aea-framework-documentation/erc1155-skills/#update-soef-configurations-for-both-aeas","title":"Update SOEF Configurations for both AEAs","text":"<p>Update the SOEF configuration in both AEA projects:</p> <pre><code>aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum\n</code></pre>"},{"location":"aea-framework-documentation/erc1155-skills/#run-the-aeas","title":"Run the AEAs","text":"<p>First, run the deployer AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of this address.</p> <p>Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address. The output will be something like <code>/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm2JPsUX1Su59YVDXJQizYkNSe8JCusqRpLeeTbvY76fE5</code>.</p> <p>This is the entry peer address for the local agent communication network created by the deployer.</p> <p>This AEA then performs the following steps:</p> <ul> <li>deploys the smart contract</li> <li>creates a batch of items in the smart contract</li> <li>mints a batch of items in the smart contract</li> </ul> <p>At some point you should see the log output:</p> <pre><code>registering service on SOEF.\n</code></pre> <p>At this point, configure the client AEA to connect to the same local ACN created by the deployer by running the following command in the client's terminal, replacing <code>SOME_ADDRESS</code> with the value you noted above:</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Then, run the client AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that after discovery, the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network.</p> <p>Note</p> <p>Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message <code>Cannot verify whether transaction improves utility. Assuming it does!</code> can be ignored.</p>"},{"location":"aea-framework-documentation/erc1155-skills/#delete-the-aeas","title":"Delete the AEAs","text":"<p>When you're done, stop the agents (<code>CTRL+C</code>), go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete erc1155_deployer\naea delete erc1155_client\n</code></pre>"},{"location":"aea-framework-documentation/erc1155-skills/#communication","title":"Communication","text":"<p>This diagram shows the communication between the various entities in this interaction:</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Erc1155_contract\n        participant Client_AEA\n        participant Deployer_AEA\n        participant Blockchain\n\n        activate Search\n        activate Erc1155_contract\n        activate Client_AEA\n        activate Deployer_AEA\n        activate Blockchain\n\n        Deployer_AEA-&gt;&gt;Blockchain: deployes smart contract\n        Deployer_AEA-&gt;&gt;ERC1155_contract: creates tokens\n        Deployer_AEA-&gt;&gt;ERC1155_contract: mint tokens       \n        Deployer_AEA-&gt;&gt;Search: register_service\n        Client_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Client_AEA: list_of_agents\n        Client_AEA-&gt;&gt;Deployer_AEA: call_for_proposal\n        Deployer_AEA-&gt;&gt;Client_AEA: inform_message\n        Client_AEA-&gt;&gt;Deployer_AEA: signature\n        Deployer_AEA-&gt;&gt;Blockchain: send_transaction\n        Client_AEA-&gt;&gt;ERC1155_contract: asks_balance\n\n        deactivate Search\n        deactivate Erc1155_contract\n        deactivate Client_AEA\n        deactivate Deployer_AEA\n        deactivate Blockchain</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/","title":"Trade between Two AEAs","text":"<p>This guide is a step-by-step introduction to building AEAs that advertise their static and dynamic data, find other AEAs with required data, negotiate terms of trade, and carry out trades via ledger transactions.</p> <p>If you simply want to run the resulting AEAs go here.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#dependencies-required","title":"Dependencies (Required)","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#reference-code-optional","title":"Reference Code (Optional)","text":"<p>This step-by-step guide goes through the creation of two AEAs which are already developed by Fetch.ai. You can get the finished AEAs, and compare your code against them, by following the next steps:</p> <pre><code>aea fetch fetchai/generic_seller:0.29.5\ncd generic_seller\naea eject skill fetchai/generic_seller:0.28.6\ncd ..\n</code></pre> <pre><code>aea fetch fetchai/generic_buyer:0.30.5\ncd generic_buyer\naea eject skill fetchai/generic_buyer:0.27.6\ncd ..\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#simplification-step","title":"Simplification Step","text":"<p>To keep file paths consistent with the reference code, we suggest you initialize your local author as <code>fetchai</code> for the purpose of this demo only:</p> <pre><code>aea init --reset --author fetchai\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#generic-seller-aea","title":"Generic Seller AEA","text":""},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-1-create-the-aea","title":"Step 1: Create the AEA","text":"<p>Create a new AEA by typing the following command in the terminal:</p> <pre><code>aea create my_generic_seller\ncd my_generic_seller\naea install\n</code></pre> <p>Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of data. Type the following command:</p> <pre><code>aea scaffold skill generic_seller\n</code></pre> <p>The <code>scaffold skill</code> command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the \"skills\" folder (<code>my_generic_seller/skills/generic_seller/</code>), and it must contain the following files:</p> <ul> <li><code>__init__.py</code></li> <li><code>behaviours.py</code></li> <li><code>handlers.py</code></li> <li><code>my_model.py</code></li> <li><code>skills.yaml</code></li> </ul>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-2-create-the-behaviour","title":"Step 2: Create the Behaviour","text":"<p>A <code>Behaviour</code> class contains the business logic specific to actions initiated by the AEA, rather than reactions to other events.</p> <p>Open the <code>behaviours.py</code> file (<code>my_generic_seller/skills/generic_seller/behaviours.py</code>) and replace the stub code with the following:</p> <pre><code>from typing import Any, Optional, cast\nfrom aea.helpers.search.models import Description\nfrom aea.skills.behaviours import TickerBehaviour\nfrom packages.fetchai.connections.ledger.base import (\nCONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID,\n)\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.generic_seller.dialogues import (\nLedgerApiDialogues,\nOefSearchDialogues,\n)\nfrom packages.fetchai.skills.generic_seller.strategy import GenericStrategy\nDEFAULT_SERVICES_INTERVAL = 60.0\nDEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5\nLEDGER_API_ADDRESS = str(LEDGER_CONNECTION_PUBLIC_ID)\nclass GenericServiceRegistrationBehaviour(TickerBehaviour):\n\"\"\"This class implements a behaviour.\"\"\"\ndef __init__(self, **kwargs: Any):\n\"\"\"Initialise the behaviour.\"\"\"\nservices_interval = kwargs.pop(\n\"services_interval\", DEFAULT_SERVICES_INTERVAL\n)  # type: int\nself._max_soef_registration_retries = kwargs.pop(\n\"max_soef_registration_retries\", DEFAULT_MAX_SOEF_REGISTRATION_RETRIES\n)  # type: int\nsuper().__init__(tick_interval=services_interval, **kwargs)\nself.failed_registration_msg = None  # type: Optional[OefSearchMessage]\nself._nb_retries = 0\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_ledger_tx:\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_msg, _ = ledger_api_dialogues.create(\ncounterparty=LEDGER_API_ADDRESS,\nperformative=LedgerApiMessage.Performative.GET_BALANCE,\nledger_id=strategy.ledger_id,\naddress=cast(str, self.context.agent_addresses.get(strategy.ledger_id)),\n)\nself.context.outbox.put_message(message=ledger_api_msg)\nself._register_agent()\ndef act(self) -&gt; None:\n\"\"\"Implement the act.\"\"\"\nself._retry_failed_registration()\ndef teardown(self) -&gt; None:\n\"\"\"Implement the task teardown.\"\"\"\nself._unregister_service()\nself._unregister_agent()\ndef _retry_failed_registration(self) -&gt; None:\n\"\"\"Retry a failed registration.\"\"\"\nif self.failed_registration_msg is not None:\nself._nb_retries += 1\nif self._nb_retries &gt; self._max_soef_registration_retries:\nself.context.is_active = False\nreturn\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.failed_registration_msg.to,\nperformative=self.failed_registration_msg.performative,\nservice_description=self.failed_registration_msg.service_description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\nf\"Retrying registration on SOEF. Retry {self._nb_retries} out of {self._max_soef_registration_retries}.\"\n)\nself.failed_registration_msg = None\ndef _register(self, description: Description, logger_msg: str) -&gt; None:\n\"\"\"\n        Register something on the SOEF.\n        :param description: the description of what is being registered\n        :param logger_msg: the logger message to print after the registration\n        \"\"\"\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.REGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(logger_msg)\ndef _register_agent(self) -&gt; None:\n\"\"\"Register the agent's location.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_location_description()\nself._register(description, \"registering agent on SOEF.\")\ndef register_service(self) -&gt; None:\n\"\"\"Register the agent's service.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_register_service_description()\nself._register(description, \"registering agent's service on the SOEF.\")\ndef register_genus(self) -&gt; None:\n\"\"\"Register the agent's personality genus.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_register_personality_description()\nself._register(\ndescription, \"registering agent's personality genus on the SOEF.\"\n)\ndef register_classification(self) -&gt; None:\n\"\"\"Register the agent's personality classification.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_register_classification_description()\nself._register(\ndescription, \"registering agent's personality classification on the SOEF.\"\n)\ndef _unregister_service(self) -&gt; None:\n\"\"\"Unregister service from the SOEF.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_unregister_service_description()\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.UNREGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\"unregistering service from SOEF.\")\ndef _unregister_agent(self) -&gt; None:\n\"\"\"Unregister agent from the SOEF.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\ndescription = strategy.get_location_description()\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.UNREGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\"unregistering agent from SOEF.\")\n</code></pre> <p>This <code>TickerBehaviour</code> registers (see <code>setup</code> method) and de-registers (see <code>teardown</code> method) our AEA\u2019s service on the SOEF search node at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to other AEAs.</p> <p>In <code>setup</code>, prior to registrations, we send a message to the ledger connection to check the account balance for the AEA's address on the configured ledger.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-3-create-the-handler","title":"Step 3: Create the Handler","text":"<p>So far, we have tasked the AEA with sending register/unregister requests to the SOEF search node. However at present, the AEA has no way of handling the responses it receives from the search node, or in fact messages sent by any other AEA.</p> <p>We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow that we want this AEA to use, as well as interactions with a search node and the blockchain between a <code>seller_AEA</code> and a <code>buyer_AEA</code>.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Buyer_AEA\n        participant Seller_AEA\n        participant Blockchain\n\n        activate Buyer_AEA\n        activate Search\n        activate Seller_AEA\n        activate Blockchain\n\n        Seller_AEA-&gt;&gt;Search: register_service\n        Buyer_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Buyer_AEA: list_of_agents\n        Buyer_AEA-&gt;&gt;Seller_AEA: call_for_proposal\n        Seller_AEA-&gt;&gt;Buyer_AEA: propose\n        Buyer_AEA-&gt;&gt;Seller_AEA: accept\n        Seller_AEA-&gt;&gt;Buyer_AEA: match_accept\n        loop Once with LedgerConnection\n            Buyer_AEA-&gt;&gt;Buyer_AEA: Get raw transaction from ledger api\n        end\n        loop Once with DecisionMaker\n            Buyer_AEA-&gt;&gt;Buyer_AEA: Get signed transaction from decision maker\n        end\n        loop Once with LedgerConnection\n            Buyer_AEA-&gt;&gt;Buyer_AEA: Send transaction and get digest from ledger api\n            Buyer_AEA-&gt;&gt;Blockchain: transfer_funds\n        end\n        Buyer_AEA-&gt;&gt;Seller_AEA: send_transaction_digest\n        Seller_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Seller_AEA-&gt;&gt;Buyer_AEA: send_data\n\n        deactivate Buyer_AEA\n        deactivate Search\n        deactivate Seller_AEA\n        deactivate Blockchain</code></pre> <p>In our case, <code>my_generic_seller</code> is the <code>Seller_AEA</code> in the above figure.</p> <p>Let us now implement a <code>Handler</code> to deal with incoming messages. Open the <code>handlers.py</code> file (<code>my_generic_seller/skills/generic_seller/handlers.py</code>) and replace the stub code with the following:</p> <pre><code>from typing import Optional, cast\nfrom aea.configurations.base import PublicId\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.helpers.transaction.base import TransactionDigest\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.connections.ledger.base import (\nCONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID,\n)\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nfrom packages.fetchai.protocols.fipa.message import FipaMessage\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.generic_seller.behaviours import (\nGenericServiceRegistrationBehaviour,\n)\nfrom packages.fetchai.skills.generic_seller.dialogues import (\nDefaultDialogues,\nFipaDialogue,\nFipaDialogues,\nLedgerApiDialogue,\nLedgerApiDialogues,\nOefSearchDialogue,\nOefSearchDialogues,\n)\nfrom packages.fetchai.skills.generic_seller.strategy import GenericStrategy\nLEDGER_API_ADDRESS = str(LEDGER_CONNECTION_PUBLIC_ID)\nclass GenericFipaHandler(Handler):\n\"\"\"This class implements a FIPA handler.\"\"\"\nSUPPORTED_PROTOCOL = FipaMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\nfipa_msg = cast(FipaMessage, message)\n# recover dialogue\nfipa_dialogues = cast(FipaDialogues, self.context.fipa_dialogues)\nfipa_dialogue = cast(FipaDialogue, fipa_dialogues.update(fipa_msg))\nif fipa_dialogue is None:\nself._handle_unidentified_dialogue(fipa_msg)\nreturn\n# handle message\nif fipa_msg.performative == FipaMessage.Performative.CFP:\nself._handle_cfp(fipa_msg, fipa_dialogue)\nelif fipa_msg.performative == FipaMessage.Performative.DECLINE:\nself._handle_decline(fipa_msg, fipa_dialogue, fipa_dialogues)\nelif fipa_msg.performative == FipaMessage.Performative.ACCEPT:\nself._handle_accept(fipa_msg, fipa_dialogue)\nelif fipa_msg.performative == FipaMessage.Performative.INFORM:\nself._handle_inform(fipa_msg, fipa_dialogue)\nelse:\nself._handle_invalid(fipa_msg, fipa_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\n</code></pre> <p>The code above contains the logic for handling <code>FipaMessages</code> received by the <code>my_generic_seller</code> AEA. We use <code>FipaDialogues</code> (more on this below) to keep track of the progress of the negotiation dialogue between the <code>my_generic_seller</code> AEA and the <code>my_generic_buyer</code> AEA.</p> <p>In the above <code>handle</code> method, we first check if a received message belongs to an existing dialogue or if we have to create a new dialogue (the <code>recover dialogue</code> part). Once this is done, we break down the AEA's response to each type of negotiation message, as indicated by the message's performative (the <code>handle message</code> part). Therefore, we implement the AEA's response to each negotiation message type in a different handler function.</p> <p>Below the unused <code>teardown</code> function, we continue by adding the following function:</p> <pre><code>    def _handle_unidentified_dialogue(self, fipa_msg: FipaMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param fipa_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid fipa message={}, unidentified dialogue.\".format(fipa_msg)\n)\ndefault_dialogues = cast(DefaultDialogues, self.context.default_dialogues)\ndefault_msg, _ = default_dialogues.create(\ncounterparty=fipa_msg.sender,\nperformative=DefaultMessage.Performative.ERROR,\nerror_code=DefaultMessage.ErrorCode.INVALID_DIALOGUE,\nerror_msg=\"Invalid dialogue.\",\nerror_data={\"fipa_message\": fipa_msg.encode()},\n)\nself.context.outbox.put_message(message=default_msg)\n</code></pre> <p>The above code handles an unidentified dialogue by responding to the sender with a <code>DefaultMessage</code> containing the appropriate error information.</p> <p>The next code block handles <code>CFP</code> (call-for-proposal) negotiation messages. Paste the following code below the <code>_handle_unidentified_dialogue</code> function:</p> <pre><code>    def _handle_cfp(self, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue) -&gt; None:\n\"\"\"\n        Handle the CFP.\n        If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.info(\n\"received CFP from sender={}\".format(fipa_msg.sender[-5:])\n)\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_matching_supply(fipa_msg.query):\nproposal, terms, data_for_sale = strategy.generate_proposal_terms_and_data(\nfipa_msg.query, fipa_msg.sender\n)\nfipa_dialogue.data_for_sale = data_for_sale\nfipa_dialogue.terms = terms\nself.context.logger.info(\n\"sending a PROPOSE with proposal={} to sender={}\".format(\nproposal.values, fipa_msg.sender[-5:]\n)\n)\nproposal_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.PROPOSE,\ntarget_message=fipa_msg,\nproposal=proposal,\n)\nself.context.outbox.put_message(message=proposal_msg)\nelse:\nself.context.logger.info(\n\"declined the CFP from sender={}\".format(fipa_msg.sender[-5:])\n)\ndecline_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.DECLINE,\ntarget_message=fipa_msg,\n)\nself.context.outbox.put_message(message=decline_msg)\n</code></pre> <p>The above code sends a <code>PROPOSE</code> message back to the buyer as a response to its <code>CFP</code> if the requested services match our seller agent's supplied services, otherwise it will respond with a <code>DECLINE</code> message.</p> <p>The next code-block  handles the decline message we receive from the buyer. Add the following code below the <code>_handle_cfp</code>function:</p> <pre><code>    def _handle_decline(\nself,\nfipa_msg: FipaMessage,\nfipa_dialogue: FipaDialogue,\nfipa_dialogues: FipaDialogues,\n) -&gt; None:\n\"\"\"\n        Handle the DECLINE.\n        Close the dialogue.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        :param fipa_dialogues: the dialogues object\n        \"\"\"\nself.context.logger.info(\n\"received DECLINE from sender={}\".format(fipa_msg.sender[-5:])\n)\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.DECLINED_PROPOSE, fipa_dialogue.is_self_initiated\n)\n</code></pre> <p>If we receive a decline message from the buyer we close the dialogue and terminate this conversation with <code>my_generic_buyer</code>.</p> <p>Alternatively, we might receive an <code>ACCEPT</code> message. In order to handle this option add the following code below the <code>_handle_decline</code> function:</p> <pre><code>    def _handle_accept(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle the ACCEPT.\n        Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.info(\n\"received ACCEPT from sender={}\".format(fipa_msg.sender[-5:])\n)\ninfo = {\"address\": fipa_dialogue.terms.sender_address}\nmatch_accept_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.MATCH_ACCEPT_W_INFORM,\ntarget_message=fipa_msg,\ninfo=info,\n)\nself.context.logger.info(\n\"sending MATCH_ACCEPT_W_INFORM to sender={} with info={}\".format(\nfipa_msg.sender[-5:],\ninfo,\n)\n)\nself.context.outbox.put_message(message=match_accept_msg)\n</code></pre> <p>When <code>my_generic_buyer</code> accepts the <code>Proposal</code> we send it and sends an <code>ACCEPT</code> message, we have to respond with another message (<code>MATCH_ACCEPT_W_INFORM</code>) to match the acceptance of the terms of trade and to inform the buyer of the address we would like it to send the funds to.</p> <p>Lastly, we must handle an <code>INFORM</code> message, which the buyer uses to inform us that it has indeed sent the funds to the provided address. Add the following code at the end of the file:</p> <pre><code>    def _handle_inform(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle the INFORM.\n        If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing.\n        If the transaction is settled, send the data, otherwise do nothing.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.info(\n\"received INFORM from sender={}\".format(fipa_msg.sender[-5:])\n)\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_ledger_tx and \"transaction_digest\" in fipa_msg.info.keys():\nself.context.logger.info(\n\"checking whether transaction={} has been received ...\".format(\nfipa_msg.info[\"transaction_digest\"]\n)\n)\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_msg, ledger_api_dialogue = ledger_api_dialogues.create(\ncounterparty=LEDGER_API_ADDRESS,\nperformative=LedgerApiMessage.Performative.GET_TRANSACTION_RECEIPT,\ntransaction_digest=TransactionDigest(\nfipa_dialogue.terms.ledger_id, fipa_msg.info[\"transaction_digest\"]\n),\n)\nledger_api_dialogue = cast(LedgerApiDialogue, ledger_api_dialogue)\nledger_api_dialogue.associated_fipa_dialogue = fipa_dialogue\nself.context.outbox.put_message(message=ledger_api_msg)\nelif strategy.is_ledger_tx:\nself.context.logger.warning(\n\"did not receive transaction digest from sender={}.\".format(\nfipa_msg.sender[-5:]\n)\n)\nelif not strategy.is_ledger_tx and \"Done\" in fipa_msg.info.keys():\ninform_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.INFORM,\ntarget_message=fipa_msg,\ninfo=fipa_dialogue.data_for_sale,\n)\nself.context.outbox.put_message(message=inform_msg)\nfipa_dialogues = cast(FipaDialogues, self.context.fipa_dialogues)\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.SUCCESSFUL, fipa_dialogue.is_self_initiated\n)\nself.context.logger.info(\n\"transaction confirmed, sending data={} to buyer={}.\".format(\nfipa_dialogue.data_for_sale,\nfipa_msg.sender[-5:],\n)\n)\nelse:\nself.context.logger.warning(\n\"did not receive transaction confirmation from sender={}.\".format(\nfipa_msg.sender[-5:]\n)\n)\n</code></pre> <p>In the above code, we check the <code>INFORM</code> message. If it contains a transaction digest, then we verify that the transaction matches the proposal the buyer accepted. If the transaction is valid and we received the funds, then we send the data to the buyer. Otherwise, we do not send the data.</p> <p>The remaining handlers are as follows:</p> <pre><code>    def _handle_invalid(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle a fipa message of invalid performative.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle fipa message of performative={} in dialogue={}.\".format(\nfipa_msg.performative, fipa_dialogue\n)\n)\nclass GenericLedgerApiHandler(Handler):\n\"\"\"Implement the ledger handler.\"\"\"\nSUPPORTED_PROTOCOL = LedgerApiMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\nledger_api_msg = cast(LedgerApiMessage, message)\n# recover dialogue\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_dialogue = cast(\nOptional[LedgerApiDialogue], ledger_api_dialogues.update(ledger_api_msg)\n)\nif ledger_api_dialogue is None:\nself._handle_unidentified_dialogue(ledger_api_msg)\nreturn\n# handle message\nif ledger_api_msg.performative is LedgerApiMessage.Performative.BALANCE:\nself._handle_balance(ledger_api_msg)\nelif (\nledger_api_msg.performative\nis LedgerApiMessage.Performative.TRANSACTION_RECEIPT\n):\nself._handle_transaction_receipt(ledger_api_msg, ledger_api_dialogue)\nelif ledger_api_msg.performative == LedgerApiMessage.Performative.ERROR:\nself._handle_error(ledger_api_msg, ledger_api_dialogue)\nelse:\nself._handle_invalid(ledger_api_msg, ledger_api_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\ndef _handle_unidentified_dialogue(self, ledger_api_msg: LedgerApiMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param ledger_api_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid ledger_api message={}, unidentified dialogue.\".format(\nledger_api_msg\n)\n)\ndef _handle_balance(self, ledger_api_msg: LedgerApiMessage) -&gt; None:\n\"\"\"\n        Handle a message of balance performative.\n        :param ledger_api_msg: the ledger api message\n        \"\"\"\nself.context.logger.info(\n\"starting balance on {} ledger={}.\".format(\nledger_api_msg.ledger_id,\nledger_api_msg.balance,\n)\n)\ndef _handle_transaction_receipt(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of balance performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nfipa_dialogue = ledger_api_dialogue.associated_fipa_dialogue\nis_settled = LedgerApis.is_transaction_settled(\nfipa_dialogue.terms.ledger_id, ledger_api_msg.transaction_receipt.receipt\n)\nis_valid = LedgerApis.is_transaction_valid(\nfipa_dialogue.terms.ledger_id,\nledger_api_msg.transaction_receipt.transaction,\nfipa_dialogue.terms.sender_address,\nfipa_dialogue.terms.counterparty_address,\nfipa_dialogue.terms.nonce,\nfipa_dialogue.terms.counterparty_payable_amount,\n)\nif is_settled and is_valid:\nlast_message = cast(\nOptional[FipaMessage], fipa_dialogue.last_incoming_message\n)\nif last_message is None:\nraise ValueError(\"Cannot retrieve last fipa message.\")\ninform_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.INFORM,\ntarget_message=last_message,\ninfo=fipa_dialogue.data_for_sale,\n)\nself.context.outbox.put_message(message=inform_msg)\nfipa_dialogues = cast(FipaDialogues, self.context.fipa_dialogues)\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.SUCCESSFUL, fipa_dialogue.is_self_initiated\n)\nself.context.logger.info(\n\"transaction confirmed, sending data={} to buyer={}.\".format(\nfipa_dialogue.data_for_sale,\nlast_message.sender[-5:],\n)\n)\nelse:\nself.context.logger.info(\n\"transaction_receipt={} not settled or not valid, aborting\".format(\nledger_api_msg.transaction_receipt\n)\n)\ndef _handle_error(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of error performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.info(\n\"received ledger_api error message={} in dialogue={}.\".format(\nledger_api_msg, ledger_api_dialogue\n)\n)\ndef _handle_invalid(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of invalid performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle ledger_api message of performative={} in dialogue={}.\".format(\nledger_api_msg.performative,\nledger_api_dialogue,\n)\n)\nclass GenericOefSearchHandler(Handler):\n\"\"\"This class implements an OEF search handler.\"\"\"\nSUPPORTED_PROTOCOL = OefSearchMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Call to setup the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\noef_search_msg = cast(OefSearchMessage, message)\n# recover dialogue\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_dialogue = cast(\nOptional[OefSearchDialogue], oef_search_dialogues.update(oef_search_msg)\n)\nif oef_search_dialogue is None:\nself._handle_unidentified_dialogue(oef_search_msg)\nreturn\n# handle message\nif oef_search_msg.performative == OefSearchMessage.Performative.SUCCESS:\nself._handle_success(oef_search_msg, oef_search_dialogue)\nelif oef_search_msg.performative == OefSearchMessage.Performative.OEF_ERROR:\nself._handle_error(oef_search_msg, oef_search_dialogue)\nelse:\nself._handle_invalid(oef_search_msg, oef_search_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\ndef _handle_unidentified_dialogue(self, oef_search_msg: OefSearchMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param oef_search_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid oef_search message={}, unidentified dialogue.\".format(\noef_search_msg\n)\n)\ndef _handle_success(\nself,\noef_search_success_msg: OefSearchMessage,\noef_search_dialogue: OefSearchDialogue,\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_success_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nself.context.logger.info(\n\"received oef_search success message={} in dialogue={}.\".format(\noef_search_success_msg, oef_search_dialogue\n)\n)\ntarget_message = cast(\nOefSearchMessage,\noef_search_dialogue.get_message_by_id(oef_search_success_msg.target),\n)\nif (\ntarget_message.performative\n== OefSearchMessage.Performative.REGISTER_SERVICE\n):\ndescription = target_message.service_description\ndata_model_name = description.data_model.name\nregistration_behaviour = cast(\nGenericServiceRegistrationBehaviour,\nself.context.behaviours.service_registration,\n)\nif \"location_agent\" in data_model_name:\nregistration_behaviour.register_service()\nelif \"set_service_key\" in data_model_name:\nregistration_behaviour.register_genus()\nelif (\n\"personality_agent\" in data_model_name\nand description.values[\"piece\"] == \"genus\"\n):\nregistration_behaviour.register_classification()\nelif (\n\"personality_agent\" in data_model_name\nand description.values[\"piece\"] == \"classification\"\n):\nself.context.logger.info(\n\"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\"\n)\nelse:\nself.context.logger.warning(\nf\"received soef SUCCESS message as a reply to the following unexpected message: {target_message}\"\n)\ndef _handle_error(\nself,\noef_search_error_msg: OefSearchMessage,\noef_search_dialogue: OefSearchDialogue,\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_error_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nself.context.logger.info(\n\"received oef_search error message={} in dialogue={}.\".format(\noef_search_error_msg, oef_search_dialogue\n)\n)\ntarget_message = cast(\nOefSearchMessage,\noef_search_dialogue.get_message_by_id(oef_search_error_msg.target),\n)\nif (\ntarget_message.performative\n== OefSearchMessage.Performative.REGISTER_SERVICE\n):\nregistration_behaviour = cast(\nGenericServiceRegistrationBehaviour,\nself.context.behaviours.service_registration,\n)\nregistration_behaviour.failed_registration_msg = target_message\ndef _handle_invalid(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle oef_search message of performative={} in dialogue={}.\".format(\noef_search_msg.performative,\noef_search_dialogue,\n)\n)\n</code></pre> <p>The <code>GenericLedgerApiHandler</code> deals with <code>LedgerApiMessages</code> from the ledger connection and the <code>GenericOefSearchHandler</code> handles <code>OefSearchMessages</code> from the SOEF connection.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-4-create-the-strategy","title":"Step 4: Create the Strategy","text":"<p>Next, we are going to create the strategy that we want our <code>my_generic_seller</code> AEA to follow. Rename the <code>my_model.py</code> file (<code>my_generic_seller/skills/generic_seller/my_model.py</code>) to <code>strategy.py</code> and replace the stub code with the following:</p> <pre><code>import uuid\nfrom typing import Any, Dict, Optional, Tuple\nfrom aea.common import Address\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.exceptions import enforce\nfrom aea.helpers.search.generic import (\nAGENT_LOCATION_MODEL,\nAGENT_PERSONALITY_MODEL,\nAGENT_REMOVE_SERVICE_MODEL,\nAGENT_SET_SERVICE_MODEL,\nSIMPLE_SERVICE_MODEL,\n)\nfrom aea.helpers.search.models import Description, Location, Query\nfrom aea.helpers.transaction.base import Terms\nfrom aea.skills.base import Model\nDEFAULT_IS_LEDGER_TX = True\nDEFAULT_UNIT_PRICE = 4\nDEFAULT_SERVICE_ID = \"generic_service\"\nDEFAULT_LOCATION = {\"longitude\": 0.1270, \"latitude\": 51.5194}\nDEFAULT_SERVICE_DATA = {\"key\": \"seller_service\", \"value\": \"generic_service\"}\nDEFAULT_PERSONALITY_DATA = {\"piece\": \"genus\", \"value\": \"data\"}\nDEFAULT_CLASSIFICATION = {\"piece\": \"classification\", \"value\": \"seller\"}\nDEFAULT_HAS_DATA_SOURCE = False\nDEFAULT_DATA_FOR_SALE = {\n\"some_generic_data_key\": \"some_generic_data_value\"\n}  # type: Optional[Dict[str, Any]]\nclass GenericStrategy(Model):\n\"\"\"This class defines a strategy for the agent.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize the strategy of the agent.\n        :param kwargs: keyword arguments\n        \"\"\"\nledger_id = kwargs.pop(\"ledger_id\", None)\ncurrency_id = kwargs.pop(\"currency_id\", None)\nself._is_ledger_tx = kwargs.pop(\"is_ledger_tx\", DEFAULT_IS_LEDGER_TX)\nself._unit_price = kwargs.pop(\"unit_price\", DEFAULT_UNIT_PRICE)\nself._service_id = kwargs.pop(\"service_id\", DEFAULT_SERVICE_ID)\nlocation = kwargs.pop(\"location\", DEFAULT_LOCATION)\nself._agent_location = {\n\"location\": Location(\nlatitude=location[\"latitude\"], longitude=location[\"longitude\"]\n)\n}\nself._set_personality_data = kwargs.pop(\n\"personality_data\", DEFAULT_PERSONALITY_DATA\n)\nenforce(\nlen(self._set_personality_data) == 2\nand \"piece\" in self._set_personality_data\nand \"value\" in self._set_personality_data,\n\"personality_data must contain keys `key` and `value`\",\n)\nself._set_classification = kwargs.pop(\"classification\", DEFAULT_CLASSIFICATION)\nenforce(\nlen(self._set_classification) == 2\nand \"piece\" in self._set_classification\nand \"value\" in self._set_classification,\n\"classification must contain keys `key` and `value`\",\n)\nself._set_service_data = kwargs.pop(\"service_data\", DEFAULT_SERVICE_DATA)\nenforce(\nlen(self._set_service_data) == 2\nand \"key\" in self._set_service_data\nand \"value\" in self._set_service_data,\n\"service_data must contain keys `key` and `value`\",\n)\nself._remove_service_data = {\"key\": self._set_service_data[\"key\"]}\nself._simple_service_data = {\nself._set_service_data[\"key\"]: self._set_service_data[\"value\"]\n}\nself._has_data_source = kwargs.pop(\"has_data_source\", DEFAULT_HAS_DATA_SOURCE)\ndata_for_sale_ordered = kwargs.pop(\"data_for_sale\", DEFAULT_DATA_FOR_SALE)\ndata_for_sale = {\nstr(key): str(value) for key, value in data_for_sale_ordered.items()\n}\nsuper().__init__(**kwargs)\nself._ledger_id = (\nledger_id if ledger_id is not None else self.context.default_ledger_id\n)\nif currency_id is None:\ncurrency_id = self.context.currency_denominations.get(self._ledger_id, None)\nenforce(\ncurrency_id is not None,\nf\"Currency denomination for ledger_id={self._ledger_id} not specified.\",\n)\nself._currency_id = currency_id\nenforce(\nself.context.agent_addresses.get(self._ledger_id, None) is not None,\n\"Wallet does not contain cryptos for provided ledger id.\",\n)\nself._data_for_sale = data_for_sale\n</code></pre> <p>In the above code snippet, we initialise the strategy class by trying to read the variables specific to the strategy from a YAML configuration file. If any variable is not provided, some default values will be used.</p> <p>The following properties and methods deal with different aspects of the strategy. They should be relatively self-descriptive. Add them under the initialization of the strategy class:</p> <pre><code>    @property\ndef data_for_sale(self) -&gt; Dict[str, str]:\n\"\"\"Get the data for sale.\"\"\"\nif self._has_data_source:\nreturn self.collect_from_data_source()  # pragma: nocover\nreturn self._data_for_sale\n@property\ndef ledger_id(self) -&gt; str:\n\"\"\"Get the ledger id.\"\"\"\nreturn self._ledger_id\n@property\ndef is_ledger_tx(self) -&gt; bool:\n\"\"\"Check whether or not tx are settled on a ledger.\"\"\"\nreturn self._is_ledger_tx\ndef get_location_description(self) -&gt; Description:\n\"\"\"\n        Get the location description.\n        :return: a description of the agent's location\n        \"\"\"\ndescription = Description(\nself._agent_location,\ndata_model=AGENT_LOCATION_MODEL,\n)\nreturn description\ndef get_register_service_description(self) -&gt; Description:\n\"\"\"\n        Get the register service description.\n        :return: a description of the offered services\n        \"\"\"\ndescription = Description(\nself._set_service_data,\ndata_model=AGENT_SET_SERVICE_MODEL,\n)\nreturn description\ndef get_register_personality_description(self) -&gt; Description:\n\"\"\"\n        Get the register personality description.\n        :return: a description of the personality\n        \"\"\"\ndescription = Description(\nself._set_personality_data,\ndata_model=AGENT_PERSONALITY_MODEL,\n)\nreturn description\ndef get_register_classification_description(self) -&gt; Description:\n\"\"\"\n        Get the register classification description.\n        :return: a description of the classification\n        \"\"\"\ndescription = Description(\nself._set_classification,\ndata_model=AGENT_PERSONALITY_MODEL,\n)\nreturn description\ndef get_service_description(self) -&gt; Description:\n\"\"\"\n        Get the simple service description.\n        :return: a description of the offered services\n        \"\"\"\ndescription = Description(\nself._simple_service_data,\ndata_model=SIMPLE_SERVICE_MODEL,\n)\nreturn description\ndef get_unregister_service_description(self) -&gt; Description:\n\"\"\"\n        Get the unregister service description.\n        :return: a description of the to be removed service\n        \"\"\"\ndescription = Description(\nself._remove_service_data,\ndata_model=AGENT_REMOVE_SERVICE_MODEL,\n)\nreturn description\ndef is_matching_supply(self, query: Query) -&gt; bool:\n\"\"\"\n        Check if the query matches the supply.\n        :param query: the query\n        :return: bool indicating whether matches or not\n        \"\"\"\nreturn query.check(self.get_service_description())\ndef generate_proposal_terms_and_data(  # pylint: disable=unused-argument\nself, query: Query, counterparty_address: Address\n) -&gt; Tuple[Description, Terms, Dict[str, str]]:\n\"\"\"\n        Generate a proposal matching the query.\n        :param query: the query\n        :param counterparty_address: the counterparty of the proposal.\n        :return: a tuple of proposal, terms and the weather data\n        \"\"\"\ndata_for_sale = self.data_for_sale\nsale_quantity = len(data_for_sale)\nseller_address = self.context.agent_addresses[self.ledger_id]\ntotal_price = sale_quantity * self._unit_price\nif self.is_ledger_tx:\ntx_nonce = LedgerApis.generate_tx_nonce(\nidentifier=self.ledger_id,\nseller=seller_address,\nclient=counterparty_address,\n)\nelse:\ntx_nonce = uuid.uuid4().hex  # pragma: nocover\nproposal = Description(\n{\n\"ledger_id\": self.ledger_id,\n\"price\": total_price,\n\"currency_id\": self._currency_id,\n\"service_id\": self._service_id,\n\"quantity\": sale_quantity,\n\"tx_nonce\": tx_nonce,\n}\n)\nterms = Terms(\nledger_id=self.ledger_id,\nsender_address=seller_address,\ncounterparty_address=counterparty_address,\namount_by_currency_id={self._currency_id: total_price},\nquantities_by_good_id={self._service_id: -sale_quantity},\nis_sender_payable_tx_fee=False,\nnonce=tx_nonce,\nfee_by_currency_id={self._currency_id: 0},\n)\nreturn proposal, terms, data_for_sale\ndef collect_from_data_source(self) -&gt; Dict[str, str]:\n\"\"\"Implement the logic to communicate with the sensor.\"\"\"\nraise NotImplementedError\n</code></pre> <p>The helper private function <code>collect_from_data_source</code> is where we read data from a sensor or if there are no sensor we use some default data provided (see the <code>data_for_sale</code> property).</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-5-create-the-dialogues","title":"Step 5: Create the Dialogues","text":"<p>To keep track of the structure and progress of interactions, including negotiations with a buyer AEA and interactions with search nodes and ledgers, we use dialogues. Create a new file in the skill folder (<code>my_generic_seller/skills/generic_seller/</code>) and name it <code>dialogues.py</code>. Inside this file add the following code:</p> <pre><code>from typing import Any, Dict, Optional, Type\nfrom aea.common import Address\nfrom aea.exceptions import AEAEnforceError, enforce\nfrom aea.helpers.transaction.base import Terms\nfrom aea.protocols.base import Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel\nfrom aea.skills.base import Model\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogue as BaseDefaultDialogue,\n)\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogues as BaseDefaultDialogues,\n)\nfrom packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue\nfrom packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues\nfrom packages.fetchai.protocols.fipa.message import FipaMessage\nfrom packages.fetchai.protocols.ledger_api.dialogues import (\nLedgerApiDialogue as BaseLedgerApiDialogue,\n)\nfrom packages.fetchai.protocols.ledger_api.dialogues import (\nLedgerApiDialogues as BaseLedgerApiDialogues,\n)\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogue as BaseOefSearchDialogue,\n)\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogues as BaseOefSearchDialogues,\n)\nDefaultDialogue = BaseDefaultDialogue\nclass DefaultDialogues(Model, BaseDefaultDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn DefaultDialogue.Role.AGENT\nBaseDefaultDialogues.__init__(\nself,\nself_address=self.context.agent_address,\nrole_from_first_message=role_from_first_message,\n)\nclass FipaDialogue(BaseFipaDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\n__slots__ = (\"data_for_sale\", \"_terms\")\ndef __init__(\nself,\ndialogue_label: BaseDialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[FipaMessage] = FipaMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :param message_class: the message class\n        \"\"\"\nBaseFipaDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself.data_for_sale = None  # type: Optional[Dict[str, str]]\nself._terms = None  # type: Optional[Terms]\n@property\ndef terms(self) -&gt; Terms:\n\"\"\"Get terms.\"\"\"\nif self._terms is None:\nraise AEAEnforceError(\"Terms not set!\")\nreturn self._terms\n@terms.setter\ndef terms(self, terms: Terms) -&gt; None:\n\"\"\"Set terms.\"\"\"\nenforce(self._terms is None, \"Terms already set!\")\nself._terms = terms\nclass FipaDialogues(Model, BaseFipaDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn FipaDialogue.Role.SELLER\nBaseFipaDialogues.__init__(\nself,\nself_address=self.context.agent_address,\nrole_from_first_message=role_from_first_message,\ndialogue_class=FipaDialogue,\n)\nclass LedgerApiDialogue(BaseLedgerApiDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\n__slots__ = (\"_associated_fipa_dialogue\",)\ndef __init__(\nself,\ndialogue_label: BaseDialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[LedgerApiMessage] = LedgerApiMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :param message_class: the message class\n        \"\"\"\nBaseLedgerApiDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself._associated_fipa_dialogue = None  # type: Optional[FipaDialogue]\n@property\ndef associated_fipa_dialogue(self) -&gt; FipaDialogue:\n\"\"\"Get associated_fipa_dialogue.\"\"\"\nif self._associated_fipa_dialogue is None:\nraise AEAEnforceError(\"FipaDialogue not set!\")\nreturn self._associated_fipa_dialogue\n@associated_fipa_dialogue.setter\ndef associated_fipa_dialogue(self, fipa_dialogue: FipaDialogue) -&gt; None:\n\"\"\"Set associated_fipa_dialogue\"\"\"\nenforce(self._associated_fipa_dialogue is None, \"FipaDialogue already set!\")\nself._associated_fipa_dialogue = fipa_dialogue\nclass LedgerApiDialogues(Model, BaseLedgerApiDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseLedgerApiDialogue.Role.AGENT\nBaseLedgerApiDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\ndialogue_class=LedgerApiDialogue,\n)\nOefSearchDialogue = BaseOefSearchDialogue\nclass OefSearchDialogues(Model, BaseOefSearchDialogues):\n\"\"\"This class keeps track of all oef_search dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseOefSearchDialogue.Role.AGENT\nBaseOefSearchDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\n</code></pre> <p>The <code>FipaDialogues</code> class contains negotiation dialogues with each <code>my_generic_buyer</code> AEA (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to the dialogues they belong to, access previous messages and enable us to identify possible communications problems between the <code>my_generic_seller</code> AEA and the <code>my_generic_buyer</code> AEA. It also keeps track of the data that we offer for sale during the proposal phase.</p> <p>The <code>FipaDialogues</code> class extends <code>BaseFipaDialogues</code>, which itself derives from the base <code>Dialogues</code> class. Similarly, the <code>FipaDialogue</code> class extends <code>BaseFipaDialogue</code> which itself derives from the base <code>Dialogue</code> class. To learn more about dialogues have a look here.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-6-update-the-yaml-files","title":"Step 6: Update the YAML Files","text":"<p>Since we made so many changes to our AEA we have to update the <code>skill.yaml</code> (at <code>my_generic_seller/skills/generic_seller/skill.yaml</code>). Make sure you update your <code>skill.yaml</code> with the following configuration:</p> <pre><code>name: generic_seller\nauthor: fetchai\nversion: 0.1.0\ntype: skill\ndescription: The weather station skill implements the functionality to sell weather\ndata.\nlicense: Apache-2.0\naea_version: '&gt;=1.0.0, &lt;2.0.0'\nfingerprint:\nREADME.md: QmPb5kHYZyhUN87EKmuahyGqDGgqVdGPyfC1KpGC3xfmcP\n__init__.py: QmTSEedzQySy2nzRCY3F66CBSX52f8s3pWHZTejX4hKC9h\nbehaviours.py: QmS9sPCv2yBnhWsmHeaCptpApMtYZipbR39TXixeGK64Ks\ndialogues.py: QmdTW8q1xQ7ajFVsWmuV62ypoT5J2b6Hkyz52LFaWuMEtd\nhandlers.py: QmQnQhSaHPUYaJut8bMe2LHEqiZqokMSVfCthVaqrvPbdi\nstrategy.py: QmYTUsfv64eRQDevCfMUDQPx2GCtiMLFdacN4sS1E4Fdfx\nfingerprint_ignore_patterns: []\nconnections:\n- fetchai/ledger:0.21.5\ncontracts: []\nprotocols:\n- fetchai/default:1.1.7\n- fetchai/fipa:1.1.7\n- fetchai/ledger_api:1.1.7\n- fetchai/oef_search:1.1.7\nskills: []\nbehaviours:\nservice_registration:\nargs:\nservices_interval: 20\nclass_name: GenericServiceRegistrationBehaviour\nhandlers:\nfipa:\nargs: {}\nclass_name: GenericFipaHandler\nledger_api:\nargs: {}\nclass_name: GenericLedgerApiHandler\noef_search:\nargs: {}\nclass_name: GenericOefSearchHandler\nmodels:\ndefault_dialogues:\nargs: {}\nclass_name: DefaultDialogues\nfipa_dialogues:\nargs: {}\nclass_name: FipaDialogues\nledger_api_dialogues:\nargs: {}\nclass_name: LedgerApiDialogues\noef_search_dialogues:\nargs: {}\nclass_name: OefSearchDialogues\nstrategy:\nargs:\ndata_for_sale:\ngeneric: data\nhas_data_source: false\nis_ledger_tx: true\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nservice_data:\nkey: seller_service\nvalue: generic_service\nservice_id: generic_service\nunit_price: 10\nclass_name: GenericStrategy\nis_abstract: false\ndependencies: {}\n</code></pre> <p>We must pay attention to the models and in particular the strategy\u2019s variables. Here we can change the price we would like to sell each data reading for, or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor.</p> <p>Finally, we fingerprint our new skill:</p> <pre><code>aea fingerprint skill fetchai/generic_seller:0.1.0\n</code></pre> <p>This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#generic-buyer-aea","title":"Generic Buyer AEA","text":""},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-1-create-the-aea_1","title":"Step 1: Create the AEA","text":"<p>In a new terminal, create a new AEA by typing the following command in the terminal:</p> <pre><code>aea create my_generic_buyer\ncd my_generic_buyer\naea install\n</code></pre> <p>Our newly created AEA is inside the current working directory. Let\u2019s create a new skill for purchasing data. Type the following command:</p> <pre><code>aea scaffold skill generic_buyer\n</code></pre> <p>This command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the skills folder (<code>my_generic_buyer/skills/generic_buyer/</code>) and it must contain the following files:</p> <ul> <li><code>__init__.py</code></li> <li><code>behaviours.py</code></li> <li><code>handlers.py</code></li> <li><code>my_model.py</code></li> <li><code>skills.yaml</code></li> </ul>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-2-create-the-behaviour_1","title":"Step 2: Create the Behaviour","text":"<p>Open the <code>behaviours.py</code> file (<code>my_generic_buyer/skills/generic_buyer/behaviours.py</code>) and replace the stub code with the following:</p> <pre><code>from typing import Any, List, Optional, Set, cast\nfrom aea.protocols.dialogue.base import DialogueLabel\nfrom aea.skills.behaviours import TickerBehaviour\nfrom packages.fetchai.connections.ledger.base import (\nCONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID,\n)\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.generic_buyer.dialogues import (\nFipaDialogue,\nLedgerApiDialogue,\nLedgerApiDialogues,\nOefSearchDialogues,\n)\nfrom packages.fetchai.skills.generic_buyer.strategy import GenericStrategy\nDEFAULT_MAX_PROCESSING = 120\nDEFAULT_TX_INTERVAL = 2.0\nDEFAULT_SEARCH_INTERVAL = 5.0\nLEDGER_API_ADDRESS = str(LEDGER_CONNECTION_PUBLIC_ID)\nclass GenericSearchBehaviour(TickerBehaviour):\n\"\"\"This class implements a search behaviour.\"\"\"\ndef __init__(self, **kwargs: Any):\n\"\"\"Initialize the search behaviour.\"\"\"\nsearch_interval = cast(\nfloat, kwargs.pop(\"search_interval\", DEFAULT_SEARCH_INTERVAL)\n)\nsuper().__init__(tick_interval=search_interval, **kwargs)\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the behaviour.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_ledger_tx:\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_msg, _ = ledger_api_dialogues.create(\ncounterparty=LEDGER_API_ADDRESS,\nperformative=LedgerApiMessage.Performative.GET_BALANCE,\nledger_id=strategy.ledger_id,\naddress=cast(str, self.context.agent_addresses.get(strategy.ledger_id)),\n)\nself.context.outbox.put_message(message=ledger_api_msg)\nelse:\nstrategy.is_searching = True\ndef act(self) -&gt; None:\n\"\"\"Implement the act.\"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\nif not strategy.is_searching:\nreturn\ntransaction_behaviour = cast(\nGenericTransactionBehaviour, self.context.behaviours.transaction\n)\nremaining_transactions_count = len(transaction_behaviour.waiting)\nif remaining_transactions_count &gt; 0:\nself.context.logger.info(\nf\"Transaction behaviour has {remaining_transactions_count} transactions remaining. Skipping search!\"\n)\nreturn\nstrategy.update_search_query_params()\nquery = strategy.get_location_and_service_query()\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.SEARCH_SERVICES,\nquery=query,\n)\nself.context.outbox.put_message(message=oef_search_msg)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the task teardown.\"\"\"\nclass GenericTransactionBehaviour(TickerBehaviour):\n\"\"\"A behaviour to sequentially submit transactions to the blockchain.\"\"\"\ndef __init__(self, **kwargs: Any):\n\"\"\"Initialize the transaction behaviour.\"\"\"\ntx_interval = cast(\nfloat, kwargs.pop(\"transaction_interval\", DEFAULT_TX_INTERVAL)\n)\nself.max_processing = cast(\nfloat, kwargs.pop(\"max_processing\", DEFAULT_MAX_PROCESSING)\n)\nself.processing_time = 0.0\nself.waiting: List[FipaDialogue] = []\nself.processing: Optional[LedgerApiDialogue] = None\nself.timedout: Set[DialogueLabel] = set()\nsuper().__init__(tick_interval=tx_interval, **kwargs)\ndef setup(self) -&gt; None:\n\"\"\"Setup behaviour.\"\"\"\ndef act(self) -&gt; None:\n\"\"\"Implement the act.\"\"\"\nif self.processing is not None:\nif self.processing_time &lt;= self.max_processing:\n# already processing\nself.processing_time += self.tick_interval\nreturn\nself._timeout_processing()\nif len(self.waiting) == 0:\n# nothing to process\nreturn\nself._start_processing()\ndef _start_processing(self) -&gt; None:\n\"\"\"Process the next transaction.\"\"\"\nfipa_dialogue = self.waiting.pop(0)\nself.context.logger.info(\nf\"Processing transaction, {len(self.waiting)} transactions remaining\"\n)\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_msg, ledger_api_dialogue = ledger_api_dialogues.create(\ncounterparty=LEDGER_API_ADDRESS,\nperformative=LedgerApiMessage.Performative.GET_RAW_TRANSACTION,\nterms=fipa_dialogue.terms,\n)\nledger_api_dialogue = cast(LedgerApiDialogue, ledger_api_dialogue)\nledger_api_dialogue.associated_fipa_dialogue = fipa_dialogue\nself.processing_time = 0.0\nself.processing = ledger_api_dialogue\nself.context.logger.info(\nf\"requesting transfer transaction from ledger api for message={ledger_api_msg}...\"\n)\nself.context.outbox.put_message(message=ledger_api_msg)\ndef teardown(self) -&gt; None:\n\"\"\"Teardown behaviour.\"\"\"\ndef _timeout_processing(self) -&gt; None:\n\"\"\"Timeout processing.\"\"\"\nif self.processing is None:\nreturn\nself.timedout.add(self.processing.dialogue_label)\nself.waiting.append(self.processing.associated_fipa_dialogue)\nself.processing_time = 0.0\nself.processing = None\ndef finish_processing(self, ledger_api_dialogue: LedgerApiDialogue) -&gt; None:\n\"\"\"\n        Finish processing.\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nif self.processing == ledger_api_dialogue:\nself.processing_time = 0.0\nself.processing = None\nreturn\nif ledger_api_dialogue.dialogue_label not in self.timedout:\nraise ValueError(\nf\"Non-matching dialogues in transaction behaviour: {self.processing} and {ledger_api_dialogue}\"\n)\nself.timedout.remove(ledger_api_dialogue.dialogue_label)\nself.context.logger.debug(\nf\"Timeout dialogue in transaction processing: {ledger_api_dialogue}\"\n)\n# don't reset, as another might be processing\ndef failed_processing(self, ledger_api_dialogue: LedgerApiDialogue) -&gt; None:\n\"\"\"\n        Failed processing.\n        Currently, we retry processing indefinitely.\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.finish_processing(ledger_api_dialogue)\nself.waiting.append(ledger_api_dialogue.associated_fipa_dialogue)\n</code></pre> <p>This <code>TickerBehaviour</code> will send a search query to the SOEF search node at regular tick intervals.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-3-create-the-handler_1","title":"Step 3: Create the Handler","text":"<p>So far, the AEA is tasked with sending search queries to the SOEF search node. However, currently the AEA has no way of handling the responses it receives from the SOEF or messages from other agents.</p> <p>Let us now implement <code>Handlers</code> to deal with the expected incoming messages. Open the <code>handlers.py</code> file (<code>my_generic_buyer/skills/generic_buyer/handlers.py</code>) and add the following code (replacing the stub code already present in the file):</p> <pre><code>import pprint\nfrom typing import Optional, cast\nfrom aea.configurations.base import PublicId\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.connections.ledger.base import (\nCONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID,\n)\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nfrom packages.fetchai.protocols.fipa.message import FipaMessage\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.protocols.signing.message import SigningMessage\nfrom packages.fetchai.skills.generic_buyer.behaviours import GenericTransactionBehaviour\nfrom packages.fetchai.skills.generic_buyer.dialogues import (\nDefaultDialogues,\nFipaDialogue,\nFipaDialogues,\nLedgerApiDialogue,\nLedgerApiDialogues,\nOefSearchDialogue,\nOefSearchDialogues,\nSigningDialogue,\nSigningDialogues,\n)\nfrom packages.fetchai.skills.generic_buyer.strategy import GenericStrategy\nLEDGER_API_ADDRESS = str(LEDGER_CONNECTION_PUBLIC_ID)\nclass GenericFipaHandler(Handler):\n\"\"\"This class implements a FIPA handler.\"\"\"\nSUPPORTED_PROTOCOL = FipaMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\nfipa_msg = cast(FipaMessage, message)\n# recover dialogue\nfipa_dialogues = cast(FipaDialogues, self.context.fipa_dialogues)\nfipa_dialogue = cast(FipaDialogue, fipa_dialogues.update(fipa_msg))\nif fipa_dialogue is None:\nself._handle_unidentified_dialogue(fipa_msg)\nreturn\n# handle message\nif fipa_msg.performative == FipaMessage.Performative.PROPOSE:\nself._handle_propose(fipa_msg, fipa_dialogue)\nelif fipa_msg.performative == FipaMessage.Performative.DECLINE:\nself._handle_decline(fipa_msg, fipa_dialogue, fipa_dialogues)\nelif fipa_msg.performative == FipaMessage.Performative.MATCH_ACCEPT_W_INFORM:\nself._handle_match_accept(fipa_msg, fipa_dialogue)\nelif fipa_msg.performative == FipaMessage.Performative.INFORM:\nself._handle_inform(fipa_msg, fipa_dialogue, fipa_dialogues)\nelse:\nself._handle_invalid(fipa_msg, fipa_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\n</code></pre> <p>You will see that we are following similar logic to the <code>generic_seller</code> when we develop the <code>generic_buyer</code>\u2019s side of the negotiation. First, we create a new dialogue and store it in the dialogues class. Then we are checking what kind of message we received by checking its performative. So lets start creating our handlers:</p> <pre><code>    def _handle_unidentified_dialogue(self, fipa_msg: FipaMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param fipa_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid fipa message={}, unidentified dialogue.\".format(fipa_msg)\n)\ndefault_dialogues = cast(DefaultDialogues, self.context.default_dialogues)\ndefault_msg, _ = default_dialogues.create(\ncounterparty=fipa_msg.sender,\nperformative=DefaultMessage.Performative.ERROR,\nerror_code=DefaultMessage.ErrorCode.INVALID_DIALOGUE,\nerror_msg=\"Invalid dialogue.\",\nerror_data={\"fipa_message\": fipa_msg.encode()},\n)\nself.context.outbox.put_message(message=default_msg)\n</code></pre> <p>The above code handles messages referencing unidentified dialogues and responds with an error message to the sender. Next we will handle the <code>PROPOSE</code> message received from the <code>my_generic_seller</code> AEA:</p> <pre><code>    def _handle_propose(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle the propose.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.info(\n\"received proposal={} from sender={}\".format(\nfipa_msg.proposal.values,\nfipa_msg.sender[-5:],\n)\n)\nstrategy = cast(GenericStrategy, self.context.strategy)\nacceptable = strategy.is_acceptable_proposal(fipa_msg.proposal)\naffordable = strategy.is_affordable_proposal(fipa_msg.proposal)\nif acceptable and affordable:\nself.context.logger.info(\n\"accepting the proposal from sender={}\".format(fipa_msg.sender[-5:])\n)\nterms = strategy.terms_from_proposal(fipa_msg.proposal, fipa_msg.sender)\nfipa_dialogue.terms = terms\naccept_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.ACCEPT,\ntarget_message=fipa_msg,\n)\nself.context.outbox.put_message(message=accept_msg)\nelse:\nself.context.logger.info(\n\"declining the proposal from sender={}\".format(fipa_msg.sender[-5:])\n)\ndecline_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.DECLINE,\ntarget_message=fipa_msg,\n)\nself.context.outbox.put_message(message=decline_msg)\n</code></pre> <p>When we receive a proposal, we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable, we respond with a <code>DECLINE</code> message. Otherwise, we send an <code>ACCEPT</code> message to the seller.</p> <p>The next code-block handles the <code>DECLINE</code> message that we may receive from the seller as a response to our <code>CFP</code> or <code>ACCEPT</code> messages:</p> <pre><code>    def _handle_decline(\nself,\nfipa_msg: FipaMessage,\nfipa_dialogue: FipaDialogue,\nfipa_dialogues: FipaDialogues,\n) -&gt; None:\n\"\"\"\n        Handle the decline.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the fipa dialogue\n        :param fipa_dialogues: the fipa dialogues\n        \"\"\"\nself.context.logger.info(\n\"received DECLINE from sender={}\".format(fipa_msg.sender[-5:])\n)\ntarget_message = fipa_dialogue.get_message_by_id(fipa_msg.target)\nif not target_message:\nraise ValueError(\"Can not find target message!\")  # pragma: nocover\ndeclined_performative = target_message.performative\nif declined_performative == FipaMessage.Performative.CFP:\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.DECLINED_CFP, fipa_dialogue.is_self_initiated\n)\nif declined_performative == FipaMessage.Performative.ACCEPT:\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.DECLINED_ACCEPT, fipa_dialogue.is_self_initiated\n)\n</code></pre> <p>The above code terminates each dialogue with the specific AEA and stores the state of the terminated dialogue (whether it was terminated after a <code>CFP</code> or an <code>ACCEPT</code>).</p> <p>If <code>my_generic_seller</code> AEA wants to move on with the sale, it will send a <code>MATCH_ACCEPT</code> message. In order to handle this we add the following code:</p> <pre><code>def _handle_match_accept(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle the match accept.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the dialogue object\n        \"\"\"\nself.context.logger.info(\n\"received MATCH_ACCEPT_W_INFORM from sender={} with info={}\".format(\nfipa_msg.sender[-5:], fipa_msg.info\n)\n)\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_ledger_tx:\ntransfer_address = fipa_msg.info.get(\"address\", None)\nif transfer_address is not None and isinstance(transfer_address, str):\nfipa_dialogue.terms.counterparty_address = (  # pragma: nocover\ntransfer_address\n)\ntx_behaviour = cast(\nGenericTransactionBehaviour, self.context.behaviours.transaction\n)\ntx_behaviour.waiting.append(fipa_dialogue)\nelse:\ninform_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.INFORM,\ntarget_message=fipa_msg,\ninfo={\"Done\": \"Sending payment via bank transfer\"},\n)\nself.context.outbox.put_message(message=inform_msg)\nself.context.logger.info(\n\"informing counterparty={} of payment.\".format(fipa_msg.sender[-5:])\n)\n</code></pre> <p>The first thing we are checking is if we enabled our AEA to transact with a ledger. If so, we add this negotiation to the queue of transactions to be processed. If not, we simulate non-ledger payment by sending an <code>inform</code> to the seller that the payment is done (say via bank transfer).</p> <p>Lastly, we need to handle <code>INFORM</code> messages. This is the message that will have our data:</p> <pre><code>    def _handle_inform(\nself,\nfipa_msg: FipaMessage,\nfipa_dialogue: FipaDialogue,\nfipa_dialogues: FipaDialogues,\n) -&gt; None:\n\"\"\"\n        Handle the match inform.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the fipa dialogue\n        :param fipa_dialogues: the fipa dialogues\n        \"\"\"\nself.context.logger.info(\n\"received INFORM from sender={}\".format(fipa_msg.sender[-5:])\n)\nif len(fipa_msg.info.keys()) &gt;= 1:\ndata = fipa_msg.info\ndata_string = pprint.pformat(data)[:1000]\nself.context.logger.info(f\"received the following data={data_string}\")\nfipa_dialogues.dialogue_stats.add_dialogue_endstate(\nFipaDialogue.EndState.SUCCESSFUL, fipa_dialogue.is_self_initiated\n)\nstrategy = cast(GenericStrategy, self.context.strategy)\nstrategy.successful_trade_with_counterparty(fipa_msg.sender, data)\nelse:\nself.context.logger.info(\n\"received no data from sender={}\".format(fipa_msg.sender[-5:])\n)\ndef _handle_invalid(\nself, fipa_msg: FipaMessage, fipa_dialogue: FipaDialogue\n) -&gt; None:\n\"\"\"\n        Handle a fipa message of invalid performative.\n        :param fipa_msg: the message\n        :param fipa_dialogue: the fipa dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle fipa message of performative={} in dialogue={}.\".format(\nfipa_msg.performative, fipa_dialogue\n)\n)\n</code></pre> <p>We now need to add handlers for messages received from the <code>DecisionMaker</code> and the SOEF search node. We need one handler for each type of protocol we use.</p> <p>To handle the messages in the <code>oef_search</code> protocol used by the SOEF search node we add the following code in the same file (<code>my_generic_buyer/skills/generic_buyer/handlers.py</code>):</p> <pre><code>class GenericOefSearchHandler(Handler):\n\"\"\"This class implements an OEF search handler.\"\"\"\nSUPPORTED_PROTOCOL = OefSearchMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Call to setup the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\noef_search_msg = cast(OefSearchMessage, message)\n# recover dialogue\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_dialogue = cast(\nOptional[OefSearchDialogue], oef_search_dialogues.update(oef_search_msg)\n)\nif oef_search_dialogue is None:\nself._handle_unidentified_dialogue(oef_search_msg)\nreturn\n# handle message\nif oef_search_msg.performative is OefSearchMessage.Performative.OEF_ERROR:\nself._handle_error(oef_search_msg, oef_search_dialogue)\nelif oef_search_msg.performative is OefSearchMessage.Performative.SEARCH_RESULT:\nself._handle_search(oef_search_msg, oef_search_dialogue)\nelse:\nself._handle_invalid(oef_search_msg, oef_search_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\ndef _handle_unidentified_dialogue(self, oef_search_msg: OefSearchMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param oef_search_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid oef_search message={}, unidentified dialogue.\".format(\noef_search_msg\n)\n)\ndef _handle_error(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nself.context.logger.info(\n\"received oef_search error message={} in dialogue={}.\".format(\noef_search_msg, oef_search_dialogue\n)\n)\ndef _handle_search(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle the search response.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nif len(oef_search_msg.agents) == 0:\nself.context.logger.info(\nf\"found no agents in dialogue={oef_search_dialogue}, continue searching.\"\n)\nreturn\nstrategy = cast(GenericStrategy, self.context.strategy)\nif strategy.is_stop_searching_on_result:\nself.context.logger.info(\n\"found agents={}, stopping search.\".format(\nlist(map(lambda x: x[-5:], oef_search_msg.agents)),\n)\n)\nstrategy.is_searching = False  # stopping search\nelse:\nself.context.logger.info(\n\"found agents={}.\".format(\nlist(map(lambda x: x[-5:], oef_search_msg.agents)),\n)\n)\nquery = strategy.get_service_query()\nfipa_dialogues = cast(FipaDialogues, self.context.fipa_dialogues)\ncounterparties = strategy.get_acceptable_counterparties(oef_search_msg.agents)\nfor counterparty in counterparties:\ncfp_msg, _ = fipa_dialogues.create(\ncounterparty=counterparty,\nperformative=FipaMessage.Performative.CFP,\nquery=query,\n)\nself.context.outbox.put_message(message=cfp_msg)\nself.context.logger.info(\n\"sending CFP to agent={}\".format(counterparty[-5:])\n)\ndef _handle_invalid(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle oef_search message of performative={} in dialogue={}.\".format(\noef_search_msg.performative,\noef_search_dialogue,\n)\n)\n</code></pre> <p>When we receive a message from the SOEF search node of a type <code>OefSearchMessage.Performative.SEARCH_RESULT</code>, we are passing the details to the relevant handler method. In the <code>_handle_search</code> function, we are checking that the response contains some agents, and we stop the search if it does. We pick our first agent and send a <code>CFP</code> message.</p> <p>The last handlers we need are the <code>GenericSigningHandler</code> and the <code>GenericLedgerApiHandler</code>. These handlers are responsible for <code>SigningMessages</code> that we receive from the <code>DecisionMaker</code>, and <code>LedgerApiMessages</code> that we receive from the ledger connection, respectively.</p> <pre><code>class GenericSigningHandler(Handler):\n\"\"\"Implement the signing handler.\"\"\"\nSUPPORTED_PROTOCOL = SigningMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\nsigning_msg = cast(SigningMessage, message)\n# recover dialogue\nsigning_dialogues = cast(SigningDialogues, self.context.signing_dialogues)\nsigning_dialogue = cast(\nOptional[SigningDialogue], signing_dialogues.update(signing_msg)\n)\nif signing_dialogue is None:\nself._handle_unidentified_dialogue(signing_msg)\nreturn\n# handle message\nif signing_msg.performative is SigningMessage.Performative.SIGNED_TRANSACTION:\nself._handle_signed_transaction(signing_msg, signing_dialogue)\nelif signing_msg.performative is SigningMessage.Performative.ERROR:\nself._handle_error(signing_msg, signing_dialogue)\nelse:\nself._handle_invalid(signing_msg, signing_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\ndef _handle_unidentified_dialogue(self, signing_msg: SigningMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param signing_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid signing message={}, unidentified dialogue.\".format(\nsigning_msg\n)\n)\ndef _handle_signed_transaction(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        \"\"\"\nself.context.logger.info(\"transaction signing was successful.\")\nledger_api_dialogue = signing_dialogue.associated_ledger_api_dialogue\nlast_ledger_api_msg = ledger_api_dialogue.last_incoming_message\nif last_ledger_api_msg is None:\nraise ValueError(\"Could not retrieve last message in ledger api dialogue\")\nledger_api_msg = ledger_api_dialogue.reply(\nperformative=LedgerApiMessage.Performative.SEND_SIGNED_TRANSACTION,\ntarget_message=last_ledger_api_msg,\nsigned_transaction=signing_msg.signed_transaction,\n)\nself.context.outbox.put_message(message=ledger_api_msg)\nself.context.logger.info(\"sending transaction to ledger.\")\ndef _handle_error(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        \"\"\"\nself.context.logger.info(\n\"transaction signing was not successful. Error_code={} in dialogue={}\".format(\nsigning_msg.error_code, signing_dialogue\n)\n)\nsigning_msg_ = cast(\nOptional[SigningMessage], signing_dialogue.last_outgoing_message\n)\nif (\nsigning_msg_ is not None\nand signing_msg_.performative\n== SigningMessage.Performative.SIGN_TRANSACTION\n):\ntx_behaviour = cast(\nGenericTransactionBehaviour, self.context.behaviours.transaction\n)\nledger_api_dialogue = signing_dialogue.associated_ledger_api_dialogue\ntx_behaviour.failed_processing(ledger_api_dialogue)\ndef _handle_invalid(\nself, signing_msg: SigningMessage, signing_dialogue: SigningDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param signing_msg: the signing message\n        :param signing_dialogue: the dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle signing message of performative={} in dialogue={}.\".format(\nsigning_msg.performative, signing_dialogue\n)\n)\nclass GenericLedgerApiHandler(Handler):\n\"\"\"Implement the ledger handler.\"\"\"\nSUPPORTED_PROTOCOL = LedgerApiMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup for the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        \"\"\"\nledger_api_msg = cast(LedgerApiMessage, message)\n# recover dialogue\nledger_api_dialogues = cast(\nLedgerApiDialogues, self.context.ledger_api_dialogues\n)\nledger_api_dialogue = cast(\nOptional[LedgerApiDialogue], ledger_api_dialogues.update(ledger_api_msg)\n)\nif ledger_api_dialogue is None:\nself._handle_unidentified_dialogue(ledger_api_msg)\nreturn\n# handle message\nif ledger_api_msg.performative is LedgerApiMessage.Performative.BALANCE:\nself._handle_balance(ledger_api_msg)\nelif (\nledger_api_msg.performative is LedgerApiMessage.Performative.RAW_TRANSACTION\n):\nself._handle_raw_transaction(ledger_api_msg, ledger_api_dialogue)\nelif (\nledger_api_msg.performative\n== LedgerApiMessage.Performative.TRANSACTION_DIGEST\n):\nself._handle_transaction_digest(ledger_api_msg, ledger_api_dialogue)\nelif (\nledger_api_msg.performative\n== LedgerApiMessage.Performative.TRANSACTION_RECEIPT\n):\nself._handle_transaction_receipt(ledger_api_msg, ledger_api_dialogue)\nelif ledger_api_msg.performative == LedgerApiMessage.Performative.ERROR:\nself._handle_error(ledger_api_msg, ledger_api_dialogue)\nelse:\nself._handle_invalid(ledger_api_msg, ledger_api_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\ndef _handle_unidentified_dialogue(self, ledger_api_msg: LedgerApiMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param ledger_api_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid ledger_api message={}, unidentified dialogue.\".format(\nledger_api_msg\n)\n)\ndef _handle_balance(self, ledger_api_msg: LedgerApiMessage) -&gt; None:\n\"\"\"\n        Handle a message of balance performative.\n        :param ledger_api_msg: the ledger api message\n        \"\"\"\nstrategy = cast(GenericStrategy, self.context.strategy)\nif ledger_api_msg.balance &gt; 0:\nself.context.logger.info(\n\"starting balance on {} ledger={}.\".format(\nstrategy.ledger_id,\nledger_api_msg.balance,\n)\n)\nstrategy.balance = ledger_api_msg.balance\nstrategy.is_searching = True\nelse:\nself.context.logger.warning(\nf\"you have no starting balance on {strategy.ledger_id} ledger! Stopping skill {self.skill_id}.\"\n)\nself.context.is_active = False\ndef _handle_raw_transaction(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of raw_transaction performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.info(\"received raw transaction={}\".format(ledger_api_msg))\nsigning_dialogues = cast(SigningDialogues, self.context.signing_dialogues)\nsigning_msg, signing_dialogue = signing_dialogues.create(\ncounterparty=self.context.decision_maker_address,\nperformative=SigningMessage.Performative.SIGN_TRANSACTION,\nraw_transaction=ledger_api_msg.raw_transaction,\nterms=ledger_api_dialogue.associated_fipa_dialogue.terms,\n)\nsigning_dialogue = cast(SigningDialogue, signing_dialogue)\nsigning_dialogue.associated_ledger_api_dialogue = ledger_api_dialogue\nself.context.decision_maker_message_queue.put_nowait(signing_msg)\nself.context.logger.info(\n\"proposing the transaction to the decision maker. Waiting for confirmation ...\"\n)\ndef _handle_transaction_digest(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of transaction_digest performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.info(\n\"transaction was successfully submitted. Transaction digest={}\".format(\nledger_api_msg.transaction_digest\n)\n)\nledger_api_msg_ = ledger_api_dialogue.reply(\nperformative=LedgerApiMessage.Performative.GET_TRANSACTION_RECEIPT,\ntarget_message=ledger_api_msg,\ntransaction_digest=ledger_api_msg.transaction_digest,\n)\nself.context.logger.info(\"checking transaction is settled.\")\nself.context.outbox.put_message(message=ledger_api_msg_)\ndef _handle_transaction_receipt(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of balance performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nfipa_dialogue = ledger_api_dialogue.associated_fipa_dialogue\nis_settled = LedgerApis.is_transaction_settled(\nfipa_dialogue.terms.ledger_id, ledger_api_msg.transaction_receipt.receipt\n)\ntx_behaviour = cast(\nGenericTransactionBehaviour, self.context.behaviours.transaction\n)\nif is_settled:\ntx_behaviour.finish_processing(ledger_api_dialogue)\nledger_api_msg_ = cast(\nOptional[LedgerApiMessage], ledger_api_dialogue.last_outgoing_message\n)\nif ledger_api_msg_ is None:\nraise ValueError(  # pragma: nocover\n\"Could not retrieve last ledger_api message\"\n)\nfipa_msg = cast(Optional[FipaMessage], fipa_dialogue.last_incoming_message)\nif fipa_msg is None:\nraise ValueError(\"Could not retrieve last fipa message\")\ninform_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.INFORM,\ntarget_message=fipa_msg,\ninfo={\"transaction_digest\": ledger_api_msg_.transaction_digest.body},\n)\nself.context.outbox.put_message(message=inform_msg)\nself.context.logger.info(\n\"transaction confirmed, informing counterparty={} of transaction digest.\".format(\nfipa_dialogue.dialogue_label.dialogue_opponent_addr[-5:],\n)\n)\nelse:\ntx_behaviour.failed_processing(ledger_api_dialogue)\nself.context.logger.info(\n\"transaction_receipt={} not settled or not valid, aborting\".format(\nledger_api_msg.transaction_receipt\n)\n)\ndef _handle_error(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of error performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.info(\n\"received ledger_api error message={} in dialogue={}.\".format(\nledger_api_msg, ledger_api_dialogue\n)\n)\nledger_api_msg_ = cast(\nOptional[LedgerApiMessage], ledger_api_dialogue.last_outgoing_message\n)\nif (\nledger_api_msg_ is not None\nand ledger_api_msg_.performative\n!= LedgerApiMessage.Performative.GET_BALANCE\n):\ntx_behaviour = cast(\nGenericTransactionBehaviour, self.context.behaviours.transaction\n)\ntx_behaviour.failed_processing(ledger_api_dialogue)\ndef _handle_invalid(\nself, ledger_api_msg: LedgerApiMessage, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"\n        Handle a message of invalid performative.\n        :param ledger_api_msg: the ledger api message\n        :param ledger_api_dialogue: the ledger api dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle ledger_api message of performative={} in dialogue={}.\".format(\nledger_api_msg.performative,\nledger_api_dialogue,\n)\n)\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-4-create-the-strategy_1","title":"Step 4: Create the Strategy","text":"<p>We are going to create the strategy that we want our AEA to follow. Rename the <code>my_model.py</code> file (in <code>my_generic_buyer/skills/generic_buyer/</code>) to <code>strategy.py</code> and replace the stub code with the following:</p> <pre><code>from typing import Any, Dict, List, Tuple\nfrom aea.common import Address\nfrom aea.exceptions import enforce\nfrom aea.helpers.search.generic import SIMPLE_SERVICE_MODEL\nfrom aea.helpers.search.models import (\nConstraint,\nConstraintType,\nDescription,\nLocation,\nQuery,\n)\nfrom aea.helpers.transaction.base import Terms\nfrom aea.skills.base import Model\nDEFAULT_IS_LEDGER_TX = True\nDEFAULT_MAX_UNIT_PRICE = 5\nDEFAULT_MAX_TX_FEE = 2\nDEFAULT_SERVICE_ID = \"generic_service\"\nDEFAULT_MIN_QUANTITY = 1\nDEFAULT_MAX_QUANTITY = 100\nDEFAULT_LOCATION = {\"longitude\": 0.1270, \"latitude\": 51.5194}\nDEFAULT_SEARCH_QUERY = {\n\"search_key\": \"seller_service\",\n\"search_value\": \"generic_service\",\n\"constraint_type\": \"==\",\n}\nDEFAULT_SEARCH_RADIUS = 5.0\nDEFAULT_MAX_NEGOTIATIONS = 2\nclass GenericStrategy(Model):\n\"\"\"This class defines a strategy for the agent.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize the strategy of the agent.\n        :param kwargs: keyword arguments\n        \"\"\"\nledger_id = kwargs.pop(\"ledger_id\", None)\ncurrency_id = kwargs.pop(\"currency_id\", None)\nself._is_ledger_tx = kwargs.pop(\"is_ledger_tx\", DEFAULT_IS_LEDGER_TX)\nself._max_unit_price = kwargs.pop(\"max_unit_price\", DEFAULT_MAX_UNIT_PRICE)\nself._min_quantity = kwargs.pop(\"min_quantity\", DEFAULT_MIN_QUANTITY)\nself._max_quantity = kwargs.pop(\"max_quantity\", DEFAULT_MAX_QUANTITY)\nself._max_tx_fee = kwargs.pop(\"max_tx_fee\", DEFAULT_MAX_TX_FEE)\nself._service_id = kwargs.pop(\"service_id\", DEFAULT_SERVICE_ID)\nself._search_query = kwargs.pop(\"search_query\", DEFAULT_SEARCH_QUERY)\nlocation = kwargs.pop(\"location\", DEFAULT_LOCATION)\nself._agent_location = Location(\nlatitude=location[\"latitude\"], longitude=location[\"longitude\"]\n)\nself._radius = kwargs.pop(\"search_radius\", DEFAULT_SEARCH_RADIUS)\nself._max_negotiations = kwargs.pop(\n\"max_negotiations\", DEFAULT_MAX_NEGOTIATIONS\n)\nself._is_stop_searching_on_result = kwargs.pop(\"stop_searching_on_result\", True)\nsuper().__init__(**kwargs)\nself._ledger_id = (\nledger_id if ledger_id is not None else self.context.default_ledger_id\n)\nif currency_id is None:\ncurrency_id = self.context.currency_denominations.get(self._ledger_id, None)\nenforce(\ncurrency_id is not None,\nf\"Currency denomination for ledger_id={self._ledger_id} not specified.\",\n)\nself._currency_id = currency_id\nself._is_searching = False\nself._balance = 0\n</code></pre> <p>Similar to the seller AEA, we initialize the strategy class by trying to read the strategy variables from the YAML file, and if not possible, use some default values. In the following snippet, the two methods after the properties are related to the OEF search service. Add this snippet under the initialization of the strategy class:</p> <pre><code>    @property\ndef ledger_id(self) -&gt; str:\n\"\"\"Get the ledger id.\"\"\"\nreturn self._ledger_id\n@property\ndef is_ledger_tx(self) -&gt; bool:\n\"\"\"Check whether or not tx are settled on a ledger.\"\"\"\nreturn self._is_ledger_tx\n@property\ndef is_stop_searching_on_result(self) -&gt; bool:\n\"\"\"Check if search is stopped on result.\"\"\"\nreturn self._is_stop_searching_on_result\n@property\ndef is_searching(self) -&gt; bool:\n\"\"\"Check if the agent is searching.\"\"\"\nreturn self._is_searching\n@is_searching.setter\ndef is_searching(self, is_searching: bool) -&gt; None:\n\"\"\"Check if the agent is searching.\"\"\"\nenforce(isinstance(is_searching, bool), \"Can only set bool on is_searching!\")\nself._is_searching = is_searching\n@property\ndef balance(self) -&gt; int:\n\"\"\"Get the balance.\"\"\"\nreturn self._balance\n@balance.setter\ndef balance(self, balance: int) -&gt; None:\n\"\"\"Set the balance.\"\"\"\nself._balance = balance\n@property\ndef max_negotiations(self) -&gt; int:\n\"\"\"Get the maximum number of negotiations the agent can start.\"\"\"\nreturn self._max_negotiations\ndef get_location_and_service_query(self) -&gt; Query:\n\"\"\"\n        Get the location and service query of the agent.\n        :return: the query\n        \"\"\"\nclose_to_my_service = Constraint(\n\"location\", ConstraintType(\"distance\", (self._agent_location, self._radius))\n)\nservice_key_filter = Constraint(\nself._search_query[\"search_key\"],\nConstraintType(\nself._search_query[\"constraint_type\"],\nself._search_query[\"search_value\"],\n),\n)\nquery = Query(\n[close_to_my_service, service_key_filter],\n)\nreturn query\ndef get_service_query(self) -&gt; Query:\n\"\"\"\n        Get the service query of the agent.\n        :return: the query\n        \"\"\"\nservice_key_filter = Constraint(\nself._search_query[\"search_key\"],\nConstraintType(\nself._search_query[\"constraint_type\"],\nself._search_query[\"search_value\"],\n),\n)\nquery = Query([service_key_filter], model=SIMPLE_SERVICE_MODEL)\nreturn query\n</code></pre> <p>The following code block checks if the proposal that we received is acceptable according to a strategy:</p> <pre><code>    def is_acceptable_proposal(self, proposal: Description) -&gt; bool:\n\"\"\"\n        Check whether it is an acceptable proposal.\n        :param proposal: a description\n        :return: whether it is acceptable\n        \"\"\"\nresult = (\nall(\nkey in proposal.values\nfor key in [\n\"ledger_id\",\n\"currency_id\",\n\"price\",\n\"service_id\",\n\"quantity\",\n\"tx_nonce\",\n]\n)\nand proposal.values[\"ledger_id\"] == self.ledger_id\nand proposal.values[\"price\"] &gt; 0\nand proposal.values[\"quantity\"] &gt;= self._min_quantity\nand proposal.values[\"quantity\"] &lt;= self._max_quantity\nand proposal.values[\"price\"]\n&lt;= proposal.values[\"quantity\"] * self._max_unit_price\nand proposal.values[\"currency_id\"] == self._currency_id\nand proposal.values[\"service_id\"] == self._service_id\nand isinstance(proposal.values[\"tx_nonce\"], str)\nand proposal.values[\"tx_nonce\"] != \"\"\n)\nreturn result\n</code></pre> <p>The <code>is_affordable_proposal</code> method in the following code block checks if we can afford the transaction based on the funds we have in our wallet on the ledger. The rest of the methods are self-explanatory.</p> <pre><code>    def is_affordable_proposal(self, proposal: Description) -&gt; bool:\n\"\"\"\n        Check whether it is an affordable proposal.\n        :param proposal: a description\n        :return: whether it is affordable\n        \"\"\"\nif self.is_ledger_tx:\npayable = proposal.values.get(\"price\", 0) + self._max_tx_fee\nresult = self.balance &gt;= payable\nelse:\nresult = True\nreturn result\ndef get_acceptable_counterparties(\nself, counterparties: Tuple[str, ...]\n) -&gt; Tuple[str, ...]:\n\"\"\"\n        Process counterparties and drop unacceptable ones.\n        :param counterparties: a tuple of counterparties\n        :return: list of counterparties\n        \"\"\"\nvalid_counterparties: List[str] = []\nfor idx, counterparty in enumerate(counterparties):\nif idx &lt; self.max_negotiations:\nvalid_counterparties.append(counterparty)\nreturn tuple(valid_counterparties)\ndef terms_from_proposal(\nself, proposal: Description, counterparty_address: Address\n) -&gt; Terms:\n\"\"\"\n        Get the terms from a proposal.\n        :param proposal: the proposal\n        :param counterparty_address: the counterparty\n        :return: terms\n        \"\"\"\nbuyer_address = self.context.agent_addresses[proposal.values[\"ledger_id\"]]\nterms = Terms(\nledger_id=proposal.values[\"ledger_id\"],\nsender_address=buyer_address,\ncounterparty_address=counterparty_address,\namount_by_currency_id={\nproposal.values[\"currency_id\"]: -proposal.values[\"price\"]\n},\nquantities_by_good_id={\nproposal.values[\"service_id\"]: proposal.values[\"quantity\"]\n},\nis_sender_payable_tx_fee=True,\nnonce=proposal.values[\"tx_nonce\"],\nfee_by_currency_id={proposal.values[\"currency_id\"]: self._max_tx_fee},\n)\nreturn terms\ndef successful_trade_with_counterparty(\nself, counterparty: str, data: Dict[str, str]\n) -&gt; None:\n\"\"\"\n        Do something on successful trade.\n        :param counterparty: the counterparty address\n        :param data: the data\n        \"\"\"\ndef update_search_query_params(self) -&gt; None:\n\"\"\"Update agent location and query for search.\"\"\"\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-5-create-the-dialogues_1","title":"Step 5: Create the Dialogues","text":"<p>As mentioned during the creation of the seller AEA, we should keep track of the various interactions an AEA has with others and this is done via dialogues. Create a new file and name it <code>dialogues.py</code> (in <code>my_generic_buyer/skills/generic_buyer/</code>). Inside this file add the following code:</p> <pre><code>from typing import Any, Optional, Type\nfrom aea.common import Address\nfrom aea.exceptions import AEAEnforceError, enforce\nfrom aea.helpers.transaction.base import Terms\nfrom aea.protocols.base import Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel\nfrom aea.skills.base import Model\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogue as BaseDefaultDialogue,\n)\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogues as BaseDefaultDialogues,\n)\nfrom packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue\nfrom packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues\nfrom packages.fetchai.protocols.fipa.message import FipaMessage\nfrom packages.fetchai.protocols.ledger_api.dialogues import (\nLedgerApiDialogue as BaseLedgerApiDialogue,\n)\nfrom packages.fetchai.protocols.ledger_api.dialogues import (\nLedgerApiDialogues as BaseLedgerApiDialogues,\n)\nfrom packages.fetchai.protocols.ledger_api.message import LedgerApiMessage\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogue as BaseOefSearchDialogue,\n)\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogues as BaseOefSearchDialogues,\n)\nfrom packages.fetchai.protocols.signing.dialogues import (\nSigningDialogue as BaseSigningDialogue,\n)\nfrom packages.fetchai.protocols.signing.dialogues import (\nSigningDialogues as BaseSigningDialogues,\n)\nfrom packages.fetchai.protocols.signing.message import SigningMessage\nDefaultDialogue = BaseDefaultDialogue\nclass DefaultDialogues(Model, BaseDefaultDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn DefaultDialogue.Role.AGENT\nBaseDefaultDialogues.__init__(\nself,\nself_address=self.context.agent_address,\nrole_from_first_message=role_from_first_message,\n)\nclass FipaDialogue(BaseFipaDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\n__slots__ = (\n\"_terms\",\n\"_associated_ledger_api_dialogue\",\n)\ndef __init__(\nself,\ndialogue_label: BaseDialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[FipaMessage] = FipaMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :param message_class: the message class\n        \"\"\"\nBaseFipaDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself._terms = None  # type: Optional[Terms]\n@property\ndef terms(self) -&gt; Terms:\n\"\"\"Get terms.\"\"\"\nif self._terms is None:\nraise AEAEnforceError(\"Terms not set!\")\nreturn self._terms\n@terms.setter\ndef terms(self, terms: Terms) -&gt; None:\n\"\"\"Set terms.\"\"\"\nenforce(self._terms is None, \"Terms already set!\")\nself._terms = terms\nclass FipaDialogues(Model, BaseFipaDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseFipaDialogue.Role.BUYER\nBaseFipaDialogues.__init__(\nself,\nself_address=self.context.agent_address,\nrole_from_first_message=role_from_first_message,\ndialogue_class=FipaDialogue,\n)\nclass LedgerApiDialogue(BaseLedgerApiDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\n__slots__ = (\"_associated_fipa_dialogue\",)\ndef __init__(\nself,\ndialogue_label: BaseDialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[LedgerApiMessage] = LedgerApiMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :param message_class: the message class\n        \"\"\"\nBaseLedgerApiDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself._associated_fipa_dialogue = None  # type: Optional[FipaDialogue]\n@property\ndef associated_fipa_dialogue(self) -&gt; FipaDialogue:\n\"\"\"Get associated_fipa_dialogue.\"\"\"\nif self._associated_fipa_dialogue is None:\nraise AEAEnforceError(\"FipaDialogue not set!\")\nreturn self._associated_fipa_dialogue\n@associated_fipa_dialogue.setter\ndef associated_fipa_dialogue(self, fipa_dialogue: FipaDialogue) -&gt; None:\n\"\"\"Set associated_fipa_dialogue\"\"\"\nenforce(self._associated_fipa_dialogue is None, \"FipaDialogue already set!\")\nself._associated_fipa_dialogue = fipa_dialogue\nclass LedgerApiDialogues(Model, BaseLedgerApiDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseLedgerApiDialogue.Role.AGENT\nBaseLedgerApiDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\ndialogue_class=LedgerApiDialogue,\n)\nOefSearchDialogue = BaseOefSearchDialogue\nclass OefSearchDialogues(Model, BaseOefSearchDialogues):\n\"\"\"This class keeps track of all oef_search dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseOefSearchDialogue.Role.AGENT\nBaseOefSearchDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\nclass SigningDialogue(BaseSigningDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\n__slots__ = (\"_associated_ledger_api_dialogue\",)\ndef __init__(\nself,\ndialogue_label: BaseDialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[SigningMessage] = SigningMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :param message_class: the message class\n        \"\"\"\nBaseSigningDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself._associated_ledger_api_dialogue = None  # type: Optional[LedgerApiDialogue]\n@property\ndef associated_ledger_api_dialogue(self) -&gt; LedgerApiDialogue:\n\"\"\"Get associated_ledger_api_dialogue.\"\"\"\nif self._associated_ledger_api_dialogue is None:\nraise AEAEnforceError(\"LedgerApiDialogue not set!\")\nreturn self._associated_ledger_api_dialogue\n@associated_ledger_api_dialogue.setter\ndef associated_ledger_api_dialogue(\nself, ledger_api_dialogue: LedgerApiDialogue\n) -&gt; None:\n\"\"\"Set associated_ledger_api_dialogue\"\"\"\nenforce(\nself._associated_ledger_api_dialogue is None,\n\"LedgerApiDialogue already set!\",\n)\nself._associated_ledger_api_dialogue = ledger_api_dialogue\nclass SigningDialogues(Model, BaseSigningDialogues):\n\"\"\"This class keeps track of all oef_search dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseSigningDialogue.Role.SKILL\nBaseSigningDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\ndialogue_class=SigningDialogue,\n)\n</code></pre> <p>The various dialogues classes in the above code snippet store dialogues with other AEAs, services and components, (e.g. SOEF search node via the <code>fetchai/soef</code> connection, ledgers via the <code>fetchai/ledger</code> connection and the decision maker). They expose useful methods to manipulate these interactions, access previous messages, and enable us to identify possible communications problems between <code>my_generic_seller</code> and <code>my_generic_buyer</code> AEAs.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#step-6-update-the-yaml-files_1","title":"Step 6: Update the YAML Files","text":"<p>After making so many changes to our skill, we have to update the <code>skill.yaml</code> configuration file so it reflects our newly created classes, and contains the values used by the strategy. Make sure <code>skill.yaml</code> contains the following configuration:</p> <pre><code>name: generic_buyer\nauthor: fetchai\nversion: 0.1.0\ntype: skill\ndescription: The weather client skill implements the skill to purchase weather data.\nlicense: Apache-2.0\naea_version: '&gt;=1.0.0, &lt;2.0.0'\nfingerprint:\nREADME.md: QmTR91jm7WfJpmabisy74NR5mc35YXjDU1zQAUKZeHRw8L\n__init__.py: QmU5vrC8FipyjfS5biNa6qDWdp4aeH5h4YTtbFDmCg8Chj\nbehaviours.py: QmNwvSjEz4kzM3gWtnKbZVFJc2Z85Nb748CWAK4C4Sa4nT\ndialogues.py: QmNen91qQDWy4bNBKrB3LabAP5iRf29B8iwYss4NB13iNU\nhandlers.py: QmZfudXXbdiREiViuwPZDXoQQyXT2ySQHdF7psQsohZXQy\nstrategy.py: QmcrwaEWvKHDCNti8QjRhB4utJBJn5L8GpD27Uy9zHwKhY\nfingerprint_ignore_patterns: []\nconnections:\n- fetchai/ledger:0.21.5\ncontracts: []\nprotocols:\n- fetchai/default:1.1.7\n- fetchai/fipa:1.1.7\n- fetchai/ledger_api:1.1.7\n- fetchai/oef_search:1.1.7\n- fetchai/signing:1.1.7\nskills: []\nbehaviours:\nsearch:\nargs:\nsearch_interval: 5\nclass_name: GenericSearchBehaviour\ntransaction:\nargs:\nmax_processing: 420\ntransaction_interval: 2\nclass_name: GenericTransactionBehaviour\nhandlers:\nfipa:\nargs: {}\nclass_name: GenericFipaHandler\nledger_api:\nargs: {}\nclass_name: GenericLedgerApiHandler\noef_search:\nargs: {}\nclass_name: GenericOefSearchHandler\nsigning:\nargs: {}\nclass_name: GenericSigningHandler\nmodels:\ndefault_dialogues:\nargs: {}\nclass_name: DefaultDialogues\nfipa_dialogues:\nargs: {}\nclass_name: FipaDialogues\nledger_api_dialogues:\nargs: {}\nclass_name: LedgerApiDialogues\noef_search_dialogues:\nargs: {}\nclass_name: OefSearchDialogues\nsigning_dialogues:\nargs: {}\nclass_name: SigningDialogues\nstrategy:\nargs:\nis_ledger_tx: true\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nmax_negotiations: 1\nmax_tx_fee: 3550000000000000\nmax_unit_price: 20\nmin_quantity: 1\nsearch_query:\nconstraint_type: ==\nsearch_key: seller_service\nsearch_value: generic_service\nsearch_radius: 5.0\nservice_id: generic_service\nstop_searching_on_result: true\nclass_name: GenericStrategy\nis_abstract: false\ndependencies: {}\n</code></pre> <p>We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading at, the maximum transaction fee we are prepared to pay, and so on.</p> <p>Finally, we fingerprint our new skill:</p> <pre><code>aea fingerprint skill fetchai/generic_buyer:0.1.0\n</code></pre> <p>This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#run-the-aeas","title":"Run the AEAs","text":""},{"location":"aea-framework-documentation/generic-skills-step-by-step/#create-private-keys","title":"Create Private Keys","text":"<p>For each AEA, create a private key:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#update-the-aea-configurations","title":"Update the AEA Configurations","text":"<p>In both AEAs run:</p> <pre><code>aea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#fund-the-buyer-aea","title":"Fund the Buyer AEA","text":"<p>Create some wealth for your buyer on the Fetch.ai testnet (this operation might take a while).</p> <pre><code>aea generate-wealth fetchai --sync\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#run-seller-aea","title":"Run Seller AEA","text":"<p>Add the remaining packages for the seller AEA, then run it:</p> <pre><code>aea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add protocol fetchai/fipa:1.1.7\naea install\naea build\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr: ['SOME_ADDRESS']</code> take note of the address.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#run-buyer-aea","title":"Run Buyer AEA","text":"<p>Add the remaining packages for the buyer AEA:</p> <pre><code>aea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add protocol fetchai/fipa:1.1.7\naea add protocol fetchai/signing:1.1.7\naea install\naea build\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\n</code></pre> <p>Then, update the configuration of the buyer AEA's P2P connection:</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>where <code>SOME_ADDRESS</code> is replaced accordingly.</p> <p>Then run the buyer AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that the AEAs negotiate and then transact using the Dorado testnet.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#delete-the-aeas","title":"Delete the AEAs","text":"<p>When you are done, go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete my_generic_seller\naea delete my_generic_buyer\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#next-steps","title":"Next Steps","text":"<p>You have completed the \"Getting Started\" series. Congratulations!</p> <p>The following guide provides some hints on AEA development setup.</p>"},{"location":"aea-framework-documentation/generic-skills-step-by-step/#recommended","title":"Recommended","text":"<p>We recommend you build your own AEA next. There are many helpful guides and demos in the documentation, and a developer community on Discord. Speak to you there!</p>"},{"location":"aea-framework-documentation/generic-skills/","title":"Generic Skills","text":"<p>The AEA generic buyer and seller skills demonstrate an interaction between two AEAs:</p> <ul> <li>An AEA that provides a (data selling) service.</li> <li>An AEA that demands this service.</li> </ul>"},{"location":"aea-framework-documentation/generic-skills/#discussion","title":"Discussion","text":"<p>The scope of this guide is demonstrating how to create easily configurable AEAs. The buyer AEA finds the seller, negotiates the terms of trade, and if successful purchases the data by sending payment. The seller AEA sells the service specified in its <code>skill.yaml</code> file, delivering it to the buyer upon receiving payment.</p> <p>Note that these agents do not utilize a smart contract but interact with a ledger to complete a transaction. Moreover, in this setup, the buyer agent has to trust the seller to send the data upon successful payment.</p> <p>The corresponding packages can be customised to allow for a database or sensor to be defined from which data is loaded. This is done by first modifying the <code>has_data_source</code> variable in <code>skill.yaml</code> file of the <code>generic_seller</code> skill to <code>True</code>. Then you have to provide an implementation for the <code>collect_from_data_source(self)</code> method in the <code>strategy.py</code> file. More detailed instructions is beyond the scope of this guide.</p>"},{"location":"aea-framework-documentation/generic-skills/#communication","title":"Communication","text":"<p>The following diagram shows the communication between various entities in this interaction.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Buyer_AEA\n        participant Seller_AEA\n        participant Blockchain\n\n        activate Buyer_AEA\n        activate Search\n        activate Seller_AEA\n        activate Blockchain\n\n        Seller_AEA-&gt;&gt;Search: register_service\n        Buyer_AEA-&gt;&gt;Search: search_agents\n        Search--&gt;&gt;Buyer_AEA: list_of_agents\n        Buyer_AEA-&gt;&gt;Seller_AEA: call_for_proposal\n        Seller_AEA-&gt;&gt;Buyer_AEA: propose\n        Buyer_AEA-&gt;&gt;Seller_AEA: accept\n        Seller_AEA-&gt;&gt;Buyer_AEA: match_accept\n        Buyer_AEA-&gt;&gt;Blockchain: transfer_funds\n        Buyer_AEA-&gt;&gt;Seller_AEA: send_transaction_hash\n        Seller_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Seller_AEA-&gt;&gt;Buyer_AEA: send_data\n\n        deactivate Buyer_AEA\n        deactivate Search\n        deactivate Seller_AEA\n        deactivate Blockchain </code></pre>"},{"location":"aea-framework-documentation/generic-skills/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/generic-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/generic-skills/#demo-instructions","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/generic-skills/#create-the-seller-aea","title":"Create the Seller AEA","text":"<p>First, fetch the seller AEA:</p> <pre><code>aea fetch fetchai/generic_seller:0.29.5 --alias my_seller_aea\ncd my_seller_aea\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the seller from scratch:</p> <pre><code>aea create my_seller_aea\ncd my_seller_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/generic_seller:0.28.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#create-the-buyer-aea","title":"Create the Buyer AEA","text":"<p>Then, in another terminal fetch the buyer AEA:</p> <pre><code>aea fetch fetchai/generic_buyer:0.30.5 --alias my_buyer_aea\ncd my_buyer_aea\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the buyer from scratch:</p> <pre><code>aea create my_buyer_aea\ncd my_buyer_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/generic_buyer:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#add-keys-for-the-seller-aea","title":"Add Keys for the Seller AEA","text":"<p>Create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#add-keys-and-generate-wealth-for-the-buyer-aea","title":"Add Keys and Generate Wealth for the Buyer AEA","text":"<p>The buyer needs to have some wealth to purchase the data from the seller.</p> <p>First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai <code>Dorado</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#update-the-skill-configurations","title":"Update the Skill Configurations","text":"<p>The default skill configurations assume that the transaction is settled against the Fetch.ai ledger.</p> <p>In the generic seller's skill configuration file (<code>my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml</code>) the <code>data_for_sale</code> is the data the seller AEA is offering for sale. In the following case, this is a one item dictionary where key is <code>generic</code> and value is <code>data</code>.</p> <p>Furthermore, the <code>service_data</code> is used to register the seller's service in the SOEF search node and make your agent discoverable.</p> <pre><code>models:\n...\nstrategy:\nargs:\ncurrency_id: FET\ndata_for_sale:\ngeneric: data\nhas_data_source: false\nis_ledger_tx: true\nledger_id: fetchai\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nservice_data:\nkey: seller_service\nvalue: generic_service\nservice_id: generic_service\nunit_price: 10\nclass_name: GenericStrategy\n</code></pre> <p>The generic buyer skill configuration file (<code>my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml</code>) includes the <code>search_query</code> which has to match the <code>service_data</code> of the seller.</p> <pre><code>models:\n...\nstrategy:\nargs:\ncurrency_id: FET\nis_ledger_tx: true\nledger_id: fetchai\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nmax_negotiations: 1\nmax_tx_fee: 3550000000000000\nmax_unit_price: 20\nsearch_query:\nconstraint_type: ==\nsearch_key: seller_service\nsearch_value: generic_service\nsearch_radius: 5.0\nservice_id: generic_service\nclass_name: GenericStrategy\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#update-the-skill-configurations_1","title":"Update the Skill Configurations","text":"<p>Both skills are abstract skills, make them instantiable:</p> <pre><code>cd my_seller_aea\naea config set vendor.fetchai.skills.generic_seller.is_abstract false --type bool\n</code></pre> <pre><code>cd my_buyer_aea\naea config set vendor.fetchai.skills.generic_buyer.is_abstract false --type bool\n</code></pre>"},{"location":"aea-framework-documentation/generic-skills/#run-the-aeas","title":"Run the AEAs","text":"<p>First, run the seller AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of this address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the seller.</p> <p>Then, configure the buyer to connect to this same local ACN by running the following command in the buyer terminal, replacing <code>SOME_ADDRESS</code> with the value you noted above:</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Then run the buyer AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.</p>"},{"location":"aea-framework-documentation/generic-skills/#delete-the-aeas","title":"Delete the AEAs","text":"<p>When you're done, stop the agents (<code>CTRL+C</code>), go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete my_seller_aea\naea delete my_buyer_aea\n</code></pre>"},{"location":"aea-framework-documentation/generic-storage/","title":"Generic Storage","text":"<p>The AEA generic storage: description and usage.</p>"},{"location":"aea-framework-documentation/generic-storage/#aea-generic-storage","title":"AEA Generic Storage","text":"<p>AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style.</p>"},{"location":"aea-framework-documentation/generic-storage/#configuration","title":"Configuration","text":"<p>Storage is enabled by providing in the agent configuration (<code>aea-config.yaml</code>) an optional <code>storage_uri</code>. The storage URI consists of the backend name and string data provided to selected backend.</p> <p>The storage URI schema is <code>&lt;BACKEND_NAME&gt;://[Optional string]</code> Example: <code>storage_uri: sqlite://./some_file.db</code> tells the AEA to use SQLite backend and store data in <code>./some_file.db</code>.</p> <p>Supported backends:</p> <ul> <li>SQLite - bundled with python simple SQL engine that uses file or in-memory storage.</li> </ul>"},{"location":"aea-framework-documentation/generic-storage/#dialogues-and-storage-integration","title":"Dialogues and Storage Integration","text":"<p>One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature.</p>"},{"location":"aea-framework-documentation/generic-storage/#keep-terminal-state-dialogues","title":"Keep Terminal State Dialogues","text":"<p>The Dialogues class has the optional boolean argument <code>keep_terminal_state_dialogues</code> which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If <code>keep_terminal_state_dialogues</code> is <code>False</code>, dialogues that reach a terminal state are removed from memory and can not be used anymore. If <code>keep_terminal_state_dialogues</code> is <code>True</code>, dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start.</p> <p>It is useful to save memory with terminated dialogues that will (possibly) be never used again.</p> <p>Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section.</p> <p>Skill configuration to keep terminated dialogues for <code>DefaultDialogues</code>. Example:</p>"},{"location":"aea-framework-documentation/generic-storage/#dialogues-dumprestore-on-agent-restart","title":"Dialogues Dump/Restore on Agent Restart","text":"<p>If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start.</p>"},{"location":"aea-framework-documentation/generic-storage/#offload-terminal-state-dialogues","title":"Offload Terminal State Dialogues","text":"<p>If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory.</p> <p>All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart.</p> <p>To enable dialogues offloading <code>keep_terminal_state_dialogues</code> has to be enabled and storage configured.</p>"},{"location":"aea-framework-documentation/generic-storage/#manual-usage-with-skill-components","title":"Manual Usage with Skill Components","text":"<p>Handlers, Behaviours and Models are able to use storage if enabled.</p> <p>Storage is available with skill context: <code>self.context.storage</code> if <code>self.context.storage</code> is not None, storage is enabled and ready to use.</p> <p>Generic storage consists of two parts: objects and collections. Objects consist of the <code>object_id</code> (unique string) and object body. The object body is any JSON friendly python data type: <code>list</code>, <code>dict</code>, <code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code>.</p> <p>Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and <code>_</code>.</p> <p>To get/put specific object collection instance should be used.</p> <pre><code>my_collection = self.context.storage.get_sync_connection('my_collection')\n</code></pre> <p>Collection instance provide set of methods to handle data objects. List of collection methods:</p> <pre><code>    def put(self, object_id: str, object_body: JSON_TYPES) -&gt; None:\n\"\"\"\n        Put object into collection.\n        :param object_id: str object id\n        :param object_body: python dict, json compatible.\n        :return: None\n        \"\"\"\ndef get(self, object_id: str) -&gt; Optional[JSON_TYPES]:\n\"\"\"\n        Get object from the collection.\n        :param object_id: str object id\n        :return: dict if object exists in collection otherwise None\n        \"\"\"\ndef remove(self, object_id: str) -&gt; None:\n\"\"\"\n        Remove object from the collection.\n        :param object_id: str object id\n        :return: None\n        \"\"\"\ndef find(self, field: str, equals: EQUALS_TYPE) -&gt; List[OBJECT_ID_AND_BODY]:\n\"\"\"\n        Get objects from the collection by filtering by field value.\n        :param field: field name to search: example \"parent.field\"\n        :param equals: value field should be equal to\n        :return: List of object bodies\n        \"\"\"\ndef list(self) -&gt; List[OBJECT_ID_AND_BODY]:\n\"\"\"\n        List all objects with keys from the collection.\n        :return: Tuple of objects keys, bodies.\n        \"\"\"\n</code></pre> <p>Simple behaviour example:</p> <p>It saves the <code>datetime</code> string of the first act and print it to stdout.</p> <pre><code>class TestBehaviour(TickerBehaviour):\n\"\"\"Simple behaviour to count how many acts were called.\"\"\"\ndef setup(self) -&gt; None:\n\"\"\"Set up behaviour.\"\"\"\ndef act(self) -&gt; None:\n\"\"\"Make an action.\"\"\"\nif not (self.context.storage and self.context.storage.is_connected):\nreturn\ncollection = self.context.storage.get_sync_collection('my_collection')\nfirst_call_datetime = collection.get(\"first_call_ts\")\nif not first_call_ts:\n# there is no object with \"first_call_ts\" id.\nfirst_call_datetime = str(datetime.datetime.now())\ncol.put(first_call_ts, first_call_datetime)\nprint(\"Act was called for the first time on:\", first_call_datetime)\n</code></pre> <p>Please, pay attention: <code>datetime</code> object is not JSON friendly and can not be stored directly. it should be transformed to <code>timestamp</code> or string before put into the storage.</p>"},{"location":"aea-framework-documentation/glossary/","title":"Glossary","text":"<p>This glossary defines a number of terms commonly used across the documentation. For the definitions of framework components consult the API docs.</p> <ul> <li> <p>AEA (Autonomous Economic Agent): An AEA is \"an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner\". AEAs are a special type of agent. [more]</p> </li> <li> <p>Software Agent: a software agent is a computer program that acts on behalf of an entity (e.g. individual, organisation, business). [more]</p> </li> <li> <p>sOEF (Simple Open Economic Framework): The simple-OEF, or sOEF, is a search and discovery service for autonomous economic agents. [more]</p> </li> <li> <p>ACN (Agent Communication Network): The ACN is a peer-to-peer communication network for autonomous economic agents. [more]</p> </li> </ul>"},{"location":"aea-framework-documentation/gym-example/","title":"Gym Example","text":"<p>The <code>gym</code> example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's <code>gym</code> framework.</p>"},{"location":"aea-framework-documentation/gym-example/#discussion","title":"Discussion","text":"<p>There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster).</p> <p>However, the example decouples the RL agent from the <code>gym.Env</code> allowing them to run in separate execution environments, potentially owned by different entities.</p>"},{"location":"aea-framework-documentation/gym-example/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/gym-example/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p> <p>Download the necessary directories into your working directory:</p> <pre><code>svn export https://github.com/fetchai/agents-aea.git/trunk/examples\nsvn export https://github.com/fetchai/agents-aea.git/trunk/packages\n</code></pre> <p>Install the <code>gym</code> and <code>numpy</code> library.</p> <pre><code>pip install numpy gym\n</code></pre>"},{"location":"aea-framework-documentation/gym-example/#demo-instructions","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/gym-example/#run-the-example","title":"Run the Example","text":"<pre><code>python examples/gym_ex/train.py\n</code></pre> <p>Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation.</p> <p>Note how <code>train.py</code> demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI <code>gym.Env</code> and a standard RL agent.</p> <p>It is just one line of code to introduce the proxy agent and proxy environment!</p> <pre><code>from gyms.env import BanditNArmedRandom\nfrom proxy.env import ProxyEnv\nfrom rl.agent import RLAgent\nif __name__ == \"__main__\":\nNB_GOODS = 10\nNB_PRICES_PER_GOOD = 100\nNB_STEPS = 4000\n# Use any gym.Env compatible environment:\ngym_env = BanditNArmedRandom(nb_bandits=NB_GOODS, nb_prices_per_bandit=NB_PRICES_PER_GOOD)\n# Pass the gym environment to a proxy environment:\nproxy_env = ProxyEnv(gym_env)\n# Use any RL agent compatible with the gym environment and call the fit method:\nrl_agent = RLAgent(nb_goods=NB_GOODS)\nrl_agent.fit(env=proxy_env, nb_steps=NB_STEPS)\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/","title":"Gym Skill","text":"<p>The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection.</p>"},{"location":"aea-framework-documentation/gym-skill/#discussion","title":"Discussion","text":"<p>The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the <code>gym.Env</code> allowing them to run in separate execution environments, potentially owned by different entities.</p>"},{"location":"aea-framework-documentation/gym-skill/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/gym-skill/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p> <p>Download the necessary directories into your working directory:</p> <pre><code>mkdir gym_skill_agent\nsvn export https://github.com/fetchai/agents-aea.git/trunk/examples\n</code></pre> <p>Install the <code>gym</code> and <code>numpy</code> library.</p> <pre><code>pip install numpy gym\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#demo-instructions","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/gym-skill/#create-the-aea","title":"Create the AEA","text":"<p>First, fetch the gym AEA:</p> <pre><code>aea fetch fetchai/gym_aea:0.26.5 --alias my_gym_aea\ncd my_gym_aea\naea install\n</code></pre> Alternatively, create from scratch:"},{"location":"aea-framework-documentation/gym-skill/#create-the-aea_1","title":"Create the AEA","text":"<p>In the root directory, create the gym AEA and enter the project.</p> <pre><code>aea create my_gym_aea\ncd my_gym_aea\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#add-the-gym-skill","title":"Add the gym skill","text":"<pre><code>aea add skill fetchai/gym:0.21.6\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#set-gym-connection-as-default","title":"Set gym connection as default","text":"<pre><code>aea config set agent.default_connection fetchai/gym:0.20.6\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#install-the-skill-dependencies","title":"Install the skill dependencies","text":"<p>To install the <code>gym</code> package, a dependency of the gym skill, from PyPI run</p> <pre><code>aea install\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#set-up-the-training-environment","title":"Set up the Training Environment","text":""},{"location":"aea-framework-documentation/gym-skill/#copy-the-gym-environment-to-the-aea-directory","title":"Copy the Gym Environment to the AEA Directory","text":"<pre><code>mkdir gyms\ncp -a ../examples/gym_ex/gyms/. gyms/\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#update-the-connection-configuration","title":"Update the Connection Configuration","text":"<pre><code>aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#create-and-add-a-private-key","title":"Create and Add a Private Key","text":"<pre><code>aea generate-key fetchai\naea add-key fetchai\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#run-the-aea-with-the-gym-connection","title":"Run the AEA with the Gym Connection","text":"<pre><code>aea run\n</code></pre> <p>You will see the gym training logs.</p> <p></p>"},{"location":"aea-framework-documentation/gym-skill/#delete-the-aea","title":"Delete the AEA","text":"<p>When you're done, you can go up a level and delete the AEA.</p> <pre><code>cd ..\naea delete my_gym_aea\n</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#communication","title":"Communication","text":"<p>This diagram shows the communication between the AEA and the gym environment</p> <pre><code>    sequenceDiagram\n        participant AEA\n        participant Environment\n\n        activate AEA\n        activate Environment\n        AEA-&gt;&gt;Environment: reset\n        loop learn\n            AEA-&gt;&gt;Environment: act\n            Environment-&gt;&gt;AEA: percept\n        end\n        AEA-&gt;&gt;Environment: close\n\n        deactivate AEA\n        deactivate Environment</code></pre>"},{"location":"aea-framework-documentation/gym-skill/#skill-architecture","title":"Skill Architecture","text":"<p>The skill consists of two core components: <code>GymHandler</code> and <code>GymTask</code>.</p> <p>In the <code>setup</code> method of the <code>GymHandler</code> the <code>GymTask</code> is initialized, as well as its <code>setup</code> and <code>execute</code> methods called. The handler, which is registered against the <code>GymMessage.protocol_id</code> then filters for messages of that protocol with the performative <code>GymMessage.Performative.PERCEPT</code>. These messages are passed to the <code>proxy_env_queue</code> of the task.</p> <p>The <code>GymTask</code> is responsible for training the RL agent. In particular, <code>MyRLAgent</code> is initialized and trained against <code>ProxyEnv</code>. The <code>ProxyEnv</code> instantiates a <code>gym.Env</code> class and therefore implements its API. This means the proxy environment is compatible with any <code>gym</code> compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the <code>gym.env</code> from the process environment of the RL agent. The actual <code>gym.env</code> against which the agent is trained is wrapped by the <code>gym</code> connection. The proxy environment and gym connection communicate via a protocol, the <code>gym</code> protocol. Note, it would trivially be possible to implement the <code>gym</code> environment in another AEA; this way one AEA could provide <code>gym</code> environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent.</p> <p>In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of <code>n</code> goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the <code>n</code> goods on each training step and then chooses as an <code>action</code> the price which it deems is most likely accepted. Each good is represented by an id and the possible price range <code>[1,100]</code> divided into 100 integer bins. For each price bin, a <code>PriceBandit</code> is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution. The beta distribution is initialized to the uniform distribution. Each time the price associated with a given <code>PriceBandit</code> is accepted or rejected the distribution maintained by the <code>PriceBandit</code> is updated. For each good, the agent can therefore over time learn which price is most likely.</p> <p></p> <p>The illustration shows how the RL agent only interacts with the proxy environment by sending it <code>action (A)</code> and receiving <code>observation (O)</code>, <code>reward (R)</code>, <code>done (D)</code> and  <code>info (I)</code>.</p>"},{"location":"aea-framework-documentation/http-connection-and-skill/","title":"HTTP Connection","text":""},{"location":"aea-framework-documentation/http-connection-and-skill/#description","title":"Description","text":"<p>The HTTP client and HTTP server connections enable an AEA to communicate with external servers, respectively clients, via HTTP.</p> <p>The HTTP client connection receives request envelops from an agent's skill, translates each into an HTTP request and sends it to a server external to the agent. If it receives an HTTP response from the server within a timeout window, it translates it into a response envelope, and sends this back to the relevant skill inside the agent.</p> <p>The HTTP server connection allows you to run a server inside the connection itself which accepts requests from clients external to the agent. The HTTP server connection validates requests it receives against a provided OpenAPI file. It translates each valid request into an envelope and sends it to the skill specified in the <code>connections</code> configuration. If it receives a valid response envelope from the skill within a timeout window, the connection translates the response envelope into an HTTP response and serves it to the client.</p>"},{"location":"aea-framework-documentation/http-connection-and-skill/#http-client","title":"HTTP Client","text":"<p>The <code>fetchai/simple_data_request:0.14.6</code> skill demonstrates a simple use case of the HTTP Client connection.</p> <p>The <code>HttpRequestBehaviour</code> in <code>behaviours.py</code> periodically sends HTTP envelops to the HTTP client connection. Its <code>act()</code> method, periodically called, simply calls <code>_generate_http_request</code> which contains the logic for enqueueing an HTTP request envelop.</p> <p>The <code>HttpHandler</code> in <code>handler.py</code> is a basic handler for dealing with HTTP response envelops received from the HTTP client connection. In the <code>handle()</code> method, the responses are dealt with by the private <code>_handle_response</code> method which essentially logs the response and adds the body of the response into the skill's shared state.</p>"},{"location":"aea-framework-documentation/http-connection-and-skill/#http-server","title":"HTTP Server","text":"<p>Create a new AEA:</p> <pre><code>aea create my_aea\ncd my_aea\n</code></pre> <p>Add the http server connection package:</p> <pre><code>aea add connection fetchai/http_server:0.23.6\n</code></pre> <p>Update the default connection:</p> <pre><code>aea config set agent.default_connection fetchai/http_server:0.23.6\n</code></pre> <p>Modify the <code>api_spec_path</code>:</p> <pre><code>aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\"\n</code></pre> <p>Ensure the file exists under the specified path!</p> <p>Create and add a private key:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai\n</code></pre> <p>Install the dependencies:</p> <pre><code>aea install\n</code></pre> <p>Write and add your skill:</p> <pre><code>aea scaffold skill http_echo\n</code></pre> <p>You can implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success.</p> <p>First, delete the <code>my_model.py</code> and <code>behaviour.py</code> files (in <code>my_aea/skills/http_echo/</code>). The server will be purely reactive, so you only need the <code>handlers.py</code> file, and the <code>dialogues.py</code> to record the state of the dialogues. Update <code>skill.yaml</code> accordingly, so set <code>models: {}</code> and <code>behaviours: {}</code>.</p> <p>Next implement a basic handler which prints the received envelopes and responds.</p> <p>Then, replace the content of <code>handlers.py</code> with the following code snippet, after having replaced the placeholder <code>YOUR_USERNAME</code> with the author username (i.e. the output of <code>aea config get agent.author</code>):</p> <pre><code>import json\nfrom typing import cast\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.protocols.default import DefaultMessage\nfrom packages.fetchai.protocols.http.message import HttpMessage\nfrom packages.YOUR_USERNAME.skills.http_echo.dialogues import (\nDefaultDialogues,\nHttpDialogue,\nHttpDialogues,\n)\nclass HttpHandler(Handler):\n\"\"\"This implements the echo handler.\"\"\"\nSUPPORTED_PROTOCOL = HttpMessage.protocol_id\ndef setup(self) -&gt; None:\n\"\"\"Implement the setup.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to an envelope.\n        :param message: the message\n        \"\"\"\nhttp_msg = cast(HttpMessage, message)\n# recover dialogue\nhttp_dialogues = cast(HttpDialogues, self.context.http_dialogues)\nhttp_dialogue = cast(HttpDialogue, http_dialogues.update(http_msg))\nif http_dialogue is None:\nself._handle_unidentified_dialogue(http_msg)\nreturn\n# handle message\nif http_msg.performative == HttpMessage.Performative.REQUEST:\nself._handle_request(http_msg, http_dialogue)\nelse:\nself._handle_invalid(http_msg, http_dialogue)\ndef _handle_unidentified_dialogue(self, http_msg: HttpMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param http_msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid http message={}, unidentified dialogue.\".format(http_msg)\n)\ndefault_dialogues = cast(DefaultDialogues, self.context.default_dialogues)\ndefault_msg, _ = default_dialogues.create(\ncounterparty=http_msg.sender,\nperformative=DefaultMessage.Performative.ERROR,\nerror_code=DefaultMessage.ErrorCode.INVALID_DIALOGUE,\nerror_msg=\"Invalid dialogue.\",\nerror_data={\"http_message\": http_msg.encode()},\n)\nself.context.outbox.put_message(message=default_msg)\ndef _handle_request(\nself, http_msg: HttpMessage, http_dialogue: HttpDialogue\n) -&gt; None:\n\"\"\"\n        Handle a Http request.\n        :param http_msg: the http message\n        :param http_dialogue: the http dialogue\n        \"\"\"\nself.context.logger.info(\n\"received http request with method={}, url={} and body={!r}\".format(\nhttp_msg.method,\nhttp_msg.url,\nhttp_msg.body,\n)\n)\nif http_msg.method == \"get\":\nself._handle_get(http_msg, http_dialogue)\nelif http_msg.method == \"post\":\nself._handle_post(http_msg, http_dialogue)\ndef _handle_get(self, http_msg: HttpMessage, http_dialogue: HttpDialogue) -&gt; None:\n\"\"\"\n        Handle a Http request of verb GET.\n        :param http_msg: the http message\n        :param http_dialogue: the http dialogue\n        \"\"\"\nhttp_response = http_dialogue.reply(\nperformative=HttpMessage.Performative.RESPONSE,\ntarget_message=http_msg,\nversion=http_msg.version,\nstatus_code=200,\nstatus_text=\"Success\",\nheaders=http_msg.headers,\nbody=json.dumps({\"tom\": {\"type\": \"cat\", \"age\": 10}}).encode(\"utf-8\"),\n)\nself.context.logger.info(\"responding with: {}\".format(http_response))\nself.context.outbox.put_message(message=http_response)\ndef _handle_post(self, http_msg: HttpMessage, http_dialogue: HttpDialogue) -&gt; None:\n\"\"\"\n        Handle a Http request of verb POST.\n        :param http_msg: the http message\n        :param http_dialogue: the http dialogue\n        \"\"\"\nhttp_response = http_dialogue.reply(\nperformative=HttpMessage.Performative.RESPONSE,\ntarget_message=http_msg,\nversion=http_msg.version,\nstatus_code=200,\nstatus_text=\"Success\",\nheaders=http_msg.headers,\nbody=http_msg.body,\n)\nself.context.logger.info(\"responding with: {}\".format(http_response))\nself.context.outbox.put_message(message=http_response)\ndef _handle_invalid(\nself, http_msg: HttpMessage, http_dialogue: HttpDialogue\n) -&gt; None:\n\"\"\"\n        Handle an invalid http message.\n        :param http_msg: the http message\n        :param http_dialogue: the http dialogue\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle http message of performative={} in dialogue={}.\".format(\nhttp_msg.performative, http_dialogue\n)\n)\ndef teardown(self) -&gt; None:\n\"\"\"Implement the handler teardown.\"\"\"\n</code></pre> <p>Moreover, add a <code>dialogues.py</code> file with the following code:</p> <pre><code>from typing import Any\nfrom aea.protocols.base import Address, Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.skills.base import Model\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogue as BaseDefaultDialogue,\n)\nfrom packages.fetchai.protocols.default.dialogues import (\nDefaultDialogues as BaseDefaultDialogues,\n)\nfrom packages.fetchai.protocols.http.dialogues import HttpDialogue as BaseHttpDialogue\nfrom packages.fetchai.protocols.http.dialogues import HttpDialogues as BaseHttpDialogues\nDefaultDialogue = BaseDefaultDialogue\nclass DefaultDialogues(Model, BaseDefaultDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn DefaultDialogue.Role.AGENT\nBaseDefaultDialogues.__init__(\nself,\nself_address=self.context.agent_address,\nrole_from_first_message=role_from_first_message,\n)\nHttpDialogue = BaseHttpDialogue\nclass HttpDialogues(Model, BaseHttpDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param kwargs: keyword arguments\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseHttpDialogue.Role.SERVER\nBaseHttpDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\n</code></pre> <p>Then, update the <code>skill.yaml</code> accordingly:</p> <pre><code>handlers:\nhttp_handler:\nargs: {}\nclass_name: HttpHandler\nmodels:\ndefault_dialogues:\nargs: {}\nclass_name: DefaultDialogues\nhttp_dialogues:\nargs: {}\nclass_name: HttpDialogues\n</code></pre> <p>Run the fingerprinter (note, you will have to replace the author name with your author handle):</p> <pre><code>aea fingerprint skill fetchai/http_echo:0.21.6\n</code></pre> <p>Moreover, we need to tell to the <code>http_server</code> connection to what skill the HTTP requests should be forwarded. In our case, this is the <code>http_echo</code> that you have just scaffolded. Its public id will be <code>&lt;your-author-name&gt;/http_echo:0.1.0</code>.</p> <pre><code>aea config set vendor.fetchai.connections.http_server.config.target_skill_id \"$(aea config get agent.author)/http_echo:0.1.0\" </code></pre> <p>You can now run the AEA:</p> <pre><code>aea run\n</code></pre> <p>In a separate terminal, you can create a client and communicate with the server:</p> <pre><code>import requests\nresponse = requests.get('http://127.0.0.1:8000')\nresponse.status_code\n# &gt;&gt;&gt; 404\n# we receive a not found since the path is not available in the api spec\nresponse = requests.get('http://127.0.0.1:8000/pets')\nresponse.status_code\n# &gt;&gt;&gt; 200\nresponse.content\n# &gt;&gt;&gt; b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}'\nresponse = requests.post('http://127.0.0.1:8000/pets')\nresponse.status_code\n# &gt;&gt;&gt; 200\nresponse.content\n# &gt;&gt;&gt; b''\n</code></pre>"},{"location":"aea-framework-documentation/identity/","title":"Identity","text":"<p>Note</p> <p>This section is incomplete and will soon be updated.</p> <p>The AEAs currently use the addresses associated with their private-public key pairs to identify themselves.</p> <p></p> <p>To learn how to generate a private-public key pair check out the relevant  CLI commands .</p> <p>To learn more about public-key cryptography check out Wikipedia.</p> <p>An AEA can provide evidence of its identity using third-party solutions. We have implemented a demo using Aries Hyperledger Cloud Agent which is available here and another demo using Yoti which is available here.</p>"},{"location":"aea-framework-documentation/install/","title":"Installation","text":"<p>Platforms</p> <p>The AEA framework can be used on <code>Windows</code>, <code>Ubuntu/Debian</code> and <code>MacOS</code>.</p>"},{"location":"aea-framework-documentation/install/#system-requirements","title":"System Requirements","text":"<ol> <li>You need Python 3.8, 3.9 or 3.10 on your system.</li> <li> <p>GCC installation is also required:</p> UbuntuMacOS X (with Homebrew)Windows (with choco) <pre><code>apt-get install gcc\n</code></pre> <pre><code>brew install gcc\n</code></pre> <pre><code>choco install mingw\n</code></pre> </li> </ol> Tips <ul> <li> <p>Ubuntu/Debian: install Python headers, depending on the Python version you have installed on your machine. For example for Python 3.8: </p> <pre><code>sudo apt-get install python3.8-dev\n</code></pre> </li> <li> <p>Windows: install tools for Visual Studio.</p> </li> </ul>"},{"location":"aea-framework-documentation/install/#alternatively-use-docker","title":"Alternatively: Use Docker","text":"<p>We also provide a Docker image with all the needed dependencies.</p> <ol> <li> <p>Pull the image:</p> <pre><code>docker pull fetchai/aea-user:latest\n</code></pre> </li> <li> <p>Run the image with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container:</p> Linux and MacOsWindows <pre><code>docker run -it -v $(pwd):/agents --workdir=/agents fetchai/aea-user:latest\n</code></pre> <pre><code>docker run -it -v %cd%:/agents --workdir=/agents fetchai/aea-user:latest\n</code></pre> </li> </ol> <p>Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker.</p>"},{"location":"aea-framework-documentation/install/#for-agent-development","title":"For Agent Development","text":""},{"location":"aea-framework-documentation/install/#preliminaries","title":"Preliminaries","text":"<ol> <li> <p>Create a new working directory. Let's call it <code>my_aea_projects</code>. This is where you will create your agent projects.</p> </li> <li> <p>Inside <code>my_aea_projects</code>, add an empty directory called <code>packages</code>. This is a local registry for your agents' components.</p> </li> </ol> <p>You should now have the following directory structure:</p> <pre><code>my_aea_projects\n\u2514\u2500\u2500 packages\n</code></pre> <p>Alternatively, clone a template repo:</p> <p>Instead of the above, you can clone the template repo as described in <code>Approach 1</code> in the development setup guide.</p>"},{"location":"aea-framework-documentation/install/#virtual-environment","title":"Virtual Environment","text":"<p>Unless you are using the docker image, we highly recommend using a virtual environment so that your setup is isolated from the rest of your system. This prevents clashes and ensures consistency across dependencies.</p> <p>You can use any common virtual environment manager for Python, such as <code>pipenv</code> and <code>poetry</code>. If you do not have either, install one.</p> <p>Once installed, create a new virtual environment in the <code>my_aea_projects</code> directory and enter it:</p> pipenvpoetry <p>Use any Python version supported in the command: <pre><code>pipenv --python 3.9 &amp;&amp; pipenv shell\n</code></pre></p> <pre><code>poetry init -n &amp;&amp; poetry shell\n</code></pre>"},{"location":"aea-framework-documentation/install/#installation_1","title":"Installation","text":"<p>The latest version of the Python implementation of the AEA Framework is:</p> <p> </p> <p>Note</p> <p>If you are upgrading your AEA project from a previous version of the AEA framework, make sure you check out the upgrading notes.</p>"},{"location":"aea-framework-documentation/install/#using-pip","title":"Using pip","text":"<p>Install the AEA framework using pip:</p> bash/windowszsh <pre><code>pip install aea[all]\n</code></pre> <pre><code>pip install 'aea[all]'\n</code></pre> Troubleshooting <p>To ensure no cache is used, add <code>--force --no-cache-dir</code> to the installation command.</p>"},{"location":"aea-framework-documentation/install/#using-pipx","title":"Using pipx","text":"<p>Install the AEA framework using pipx:</p> <pre><code>pipx install aea[all]\n</code></pre>"},{"location":"aea-framework-documentation/install/#for-contributing-to-the-aea-framework","title":"For Contributing to the AEA Framework","text":"<p>To contribute to the development of the framework or related tools (e.g. ACN), please refer to the Contribution and Development guides in our GitHub repository.</p>"},{"location":"aea-framework-documentation/install/#other-tools-you-might-need","title":"Other Tools You Might Need","text":"<p>Depending on what you want to do, you might need extra tools on your system:</p> <ul> <li>To use the Agent Communication Network (ACN) for peer-to-peer communication between agents (e.g. using the <code>fetchai/p2p_libp2p</code> connection) you will need  Golang 1.14.2 or higher.</li> <li>The framework uses Google Protocol Buffers for message serialization. If you want to develop protocols, install the protobuf compiler on your system. The version you install must match the <code>protobuf</code> library installed with the project (see pyproject.toml).</li> <li>To update fingerprint hashes of packages, you will need the IPFS daemon.</li> </ul>"},{"location":"aea-framework-documentation/interaction-protocol/","title":"How AEAs Talk to Each Other - Interaction Protocols","text":"<p>Although one can imagine scenarios where single AEAs pursue their goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs have the potential of achieving much more, especially when taking into account agents' heterogeneity, specialisations, and differing and often complimentary local views of the environment.</p> <p>Interactions in the AEA world are in the form of communication. This is influenced by established practices in the field of multi-agent systems and the prominent speech-act theory which suggests that a communicative expression is not only about transferring information from the speaker to the hearer, but that there may be meanings and commitments beyond the statement's appearance. Therefore, speech may more suitably be considered as action. For example, \"I hereby appoint you as chairman\" is not just a sequence of words, but an action done by the speaker with wide-ranging consequences for the hearer and any other audience to that sentence.</p> <p>Interaction protocols are thus possible communication scenarios between agents or agent components (specifically, skills and connections).</p> <p>There are multiple types of interactions an AEA can have:</p> <ul> <li> <p>AEA-to-AEA interactions. You can find some examples in the demo section.</p> </li> <li> <p>Interactions between an AEA's internal components.</p> </li> </ul> <p></p> <p>Usually, an interaction involves three types of framework packages: skills, protocols and connections.</p>"},{"location":"aea-framework-documentation/interaction-protocol/#examples","title":"Examples","text":""},{"location":"aea-framework-documentation/interaction-protocol/#example-1-negotiation","title":"Example 1: Negotiation","text":"<p>The generic buyer/seller skills use the <code>fetchai/fipa</code> protocol which defines the negotiation dialogue between two AEAs. The <code>fetchai/generic_buyer</code> and <code>fetchai/generic_seller</code> skills implement specific strategies for engaging in such negotiations, by providing the logic for producing negotiation messages to be sent, handling negotiation messages received. The <code>fetchai/p2p_libp2p</code> connection is then used for connecting to the agent communication network enabling two AEAs with these skills to deliver negotiation messages to each other.</p>"},{"location":"aea-framework-documentation/interaction-protocol/#example-2-aea-web-client","title":"Example 2: AEA &lt;&gt; Web Client","text":"<p>In the http connection guide we demonstrate how an AEA with a http server connection (e.g. <code>fetchai/http_server</code>) receives http payloads from web clients, translates them to messages conforming with the <code>fetchai/http</code> protocol and passes it to a skill (e.g. <code>fetchai/http_echo</code>) to process. The <code>fetchai/http</code> protocol in this case is used for communication between the connection and the skill.</p>"},{"location":"aea-framework-documentation/interaction-protocol/#example-3-aea-3rd-party-server","title":"Example 3 : AEA &lt;&gt; 3rd Party Server","text":"<p>The <code>fetchai/http_client</code> connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the <code>fetchai/http</code> protocol and sends it to the <code>fetchai/http_client</code> connection which in turn translates it into http payload and sends it to the destination server.</p> <p>Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK.</p>"},{"location":"aea-framework-documentation/interaction-protocol/#next-steps","title":"Next Steps","text":""},{"location":"aea-framework-documentation/interaction-protocol/#recommended","title":"Recommended","text":"<p>We recommend you continue with the next step in the 'Getting Started' series:</p> <ul> <li>Trade between two AEAs</li> </ul>"},{"location":"aea-framework-documentation/interaction-protocol/#relevant-deep-dives","title":"Relevant Deep-Dives","text":"<p>Most AEA development focuses on developing the <code>Skills</code> and <code>Protocols</code> necessary for an AEA to deliver against its economic objectives and implement interaction protocols.</p> <p>Understanding <code>Protocols</code> is core to developing your own agent. You can learn more about the <code>Protocols</code> agents use to communicate with each other and how they are created in the following section:</p> <ul> <li>Protocols</li> </ul> <p>Most of an AEA developer's time is spent on <code>Skill</code> development. <code>Skills</code> are the core business logic components of an AEA. Check out the following guide to learn more:</p> <ul> <li>Skills</li> </ul> <p>In most cases, one of the available <code>Connection</code> packages can be used. Occasionally, you might develop your own <code>Connection</code>:</p> <ul> <li>Connections</li> </ul>"},{"location":"aea-framework-documentation/known-limits/","title":"Known Limitations","text":"<p>The AEA framework makes a multitude of tradeoffs.</p> <p>Here we present an incomplete list of known limitations:</p> <ul> <li> <p>The <code>AEABuilder</code> checks the consistency of packages at the <code>add</code> stage. However, it does not currently check the consistency again at the <code>load</code> stage. This means, if a package is tampered with after it is added to the <code>AEABuilder</code> then these inconsistencies might not be detected by the <code>AEABuilder</code>.</p> </li> <li> <p>The <code>AEABuilder</code> assumes that packages with public ids of identical author and package name have a matching version. As a result, if a developer uses a package with matching author and package name but different version in the public id, then the <code>AEABuilder</code> will not detect this and simply use the last loaded package.</p> </li> <li> <p>The order in which <code>setup</code> and <code>teardown</code> are called on the skills, and <code>act</code> is called on the behaviours, is not guaranteed. Skills should be designed to work independently. Where skills use the <code>shared_context</code> to exchange information they must do so safely.</p> </li> </ul>"},{"location":"aea-framework-documentation/language-agnostic-definition/","title":"Language Agnostic Definition","text":"<p>Currently, there is an implementation of the AEA framework in Python which enables the development of AEAs in Python, and allows AEAs which are built with it to run.</p> <p>However, AEAs can be developed in different programming languages. This is further backed by the idea that agent-based solutions are suited for multi-stakeholder environments where the different AEAs may be developed independently of one another, resulting in heterogeneous systems.</p> <p>This means that in principle, there could be different implementations of the AEA framework, in various programming languages and for different platforms. However, to ensure that AEAs under any implementation are compatible with one another and able to interact, they must satisfy specific definitions. In this page, we compile a set of definitions which any AEA independent of its implementation must satisfy in order to be able to interact with other AEAs.</p> <p>An AEA, in technical terms, must satisfy the following requirements:</p> <ul> <li> <p>It MUST be capable of receiving and sending <code>Envelopes</code> which satisfy the following protobuf schema:</p> <pre><code>syntax = \"proto3\";\npackage aea.base.v0_1_0;\nmessage Envelope{\nstring to = 1;\nstring sender = 2;\nstring protocol_id = 3;\nbytes message = 4;\nstring uri = 5;\n}\n</code></pre> <p>The format for the above fields are as follows:</p> <ul> <li><code>to</code> and <code>sender</code>: an address derived from the private key of a secp256k1-compatible elliptic curve</li> <li><code>protocol_id</code>: this must match a defined  regular expression (see below)</li> <li><code>message</code>: a bytes string representing a serialized message in the specified  protocol</li> <li><code>URI</code>: follows this syntax</li> </ul> </li> <li> <p>It MUST implement each protocol's <code>message</code> with the required meta-fields:</p> <pre><code>syntax = \"proto3\";\npackage aea.base.v0_1_0;\nimport \"google/protobuf/struct.proto\";\nmessage DialogueMessage {\nint32 message_id = 1;\nstring dialogue_starter_reference = 2;\nstring dialogue_responder_reference = 3;\nint32 target = 4;\nbytes content = 5;\n}\nmessage Message {\noneof message {\ngoogle.protobuf.Struct body = 1;\nDialogueMessage dialogue_message = 2;\n}\n}\nmessage Envelope{\nstring to = 1;\nstring sender = 2;\nstring protocol_id = 3;\nbytes message = 4;\nstring uri = 5;\n}\n</code></pre> <p>where <code>content</code> is replaced with the protocol specific content (see here for details).</p> </li> <li> <p>It MUST implement protocols according to their specification (see here for details).</p> </li> <li> <p>It SHOULD implement the <code>fetchai/default:1.1.7</code> protocol which satisfies the following protobuf schema:</p> <pre><code>syntax = \"proto3\";\npackage aea.fetchai.default.v1_0_0;\nmessage DefaultMessage{\n// Custom Types\nmessage ErrorCode{\nenum ErrorCodeEnum {\nUNSUPPORTED_PROTOCOL = 0;\nDECODING_ERROR = 1;\nINVALID_MESSAGE = 2;\nUNSUPPORTED_SKILL = 3;\nINVALID_DIALOGUE = 4;\n}\nErrorCodeEnum error_code = 1;\n}\n// Performatives and contents\nmessage Bytes_Performative{\nbytes content = 1;\n}\nmessage Error_Performative{\nErrorCode error_code = 1;\nstring error_msg = 2;\nmap&lt;string, bytes&gt; error_data = 3;\n}\nmessage End_Performative{\n}\noneof performative{\nBytes_Performative bytes = 5;\nEnd_Performative end = 6;\nError_Performative error = 7;\n}\n}\n</code></pre> </li> <li> <p>The protocol id MUST match the following regular expression: <code>^([a-zA-Z_][a-zA-Z0-9_]{0,127})/([a-zA-Z_][a-zA-Z0-9_]{0,127})(:((any|latest|((0|[1-9]\\d*))\\.((0|[1-9]\\d*))\\.((0|[1-9]\\d*))(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)))?$</code></p> </li> <li>It is recommended that it processes <code>Envelopes</code> asynchronously. Note, the specification regarding the processing of messages does not impose any particular implementation, and the AEA can be designed to process envelopes either synchronously and asynchronously. However, asynchronous message handling enables the agent to be more responsive and scalable in maintaining many concurrent dialogues with its peers.</li> <li>It MUST have an identity in the form of, at a minimum, an address derived from a public key and its associated private key (where the elliptic curve must be of type SECP256k1).</li> <li>It SHOULD implement handling of errors using the <code>fetchai/default:1.1.7</code> protocol. The protobuf schema is given above.</li> <li>It MUST implement the following principles when handling messages:<ul> <li>It MUST ALWAYS handle incoming envelopes/messages and NEVER raise an exception when decoding and validating the message. This ensures another AEA cannot cause the agent to fail by sending a malicious envelope/message.</li> <li>It MUST NEVER handle outgoing messages and ALWAYS raise an exception when validating the message. An exception implies that the handler is resolving a bug in the implementation.</li> </ul> </li> </ul> <p>Note</p> <p>Additional constraints will be added soon!</p>"},{"location":"aea-framework-documentation/ledger-integration/","title":"Ledger &amp; Crypto APIs","text":"<p>In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers.</p>"},{"location":"aea-framework-documentation/ledger-integration/#ledger-support","title":"Ledger Support","text":"<p>For a ledger to be considered supported in the framework, three abstract base classes need to be implemented:</p> <ul> <li>the <code>LedgerApi</code> class wraps the API to talk to the ledger and its helper methods</li> <li>the <code>Crypto</code> class wraps the API to perform cryptographic operations for the relevant ledger</li> <li>the <code>FaucetApi</code> class wraps the API to talk to a faucet on a testnet</li> </ul> <p>These three classes have their own registries, which allow the developer to import the relevant object where needed.</p>"},{"location":"aea-framework-documentation/ledger-integration/#ledger-plug-in-architecture","title":"Ledger Plug-in Architecture","text":"<p>The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendable way. At import time, the framework will load all the crypto plug-ins available in the current Python environment.</p> <p>A crypto plug-in is a Python package which declares some specific  <code>setuptools</code> \"entry points\" in its <code>setup.py</code> script. In particular, there are three types of entry points the framework looks up:</p> <ul> <li><code>aea.ledger_apis</code>, which points to instantiable classes implementing the <code>LedgerApi</code> interface;</li> <li><code>aea.cryptos</code>, which points to instantiable classes implementing the <code>Crypto</code> interface;</li> <li><code>aea.faucet_apis</code>, which points to instantiable classes implementing the <code>FaucetApi</code> interface.</li> </ul> <p>This is an example of <code>setup.py</code> script for a ledger plug-in <code>aea-ledger-myledger</code>:</p> <pre><code># sample ./setup.py file\nfrom setuptools import setup\nsetup(\nname=\"aea-ledger-myledger\",\npackages=[\"aea_ledger_myledger\"],\n# plugins must depend on 'aea'  \ninstall_requires=[\"aea\"], # add other dependencies...\n# the following makes a plugin available to aea\nentry_points={\n\"aea.cryptos\": [\"myledger = aea_ledger_myledger:MyLedgerCrypto\"],\n\"aea.ledger_apis\": [\"myledger = aea_ledger_myledger:MyLedgerApi\"],\n\"aea.faucet_apis\": [\"myledger = aea_ledger_myledger:MyLedgerFaucetApi\"],\n},\n# PyPI classifier for AEA plugins\nclassifiers=[\"Framework :: AEA\"],\n)\n</code></pre> <p>By convention, such plug-in packages should be named <code>aea-ledger-${LEDGER_ID}</code>, and the importable package name <code>aea_ledger_${LEDGER_ID}</code>. In the example above, the package name is <code>aea-ledger-myledger</code>, and the importable package name is <code>aea_ledger_myledger</code>.</p> <p>You can search for AEA ledger plug-ins on PyPI: https://pypi.org/search/?q=aea-ledger</p>"},{"location":"aea-framework-documentation/ledger-integration/#maintained-plug-ins","title":"Maintained Plug-ins","text":"<p>At the moment, the framework natively supports the following three ledgers:</p> <ul> <li>Fetch.ai: PyPI package: <code>aea-ledger-fetchai</code>, and source code.</li> <li>Ethereum: PyPI package: <code>aea-ledger-ethereum</code>, and source code.</li> <li>Cosmos: PyPI package: <code>aea-ledger-cosmos</code>, and source code.</li> </ul> <p>However, support for additional ledgers can be added to the framework at runtime.</p>"},{"location":"aea-framework-documentation/ledger-integration/#examples","title":"Examples","text":"<ul> <li>Examples of how to interact with the crypto registry:</li> </ul> <pre><code>from aea.crypto.registries import crypto_registry, make_crypto, register_crypto\n# by default we can use the native cryptos\nfetchai_crypto = make_crypto(\"fetchai\")\n# we can check what cryptos are registered\ncrypto_registry.supported_ids\n# we can also add a new crypto to the registry\nregister_crypto(id_=\"my_ledger_id\", entry_point=\"some.dotted.path:MyLedgerCrypto\")\n# and then make it anywhere\nmy_ledger_crypto = make_crypto(\"my_ledger_id\")\n</code></pre> <ul> <li>Examples of how to interact with the ledger API registry:</li> </ul> <pre><code>from aea.crypto.registries import ledger_apis_registry, make_ledger_api, register_ledger_api\n# by default we can use the native ledger apis\nCONFIG = {\"network\": \"testnet\"}\nfetchai_ledger_api = make_ledger_api(\"fetchai\", **CONFIG)\n# we can check what ledger apis are registered\nledger_apis_registry.supported_ids\n# we can also add a new ledger api to the registry\nregister_ledger_api(id_=\"my_ledger_id\", entry_point=\"some.dotted.path:MyLedgerApi\")\n# and then make it anywhere\nmy_ledger_api = make_ledger_api(\"my_ledger_id\")\n</code></pre> <ul> <li>Examples of how to interact with the faucet API registry:</li> </ul> <pre><code>from aea.crypto.registries import faucet_apis_registry, make_faucet_api, register_faucet_api\n# by default we can use the native faucet apis\nCONFIG = dict(poll_interval=1.0)\nfetchai_faucet_api = make_faucet_api(\"fetchai\", **CONFIG)\n# we can check what faucet apis are registered\nfaucet_apis_registry.supported_ids\n# we can also add a new faucet api to the registry\nregister_faucet_api(id_=\"my_ledger_id\", entry_point=\"some.dotted.path:MyLedgerFaucetApi\")\n# and then make it anywhere\nmy_faucet_api = make_faucet_api(\"my_ledger_id\")\n</code></pre> <p>The framework wraps all <code>LedgerApi</code> classes and exposes them in the <code>LedgerApis</code> classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the <code>Wallet</code>.</p> <p>The separation between the <code>Crypto</code> and <code>LedgerApi</code> is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's <code>Wallet</code> whilst <code>LedgerApis</code> are accessible by all skills.</p>"},{"location":"aea-framework-documentation/ledger-integration/#stargate-world-fetchai-testnet-for-agents","title":"Stargate World - Fetch.ai Testnet for Agents","text":"<p>Stargate World is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development.</p> Parameter Value Chain ID dorado-1 Denomination atestfet Decimals 18 Version v0.8.x RPC Endpoint https://rpc-dorado.fetch.ai:443 REST Endpoint https://rest-dorado.fetch.ai:443 Block Explorer https://explore-dorado.fetch.ai Token Faucet Use block explorer <p>You can access more details on docs section.</p> <p>The configurations can be specified for the <code>fetchai/ledger:0.21.5</code> connection.</p>"},{"location":"aea-framework-documentation/ledger-integration/#cosmwasm-supporting-chains","title":"CosmWasm Supporting Chains","text":"<p>The Fetch.ai networks use CosmWasm for smart contract support.</p>"},{"location":"aea-framework-documentation/limits/","title":"Limitations of v1","text":"<p>This document describes some of the limitations of <code>v1</code> of the AEA framework and tradeoffs made in its design.</p>"},{"location":"aea-framework-documentation/limits/#rejected-ideas","title":"Rejected Ideas","text":""},{"location":"aea-framework-documentation/limits/#handlers-implemented-as-behaviours","title":"Handlers Implemented as Behaviours","text":"<p>Handlers can be considered a special cases of a \"behaviour that listens for specific events to happen\".</p> <p>One could implement <code>Handler</code> classes in terms of <code>Behaviours</code>, after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol).</p> <p>This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development.</p>"},{"location":"aea-framework-documentation/limits/#multiple-versions-of-the-same-package","title":"Multiple Versions of the Same Package","text":"<p>The framework does not allow for the usage of multiple versions of the same package in a given project.</p> <p>Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA.</p>"},{"location":"aea-framework-documentation/limits/#potential-extensions-considered-yet-not-decided","title":"Potential Extensions, Considered yet not Decided","text":""},{"location":"aea-framework-documentation/limits/#alternative-skill-design","title":"Alternative Skill Design","text":"<p>For very simple skills, the splitting of skills into <code>Behaviour</code>, <code>Handler</code>, <code>Model</code> and <code>Task</code> classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the <code>SkillContext</code> object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in <code>SkillComponent</code> classes <code>Handler</code>, <code>Behaviour</code> or <code>Model</code>. This approach is consistent and transparent, however it creates a lot of boilerplate code for simple skills.</p> <p>Hence, for some use cases it would be useful to have a single <code>Skill</code> class with abstract methods <code>setup</code>, <code>act</code>, <code>handle</code> and <code>teardown</code>. Then the developer can decide how to split up their code.</p> <pre><code>class SkillTemplate(SimpleSkill):\nprotocol_ids: Optional[List[PublicId]] = None\ndef setup():\n# setup skill\ndef handle(message: Message):\n# handle messages\ndef act():\nfor b in behaviours:\nb.act()\ndef teardown():\n# teardown skill\n</code></pre> <p>Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual <code>Behaviour</code> and <code>Handler</code> classes provided by the framework).</p> <p>The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each other's code.</p> <p>The separation between all four base classes does exist both in convention and at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic.</p> <p>By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling.</p>"},{"location":"aea-framework-documentation/limits/#further-modularity-for-skill-level-code","title":"Further Modularity for Skill Level Code","text":"<p>Currently, we have three levels of modularity:</p> <ul> <li>PyPI packages</li> <li>framework packages: protocols, contracts, connections and skills</li> <li>framework plugins: CLI, ledger</li> </ul> <p>We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development.</p>"},{"location":"aea-framework-documentation/limits/#promise-pattern","title":"\"promise\" Pattern","text":"<p>Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a \"fat\" handler. Take the example of a handler for a certain type of message <code>A</code> for a certain protocol <code>p</code>. The handler for protocol <code>p</code> would look something like this:</p> <pre><code>class PHandler:\n...\ndef handle(msg):\nif message type is A:\nself._handle_a(msg)\n</code></pre> <p>However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider this in context):</p> <pre><code># callable that handles the reply\ndef my_callback(msg):\n# handle reply\nself.context.outbox.put_message(message, handler_func=my_callback, failure_func=...)\n</code></pre> <p>This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues.</p>"},{"location":"aea-framework-documentation/limits/#cli-using-standard-lib","title":"CLI using Standard Lib","text":"<p>Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable.</p>"},{"location":"aea-framework-documentation/limits/#metadata-vs-configurations","title":"Metadata vs Configurations","text":"<p>The current approach uses <code>yaml</code> files to specify both metadata and component configuration. It would be desirable to introduce the following separation:</p> <ul> <li>package metadata</li> <li>package default developer configuration</li> <li>package default user configuration</li> </ul> <p>A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework.</p>"},{"location":"aea-framework-documentation/limits/#configuring-agent-goal-setup","title":"Configuring Agent Goal Setup","text":"<p>By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it.</p> <p>It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user.</p>"},{"location":"aea-framework-documentation/limits/#connection-status-monitoring","title":"Connection Status Monitoring","text":"<p>Currently, connections are responsible for managing their own status after they have been \"connected\" by the <code>Multiplexer</code>. Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level:</p> <ul> <li>disconnect one, keep others alive</li> <li>disconnect all</li> <li>try to reconnect indefinitely</li> </ul>"},{"location":"aea-framework-documentation/limits/#agent-snapshots-on-teardown-or-error","title":"Agent Snapshots on Teardown or Error","text":"<p>Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error.</p>"},{"location":"aea-framework-documentation/limits/#dialogues-management","title":"Dialogues Management","text":"<p>The current implementation of Dialogues is verbose. Developers often need to subclass <code>Dialogues</code> and <code>Dialogue</code> classes. More effort can be made to simplify and streamline dialogues management.</p>"},{"location":"aea-framework-documentation/limits/#instantiate-multiple-instances-of-the-same-class-of-skillcomponent","title":"Instantiate Multiple Instances of the Same Class of <code>SkillComponent</code>","text":"<p>Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations.</p> <p>This feature could be problematic with respect to component-to-component messaging which currently relies on component ids, which are bound to the package and not its instance.</p>"},{"location":"aea-framework-documentation/limits/#containerized-agents","title":"Containerized Agents","text":"<p>Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases.</p> <p>A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the <code>Dockerfile</code>: the <code>Agentfile</code>), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations.</p> <p>Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents.</p>"},{"location":"aea-framework-documentation/limits/#dependency-light-version-of-the-aea-framework","title":"Dependency Light Version of the AEA Framework","text":"<p>The <code>v1</code> of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time.</p> <p>It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library.</p> <p>This could be taken further, and a reduced spec version for micropython could be designed.</p>"},{"location":"aea-framework-documentation/limits/#compiled-aea","title":"Compiled AEA","text":"<p>Python is not a compiled language. However, various projects attempt this, e.g. Nuitka and it would be desirable to explore how useful and practical this would be in the context of AEA.</p>"},{"location":"aea-framework-documentation/limits/#did-integration","title":"DID Integration","text":"<p>It would be great to integrate DID in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity):</p> <ul> <li>ERC 725: Ethereum Identity Standard and here.</li> <li>ERC 735: Claim Holder</li> </ul>"},{"location":"aea-framework-documentation/limits/#optimise-protocol-schemas-and-messages","title":"Optimise Protocol Schemas and Messages","text":"<p>The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations.</p>"},{"location":"aea-framework-documentation/limits/#constraints-on-primitive-types-in-protocols","title":"Constraints on Primitive Types in Protocols","text":"<p>The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification.</p> <p>There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers.</p> <p>Example constraints:</p> <ul> <li>strings following specific regular expression format (e.g. all lower case, any arbitrary regex format)</li> <li>max number of elements on lists/sets</li> <li>keys in one <code>dict</code> type be equal to keys in another <code>dict</code> type</li> <li>other logical constraints, e.g. as supported in ontological languages</li> <li>support for bounds (i.e. min, max) for numerical types (i.e. <code>int</code> and <code>float</code>) in protocol specification.</li> </ul> <p>Example syntax:</p> <ul> <li><code>pt:int[0, ]</code></li> <li><code>pt:float[1.0, 10.0]</code></li> <li><code>pt:int[-1000, 1000]</code></li> <li><code>pt:float[, 0]</code></li> </ul> <p>This would automatically enable support for signed/unsigned <code>int</code> and <code>float</code>. This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types.</p> <p>Currently, the developer has to specify a custom type to implement any constraints on primitive types.</p>"},{"location":"aea-framework-documentation/limits/#sub-protocols-multi-party-interactions","title":"Sub-protocols &amp; Multi-Party Interactions","text":"<p>Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties.</p> <p>Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added.</p> <p>Then the current <code>fipa</code> setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies).</p>"},{"location":"aea-framework-documentation/limits/#timeouts-in-protocols","title":"Timeouts in Protocols","text":"<p>Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules.</p>"},{"location":"aea-framework-documentation/limits/#framework-internal-messages","title":"Framework Internal Messages","text":"<p>The activation/deactivation of skills and addition/removal of components is implemented in a \"passive\" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills).</p> <p>One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The <code>DecisionMaker</code> or the <code>Filter</code> can be the components that take such actions.</p> <p>This is a further small but meaningful step toward an actor-based model for agent internals.</p>"},{"location":"aea-framework-documentation/limits/#ledger-transaction-management","title":"Ledger Transaction Management","text":"<p>Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions.</p> <p>A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause none of the subsequent transactions to be processed for some ledgers (https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.).</p> <p>A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account).</p> <p>A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block.</p> <p>This approach is currently used and implemented across all the reference skills.</p> <p>Related, the topic of latency in transactions. State channels provide a solution. E.g. Perun. There could also be an interesting overlap with our protocols here.</p>"},{"location":"aea-framework-documentation/limits/#unsolved-problems-in-multiplexer-agentloop-interplay","title":"Unsolved Problems in <code>Multiplexer</code> - <code>AgentLoop</code> Interplay","text":"<p>Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection <code>receive</code> calls.</p> <p>Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelization.</p> <p>Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop?</p>"},{"location":"aea-framework-documentation/limits/#acn","title":"ACN","text":""},{"location":"aea-framework-documentation/limits/#agent-mobility-on-acn","title":"Agent Mobility on ACN","text":"<p>If a peer-client or full client switches peer, then the DHT is not updated properly at the moment under certain conditions.</p>"},{"location":"aea-framework-documentation/limits/#mailbox-connection","title":"Mailbox Connection","text":"<p>The two available connections <code>p2p_libp2p</code> and <code>p2p_libp2p_client</code> imply that the agent is continuously connected and therefore must have uninterrupted network access and the resources to maintain a connection.</p> <p>For more lightweight implementations, a mailbox connection is desirable, as outlined in the ACN documentation.</p>"},{"location":"aea-framework-documentation/logging/","title":"Logging","text":"<p>The AEA framework supports flexible logging capabilities with the standard Python logging library.</p> <p>In this tutorial, we configure logging for an AEA.</p> <p>First, create your AEA.</p> <pre><code>aea create my_aea\ncd my_aea\n</code></pre> <p>The <code>aea-config.yaml</code> file should look like this.</p> <pre><code>agent_name: my_aea\nauthor: fetchai\nversion: 0.1.0\ndescription: ''\nlicense: Apache-2.0\naea_version: 0.6.0\nfingerprint: {}\nfingerprint_ignore_patterns: []\nconnections:\n- fetchai/stub:0.21.3\ncontracts: []\nprotocols:\n- fetchai/default:1.1.7\nskills:\n- fetchai/error:0.18.6\ndefault_connection: fetchai/stub:0.21.3\ndefault_ledger: fetchai\nrequired_ledgers:\n- fetchai\nlogging_config:\ndisable_existing_loggers: false\nversion: 1\nprivate_key_paths: {}\n</code></pre> <p>By updating the <code>logging_config</code> section, you can configure the loggers of your application.</p> <p>The format of this section is specified in the <code>logging.config</code> module.</p> <p>At this section you'll find the definition of the configuration dictionary schema.</p> <p>Below is an example of the <code>logging_config</code> value.</p> <pre><code>logging_config:\nversion: 1\ndisable_existing_loggers: False\nformatters:\nstandard:\nformat: '%(asctime)s [%(levelname)s] %(name)s: %(message)s'\nhandlers:\nlogfile:\nclass: logging.FileHandler\nformatter: standard\nlevel: DEBUG\nfilename: logconfig.log\nconsole:\nclass: logging.StreamHandler\nformatter: standard\nlevel: DEBUG\nloggers:\naea:\nhandlers:\n- logfile\n- console\nlevel: DEBUG\npropagate: False\n</code></pre> <p>This configuration will set up a logger with name <code>aea</code>. It prints both on console and on file with a format specified by the <code>standard</code> formatter.</p>"},{"location":"aea-framework-documentation/logging/#streaming-to-browser","title":"Streaming to Browser","text":"<p>It is possible to configure the AEA to stream logs to a browser.</p> <p>First, add the following configuration to your AEA:</p> <pre><code>logging_config:\nversion: 1\ndisable_existing_loggers: false\nformatters:\nstandard:\nformat: '%(asctime)s [%(levelname)s] %(name)s: %(message)s'\nhandlers:\nhttp:\nclass: logging.handlers.HTTPHandler\nformatter: standard\nlevel: INFO\nhost: localhost:5000\nurl: /stream\nmethod: POST\nloggers:\naea:\nhandlers:\n- http\nlevel: INFO\npropagate: false\n</code></pre> <p>Second, create a log server:</p> <pre><code># -*- coding: utf-8 -*-\n\"\"\"A simple flask server to serve logs.\"\"\"\nimport datetime\nimport itertools\nimport queue\nfrom flask import Flask, Response, request, stream_with_context\ndef format_log(log_dict):\n\"\"\"Format a log record.\"\"\"\ndate = datetime.datetime.fromtimestamp(float(log_dict[\"created\"]))\nformatted_log = f\"[{date.isoformat()}] [{log_dict['levelname']}] {log_dict['name']}: {log_dict['msg']}\"\nreturn formatted_log\ndef create_app():\n\"\"\"Create Flask app for streaming logs.\"\"\"\nall_logs = []\nunread_logs = queue.Queue()\napp = Flask(__name__)\n@app.route(\"/\")\ndef index():\n\"\"\"Stream logs to client.\"\"\"\ndef generate():\n# stream old logs\ndiv = \"&lt;div&gt;{}&lt;/div&gt;\"\nfor old_row in all_logs:\nyield div.format(old_row)\n# stream unread logs\nwhile True:\nrow = unread_logs.get()\nall_logs.append(row)\nyield f\"&lt;div&gt;{row}&lt;/div&gt;\"\nrows = generate()\ntitle = \"&lt;p&gt;Waiting for logs...&lt;/p&gt;\"\nreturn Response(stream_with_context(itertools.chain([title], rows)))\n@app.route(\"/stream\", methods=[\"POST\"])\ndef stream():\n\"\"\"Save log record from AEA.\"\"\"\nlog_record_formatted = format_log(dict(request.form))\nunread_logs.put(log_record_formatted)\nreturn {}, 200\napp.run()\nif __name__ == \"__main__\":\ncreate_app()\n</code></pre> <p>Save the script in a file called <code>server.py</code>, install flask with <code>pip install flask</code> and run the server with <code>python server.py</code>.</p> <p>Third, run your AEA and visit <code>localhost:5000</code> in your browser.</p>"},{"location":"aea-framework-documentation/message-routing/","title":"Message Routing","text":"<p>Message routing can be split up into the routing of incoming and outgoing <code>Messages</code>.</p> <p>It is important to keep in mind that interaction protocols can be maintained between agents (agent to agent) and between components of the AEA (component to component). In the former case, the <code>to</code>/<code>sender</code> fields of the <code>Envelope</code> are agent addresses which must follow the address standard of agents, in the latter case they are component public ids. Crucially, both addresses must reference the same type: agent or component.</p>"},{"location":"aea-framework-documentation/message-routing/#incoming-messages","title":"Incoming <code>Messages</code>","text":"<ul> <li><code>Connections</code> receive or create <code>Envelopes</code> which they deposit in the <code>InBox</code></li> <li>for agent-to-agent communication only, the <code>Multiplexer</code> keeps track of the <code>connection_id</code> via which the <code>Envelope</code> was received.</li> <li>the <code>AgentLoop</code> picks <code>Envelopes</code> off the <code>InBox</code></li> <li>the <code>AEA</code> tries to decode the message; errors are handled by the <code>ErrorHandler</code></li> <li> <p><code>Messages</code> are dispatched based on two rules:</p> <ol> <li>checks if <code>to</code> field can be interpreted as <code>skill_id</code>, if so uses that together with the <code>protocol_id</code> to dispatch to the protocol's <code>Handler</code> in the specified <code>Skill</code>, else</li> <li>uses the <code>protocol_id</code> to dispatch to the protocol's <code>Handler</code> in all skills supporting the protocol.</li> </ol> </li> </ul> <p>Note</p> <p>For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message).</p>"},{"location":"aea-framework-documentation/message-routing/#outgoing-messages","title":"Outgoing <code>Messages</code>","text":"<ul> <li><code>Skills</code> deposit <code>Messages</code> in <code>OutBox</code></li> <li><code>OutBox</code> constructs an <code>Envelope</code> from the <code>Message</code></li> <li> <p><code>Multiplexer</code> assigns messages to relevant <code>Connection</code> based on the following rules:</p> <ol> <li>Component to component messages are routed by their <code>component_id</code></li> <li>Agent to agent messages are routed following four rules:<ol> <li>checks if <code>EnvelopeContext</code> exists and specifies a <code>Connection</code>, if so uses that else</li> <li>checks which connection handled the last message from <code>sender</code>, if present uses that else</li> <li>checks if default routing is specified for the <code>protocol_id</code> referenced in the <code>Envelope</code>, if so uses that else</li> <li>sends to default <code>Connection</code>.</li> </ol> </li> </ol> </li> <li> <p><code>Connections</code> can process <code>Envelopes</code> directly or encode them for transport to another agent.</p> </li> </ul>"},{"location":"aea-framework-documentation/message-routing/#usage-of-the-envelopecontext","title":"Usage of the <code>EnvelopeContext</code>","text":"<p>The <code>EnvelopeContext</code> is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the <code>EnvelopeContext</code> explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections.</p> <p>The <code>EnvelopeContext</code> is not sent to another agent.</p>"},{"location":"aea-framework-documentation/ml-skills/","title":"ML Skills","text":"<p>The AEA ML (machine learning) skills demonstrate an interaction between two AEAs, one purchasing data from the other and training a machine learning model with it.</p> <p>There are two types of AEAs:</p> <ul> <li>The <code>ml_data_provider</code> which sells training data.</li> <li>The <code>ml_model_trainer</code> which purchases data and trains a model</li> </ul>"},{"location":"aea-framework-documentation/ml-skills/#discussion","title":"Discussion","text":"<p>This demo aims to demonstrate the integration of a simple AEA with machine learning using the AEA framework. The <code>ml_data_provider</code> AEA provides some sample data and delivers to the client upon payment. Once the client receives the data, it trains a model. This process can be found in <code>tasks.py</code>. This demo does not utilize a smart contract. As a result, the ledger interaction is only for completing a transaction.</p> <p>Since the AEA framework enables using third-party libraries from PyPI, we can directly reference any external dependencies. The <code>aea install</code> command installs all dependencies an AEA needs that is listed in one of its skills' YAML file.</p>"},{"location":"aea-framework-documentation/ml-skills/#communication","title":"Communication","text":"<p>This diagram shows the communication between the two AEAs.</p> <pre><code>    sequenceDiagram\n        participant ml_model_trainer\n        participant ml_data_provider\n        participant Search\n        participant Ledger\n\n        activate ml_model_trainer\n        activate ml_data_provider\n        activate Search\n        activate Ledger\n\n        ml_data_provider-&gt;&gt;Search: register_service\n        ml_model_trainer-&gt;&gt;Search: search\n        Search--&gt;&gt;ml_model_trainer: list_of_agents\n        ml_model_trainer-&gt;&gt;ml_data_provider: call_for_terms\n        ml_data_provider-&gt;&gt;ml_model_trainer: terms\n        ml_model_trainer-&gt;&gt;Ledger: request_transaction\n        ml_model_trainer-&gt;&gt;ml_data_provider: accept (incl transaction_hash)\n        ml_data_provider-&gt;&gt;Ledger: check_transaction_status\n        ml_data_provider-&gt;&gt;ml_model_trainer: data\n        loop train\n            ml_model_trainer-&gt;&gt;ml_model_trainer: tran_model\n        end\n\n        deactivate ml_model_trainer\n        deactivate ml_data_provider\n        deactivate Search\n        deactivate Ledger</code></pre>"},{"location":"aea-framework-documentation/ml-skills/#option-1-aea-manager-approach","title":"Option 1: AEA Manager Approach","text":"<p>Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.</p>"},{"location":"aea-framework-documentation/ml-skills/#preparation-instructions","title":"Preparation Instructions","text":"<ul> <li>Install the AEA Manager.</li> <li>Install Tensorflow</li> </ul>"},{"location":"aea-framework-documentation/ml-skills/#demo-instructions","title":"Demo Instructions","text":"<p>The following steps assume you have launched the AEA Manager Desktop app.</p> <ol> <li> <p>Add a new AEA called <code>ml_data_provider</code> with public id <code>fetchai/ml_data_provider:0.28.0</code>.</p> </li> <li> <p>Add another new AEA called <code>ml_model_trainer</code> with public id <code>fetchai/ml_model_trainer:0.29.0</code>.</p> </li> <li> <p>Copy the address from the <code>ml_model_trainer</code> into your clip board. Then go to the Dorado block explorer and request some test tokens via <code>Get Funds</code>.</p> </li> <li> <p>Run the <code>ml_data_provider</code> AEA. Navigate to its logs and copy the multiaddress displayed.</p> </li> <li> <p>Navigate to the settings of the <code>ml_model_trainer</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}\n</code></pre> </li> <li> <p>Run the <code>ml_model_trainer</code>.</p> </li> </ol> <p>In the AEA's logs, you should see the agents trading successfully, and the training agent training its machine learning model using the data purchased. The trainer keeps purchasing data and training its model until stopped.  </p>"},{"location":"aea-framework-documentation/ml-skills/#option-2-cli-approach","title":"Option 2: CLI Approach","text":"<p>Follow this approach when using the <code>aea</code> CLI.</p>"},{"location":"aea-framework-documentation/ml-skills/#preparation-instructions_1","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/ml-skills/#dependencies","title":"Dependencies","text":"<ul> <li>Follow the Preliminaries and Installation sections from the AEA quick start.</li> <li>Install Tensorflow</li> </ul>"},{"location":"aea-framework-documentation/ml-skills/#demo-instructions_1","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/ml-skills/#create-data-provider-aea","title":"Create Data Provider AEA","text":"<p>First, fetch the data provider AEA:</p> <pre><code>aea fetch fetchai/ml_data_provider:0.32.5\ncd ml_data_provider\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the data provider from scratch:</p> <pre><code>aea create ml_data_provider\ncd ml_data_provider\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/ml_data_provider:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/ml-skills/#create-model-trainer-aea","title":"Create Model Trainer AEA","text":"<p>Then, fetch the model trainer AEA:</p> <pre><code>aea fetch fetchai/ml_model_trainer:0.33.5\ncd ml_model_trainer\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the model trainer from scratch:</p> <pre><code>aea create ml_model_trainer\ncd ml_model_trainer\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/ml_train:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/ml-skills/#add-keys-for-the-data-provider-aea","title":"Add Keys for the Data Provider AEA","text":"<p>First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/ml-skills/#add-keys-and-generate-wealth-for-the-model-trainer-aea","title":"Add Keys and Generate Wealth for the Model Trainer AEA","text":"<p>The model trainer needs to have some wealth to purchase the data from the data provider.</p> <p>First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai <code>Dorado</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/ml-skills/#run-both-aeas","title":"Run both AEAs","text":"<p>Run both AEAs from their respective terminals.</p> <p>First, run the data provider AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the ML data provider.</p> <p>Then, in the ML model trainer, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>This allows the model trainer to connect to the same local agent communication network as the data provider.</p> <p>Then run the model trainer AEA:</p> <pre><code>aea run\n</code></pre> <p>You can see that the AEAs find each other, negotiate and eventually trade. After the trade, the model trainer AEA trains its ML model using the data it has purchased. This AEA keeps purchasing data and training its model until stopped.</p>"},{"location":"aea-framework-documentation/ml-skills/#cleaning-up","title":"Cleaning up","text":"<p>When you're finished, delete your AEAs:</p> <pre><code>cd ..\naea delete ml_data_provider\naea delete ml_model_trainer\n</code></pre>"},{"location":"aea-framework-documentation/modes/","title":"Modes of Running an AEA","text":"<p>We can run an AEA in multiple modes thanks to the configurable design of the framework.</p> <p>The AEA contains two runnable parts, the <code>AgentLoop</code>, which operates the skills, and the Multiplexer, which operates the connections. The <code>AgentLoop</code> can be configured to run in <code>async</code> or <code>sync</code> mode. The <code>Multiplexer</code> by default runs in <code>async</code> mode. The AEA itself, can be configured to run in <code>async</code> mode, if both the <code>Multiplexer</code> and <code>AgentLoop</code> have the same mode, or in <code>threaded</code> mode. The latter ensures that <code>AgentLoop</code> and <code>Multiplexer</code> are run in separate threads.</p>"},{"location":"aea-framework-documentation/multi-agent-manager/","title":"Multi Agent Manager","text":"<p>The <code>MultiAgentManager</code> allows managing multiple agent projects programmatically.</p>"},{"location":"aea-framework-documentation/multi-agent-manager/#setup","title":"Setup","text":"<p>We instantiate the manager by providing it with the working directory in which to operate and starting it:</p> <pre><code>import os\nfrom pathlib import Path\nfrom aea.manager import MultiAgentManager\nWORKING_DIR = \"mam\"\nmanager = MultiAgentManager(WORKING_DIR)\nmanager.start_manager()\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#adding-projects","title":"Adding Projects","text":"<p>We first add a couple of finished AEA project:</p> <pre><code>from aea.configurations.base import PublicId\nweather_station_id = PublicId.from_str(\"fetchai/weather_station:0.32.5\")\nweather_client_id = PublicId.from_str(\"fetchai/weather_client:0.33.5\")\nmanager.add_project(weather_station_id)\nmanager.add_project(weather_client_id)\nweather_station_name = weather_station_id.name\nweather_client_name = weather_client_id.name\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#adding-agent-instances","title":"Adding Agent Instances","text":"<p>Add the agent instances</p> <pre><code>agent_overrides = {\n\"private_key_paths\": {\"fetchai\": \"fetchai_private_key.txt\"},\n\"connection_private_key_paths\": {\"fetchai\": \"fetchai_connection_private_key.txt\"}\n}\np2p_public_id = PublicId.from_str(\"fetchai/p2p_libp2p:0.27.5\")\nsoef_public_id = PublicId.from_str(\"fetchai/soef:0.27.6\")\ncomponent_overrides = [{\n**p2p_public_id.json,\n\"type\": \"connection\",\n\"cert_requests\": [{\n\"identifier\": \"acn\",\n\"ledger_id\": \"fetchai\",\n\"not_after\": '2022-01-01',\n\"not_before\": '2021-01-01',\n\"public_key\": \"fetchai\",\n\"message_format\": \"{public_key}\",\n\"save_path\": \"conn_cert.txt\"\n}]\n}, {\n**soef_public_id.json,\n\"type\": \"connection\",\n\"config\": {\n\"token_storage_path\": \"soef_token.txt\"\n}\n}]\nmanager.add_agent(weather_station_id, component_overrides=component_overrides, agent_overrides=agent_overrides)\nagent_overrides = {\n\"private_key_paths\": {\"fetchai\": \"fetchai_private_key.txt\"},\n\"connection_private_key_paths\": {\"fetchai\": \"fetchai_connection_private_key.txt\"}\n}\ncomponent_overrides = [{\n**p2p_public_id.json,\n\"type\": \"connection\",\n\"config\": {\n\"delegate_uri\": \"127.0.0.1:11001\",\n\"entry_peers\": ['/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw'],\n\"local_uri\": \"127.0.0.1:9001\",\n\"public_uri\": \"127.0.0.1:9001\",\n},\n\"cert_requests\": [{\n\"identifier\": \"acn\",\n\"ledger_id\": \"fetchai\",\n\"not_after\": '2022-01-01',\n\"not_before\": '2021-01-01',\n\"public_key\": \"fetchai\",\n\"message_format\": \"{public_key}\",\n\"save_path\": \"conn_cert.txt\"\n}]\n}, {\n**soef_public_id.json,\n\"type\": \"connection\",\n\"config\": {\n\"token_storage_path\": \"soef_token.txt\"\n}\n}]\nmanager.add_agent(weather_client_id, component_overrides=component_overrides, agent_overrides=agent_overrides)\n</code></pre> <p>Save the following private keys in the respective files.</p> <pre><code>FET_PRIVATE_KEY_STATION = b\"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\"\nFET_PRIVATE_KEY_PATH_STATION = Path(manager.data_dir, weather_station_name, \"fetchai_private_key.txt\").absolute()\nFET_PRIVATE_KEY_PATH_STATION.write_bytes(FET_PRIVATE_KEY_STATION)\nFET_CONNECTION_PRIVATE_KEY_STATION = b\"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\"\nFET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path(manager.data_dir, weather_station_name, \"fetchai_connection_private_key.txt\").absolute()\nFET_CONNECTION_PRIVATE_KEY_PATH_STATION.write_bytes(FET_CONNECTION_PRIVATE_KEY_STATION)\nFET_PRIVATE_KEY_CLIENT = b\"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\"\nFET_PRIVATE_KEY_PATH_CLIENT = Path(manager.data_dir, weather_client_name, \"fetchai_private_key.txt\").absolute()\nFET_PRIVATE_KEY_PATH_CLIENT.write_bytes(FET_PRIVATE_KEY_CLIENT)\nFET_CONNECTION_PRIVATE_KEY_CLIENT = b\"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\"\nFET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path(manager.data_dir, weather_client_name, \"fetchai_connection_private_key.txt\").absolute()\nFET_CONNECTION_PRIVATE_KEY_PATH_CLIENT.write_bytes(FET_CONNECTION_PRIVATE_KEY_CLIENT)\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#running-the-agents","title":"Running the Agents","text":"<pre><code>import time\nmanager.start_agent(weather_station_id.name)\n# wait for ~10 seconds for peer node to go live\ntime.sleep(10.0)\nmanager.start_agent(weather_client_id.name)\ntime.sleep(5.0)\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#stopping-the-agents","title":"Stopping the Agents","text":"<pre><code>manager.stop_all_agents()\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#cleaning-up","title":"Cleaning up","text":"<pre><code>manager.stop_manager()\n</code></pre>"},{"location":"aea-framework-documentation/multi-agent-manager/#limitations","title":"Limitations","text":"<p>The <code>MultiAgentManager</code> can only be used with compatible package versions, in particular the same package (with respect to author and name) cannot be used in different versions. If you want to run multiple agents with differing versions of the same package then use the <code>aea launch</code> command in the multi-processing mode, or simply launch each agent individually with <code>aea run</code>.</p>"},{"location":"aea-framework-documentation/multiplexer-standalone/","title":"Use Multiplexer Stand-Alone","text":"<p>The <code>Multiplexer</code> can be used stand-alone. This way a developer can utilise the protocols and connections independent of the <code>Agent</code> or <code>AEA</code> classes.</p> <p>First, import the Python and application specific libraries and set the static variables. (Get the <code>packages</code> directory from the AEA repository <code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages</code>.)</p> <pre><code>import os\nimport time\nfrom copy import copy\nfrom threading import Thread\nfrom typing import Optional\nfrom aea.configurations.base import ConnectionConfig\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.identity.base import Identity\nfrom aea.mail.base import Envelope\nfrom aea.multiplexer import Multiplexer\nfrom packages.fetchai.connections.stub.connection import StubConnection\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nINPUT_FILE = \"input.txt\"\nOUTPUT_FILE = \"output.txt\"\n</code></pre>"},{"location":"aea-framework-documentation/multiplexer-standalone/#instantiate-a-multiplexer","title":"Instantiate a <code>Multiplexer</code>","text":"<p>A <code>Multiplexer</code> only needs a list of connections. The <code>StubConnection</code> is a simple connection which reads from and writes to file.</p> <pre><code>    # Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n# create the connection and multiplexer objects\nconfiguration = ConnectionConfig(\ninput_file=INPUT_FILE,\noutput_file=OUTPUT_FILE,\nconnection_id=StubConnection.connection_id,\n)\nstub_connection = StubConnection(\nconfiguration=configuration,\ndata_dir=\".\",\nidentity=Identity(\"some_agent\", \"some_address\", \"some_public_key\"),\n)\nmultiplexer = Multiplexer([stub_connection], protocols=[DefaultMessage])\n</code></pre>"},{"location":"aea-framework-documentation/multiplexer-standalone/#start-the-multiplexer","title":"Start the <code>Multiplexer</code>","text":"<p>We can run a multiplexer by calling, <code>connect()</code> which starts the 'receive' and 'send' loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages.</p> <pre><code>    try:\n# Set the multiplexer running in a different thread\nt = Thread(target=multiplexer.connect)\nt.start()\n# Wait for everything to start up\nfor _ in range(20):\nif multiplexer.is_connected:\nbreak\ntime.sleep(1)\nelse:\nraise Exception(\"Not connected\")\n</code></pre>"},{"location":"aea-framework-documentation/multiplexer-standalone/#send-and-receive-an-envelope","title":"Send and Receive an Envelope","text":"<p>We use the input and output text files to send an envelope to our agent and receive a response</p> <pre><code>        # Create a message inside an envelope and get the stub connection to pass it into the multiplexer\nmessage_text = (\n\"multiplexer,some_agent,fetchai/default:1.0.0,\\x08\\x01*\\x07\\n\\x05hello,\"\n)\nwith open(INPUT_FILE, \"w\") as f:\nwrite_with_lock(f, message_text)\n# Wait for the envelope to get processed\nfor _ in range(20):\nif not multiplexer.in_queue.empty():\nbreak\ntime.sleep(1)\nelse:\nraise Exception(\"No message!\")\n# get the envelope\nenvelope = multiplexer.get()  # type: Optional[Envelope]\nassert envelope is not None\n# Inspect its contents\nprint(\n\"Envelope received by Multiplexer: sender={}, to={}, protocol_specification_id={}, message={}\".format(\nenvelope.sender,\nenvelope.to,\nenvelope.protocol_specification_id,\nenvelope.message,\n)\n)\n# Create a mirrored response envelope\nresponse_envelope = copy(envelope)\nresponse_envelope.to = envelope.sender\nresponse_envelope.sender = envelope.to\n# Send the envelope back\nmultiplexer.put(response_envelope)\n# Read the output envelope generated by the multiplexer\nwith open(OUTPUT_FILE, \"r\") as f:\nprint(\"Envelope received from Multiplexer: \" + f.readline())\n</code></pre>"},{"location":"aea-framework-documentation/multiplexer-standalone/#shutdown","title":"Shutdown","text":"<p>Finally, stop our multiplexer and wait for it to finish</p> <pre><code>    finally:\n# Shut down the multiplexer\nmultiplexer.disconnect()\nt.join()\n</code></pre>"},{"location":"aea-framework-documentation/multiplexer-standalone/#your-turn","title":"Your Turn","text":"<p>Now it is your turn to develop a simple use case which utilises the <code>Multiplexer</code> to send and receive Envelopes.</p>"},{"location":"aea-framework-documentation/multiplexer-standalone/#entire-code-listing","title":"Entire Code Listing","text":"<p>If you just want to copy and paste the entire script in you can find it here:</p> Click here to see full listing: <pre><code>import os\nimport time\nfrom copy import copy\nfrom threading import Thread\nfrom typing import Optional\nfrom aea.configurations.base import ConnectionConfig\nfrom aea.helpers.file_io import write_with_lock\nfrom aea.identity.base import Identity\nfrom aea.mail.base import Envelope\nfrom aea.multiplexer import Multiplexer\nfrom packages.fetchai.connections.stub.connection import StubConnection\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nINPUT_FILE = \"input.txt\"\nOUTPUT_FILE = \"output.txt\"\ndef run():\n\"\"\"Run demo.\"\"\"\n# Ensure the input and output files do not exist initially\nif os.path.isfile(INPUT_FILE):\nos.remove(INPUT_FILE)\nif os.path.isfile(OUTPUT_FILE):\nos.remove(OUTPUT_FILE)\n# create the connection and multiplexer objects\nconfiguration = ConnectionConfig(\ninput_file=INPUT_FILE,\noutput_file=OUTPUT_FILE,\nconnection_id=StubConnection.connection_id,\n)\nstub_connection = StubConnection(\nconfiguration=configuration,\ndata_dir=\".\",\nidentity=Identity(\"some_agent\", \"some_address\", \"some_public_key\"),\n)\nmultiplexer = Multiplexer([stub_connection], protocols=[DefaultMessage])\ntry:\n# Set the multiplexer running in a different thread\nt = Thread(target=multiplexer.connect)\nt.start()\n# Wait for everything to start up\nfor _ in range(20):\nif multiplexer.is_connected:\nbreak\ntime.sleep(1)\nelse:\nraise Exception(\"Not connected\")\n# Create a message inside an envelope and get the stub connection to pass it into the multiplexer\nmessage_text = (\n\"multiplexer,some_agent,fetchai/default:1.0.0,\\x08\\x01*\\x07\\n\\x05hello,\"\n)\nwith open(INPUT_FILE, \"w\") as f:\nwrite_with_lock(f, message_text)\n# Wait for the envelope to get processed\nfor _ in range(20):\nif not multiplexer.in_queue.empty():\nbreak\ntime.sleep(1)\nelse:\nraise Exception(\"No message!\")\n# get the envelope\nenvelope = multiplexer.get()  # type: Optional[Envelope]\nassert envelope is not None\n# Inspect its contents\nprint(\n\"Envelope received by Multiplexer: sender={}, to={}, protocol_specification_id={}, message={}\".format(\nenvelope.sender,\nenvelope.to,\nenvelope.protocol_specification_id,\nenvelope.message,\n)\n)\n# Create a mirrored response envelope\nresponse_envelope = copy(envelope)\nresponse_envelope.to = envelope.sender\nresponse_envelope.sender = envelope.to\n# Send the envelope back\nmultiplexer.put(response_envelope)\n# Read the output envelope generated by the multiplexer\nwith open(OUTPUT_FILE, \"r\") as f:\nprint(\"Envelope received from Multiplexer: \" + f.readline())\nfinally:\n# Shut down the multiplexer\nmultiplexer.disconnect()\nt.join()\nif __name__ == \"__main__\":\nrun()\n</code></pre>"},{"location":"aea-framework-documentation/oracle-demo/","title":"Oracle Skills","text":"<p>This demo shows how an AEA can be used to maintain an oracle and how another AEA can request the oracle value.</p>"},{"location":"aea-framework-documentation/oracle-demo/#discussion","title":"Discussion","text":"<p>Oracle agents are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities.</p> <p>This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract.</p>"},{"location":"aea-framework-documentation/oracle-demo/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/oracle-demo/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/oracle-demo/#demo","title":"Demo","text":""},{"location":"aea-framework-documentation/oracle-demo/#create-the-oracle-aea","title":"Create the Oracle AEA","text":"<p>Fetch the AEA that will deploy and update the oracle contract.</p> <pre><code>aea fetch fetchai/coin_price_oracle:0.17.6\ncd coin_price_oracle\naea install\n</code></pre> Alternatively, create from scratch (and customize the data source): <p>Create the AEA that will deploy the contract.</p> <pre><code>aea create coin_price_oracle\ncd coin_price_oracle\naea add connection fetchai/http_client:0.24.6\naea add connection fetchai/ledger:0.21.5\naea add connection fetchai/prometheus:0.9.6\naea add skill fetchai/advanced_data_request:0.7.6\naea add skill fetchai/simple_oracle:0.16.5\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/ledger:0.21.5\naea install\n</code></pre> <p>Set the URL for the data request skill:</p> <pre><code>aea config set --type str vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url \"https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&amp;vs_currencies=usd\"\n</code></pre> <p>Specify the name and JSON path of the data to fetch from the API:</p> <pre><code>aea config set --type list vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": \"fetch-ai.usd\"}]'\n</code></pre> <p>Set the name of the oracle value in the simple oracle skill:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price\n</code></pre> <p>Then update the agent configuration with the default routing:</p> <pre><code>aea config set --type dict agent.default_routing \\\n'{\n\"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n\"fetchai/http:1.1.7\": \"fetchai/http_client:0.24.6\",\n\"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\"\n}'\n</code></pre> <p>Update the default ledger.</p> <pre><code>aea config set agent.default_ledger fetchai\n</code></pre> <p>Set the following configuration for the oracle skill:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id fetchai\naea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value\n</code></pre> <p>This demo runs on the <code>fetchai</code> ledger by default. Set the following variable for use in the configuration steps:</p> <pre><code>LEDGER_ID=fetchai\n</code></pre> Alternatively, configure the agent to use an ethereum ledger: <pre><code>LEDGER_ID=ethereum\n</code></pre> <p>Update the default ledger.</p> <pre><code>aea config set agent.default_ledger ethereum\n</code></pre> <p>Set the following configuration for the oracle skill:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id ethereum\naea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function updateOracleValue\n</code></pre> <p>Additionally, create the private key for the oracle AEA. Generate and add a key for use with the ledger:</p> <pre><code>aea generate-key $LEDGER_ID --add-key\n</code></pre> <p>If running on a testnet (not including Ganache), generate some wealth for your AEA:</p> <pre><code>aea generate-wealth $LEDGER_ID\n</code></pre>"},{"location":"aea-framework-documentation/oracle-demo/#create-the-oracle-client-aea","title":"Create the Oracle Client AEA","text":"<p>From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract.</p> <pre><code>aea fetch fetchai/coin_price_oracle_client:0.12.6\ncd coin_price_oracle_client\naea install\n</code></pre> Alternatively, create from scratch: <p>Create the AEA that will deploy the contract.</p> <pre><code>aea create coin_price_oracle_client\ncd coin_price_oracle_client\naea add connection fetchai/http_client:0.24.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/simple_oracle_client:0.13.5\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/ledger:0.21.5\naea install\n</code></pre> <p>Then update the agent configuration with the default routing:</p> <pre><code>aea config set --type dict agent.default_routing \\\n'{\n\"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n\"fetchai/http:1.1.7\": \"fetchai/http_client:0.24.6\",\n\"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\"\n}'\n</code></pre> <p>Set the default ledger:</p> <p><pre><code>aea config set agent.default_ledger fetchai\n</code></pre> Set the following configuration for the oracle client skill:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.ledger_id fetchai\naea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function query_oracle_value\n</code></pre> <p>Similar to above, set a temporary variable <code>LEDGER_ID=fetchai</code> or <code>LEDGER_ID=ethereum</code>.</p> Follow these steps to configure for an ethereum ledger: <p>Set the default ledger:</p> <pre><code>aea config set agent.default_ledger ethereum\n</code></pre> <p>Set the following configuration for the oracle client skill:</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.ledger_id ethereum\naea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function queryOracleValue\n</code></pre> <p>Create the private key for the oracle client AEA. Generate and add a key for use on the ledger:</p> <pre><code>aea generate-key $LEDGER_ID --add-key\n</code></pre> <p>If running on a testnet (not including Ganache), generate some wealth for your AEA:</p> <pre><code>aea generate-wealth $LEDGER_ID\n</code></pre>"},{"location":"aea-framework-documentation/oracle-demo/#configuring-a-ledger","title":"Configuring a Ledger","text":"<p>The oracle AEAs require either a locally running ledger node or a connection to a remote ledger. By default, they are configured to use the latest <code>fetchai</code> testnet.</p> Follow these steps to configure local Ethereum test node: <p>The easiest way to test the oracle agents on an Ethereum-based ledger to set up a local test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs:</p> <pre><code>docker run -p 8545:8545 trufflesuite/ganache-cli:latest --verbose --gasPrice=0 --gasLimit=0x1fffffffffffff --account=\"$(cat coin_price_oracle/ethereum_private_key.txt),1000000000000000000000\" --account=\"$(cat coin_price_oracle_client/ethereum_private_key.txt),1000000000000000000000\"\n</code></pre> <p>Run the following Python script (with <code>web3</code> installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent.</p> <pre><code>import json\nimport os\nfrom web3 import Web3\nFILE_DIR = os.path.dirname(os.path.realpath(__file__))\nCONTRACT_PATH = os.path.join(FILE_DIR, \"coin_price_oracle_client/vendor/fetchai/contracts/fet_erc20/build/FetERC20Mock.json\")\nORACLE_PRIVATE_KEY_PATH = os.path.join(FILE_DIR, \"coin_price_oracle/ethereum_private_key.txt\")\nCLIENT_PRIVATE_KEY_PATH = os.path.join(FILE_DIR, \"coin_price_oracle_client/ethereum_private_key.txt\")\n# Solidity source code\nwith open(CONTRACT_PATH) as file:\ncompiled_sol = json.load(file)\n# web3.py instance\nw3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))\n# Import oracle account from private key and set to default account\nwith open(ORACLE_PRIVATE_KEY_PATH) as file:\nprivate_key = file.read()\noracle_account = w3.eth.account.privateKeyToAccount(private_key)\nw3.eth.defaultAccount = oracle_account.address\n# Import client account from private key\nwith open(CLIENT_PRIVATE_KEY_PATH) as file:\nprivate_key = file.read()\nclient_account = w3.eth.account.privateKeyToAccount(private_key)\n# Deploy mock Fetch ERC20 contract\nFetERC20Mock = w3.eth.contract(abi=compiled_sol['abi'], bytecode=compiled_sol['bytecode'])\n# Submit the transaction that deploys the contract\ntx_hash = FetERC20Mock.constructor(\nname=\"FetERC20Mock\",\nsymbol=\"MFET\",\ninitialSupply=int(1e23),\ndecimals_=18).transact()\n# Wait for the transaction to be mined, and get the transaction receipt\ntx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)\n# Print out the contract address\nprint(\"FetERC20Mock contract deployed at:\", tx_receipt.contractAddress)\n# Get deployed contract\nfet_erc20_mock = w3.eth.contract(address=tx_receipt.contractAddress, abi=compiled_sol['abi'])\n# Transfer some test FET to oracle client account\ntx_hash = fet_erc20_mock.functions.transfer(client_account.address, int(1e20)).transact()\ntx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)\n</code></pre> <p>Set the ERC20 contract address for the oracle AEA</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.erc20_address $ERC20_ADDRESS\n</code></pre> <p>as well as for the oracle client AEA</p> <pre><code>aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.erc20_address $ERC20_ADDRESS\n</code></pre> <p>where <code>ERC20_ADDRESS</code> is in the output of the script above.</p>"},{"location":"aea-framework-documentation/oracle-demo/#run-the-oracle-aea","title":"Run the Oracle AEA","text":"<p>Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified).</p> <pre><code>aea run\n</code></pre> <p>After a few moments, you should see the following notices in the logs:</p> <pre><code>info: [coin_price_oracle] Oracle contract successfully deployed at address: ...\n...\ninfo: [coin_price_oracle] Oracle role successfully granted!\n...\ninfo: [coin_price_oracle] Oracle value successfully updated!\n</code></pre> <p>The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds).</p>"},{"location":"aea-framework-documentation/oracle-demo/#set-the-erc20-and-oracle-contract-addresses-for-the-oracle-client-aea","title":"Set the ERC20 and Oracle Contract Addresses for the Oracle Client AEA","text":"<pre><code>aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.oracle_contract_address $ORACLE_ADDRESS\n</code></pre> <p>where <code>ORACLE_ADDRESS</code> should be set to the address shown in the oracle AEA logs:</p> <pre><code>Oracle contract successfully deployed at address: ORACLE_ADDRESS\n</code></pre>"},{"location":"aea-framework-documentation/oracle-demo/#run-the-oracle-client-aea","title":"Run the Oracle Client AEA","text":"<p>Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified).</p> <pre><code>aea run\n</code></pre> <p>After a few moments, you should see the following notices in the logs:</p> <pre><code>info: [coin_price_oracle_client] Oracle client contract successfully deployed at address: ...\n...\ninfo: [coin_price_oracle_client] Oracle value successfully requested!\n</code></pre> <p>The AEA will continue to request the latest coin price at the default time interval (every 15 seconds).</p>"},{"location":"aea-framework-documentation/orm-integration/","title":"ORM Integration","text":"<p>This guide demonstrates how to configure an AEA to interact with a database using <code>python-sql</code> objects.</p>"},{"location":"aea-framework-documentation/orm-integration/#discussion","title":"Discussion","text":"<p>Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of this guide is to demonstrate how you can create an easily configurable AEA that reads data from a database using ORMs.</p> <ul> <li>We assume, that you followed the guide for the  thermometer-skills. </li> <li>We assume, that we have a database <code>genericdb.db</code> with table name <code>data</code>. This table contains the following columns <code>timestamp</code> and <code>thermometer</code>.</li> <li>We assume, that we have a hardware thermometer sensor that adds the readings in the <code>genericdb</code> database (although you can follow the guide without having access to a sensor).</li> </ul> <p>Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The <code>aea install</code> command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file.</p>"},{"location":"aea-framework-documentation/orm-integration/#communication","title":"Communication","text":"<p>This diagram shows the communication between the various entities in the case where the thermometer data is successfully sold by the seller AEA to the buyer.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Buyer_AEA\n        participant Seller_AEA\n        participant Blockchain\n\n        activate Buyer_AEA\n        activate Search\n        activate Seller_AEA\n        activate Blockchain\n\n        Seller_AEA-&gt;&gt;Search: register_service\n        Buyer_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Buyer_AEA: list_of_agents\n        Buyer_AEA-&gt;&gt;Seller_AEA: call_for_proposal\n        Seller_AEA-&gt;&gt;Buyer_AEA: propose\n        Buyer_AEA-&gt;&gt;Seller_AEA: accept\n        Seller_AEA-&gt;&gt;Buyer_AEA: match_accept\n        Buyer_AEA-&gt;&gt;Blockchain: transfer_funds\n        Buyer_AEA-&gt;&gt;Seller_AEA: send_transaction_hash\n        Seller_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Seller_AEA-&gt;&gt;Buyer_AEA: send_data\n\n        deactivate Buyer_AEA\n        deactivate Search\n        deactivate Seller_AEA\n        deactivate Blockchain    </code></pre>"},{"location":"aea-framework-documentation/orm-integration/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/orm-integration/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/orm-integration/#demo-instructions","title":"Demo Instructions","text":"<p>This demo involves a true ledger transaction on Fetch.ai's <code>testnet</code> network or Ethereum's <code>ropsten</code>. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.</p>"},{"location":"aea-framework-documentation/orm-integration/#create-the-seller-aea","title":"Create the Seller AEA","text":"<p>First, fetch the seller AEA which provides thermometer data:</p> <pre><code>aea fetch fetchai/thermometer_aea:0.30.5 --alias my_thermometer_aea\ncd my_thermometer_aea\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the seller from scratch:</p> <pre><code>aea create my_thermometer_aea\ncd my_thermometer_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/thermometer:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#create-the-buyer-client","title":"Create the Buyer Client","text":"<p>In another terminal, fetch the buyer AEA:</p> <pre><code>aea fetch fetchai/thermometer_client:0.32.5 --alias my_thermometer_client\ncd my_thermometer_client\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the car data client from scratch:</p> <pre><code>aea create my_thermometer_client\ncd my_thermometer_client\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/thermometer_client:0.26.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#add-keys-for-the-seller-aea","title":"Add Keys for the Seller AEA","text":"<p>First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#add-keys-and-generate-wealth-for-the-buyer-aea","title":"Add Keys and Generate Wealth for the Buyer AEA","text":"<p>The buyer needs to have some wealth to purchase the thermometer data.</p> <p>First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for the buyer based on the network you want to transact with. On the Fetch.ai <code>Dorado</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#update-the-seller-and-buyer-aea-skill-configurations","title":"Update the Seller and Buyer AEA Skill Configurations","text":"<p>In <code>my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml</code>, replace the <code>data_for_sale</code> with your data:</p> <pre><code>models:\n...\nstrategy:\nargs:\ncurrency_id: FET\ndata_for_sale:\ntemperature: 26\nhas_data_source: false\nis_ledger_tx: true\nledger_id: fetchai\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nservice_data:\nkey: seller_service\nvalue: thermometer_data\nservice_id: thermometer_data\nunit_price: 10\nclass_name: Strategy\ndependencies:\nSQLAlchemy: {}\n</code></pre> <p>The <code>service_data</code> is used to register the service in the SOEF search node and make your agent discoverable.</p> <p>In <code>my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml</code>) ensure you have matching data.</p> <pre><code>models:\n...\nstrategy:\nargs:\ncurrency_id: FET\nis_ledger_tx: true\nledger_id: fetchai\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nmax_negotiations: 1\nmax_tx_fee: 3550000000000000\nmax_unit_price: 20\nsearch_query:\nconstraint_type: ==\nsearch_key: seller_service\nsearch_value: thermometer_data\nsearch_radius: 5.0\nservice_id: thermometer_data\nclass_name: Strategy\n</code></pre> <p>After changing the skill configuration files you should run the following command for both agents to install each dependency:</p> <pre><code>aea install\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#modify-the-sellers-strategy","title":"Modify the Seller's Strategy","text":"<p>Before being able to modify a package we need to eject it from vendor:</p> <pre><code>aea eject skill fetchai/thermometer:0.27.6\n</code></pre> <p>This will move the package to your <code>skills</code> directory and reset the version to <code>0.1.0</code> and the author to your author handle.</p> <p>Open <code>strategy.py</code> (in <code>my_thermometer_aea/skills/thermometer/strategy.py</code>) and make the following modifications:</p> <p>Import the newly installed <code>sqlalchemy</code> library in your strategy.</p> <pre><code>import sqlalchemy as db\n</code></pre> <p>Then modify your strategy's <code>__init__</code> function to match the following code:</p> <pre><code>class Strategy(GenericStrategy):\n\"\"\"This class defines a strategy for the agent.\"\"\"\ndef __init__(self, **kwargs) -&gt; None:\n\"\"\"\n        Initialize the strategy of the agent.\n        :param register_as: determines whether the agent registers as seller, buyer or both\n        :param search_for: determines whether the agent searches for sellers, buyers or both\n        :return: None\n        \"\"\"\nself._db_engine = db.create_engine(\"sqlite:///genericdb.db\")\nself._tbl = self.create_database_and_table()\nself.insert_data()\nsuper().__init__(**kwargs)\n</code></pre> <p>At the end of the file modify the <code>collect_from_data_source</code> function:</p> <pre><code>    def collect_from_data_source(self) -&gt; Dict[str, str]:\n\"\"\"Implement the logic to collect data.\"\"\"\nconnection = self._db_engine.connect()\nquery = db.select([self._tbl])\nresult_proxy = connection.execute(query)\ndata_points = result_proxy.fetchall()\nreturn {\"data\": json.dumps(list(map(tuple, data_points)))}\n</code></pre> <p>Also, create two new functions, one that creates a connection with the database, and another that populates the database with some fake data. This is needed in the case you do not have access to an actual thermometer sensor that inserts data in the database.</p> <pre><code>    def create_database_and_table(self):\n\"\"\"Creates a database and a table to store the data if not exists.\"\"\"\nmetadata = db.MetaData()\ntbl = db.Table(\n\"data\",\nmetadata,\ndb.Column(\"timestamp\", db.Integer()),\ndb.Column(\"temprature\", db.String(255), nullable=False),\n)\nmetadata.create_all(self._db_engine)\nreturn tbl\ndef insert_data(self):\n\"\"\"Insert data in the database.\"\"\"\nconnection = self._db_engine.connect()\nfor _ in range(10):\nquery = db.insert(self._tbl).values(  # nosec\ntimestamp=time.time(), temprature=str(random.randrange(10, 25))\n)\nconnection.execute(query)\n</code></pre> <p>After modifying the skill we need to fingerprint it:</p> <pre><code>aea fingerprint skill {YOUR_AUTHOR_HANDLE}/thermometer:0.1.0\n</code></pre>"},{"location":"aea-framework-documentation/orm-integration/#run-both-aeas","title":"Run Both AEAs","text":"<p>First, run the thermometer (seller) AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of this address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA.</p> <p>Then, configure the thermometer client (buyer) to connect to this same local ACN by running the following command in the buyer terminal, replacing <code>SOME_ADDRESS</code> with the value you noted above:</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Then run the thermometer client AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that the AEAs negotiate and then transact using the configured testnet.</p>"},{"location":"aea-framework-documentation/orm-integration/#delete-the-aeas","title":"Delete the AEAs","text":"<p>When you're done, stop the agents (<code>CTRL+C</code>), go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete my_thermometer_aea\naea delete my_thermometer_client\n</code></pre>"},{"location":"aea-framework-documentation/p2p-connection/","title":"P2P Connection","text":"<p>The <code>fetchai/p2p_libp2p:0.27.5</code> connection allows AEAs to create a peer-to-peer communication network. In particular, the connection creates an overlay network which maps agents' public keys to IP addresses.</p>"},{"location":"aea-framework-documentation/p2p-connection/#local-demo","title":"Local Demo","text":"<p>First, make sure you have installed the crypto plugin of the target test-net. E.g. for Fetch.AI:</p> <pre><code>pip install aea-ledger-fetchai\n</code></pre>"},{"location":"aea-framework-documentation/p2p-connection/#create-and-run-the-genesis-aea","title":"Create and Run the Genesis AEA","text":"<p>Create one AEA as follows:</p> <pre><code>aea create my_genesis_aea\ncd my_genesis_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea install\naea build\n</code></pre> <p>Establish the proof of representation:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\naea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\naea issue-certificates\n</code></pre> <p>Run the AEA:</p> <pre><code>aea run --connections fetchai/p2p_libp2p:0.27.5\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA.</p>"},{"location":"aea-framework-documentation/p2p-connection/#create-and-run-another-aea","title":"Create and Run Another AEA","text":"<p>Create a second AEA:</p> <pre><code>aea create my_other_aea\ncd my_other_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea install\naea build\n</code></pre> <p>Establish the proof of representation:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\naea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\naea issue-certificates\n</code></pre> <p>Provide the AEA with the information it needs to find the genesis:</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Here <code>SOME_ADDRESS</code> needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA.</p> <p>Run the AEA:</p> <pre><code>aea run --connections fetchai/p2p_libp2p:0.27.5\n</code></pre> <p>You can inspect the <code>libp2p_node.log</code> log files of the AEA to see how they discover each other.</p> <p>Note</p> <p>Currently <code>p2p_libp2p</code> connection limits the total message size to 3 MB.</p>"},{"location":"aea-framework-documentation/p2p-connection/#local-demo-with-skills","title":"Local Demo with Skills","text":"<p>Explore the demo section for further examples.</p>"},{"location":"aea-framework-documentation/p2p-connection/#deployed-agent-communication-network","title":"Deployed Agent Communication Network","text":"<p>You can connect to the deployed public test network by adding one or multiple of the following addresses as the <code>p2p_libp2p</code> connection's <code>entry_peers</code>:</p> <pre><code>/dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx\n</code></pre> <pre><code>/dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW\n</code></pre> <p>Specifically, in an AEA's configuration <code>aea-config.yaml</code> add the above addresses for <code>entry_peers</code> as follows:</p> <pre><code>---\npublic_id: fetchai/p2p_libp2p:0.27.5\ntype: connection\nconfig:\ndelegate_uri: null\nentry_peers: [/dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx,/dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW]\npublic_uri: null\nlocal_uri: 127.0.0.1:9001\n</code></pre> <p>Note, this configuration change must be made for all agents attempting to communicate with each other via the Agent Communication Network. For example, in demos involving two agents, both agents will need the above modifications to their respective <code>aea-config.yaml</code> file. However, remember to use different ports in <code>local_uri.</code> This will allow both agents to default to this communication network without the added overhead of opening ports and specifying hosts on the individual host machines running each agent.</p>"},{"location":"aea-framework-documentation/p2p-connection/#configuring-the-connectionyaml-entries","title":"Configuring the <code>connection.yaml</code> Entries","text":"<p>To learn more about how to configure your <code>fetchai/p2p_libp2p:0.27.5</code> connection consult the <code>README.md</code> file supplied with the connection package.</p>"},{"location":"aea-framework-documentation/p2p-connection/#running-go-peer-standalone","title":"Running Go Peer Standalone","text":"<p>You can run a peer node in standalone mode; that is, as a Go process with no dependency on the AEA framework. To facilitate such a deployment, we provide a script  <code>run_acn_node_standalone.py</code>  and a corresponding  Dockerfile.</p> <p>First, you need to build the node's binary (<code>libp2p_node</code>) either:</p> <ul> <li> <p>locally</p> <pre><code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages/fetchai/connections/p2p_libp2p\ncd p2p_libp2p\ngo build\nchmod +x libp2p_node\n</code></pre> <p>Make sure you satisfy the system requirements.</p> </li> <li> <p>or within a docker image using the provided Dockerfile:</p> <pre><code>docker build -t acn_node_standalone -f scripts/acn/Dockerfile .\n</code></pre> </li> </ul> <p>Next, to run the node binary in standalone mode, it requires values for the following entries:</p> <ul> <li><code>AEA_P2P_ID</code>: the node's private key, will be used as its identity</li> <li><code>AEA_P2P_URI</code>: the local host and port to use by node</li> <li><code>AEA_P2P_URI_PUBLIC</code>: the URI under which the peer is publicly reachable</li> <li><code>AEA_P2P_DELEGATE_URI</code>: the URI under which the peer receives delegate connections</li> <li><code>AEA_P2P_ENTRY_URIS</code>: an optionally supplied list of comma-separated (<code>,</code>) entry multiaddresses for the peer to bootstrap</li> </ul> <p>The script allows different methods to pass these values to the node:</p> <ul> <li> <p>As environment variables exported in the format <code>&lt;ENTRY_KEYWORD&gt;=&lt;ENTRY_VALUE&gt;</code> for each entry. Then:</p> <pre><code>python3 run_acn_node_standalone.py libp2p_node --config-from-env\n</code></pre> </li> <li> <p>Using an environment file containing the entries and their values in the format <code>&lt;ENTRY_KEYWORD&gt;=&lt;ENTRY_VALUE&gt;</code>, one entry per line. Then:</p> <pre><code>python3 run_acn_node_standalone.py libp2p_node --config-from-file &lt;env-file-path&gt;\n</code></pre> <p>or</p> <pre><code>docker run -v &lt;acn_config_file&gt;:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config\n</code></pre> </li> <li> <p>Using command line arguments:</p> <pre><code>python3 run_acn_node_standalone.py libp2p_node --key-file &lt;node_private_key.txt&gt; \\\n--uri &lt;AEA_P2P_URI&gt; --uri-external &lt;AEA_P2P_URI_PUBLIC&gt;  \\\n--uri-delegate &lt;AEA_P2P_DELEGATE_URI&gt; \\\n--entry-peers-maddrs &lt;AEA_P2P_ENTRY_URI_1&gt; &lt;AEA_P2P_ENTRY_URI_2&gt; ...\n</code></pre> <p>or</p> <pre><code>docker run -v &lt;node_private_key.txt&gt;:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\\n--uri &lt;AEA_P2P_URI&gt; --uri-external &lt;AEA_P2P_URI_PUBLIC&gt;  \\\n--uri-delegate &lt;AEA_P2P_DELEGATE_URI&gt; \\\n--entry-peers-maddrs &lt;AEA_P2P_ENTRY_URI_1&gt; &lt;AEA_P2P_ENTRY_URI_2&gt; ...\n</code></pre> </li> </ul> <p>Note that the script will always save the configuration of the running node as a file under the name <code>.acn_config</code> in the current working directory. This can be handy when you want the exact same configuration for future runs of the node.</p>"},{"location":"aea-framework-documentation/package-imports/","title":"File Structure","text":"<p>An agent that is generated using the AEA framework is a modular system with different connections, contracts, protocols and skills.</p>"},{"location":"aea-framework-documentation/package-imports/#an-aea-projects-file-structure","title":"An AEA Project's File Structure","text":"<p>The file structure of an AEA is fixed.</p> <p>The top level directory has the AEA's name. Below is a <code>aea-config.yaml</code> configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry (local or remote - added via <code>aea fetch</code> or <code>aea add</code>) are located in <code>vendor</code> and sorted by author. Build artefacts are placed in the <code>.build/</code> directory and certificates are placed in the <code>.certs/</code> directory. Finally, there are files containing the private keys of the AEA.</p> <p>When we create a new agent with the command <code>aea create my_aea</code> we create the file structure that looks like the following:</p> <pre><code>aea_name/\n  aea-config.yaml       YAML configuration of the AEA\n  fetchai_private_key.txt   The private key file\n  connections/          Directory containing all the connections developed as part of the given project.\n    connection_1/       First connection\n    ...                 ...\n    connection_n/       nth connection\n  contracts/            Directory containing all the contracts developed as part of the given project.\n    connection_1/       First connection\n    ...                 ...\n    connection_n/       nth connection\n  protocols/            Directory containing all the protocols developed as part of the given project.\n    protocol_1/         First protocol\n    ...                 ...\n    protocol_m/         mth protocol\n  skills/               Directory containing all the skills developed as part of the given project.\n    skill_1/            First skill\n    ...                 ...\n    skill_k/            kth skill\n  vendor/               Directory containing all the added resources from the registry, sorted by author.\n    author_1/           Directory containing all the resources added from author_1\n      connections/      Directory containing all the added connections from author_1\n        ...             ...\n      protocols/        Directory containing all the added protocols from author_1\n        ...             ...\n      skills/           Directory containing all the added skills from author_1\n        ...             ...\n</code></pre> <p>The developer can create new directories where necessary but the core structure must remain the same.</p>"},{"location":"aea-framework-documentation/package-imports/#aea-configuration-yaml","title":"AEA Configuration YAML","text":"<p>The <code>aea-config.yaml</code> is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components.</p> <p>For the AEA to use a package, the <code>public_id</code> for the package must be listed in the <code>aea-config.yaml</code> file, e.g.</p> <pre><code>connections:\n- fetchai/stub:0.21.3\n</code></pre> <p>The above shows a part of the <code>aea-config.yaml</code>. If you see the connections, you will see that we follow a pattern of <code>author/name_package:version</code> to identify each package, also referred to as <code>public_id</code>. Here the <code>author</code> is the author of the package.</p>"},{"location":"aea-framework-documentation/package-imports/#vendor-and-package-directories","title":"Vendor and Package Directories","text":"<p>The <code>vendor</code> folder contains the packages from the registry (local or remote) which have been developed by ourselves, other authors or Fetch.ai and are placed in different namespaces according to the author name.</p> <p>The packages we develop as part of the given AEA project are in the respective <code>connections/</code>, <code>contracts/</code>, <code>protocols/</code>, and <code>skills/</code> folders.</p> <p>In the above configuration example, the package is authored by Fetch.ai and is located inside the <code>vendor/fetchai/connections</code> folder.</p>"},{"location":"aea-framework-documentation/package-imports/#importing-modules-from-packages","title":"Importing Modules from Packages","text":"<p>The way we import modules from packages inside the agent is in the form of <code>packages.{author}.{package_type}.{package_name}.{module_name}</code>. So for the above example, the import path is <code>packages.fetchai.connections.stub.{module_name}</code>.</p> <p>The framework loads the modules from the local agent project and adds them to Python's <code>sys.modules</code> under the respective path.</p> <p>We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem.</p>"},{"location":"aea-framework-documentation/package-imports/#python-dependencies-of-packages","title":"Python Dependencies of Packages","text":"<p>Python dependencies of packages are specified in their respective configuration files under <code>dependencies</code>. They will be installed when <code>aea install</code> is run on an agent project.</p>"},{"location":"aea-framework-documentation/package-imports/#create-a-package","title":"Create a Package","text":"<p>If you want to create a package, you can use the CLI command <code>aea scaffold connection/contract/protocol/skill [name]</code> and this will create the package and put it inside the respective folder based on the command for example if we <code>scaffold</code> skill with the name <code>my_skill</code> it will be located inside the folder skills in the root directory of the agent (<code>my_aea/skills/my_skill</code>).</p>"},{"location":"aea-framework-documentation/package-imports/#use-published-packages-from-the-registry","title":"Use Published Packages from the Registry","text":"<p>If you want to use a finished package, you can use a package from the registry.</p> <p>There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called <code>packages</code> which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the <code>packages</code> directory located in the AEA repository. The local registry is useful for development.</p> <p>You can use the CLI to interact with the registry. By default, the CLI points to the remote registry. You can point it to the local registry via the flag <code>--local</code>.</p>"},{"location":"aea-framework-documentation/package-imports/#package-versioning","title":"Package Versioning","text":"<p>By default, the AEA can only handle one version per package. That is, a project should never use both <code>some_author/some_package_name:0.1.0</code> and <code>some_author/some_package_name:0.2.0</code>.</p> <p>If two AEA packages with the same author and name but different versions are used in the same Python process, then only the code from one of the packages (generally not deterministic) will be available in <code>sys.modules</code>. This can lead to inconsistencies and exceptions at runtime.</p>"},{"location":"aea-framework-documentation/performance-benchmark/","title":"Performance Benchmark","text":"<p>Test AEA framework performance.</p>"},{"location":"aea-framework-documentation/performance-benchmark/#what-is-it","title":"What is it?","text":"<p>The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results.</p>"},{"location":"aea-framework-documentation/performance-benchmark/#how-does-it-work","title":"How does it Work?","text":"<p>The framework:</p> <ul> <li>spawns a dedicated process for each test run to execute the function to test.</li> <li>measures CPU and RAM usage periodically.</li> <li>waits for function exits or terminates them by timeout.</li> <li>repeats test execution multiple times to get more accurate results.</li> </ul>"},{"location":"aea-framework-documentation/performance-benchmark/#how-to-use","title":"How to Use","text":"<p>Steps to run a test:</p> <ul> <li>Write a function you would like to test with all arguments you would like to parametrise, add some doc strings.</li> <li>Split the function into two parts: 'prepare' and 'performance' part. The 'prepare' part will not be included in the measurement.</li> <li>Add <code>BenchmarkControl</code> support, to notify framework to start measurement.</li> <li>Import <code>TestCli</code> class,  <code>TestCli().run(function_to_be_tested)</code></li> <li>Call it from console to get text results.</li> </ul>"},{"location":"aea-framework-documentation/performance-benchmark/#simple-example","title":"Simple Example","text":"<p><code>cpuburn</code> - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution.</p> <pre><code>import time\nfrom benchmark.framework.benchmark import BenchmarkControl\nfrom benchmark.framework.cli import TestCli\ndef cpu_burn(benchmark: BenchmarkControl, run_time=10, sleep=0.0001) -&gt; None:\n\"\"\"\n    Do nothing, just burn cpu to check cpu load changed on sleep.\n    :param benchmark: benchmark special parameter to communicate with executor\n    :param run_time: time limit to run this function\n    :param sleep: time to sleep in loop\n    :return: None\n    \"\"\"\nbenchmark.start()\nstart_time = time.time()\nwhile True:\ntime.sleep(sleep)\nif time.time() - start_time &gt;= run_time:\nbreak\nif __name__ == \"__main__\":\nTestCli(cpu_burn).run()\n</code></pre> <p>Run it with <code>python ./benchmark/cases/cpu_burn.py --help</code> to get help about usage.</p> <pre><code>Usage: cpu_burn.py [OPTIONS] [ARGS]...\n\nDo nothing, just burn cpu to check cpu load changed on sleep.\n\n:param benchmark: benchmark special parameter to communicate with executor\n  :param run_time: time limit to run this function :param sleep: time to sleep in loop\n\n:return: None\n\nARGS is function arguments in format: `run_time,sleep`\ndefault ARGS is `10,0.0001`\nOptions:\n  --timeout FLOAT               Executor timeout in seconds  [default: 10.0]\n--period FLOAT                Period for measurement  [default: 0.1]\n-N, --num-executions INTEGER  Number of runs for each case  [default: 1]\n-P, --plot INTEGER            X axis parameter idx\n  --help                        Show this message and exit.\n</code></pre> <p>Run it with <code>python ./benchmark/cases/cpu_burn.py</code> to start with default parameters.</p> <pre><code>Test execution timeout: 10.0\nTest execution measure period: 0.1\nTested function name: cpu_burn\nTested function description:\n    Do nothing, just burn cpu to check cpu load changed on sleep.\n\n:param benchmark: benchmark special parameter to communicate with executor\n    :param run_time: time limit to run this function\n:param sleep: time to sleep in loop\n\n:return: None\n\nTested function argument names: ['run_time', 'sleep']\nTested function argument default values: [10, 0.0001]\n== Report created 2020-04-27 15:14:56.076549 ==\nArguments are `[10, 0.0001]`\nNumber of runs: 1\nNumber of time terminated: 0\nTime passed (seconds): 10.031443119049072 \u00b1 0\ncpu min (%): 0.0 \u00b1 0\ncpu max (%): 10.0 \u00b1 0\ncpu mean (%): 3.4 \u00b1 0\nmem min (kb): 53.98828125 \u00b1 0\nmem max (kb): 53.98828125 \u00b1 0\nmem mean (kb): 53.98828125 \u00b1 0\n</code></pre> <p>Here you can see test report for default arguments set.</p> <p>Run with multiple arguments set, multiple repeats and draw a chart on resources <code>python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01</code></p> <p>Report is:</p> <pre><code>Test execution timeout: 10.0\nTest execution measure period: 0.1\nTested function name: cpu_burn\nTested function description:\n    Do nothing, just burn cpu to check cpu load changed on sleep.\n\n:param benchmark: benchmark special parameter to communicate with executor\n    :param run_time: time limit to run this function\n:param sleep: time to sleep in loop\n\n:return: None\n\nTested function argument names: ['run_time', 'sleep']\nTested function argument default values: [10, 0.0001]\n== Report created 2020-04-27 15:38:17.849535 ==\nArguments are `(3, 1e-05)`\nNumber of runs: 5\nNumber of time terminated: 0\nTime passed (seconds): 3.0087939262390138 \u00b1 0.0001147521277690166\ncpu min (%): 0.0 \u00b1 0.0\ncpu max (%): 11.0 \u00b1 2.23606797749979\ncpu mean (%): 6.2 \u00b1 0.18257418583505522\nmem min (kb): 54.0265625 \u00b1 0.11180339887498948\nmem max (kb): 54.0265625 \u00b1 0.11180339887498948\nmem mean (kb): 54.0265625 \u00b1 0.11180339887498948\n== Report created 2020-04-27 15:38:32.947308 ==\nArguments are `(3, 0.001)`\nNumber of runs: 5\nNumber of time terminated: 0\nTime passed (seconds): 3.014109659194946 \u00b1 0.0004416575764579524\ncpu min (%): 0.0 \u00b1 0.0\ncpu max (%): 8.0 \u00b1 2.7386127875258306\ncpu mean (%): 1.9986666666666666 \u00b1 0.002981423969999689\nmem min (kb): 53.9890625 \u00b1 0.10431954926750306\nmem max (kb): 53.9890625 \u00b1 0.10431954926750306\nmem mean (kb): 53.9890625 \u00b1 0.10431954926750306\n== Report created 2020-04-27 15:38:48.067511 ==\nArguments are `(3, 0.01)`\nNumber of runs: 5\nNumber of time terminated: 0\nTime passed (seconds): 3.0181806087493896 \u00b1 0.0022409499756841883\ncpu min (%): 0.0 \u00b1 0.0\ncpu max (%): 1.0 \u00b1 2.23606797749979\ncpu mean (%): 0.06666666666666667 \u00b1 0.14907119849998599\nmem min (kb): 53.9078125 \u00b1 0.11487297672320501\nmem max (kb): 53.9078125 \u00b1 0.11487297672320501\nmem mean (kb): 53.9078125 \u00b1 0.11487297672320501\n</code></pre> <p>Chart is drawn for argument 1: sleep:</p> <p></p> <p>The most interesting part is CPU usage, as you can see  CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution.</p>"},{"location":"aea-framework-documentation/performance-benchmark/#requirements-for-tested-function","title":"Requirements for Tested Function","text":"<ul> <li>The first function's argument has to be <code>benchmark: BenchmarkControl</code> which is passed by default by the framework.</li> <li>All arguments except the fist one have to set default values.</li> <li>Function doc string is required, it used for help information.</li> <li><code>benchmark.start()</code> has to be called once in the function body to start measurement. The timeout is counted from this point!</li> <li>All the \"prepare part\" in the function that should not be measured has to be placed before <code>benchmark.start()</code></li> <li>Code to be measured has to go after <code>benchmark.start()</code></li> <li>Try to avoid infinitive loops and assume the test should exit after a while.</li> </ul>"},{"location":"aea-framework-documentation/performance-benchmark/#execution-options","title":"Execution Options","text":"<ul> <li>To pass an arguments set just provide it as a comma separated string like <code>10,0.1</code></li> <li>To pass several argument sets just separate them by white space <code>10,0.1 20,0.2</code></li> <li><code>--timeout FLOAT</code> is test execution timeout in seconds. If the test takes more time, it will be terminated.</li> <li><code>--period FLOAT</code> is measurement interval in seconds, how often to make CPU and RAM usage measurements.</li> <li><code>-N, --num-executions INTEGER</code> - how many times to run the same argument set to make result more accurate.</li> <li><code>-P, --plot INTEGER</code> -  Draw a chart, using values in the argument on the X axis, argument positions started with 0, argument benchmark not counted. For example <code>-P 0</code> will use <code>run_time</code> values, <code>-P 1</code> will use <code>sleep</code> values, and so on.</li> </ul>"},{"location":"aea-framework-documentation/performance-benchmark/#limitations","title":"Limitations","text":"<p>Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests.</p> <p>Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually.</p>"},{"location":"aea-framework-documentation/performance-benchmark/#testing-aea-handlers-example","title":"Testing AEA: Handlers Example","text":"<p>Test react speed on specific messages amount.</p> <pre><code>def react_speed_in_loop(benchmark: BenchmarkControl, inbox_amount=1000) -&gt; None:\n\"\"\"\n    Test inbox message processing in a loop.\n    :param benchmark: benchmark special parameter to communicate with executor\n    :param inbox_amount: num of inbox messages for every agent\n    :return: None\n    \"\"\"\nskill_definition = {\n\"handlers\": {\"dummy_handler\": DummyHandler}\n}\naea_test_wrapper = AEATestWrapper(\nname=\"dummy agent\",\nskills=[skill_definition],\n)\nfor _ in range(inbox_amount):\naea_test_wrapper.put_inbox(aea_test_wrapper.dummy_envelope())\naea_test_wrapper.set_loop_timeout(0.0)\nbenchmark.start()\naea_test_wrapper.start_loop()\nwhile not aea_test_wrapper.is_inbox_empty():\ntime.sleep(0.1)\naea_test_wrapper.stop_loop()\n</code></pre> <p>Create AEA wrapper with specified handler:</p> <pre><code>skill_definition = {\n\"handlers\": {\"dummy_handler\": DummyHandler}\n}\naea_test_wrapper = AEATestWrapper(\nname=\"dummy agent\",\nskills=[skill_definition],\n)\n</code></pre> <p>Populate inbox with dummy messages:</p> <pre><code>for _ in range(inbox_amount):\naea_test_wrapper.put_inbox(aea_test_wrapper.dummy_envelope())\n</code></pre> <p>Set timeout <code>0</code>, for maximum messages processing speed: <code>aea_test_wrapper.set_loop_timeout(0.0)</code></p> <p>Start benchmark: <code>benchmark.start()</code></p> <p>Start/stop AEA:</p> <pre><code>aea_test_wrapper.start()\n...\naea_test_wrapper.stop()\n</code></pre> <p>Wait till messages present in inbox:</p> <pre><code>while not aea_test_wrapper.is_inbox_empty():\ntime.sleep(0.1)\n</code></pre>"},{"location":"aea-framework-documentation/por/","title":"Proof of Representation","text":"<p>An AEA can use several key pairs. In particular, it can use different keys for securing its communication and for engaging in exchange. In the ACN we make use of this fact. To be able to signal to other agents that the address derived from one key pair is allowed to represent the agent controlling the other key pair, the key pair which is being represented must sign a message to prove that the other key pair is allowed to represent it. The <code>aea issue-certificates</code> command allows to create this association.</p> <p>The proof of representation feature is used in the context of the <code>fetchai/p2p_libp2p</code> and <code>fetchai/p2p_libp2p_client</code> connection.</p> <p>In the former connection, the configuration YAML specifies a <code>cert_requests</code> field:</p> <pre><code>cert_requests:\n- identifier: acn\nledger_id: fetchai\nnot_after: '2023-01-01'\nnot_before: '2022-01-01'\npublic_key: fetchai\nmessage_format: '{public_key}'\nsave_path: .certs/conn_cert.txt\n</code></pre> <p>The <code>identifier</code> refers to the environment for which the signature is generated, here <code>acn</code>. The <code>ledger_id</code> refers to the key pair to be used from the <code>private_key_paths</code> specified in <code>aea-config.yaml</code> for signing. The <code>not_after</code> and <code>not_before</code> fields specify constraints on the validity of the signature. The <code>public_key</code> can specify either the identifier of the key pair in <code>connection_private_key_paths</code>, of which the public key is signed, or it can contain the to be signed public key in plain text. The <code>save_path</code> specifies the path where the certificate is to be saved at.</p> <p>In the above example, the connection requests a certificate which is a signature of the <code>fetchai</code> public key in <code>connection_private_key_paths</code> with the <code>fetchai</code> key pair in <code>private_key_paths</code>. The validity of the signature will be constrained to the year <code>2021</code> for the environment <code>acn</code>.</p>"},{"location":"aea-framework-documentation/prometheus/","title":"Prometheus Monitoring","text":"<p>AEAs can create and update prometheus metrics for remote monitoring by sending messages to the prometheus connection <code>fetchai/prometheus:0.9.6</code>.</p> <p>To see this working in an agent, fetch and run the <code>coin_price_feed</code> agent and check <code>localhost:9090/metrics</code> to see the latest values of the metrics <code>num_retrievals</code> and <code>num_requests</code>:</p> <pre><code>aea fetch fetchai/coin_price_feed:0.15.5\ncd coin_price_feed\naea install\naea build\naea run\n</code></pre> <p>You can then instruct a prometheus server running on the same computing cluster as a deployed agent to scrape these metrics for remote monitoring and visualisation with the Prometheus/Grafana toolset.</p> <p>To use this connection, add a model <code>prometheus_dialogues</code> to your skill to handle the metrics configuration and messages to the prometheus connection.</p> Click here for example: <pre><code>class PrometheusDialogues(Model, BasePrometheusDialogues):\n\"\"\"The dialogues class keeps track of all prometheus dialogues.\"\"\"\ndef __init__(self, **kwargs) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :return: None\n        \"\"\"\nself.enabled = kwargs.pop(\"enabled\", False)\nself.metrics = kwargs.pop(\"metrics\", [])\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn PrometheusDialogue.Role.AGENT\nBasePrometheusDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\n</code></pre> <p>Then configure your metrics in the <code>skill.yaml</code> file. For example (from the <code>advanced_data_request</code> skill):</p> <pre><code>models:\nprometheus_dialogues:\nargs:\nenabled: true\nmetrics:\n- name: num_retrievals\ntype: Gauge\ndescription: Number of price quotes retrieved\nlabels: {}\n- name: num_requests\ntype: Gauge\ndescription: Number of price quote requests served\nlabels: {}\nclass_name: PrometheusDialogues\n</code></pre> <p>Add a metric <code>metric_name</code> of type <code>metric_type</code> {<code>Gauge</code>, <code>Counter</code>, ...} and description <code>description</code> by sending a message with performative <code>ADD_METRIC</code> to the prometheus connection:</p> <pre><code>def add_prometheus_metric(\nself,\nmetric_name: str,\nmetric_type: str,\ndescription: str,\nlabels: Dict[str, str],\n) -&gt; None:\n\"\"\"\n    Add a prometheus metric.\n    :param metric_name: the name of the metric to add.\n    :param type: the type of the metric.\n    :param description: a description of the metric.\n    :param labels: the metric labels.\n    :return: None\n    \"\"\"\n# context\nprom_dialogues = cast(PrometheusDialogues, self.context.prometheus_dialogues)\n# prometheus update message\nmessage, _ = prom_dialogues.create(\ncounterparty=str(PROM_CONNECTION_ID),\nperformative=PrometheusMessage.Performative.ADD_METRIC,\ntype=metric_type,\ntitle=metric_name,\ndescription=description,\nlabels=labels,\n)\n# send message\nself.context.outbox.put_message(message=message)\n</code></pre> <p>where <code>PROM_CONNECTION_ID</code> should be imported to your skill as follows:</p> <pre><code>from packages.fetchai.connections.prometheus.connection import (\nPUBLIC_ID as PROM_CONNECTION_ID,\n)\n</code></pre> <p>Update metric <code>metric_name</code> with update function <code>update_func</code> {<code>inc</code>, <code>set</code>, <code>observe</code>, ...} and value <code>value</code> by sending a message with performative <code>UPDATE_METRIC</code> to the prometheus connection:</p> <pre><code>def update_prometheus_metric(\nself, metric_name: str, update_func: str, value: float, labels: Dict[str, str],\n) -&gt; None:\n\"\"\"\n    Update a prometheus metric.\n    :param metric_name: the name of the metric.\n    :param update_func: the name of the update function (e.g. inc, dec, set, ...).\n    :param value: the value to provide to the update function.\n    :param labels: the metric labels.\n    :return: None\n    \"\"\"\n# context\nprom_dialogues = cast(PrometheusDialogues, self.context.prometheus_dialogues)\n# prometheus update message\nmessage, _ = prom_dialogues.create(\ncounterparty=str(PROM_CONNECTION_ID),\nperformative=PrometheusMessage.Performative.UPDATE_METRIC,\ntitle=metric_name,\ncallable=update_func,\nvalue=value,\nlabels=labels,\n)\n# send message\nself.context.outbox.put_message(message=message)\n</code></pre> <p>Initialize the metrics from the configuration file in the behaviour setup:</p> <pre><code>def setup(self) -&gt; None:\n\"\"\"Implement the setup of the behaviour\"\"\"\nprom_dialogues = cast(PrometheusDialogues, self.context.prometheus_dialogues)\nif prom_dialogues.enabled:\nfor metric in prom_dialogues.metrics:\nself.context.logger.info(\"Adding Prometheus metric: \" + metric[\"name\"])\nself.add_prometheus_metric(\nmetric[\"name\"], metric[\"type\"], metric[\"description\"], dict(metric[\"labels\"]),\n</code></pre> <p>Then call the <code>update_prometheus_metric</code> function from the appropriate places. For example, the following code in <code>handlers.py</code> for the <code>advanced_data_request</code> skill updates the number of http requests served:</p> <pre><code>if self.context.prometheus_dialogues.enabled:\nself.context.behaviours.advanced_data_request_behaviour.update_prometheus_metric(\n\"num_requests\", \"inc\", 1.0, {}\n)\n</code></pre> <p>Finally, you can add a <code>PrometheusHandler</code> to your skill to process response messages from the prometheus connection.</p> Click here for example: <pre><code>class PrometheusHandler(Handler):\n\"\"\"This class handles responses from the prometheus server.\"\"\"\nSUPPORTED_PROTOCOL = PrometheusMessage.protocol_id\ndef __init__(self, **kwargs):\n\"\"\"Initialize the handler.\"\"\"\nsuper().__init__(**kwargs)\nself.handled_message = None\ndef setup(self) -&gt; None:\n\"\"\"Set up the handler.\"\"\"\nif self.context.prometheus_dialogues.enabled:\nself.context.logger.info(\"setting up PrometheusHandler\")\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        :return: None\n        \"\"\"\nmessage = cast(PrometheusMessage, message)\n# recover dialogue\nprometheus_dialogues = cast(\nPrometheusDialogues, self.context.prometheus_dialogues\n)\nprometheus_dialogue = cast(\nPrometheusDialogue, prometheus_dialogues.update(message)\n)\nif prometheus_dialogue is None:\nself._handle_unidentified_dialogue(message)\nreturn\nself.handled_message = message\nif message.performative == PrometheusMessage.Performative.RESPONSE:\nself.context.logger.debug(\nf\"Prometheus response ({message.code}): {message.message}\"\n)\nelse:\nself.context.logger.debug(\nf\"got unexpected prometheus message: Performative = {PrometheusMessage.Performative}\"\n)\ndef _handle_unidentified_dialogue(self, msg: Message) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param msg: the unidentified message to be handled\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"received invalid message={}, unidentified dialogue.\".format(msg)\n)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Teardown the handler.\n        :return: None\n        \"\"\"\n</code></pre>"},{"location":"aea-framework-documentation/protocol-generator/","title":"Generating Protocols","text":""},{"location":"aea-framework-documentation/protocol-generator/#how-to-run","title":"How to Run","text":"<p>First make sure you are inside your AEA's folder (see here on how to create a new agent).</p> <p>Then run</p> <pre><code>aea generate protocol &lt;path-to-protocol-specification&gt;\n</code></pre> <p>where <code>&lt;path-to-protocol-specification&gt;</code> is the path to a protocol specification file.</p> <p>If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is <code>sample</code>):</p> <ol> <li><code>message.py</code>: defines messages valid under the <code>sample</code> protocol</li> <li><code>serialisation.py</code>: defines how messages are serialized/deserialized</li> <li><code>__init__.py</code>: makes the directory a package</li> <li><code>protocol.yaml</code>: contains package information about the <code>sample</code> protocol</li> <li><code>sample.proto</code> protocol buffer schema file</li> <li><code>sample_pb2.py</code>: the generated protocol buffer implementation</li> <li><code>custom_types.py</code>: stub implementations for custom types (created only if the specification contains custom types)</li> </ol>"},{"location":"aea-framework-documentation/protocol-generator/#full-mode-vs-protobuf-only-mode","title":"Full Mode vs Protobuf Only Mode","text":"<p>Currently, the generator can operate in full mode for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a protobuf only mode which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the protobuf only mode and their respective ids are below:</p> <ul> <li>go: <code>go</code></li> <li>c++: <code>cpp</code></li> <li>java: <code>java</code></li> <li>c#: <code>csharp</code></li> <li>ruby: <code>ruby</code></li> <li>objective-c: <code>objc</code></li> <li>javascript: <code>js</code></li> </ul> <p>To use the generator in protobuf only mode for any of the above languages:</p> <pre><code>aea generate protocol --l &lt;language&gt; &lt;path-to-protocol-specification&gt;\n</code></pre> <p>where <code>&lt;language&gt;</code> is a language id.</p> <p>The protocol buffer compiler requires a plugin to generate Go code. Install it with:</p> <p>Note</p> <p>Note the protocol buffer compiler <code>protoc</code> that the generator uses requires a plugin to produce <code>go</code> code. Follow this instruction.</p>"},{"location":"aea-framework-documentation/protocol-generator/#protocol-specification","title":"Protocol Specification","text":"<p>A protocol can be described in a YAML file. This is called a protocol specification. The following is an example protocol specification:</p> <pre><code>---\nname: two_party_negotiation\nauthor: fetchai\nversion: 0.1.0\ndescription: An example of a protocol specification that describes a protocol for bilateral negotiation.\nlicense: Apache-2.0\naea_version: '&gt;=1.0.0, &lt;2.0.0'\nspeech_acts:\ncfp:\nquery: ct:Query\npropose:\nprice: pt:float\nproposal: pt:dict[pt:str, pt:str]\nconditions: pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]]\nresources: pt:list[pt:bytes]\naccept: {}\ndecline: {}\n...\n---\nct:Query: |\nbytes query_bytes = 1;\n...\n---\ninitiation: [cfp]\nreply:\ncfp: [propose, decline]\npropose: [propose, accept, decline]\naccept: []\ndecline: []\ntermination: [accept, decline]\nroles: {buyer, seller}\nend_states: [agreement_reached, agreement_unreached]\nkeep_terminal_state_dialogues: true\n...\n</code></pre> <p>Each protocol specification must follow the YAML format, and have a minimum of one and a maximum of three YAML documents (each YAML document is enclosed within --- and ...).</p>"},{"location":"aea-framework-documentation/protocol-generator/#basic-protocol-detail-and-messages-syntax","title":"Basic Protocol Detail and Messages Syntax","text":"<p>The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol.</p> <p>The allowed fields and what they represent are:</p> <ul> <li><code>name</code>: The name of the protocol (written in snake_case)</li> <li><code>author</code>: The creator of the protocol</li> <li><code>version</code>: The current version of the protocol</li> <li><code>license</code>: Licensing information</li> <li><code>aea_version</code>: The version(s) of the framework that support this protocol. The format is described here.</li> <li><code>description</code>: A short description of the protocol</li> <li><code>protocol_specification_id</code>: The id which identifies the protocol for over-the-wire transport. This id is decoupled from the <code>protocol_id</code> (<code>{author}/{name}:{version}</code>) which is tied to the Python implementation.</li> </ul> <p>All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings.</p> <p>Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory <code>speech-acts</code> field which defines the set of performatives valid under this protocol, and a set of contents for each performative.</p> <p>A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types.</p> <p>The format of the <code>speech-act</code> is as follows: <code>speech-act</code> is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance <code>accept</code> and <code>decline</code> in the specification above.</p> <p>A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the <code>cfp</code> (short for 'call for proposal') performative has one content whose name is <code>query</code> and whose type is <code>ct:Query</code>.</p>"},{"location":"aea-framework-documentation/protocol-generator/#types","title":"Types","text":"<p>The specific types which could be assigned to contents in a protocol specification are described in the table below.</p> <p>Types are either user defined (i.e. custom types) or primitive:</p> <ul> <li>Custom types are prepended with <code>ct:</code> and their format is described using regular expression in the table below.</li> <li>Primitive types are prepended with <code>pt:</code>. There are different categories of primitive types. For example, <code>&lt;PT&gt;</code> such as integers and booleans, <code>&lt;PCT&gt;</code> such as sets and lists, and so on. Primitive types are compositional:<ul> <li>For example, consider <code>pt:set[...]</code> under <code>&lt;PCT&gt;</code>, i.e. an unordered collection of elements without duplicates. A <code>pt:set[...]</code> describes the type of its elements (called \"sub-type\") in square brackets. The subtype of a <code>pt:set[...]</code> must be a <code>&lt;PT&gt;</code> (e.g. <code>pt:int</code>, <code>pt:bool</code>).</li> <li>In describing the format of types, <code>/</code> between two subtypes should be treated as \"or\". For example, the subtype of a <code>pt:optional[...]</code> is either a <code>&lt;PT&gt;</code>, <code>&lt;CT&gt;</code>, <code>&lt;PCT&gt;</code>, <code>&lt;PMT&gt;</code> or <code>&lt;MT&gt;</code>.</li> </ul> </li> </ul> <p>A multi type denotes an \"or\" separated set of subtypes. For example, a content whose type is specified as <code>pt:union[pt:str, pt:int]</code> should either be <code>pt:int</code> or <code>pt:float</code>.</p> <p>An optional type <code>pt:optional[...]</code> assigned to a content means the content's existence is optional, but if it is present, its type must match <code>pt:optional[...]</code>'s subtype.</p> Type Code Format Example In Python Custom types1 <code>&lt;CT&gt;</code> <code>ct:RegExp(^[A-Z][a-zA-Z0-9]*$)</code> <code>ct:DataModel</code> Custom Class Primitive types <code>&lt;PT&gt;</code> <code>pt:bytes</code> <code>pt:bytes</code> <code>bytes</code> <code>pt:int</code> <code>pt:int</code> <code>int</code> <code>pt:float</code> <code>pt:float</code> <code>float</code> <code>pt:bool</code> <code>pt:bool</code> <code>bool</code> <code>pt:str</code> <code>pt:str</code> <code>str</code> Primitive collection types <code>&lt;PCT&gt;</code> <code>pt:set[&lt;PT&gt;]</code> <code>pt:set[pt:str]</code> <code>FrozenSet[str]</code> <code>pt:list[&lt;PT&gt;]</code> <code>pt:list[pt:int]</code> <code>Tuple[int, ...]</code>* Primitive mapping types2 <code>&lt;PMT&gt;</code> <code>pt:dict[&lt;PT&gt;, &lt;PT&gt;]</code> <code>pt:dict[pt:str, pt:bool]</code> <code>Dict[str, bool]</code> Multi types <code>&lt;MT&gt;</code> <code>pt:union[&lt;PT&gt;/&lt;CT&gt;/&lt;PCT&gt;/&lt;PMT&gt;, ..., &lt;PT&gt;/&lt;CT&gt;/&lt;PCT&gt;/&lt;PMT&gt;]</code> <code>pt:union[ct:DataModel, pt:set[pt:str]]</code> <code>Union[DataModel, FrozenSet[str]]</code> Optional types <code>&lt;O&gt;</code> <code>pt:optional[&lt;MT&gt;/&lt;PMT&gt;/&lt;PCT&gt;/&lt;PT&gt;/&lt;CT&gt;]</code> <code>pt:optional[pt:bool]</code> <code>Optional[bool]</code> <p>* This is how variable length tuples containing elements of the same type are declared in Python; see here.</p>"},{"location":"aea-framework-documentation/protocol-generator/#protocol-buffer-schema","title":"Protocol Buffer Schema","text":"<p>Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually.</p> <p>Therefore, if any of the contents declared in <code>speech-acts</code> is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type.</p> <p>You can see an example of the second YAML document in the above protocol specification.</p>"},{"location":"aea-framework-documentation/protocol-generator/#dialogues","title":"Dialogues","text":"<p>You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification.</p> <p>The allowed fields and what they represent are:</p> <ul> <li><code>initiation</code>: The list of initial performatives</li> <li><code>reply</code>: The reply structure of speech-acts</li> <li><code>termination</code>: The list of terminal performatives</li> <li><code>roles</code>: The roles of players participating in a dialogue</li> <li><code>end_states</code>: The possible outcomes a terminated dialogue.</li> <li><code>keep_terminal_state_dialogues</code>: whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept.</li> </ul> <p>All of the above fields are mandatory.</p> <p><code>initiation</code> is a YAML list, containing the performatives which can be used to start a dialogue.</p> <p><code>reply</code> specifies for every performative, what its valid replies are. If a performative <code>per_1</code> is a valid reply to another <code>per_2</code>, this means a message with performative <code>per_1</code> can target a message whose performative is <code>per_2</code>.</p> <p><code>reply</code> is a YAML dictionary, where the keys are the performatives (YAML string) defined in <code>speech-acts</code>. For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to <code>cfp</code> are <code>propose</code> and <code>decline</code>.</p> <p><code>termination</code> is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it.</p> <p><code>roles</code> is a YAML set, containing the roles  players participating in dialogues can take. <code>roles</code> may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role.</p> <p><code>end_states</code> lists the final states a terminated dialogue may have. <code>end_states</code> is a YAML list of strings.</p> <p><code>keep_terminal_state_dialogues</code> has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded.</p>"},{"location":"aea-framework-documentation/protocol-generator/#design-guidelines","title":"Design Guidelines","text":"<ol> <li> <p><code>initiation</code> and <code>termination</code> cannot be empty.</p> </li> <li> <p>Make sure that when defining <code>reply</code>, you include every speech-act you specified under <code>speech_acts</code>. If any of the speech-acts does not have a reply, indicate that with an empty list <code>[]</code> similar to <code>accept</code> and <code>decline</code> in the specification above.</p> </li> <li> <p>If a speech-act is listed in <code>termination</code>, it must not have any replies in <code>reply</code>. The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used.</p> </li> <li> <p>If a speech-act replies to no other speech-acts, it should be listed in <code>initiation</code> otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act).</p> </li> </ol>"},{"location":"aea-framework-documentation/protocol-generator/#notes","title":"Notes","text":"<ol> <li>Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually.     _ Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification.<ul> <li>Once the generator is called, it produces a <code>custom_types</code> module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer.</li> <li>Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialized/deserialized. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language).</li> </ul> </li> <li>Currently, the first element in <code>pt:dict</code> cannot be a <code>&lt;CT&gt;</code>, <code>pt:float</code> or  <code>pt:bytes</code>. This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint.</li> <li>In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type <code>pt:optional[...]</code>) has been set or not (see discussion here). In proto3, all optional fields are assigned a default value (e.g. <code>0</code> for integers types, <code>false</code> for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the <code>.proto</code> file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found.</li> <li>Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserializing values of <code>pt:float</code> contents.</li> </ol>"},{"location":"aea-framework-documentation/protocol-generator/#demo-instructions","title":"Demo Instructions","text":"<p>First, create a new AEA project:</p> <pre><code>aea create my_aea\ncd my_aea\n</code></pre> <p>Second, run the generator on the sample specification:</p> <pre><code>aea generate protocol ../examples/protocol_specification_ex/sample.yaml\n</code></pre> <p>This will generate the protocol and place it in your AEA project.</p> <p>Third, try generating other protocols by first defining a specification, then running the generator.</p>"},{"location":"aea-framework-documentation/protocol/","title":"Protocols","text":"<p><code>Protocols</code> define the structure of agent-to-agent and component-to-component interactions, which in the AEA world, are in the form of communication. To learn more about interactions and interaction protocols, see here.</p> <p>Protocols in the AEA world provide definitions for:</p> <ul> <li><code>messages</code> defining the structure and syntax of messages;</li> <li><code>serialization</code> defining how a message is encoded/decoded for transport; and optionally</li> <li><code>dialogues</code> defining the structure of dialogues formed from exchanging series of messages.</li> </ul> <p></p> <p>The framework provides a <code>default</code> protocol. This protocol provides a bare-bones implementation for an AEA protocol which includes a <code>DefaultMessage</code>  class and associated <code>DefaultSerializer</code> and <code>DefaultDialogue</code> classes.</p> <p>Additional protocols - i.e. a new type of interaction - can be added as packages or generated with the protocol generator.</p> <p>We highly recommend you to not attempt writing your protocol manually as they tend to have involved logic; always use existing packages or the protocol generator!</p>"},{"location":"aea-framework-documentation/protocol/#components-of-a-protocol","title":"Components of a Protocol","text":"<p>A protocol package contains the following files:</p> <ul> <li><code>__init__.py</code></li> <li><code>message.py</code>, which defines message representation</li> <li><code>serialization.py</code>, which defines the encoding and decoding logic</li> <li>two protobuf related files</li> </ul> <p>It optionally also contains</p> <ul> <li><code>dialogues.py</code>, which defines the structure of dialogues formed from the exchange of a series of messages</li> <li><code>custom_types.py</code>, which defines custom types</li> </ul> <p>All protocols are for point to point interactions between two agents or agent-like services.</p>"},{"location":"aea-framework-documentation/protocol/#metadata","title":"Metadata","text":"<p>Each <code>Message</code> in an interaction protocol has a set of default fields:</p> <ul> <li><code>dialogue_reference: Tuple[str, str]</code>, a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is <code>(\"\", \"\")</code>.</li> <li><code>message_id: int</code>, the identifier of the message in a dialogue. The default value is <code>1</code>.</li> <li><code>target: int</code>, the id of the message this message is replying to. The default value is <code>0</code>.</li> <li><code>performative: Enum</code>, the purpose/intention of the message.</li> <li><code>sender: Address</code>, the address of the sender of this message.</li> <li><code>to: Address</code>, the address of the receiver of this message.</li> </ul> <p>The default values for <code>message_id</code> and <code>target</code> assume the message is the first message in a dialogue. Therefore, the <code>message_id</code> is set to <code>1</code> indicating the first message in the dialogue and <code>target</code> is <code>0</code> since the first message is the only message that does not reply to any other.</p> <p>By default, the values of <code>dialogue_reference</code>, <code>message_id</code>, <code>target</code> are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the <code>dialogue_reference</code> allows different interactions to be identified as such. The <code>message_id</code> and <code>target</code> are used to keep track of messages and their replies. For instance, on receiving of a message with <code>message_id=1</code> and <code>target=0</code>, the responding agent could respond with another with <code>message_id=2</code> and <code>target=1</code> replying to the first message. In particular, <code>target</code> holds the id of the message being replied to. This can be the preceding message, or an older one.</p>"},{"location":"aea-framework-documentation/protocol/#contents","title":"Contents","text":"<p>Each message may optionally have any number of contents of varying types.</p>"},{"location":"aea-framework-documentation/protocol/#dialogue-rules","title":"Dialogue Rules","text":"<p>Protocols can optionally have a dialogue module. A dialogue, respectively dialogues object, maintains the state of a single, respectively, all dialogues associated with a protocol.</p> <p>The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the <code>Dialogue</code> and <code>Dialogues</code> base classes.</p>"},{"location":"aea-framework-documentation/protocol/#custom-protocol","title":"Custom Protocol","text":"<p>The developer can generate custom protocols with the protocol generator. This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue).</p> <p>We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator!</p>"},{"location":"aea-framework-documentation/protocol/#fetchaidefault117-protocol","title":"<code>fetchai/default:1.1.7</code> Protocol","text":"<p>The <code>fetchai/default:1.1.7</code> protocol is meant to be implemented by every AEA. It serves AEA to AEA interaction and includes three message performatives:</p> <pre><code>from enum import Enum\nclass Performative(Enum):\n\"\"\"Performatives for the default protocol.\"\"\"\nBYTES = \"bytes\"\nEND = \"end\"\nERROR = \"error\"\ndef __str__(self):\n\"\"\"Get the string representation.\"\"\"\nreturn self.value\n</code></pre> <ul> <li>The <code>DefaultMessage</code> of performative <code>DefaultMessage.Performative.BYTES</code> is used to send payloads of byte strings to other AEAs. An example is:</li> </ul> <pre><code>from packages.fetchai.protocols.default.message import DefaultMessage\nmsg = DefaultMessage(\nperformative=DefaultMessage.Performative.BYTES,\ncontent=b\"This is a bytes payload\",\n)\n</code></pre> <ul> <li>The <code>DefaultMessage</code> of performative <code>DefaultMessage.Performative.ERROR</code> is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an <code>error_code</code> in the payload:</li> </ul> <pre><code>class ErrorCode(Enum):\n\"\"\"This class represents an instance of ErrorCode.\"\"\"\nUNSUPPORTED_PROTOCOL = 0\nDECODING_ERROR = 1\nINVALID_MESSAGE = 2\nUNSUPPORTED_SKILL = 3\nINVALID_DIALOGUE = 4\n</code></pre> <p>An example is:</p> <pre><code>msg = DefaultMessage(\nperformative=DefaultMessage.Performative.ERROR,\nerror_code=DefaultMessage.ErrorCode.UNSUPPORTED_PROTOCOL,\nerror_msg=\"This protocol is not supported by this AEA.\",\nerror_data={\"unsupported_msg\": b\"serialized unsupported protocol message\"},\n)\n</code></pre> <ul> <li>The <code>DefaultMessage</code> of performative <code>DefaultMessage.Performative.END</code> is used to terminate a default protocol dialogue. An example is:</li> </ul> <pre><code>from packages.fetchai.protocols.default.message import DefaultMessage\nmsg = DefaultMessage(\nperformative=DefaultMessage.Performative.END,\n)\n</code></pre> <p>Each AEA's <code>fetchai/error:0.18.6</code> skill utilises the <code>fetchai/default:1.0.0</code> protocol for error handling.</p>"},{"location":"aea-framework-documentation/protocol/#fetchaioef_search117-protocol","title":"<code>fetchai/oef_search:1.1.7</code> Protocol","text":"<p>The <code>fetchai/oef_search:1.1.7</code> protocol is used by AEAs to interact with an SOEF search node to register and unregister their own services and search for services registered by other agents.</p> <p>The <code>fetchai/oef_search:1.1.7</code> protocol definition includes an <code>OefSearchMessage</code> with the following message types:</p> <pre><code>class Performative(Enum):\n\"\"\"Performatives for the oef_search protocol.\"\"\"\nREGISTER_SERVICE = \"register_service\"\nUNREGISTER_SERVICE = \"unregister_service\"\nSEARCH_SERVICES = \"search_services\"\nOEF_ERROR = \"oef_error\"\nSEARCH_RESULT = \"search_result\"\nSUCCESS = \"success\"\ndef __str__(self):\n\"\"\"Get string representation.\"\"\"\nreturn self.value\n</code></pre> <p>We show some example messages below:</p> <ul> <li>To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance</li> </ul> <pre><code>my_dialogue_reference = \"a_unique_register_service_dialogue_reference\"\n</code></pre> <p>and a description of the service we would like to register, for instance</p> <pre><code>from aea.helpers.search.models import Description\nmy_service_data = {\"country\": \"UK\", \"city\": \"Cambridge\"}\nmy_service_description = Description(\nmy_service_data,\ndata_model=my_data_model,\n)\n</code></pre> <p>where we use, for instance</p> <pre><code>from aea.helpers.search.generic import GenericDataModel\ndata_model_name = \"location\"\ndata_model = {\n\"attribute_one\": {\n\"name\": \"country\",\n\"type\": \"str\",\n\"is_required\": True,\n},\n\"attribute_two\": {\n\"name\": \"city\",\n\"type\": \"str\",\n\"is_required\": True,\n},\n}\nmy_data_model = GenericDataModel(data_model_name, data_model)\n</code></pre> <p>We can then create the message to register this service:</p> <pre><code>msg = OefSearchMessage(\nperformative=OefSearchMessage.Performative.REGISTER_SERVICE,\ndialogue_reference=(my_dialogue_reference, \"\"),\nservice_description=my_service_description,\n)\n</code></pre> <ul> <li>To unregister a service, we require a reference to the dialogue in string form, for instance</li> </ul> <pre><code>my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\"\n</code></pre> <p>the description of the service we would like to unregister, say <code>my_service_description</code> from above and construct the message:</p> <pre><code>msg = OefSearchMessage(\nperformative=OefSearchMessage.Performative.UNREGISTER_SERVICE,\ndialogue_reference=(my_dialogue_reference, \"\"),\nservice_description=my_service_description,\n)\n</code></pre> <ul> <li>To search a service, we similarly require a reference to the dialogue in string form, and then the query we would like the search node to evaluate, for instance</li> </ul> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType, Query\nquery_data = {\n\"search_term\": \"country\",\n\"search_value\": \"UK\",\n\"constraint_type\": \"==\",\n}\nquery = Query(\n[\nConstraint(\nquery_data[\"search_term\"],\nConstraintType(\nquery_data[\"constraint_type\"],\nquery_data[\"search_value\"],\n),\n)\n],\nmodel=None,\n)\n</code></pre> <p>We can then create the message to search these services:</p> <pre><code>oef_msg = OefSearchMessage(\nperformative=OefSearchMessage.Performative.SEARCH_SERVICES,\ndialogue_reference=(my_dialogue_reference, \"\"),\nquery=query,\n)\n</code></pre> <ul> <li> <p>The SOEF search node will respond with a message <code>msg</code> of type <code>OefSearchMessage</code> with performative <code>OefSearchMessage.Performative.SEARCH_RESULT</code>. To access the tuple of agents which match the query, simply use <code>msg.agents</code>. In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the P2P agent communication network and any protocol other than <code>fetchai/oef_search:1.0.0</code>.</p> </li> <li> <p>If the SOEF search node encounters any errors with the messages you send, it will return an <code>OefSearchMessage</code> of performative <code>OefSearchMessage.Performative.OEF_ERROR</code> and indicate the error operation encountered:</p> </li> </ul> <pre><code>class OefErrorOperation(Enum):\n\"\"\"This class represents an instance of OefErrorOperation.\"\"\"\nREGISTER_SERVICE = 0\nUNREGISTER_SERVICE = 1\nSEARCH_SERVICES = 2\nSEND_MESSAGE = 3\nOTHER = 10000\n</code></pre>"},{"location":"aea-framework-documentation/protocol/#fetchaifipa117-protocol","title":"<code>fetchai/fipa:1.1.7</code> Protocol","text":"<p>This protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language.</p> <p>The <code>fetchai/fipa:1.1.7</code> protocol definition includes a <code>FipaMessage</code> with the following performatives:</p> <pre><code>class Performative(Enum):\n\"\"\"Performatives for the fipa protocol.\"\"\"\nACCEPT = \"accept\"\nACCEPT_W_INFORM = \"accept_w_inform\"\nCFP = \"cfp\"\nDECLINE = \"decline\"\nEND = \"end\"\nINFORM = \"inform\"\nMATCH_ACCEPT = \"match_accept\"\nMATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\"\nPROPOSE = \"propose\"\ndef __str__(self):\n\"\"\"Get the string representation.\"\"\"\nreturn self.value\n</code></pre> <p><code>FipaMessages</code> are constructed with a <code>performative</code>, <code>dialogue_reference</code>, <code>message_id</code>, and <code>target</code> as well as the <code>kwargs</code> specific to each message performative.</p> <pre><code>def __init__(\nself,\nperformative: Performative,\ndialogue_reference: Tuple[str, str] = (\"\", \"\"),\nmessage_id: int = 1,\ntarget: int = 0,\n**kwargs,\n)\n</code></pre> <p>The <code>fetchai/fipa:1.1.7</code> protocol also defines a <code>FipaDialogue</code> class which specifies the valid reply structure and provides other helper methods to maintain dialogues.</p> <p>For examples of the usage of the <code>fetchai/fipa:1.1.7</code> protocol check out the  generic skills step by step guide.</p>"},{"location":"aea-framework-documentation/protocol/#fipa-dialogue","title":"Fipa Dialogue","text":"<p>Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent.</p> <p>We first create concrete implementations of <code>FipaDialogue</code> and <code>FipaDialogues</code> for the buyer and seller:</p> <pre><code>from aea.common import Address\nfrom aea.helpers.search.models import Constraint, ConstraintType, Description, Query\nfrom aea.mail.base import Envelope\nfrom aea.protocols.base import Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.protocols.dialogue.base import DialogueLabel\nfrom packages.fetchai.protocols.fipa.dialogues import FipaDialogue, FipaDialogues\nfrom packages.fetchai.protocols.fipa.message import FipaMessage\nclass BuyerDialogue(FipaDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\ndef __init__(\nself,\ndialogue_label: DialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[FipaMessage] = FipaMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :return: None\n        \"\"\"\nFipaDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself.proposal = None  # type: Optional[Description]\nclass BuyerDialogues(FipaDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, self_address: Address) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :return: None\n        \"\"\"\ndef role_from_first_message(\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseFipaDialogue.Role.BUYER\nFipaDialogues.__init__(\nself,\nself_address=self_address,\nrole_from_first_message=role_from_first_message,\ndialogue_class=FipaDialogue,\n)\nclass SellerDialogue(FipaDialogue):\n\"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\"\ndef __init__(\nself,\ndialogue_label: DialogueLabel,\nself_address: Address,\nrole: BaseDialogue.Role,\nmessage_class: Type[FipaMessage] = FipaMessage,\n) -&gt; None:\n\"\"\"\n        Initialize a dialogue.\n        :param dialogue_label: the identifier of the dialogue\n        :param self_address: the address of the entity for whom this dialogue is maintained\n        :param role: the role of the agent this dialogue is maintained for\n        :return: None\n        \"\"\"\nFipaDialogue.__init__(\nself,\ndialogue_label=dialogue_label,\nself_address=self_address,\nrole=role,\nmessage_class=message_class,\n)\nself.proposal = None  # type: Optional[Description]\nclass SellerDialogues(FipaDialogues):\n\"\"\"The dialogues class keeps track of all dialogues.\"\"\"\ndef __init__(self, self_address: Address) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :return: None\n        \"\"\"\ndef role_from_first_message(\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn FipaDialogue.Role.SELLER\nFipaDialogues.__init__(\nself,\nself_address=self_address,\nrole_from_first_message=role_from_first_message,\ndialogue_class=FipaDialogue,\n)\n</code></pre> <p>Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models:</p> <pre><code>buyer_address = \"buyer_address_stub\"\nseller_address = \"seller_address_stub\"\nbuyer_dialogues = BuyerDialogues(buyer_address)\nseller_dialogues = SellerDialogues(seller_address)\n</code></pre> <p>First, the buyer creates a message destined for the seller and updates the dialogues:</p> <pre><code>cfp_msg = FipaMessage(\nmessage_id=1,\ndialogue_reference=buyer_dialogues.new_self_initiated_dialogue_reference(),\ntarget=0,\nperformative=FipaMessage.Performative.CFP,\nquery=Query([Constraint(\"something\", ConstraintType(\"&gt;\", 1))]),\n)\ncfp_msg.counterparty = seller_addr\n# Extends the outgoing list of messages.\nbuyer_dialogue = buyer_dialogues.update(cfp_msg)\n</code></pre> <p>If the message has been correctly constructed, the <code>buyer_dialogue</code> will be returned, otherwise it will be <code>None</code>.</p> <p>In a skill, the message could now be sent:</p> <pre><code># In a skill we would do:\n# self.context.outbox.put_message(message=cfp_msg)\n</code></pre> <p>However, here we simply continue with the seller:</p> <pre><code># change the incoming message field &amp; counterparty\ncfp_msg.is_incoming = True\ncfp_msg.counterparty = buyer_address\n</code></pre> <p>In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler.</p> <p>We update the seller's dialogues model next to generate a new dialogue:</p> <pre><code># Creates a new dialogue for the seller side based on the income message.\nseller_dialogue = seller_dialogues.update(cfp_msg)\n</code></pre> <p>Next, the seller can generate a proposal:</p> <pre><code># Generate a proposal message to send to the buyer.\nproposal = Description({\"foo1\": 1, \"bar1\": 2})\nmessage_id = cfp_msg.message_id + 1\ntarget = cfp_msg.message_id\nproposal_msg = FipaMessage(\nmessage_id=message_id,\ndialogue_reference=seller_dialogue.dialogue_label.dialogue_reference,\ntarget=target,\nperformative=FipaMessage.Performative.PROPOSE,\nproposal=proposal,\n)\nproposal_msg.counterparty = cfp_msg.counterparty\n# Then we update the dialogue\nseller_dialogue.update(proposal_msg)\n</code></pre> <p>In a skill, the message could now be sent:</p> <pre><code># In a skill we would do:\n# self.context.outbox.put_message(message=proposal_msg)\n</code></pre> <p>The dialogue can continue like this.</p> <p>To retrieve a dialogue for a given message, we can do the following:</p> <pre><code>retrieved_dialogue = seller_dialogues.get_dialogue(cfp_msg)\n</code></pre>"},{"location":"aea-framework-documentation/query-language/","title":"The Query Language","text":"<p>We recommend reading Defining a Data Model before reading this section.</p> <p>Along with the Data Model language, the AEA framework offers the possibility to specify queries defined over data models.</p> <p>The <code>aea.helpers.search</code> module implements the API that allows you to build queries.</p> <p>In one sentence, a <code>Query</code> is a set of constraints, defined over a data model. The outcome is a set of description (that is, instances of <code>Description</code>) matching with the query. That is, all the description whose attributes satisfy the constraints in the query.</p> <p>In the next sections, we describe how to build queries.</p>"},{"location":"aea-framework-documentation/query-language/#constraints","title":"Constraints","text":"<p>A <code>Constraint</code> is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume.</p> <p>We have different types of constraints:</p> <ul> <li> <p>relation constraints:</p> </li> <li> <p>the author of the book must be Stephen King</p> </li> <li> <p>the publication year must be greater than 1990</p> </li> <li> <p>set constraints:</p> </li> <li> <p>the genre must fall into the following set of genres: Horror, Science fiction, Non-fiction.</p> </li> <li> <p>range constraints:</p> </li> <li> <p>the average rating must be between 3.5 and 4.5</p> </li> <li> <p>distance constraints:</p> </li> <li> <p>the nearest bookshop must be within a distance from a given location.</p> </li> </ul> <p>The class that implements the constraint concept is <code>Constraint</code> In the following, we show how to define them.</p>"},{"location":"aea-framework-documentation/query-language/#relation","title":"Relation","text":"<p>There are several <code>ConstraintTypes</code> that allows you to impose specific values for the attributes.</p> <p>The types of relation constraints are:</p> <ul> <li>Equal: <code>==</code></li> <li>Not Equal: <code>!=</code></li> <li>Less than: <code>&lt;</code></li> <li>Less than or Equal: <code>&lt;=</code></li> <li>Greater than: <code>&gt;</code></li> <li>Greater than or Equal: <code>&gt;=</code></li> </ul> <p>Examples: using the attributes we used before:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType\n# all the books whose author is Stephen King\nConstraint(\"author\", ConstraintType(\"==\", \"Stephen King\"))\n# all the books that are not of the genre Horror\nConstraint(\"genre\", ConstraintType(\"!=\", \"Horror\"))\n# all the books published before 1990\nConstraint(\"year\", ConstraintType(\"&lt;\", 1990))\n# the same of before, but including 1990\nConstraint(\"year\", ConstraintType(\"&lt;=\", 1990))\n# all the books with rating greater than 4.0\nConstraint(\"average_rating\", ConstraintType(\"&gt;\", 4.0))\n# all the books published after 2000, included\nConstraint(\"year\", ConstraintType(\"&gt;=\", 2000))\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#set","title":"Set","text":"<p>The set is a constraint type that allows you to restrict the values of the attribute in a specific set.</p> <p>There are two kind of set constraints:</p> <ul> <li>In (a set of values): <code>in</code></li> <li>Not in (a set of values): <code>not_in</code></li> </ul> <p>Examples:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType\n# all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction`\nConstraint(\"genre\", ConstraintType(\"in\", (\"horror\", \"science fiction\", \"non-fiction\")))\n# all the books that have not been published neither in 1990, nor in 1995, nor in 2000\nConstraint(\"year\", ConstraintType(\"not_in\", (1990, 1995, 2000)))\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#range","title":"Range","text":"<p>The range is a constraint type that allows you to restrict the values of the attribute in a given range.</p> <p>Examples:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType\n# all the books whose title is between 'A' and 'B' (alphanumeric order)\nConstraint(\"title\", ConstraintType(\"within\", (\"A\", \"B\")))\n# all the books that have been published between 1960 and 1970\nConstraint(\"genre\", ConstraintType(\"within\", (1960, 1970)))\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#distance","title":"Distance","text":"<p>The distance is a constraint type that allows you to put a limit on a <code>Location</code> attribute type. More specifically, you can set a maximum distance from a given location (the centre), such that will be considered only the instances whose location attribute value is within a distance from the centre.</p> <p>Examples:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType, Description, Location\n# define a location of interest, e.g. the Tour Eiffel\ntour_eiffel = Location(48.8581064, 2.29447)\n# find all the locations close to the Tour Eiffel within 1 km\nclose_to_tour_eiffel = Constraint(\"position\", ConstraintType(\"distance\", (tour_eiffel, 1.0)))\n# Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint.\nle_jules_verne_restaurant = Location(48.8579675, 2.2951849)\nclose_to_tour_eiffel.check(Description({\"position\": le_jules_verne_restaurant}))  # gives `True`\n# The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel).\ncolosseum = Location(41.8902102, 12.4922309)\nclose_to_tour_eiffel.check(Description({\"position\": colosseum}))  # gives `False`\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#constraint-expressions","title":"Constraint Expressions","text":"<p>The constraints mentioned above can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression.</p> <p>In particular, we can specify any conjunction/disjunction/negations of the previous constraints or composite <code>ConstraintExpressions</code>, e.g.:</p> <ul> <li>books that belong to Horror and has been published after 2000, but not published by Stephen King.</li> <li>books whose author is either J. K. Rowling or J. R. R. Tolkien</li> </ul> <p>The classes that implement these operators are <code>Not</code>, <code>And</code> and <code>Or</code>.</p>"},{"location":"aea-framework-documentation/query-language/#not","title":"Not","text":"<p>The <code>Not</code> is a constraint expression that allows you to specify a negation of a constraint expression. The <code>Not</code> constraint is satisfied whenever its subexpression is not satisfied.</p> <p>Example:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType, Not\n# all the books whose year of publication is not between 1990 and 2000\nNot(Constraint(\"year\", ConstraintType(\"within\", (1990, 2000))))\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#and","title":"And","text":"<p>The <code>And</code> is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the <code>And</code> constraint is satisfied whenever all the subexpressions that constitute the and are satisfied.</p> <p>Notice: the number of subexpressions must be at least 2.</p> <p>Example:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType, And\n# all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It'\nAnd([Constraint(\"title\", ConstraintType(\"within\", (\"I\", \"J\"))), Constraint(\"title\", ConstraintType(\"!=\", \"It\"))])\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#or","title":"Or","text":"<p>The class <code>Or</code> is a constraint type that allows you to specify a disjunction of constraints. That is, the <code>Or</code> constraint is satisfied whenever at least one of the constraints that constitute the <code>or</code> is satisfied.</p> <p>Notice: the number of subexpressions must be at least 2.</p> <p>Example:</p> <pre><code>from aea.helpers.search.models import Constraint, ConstraintType, Or\n# all the books that have been published either before the year 1960 or after the year 1970\nOr([Constraint(\"year\", ConstraintType(\"&lt;\", 1960)), Constraint(\"year\", ConstraintType(\"&gt;\", 1970))])\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#queries","title":"Queries","text":"<p>A query is simply a list of constraint expressions, interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.)</p> <p>Examples:</p> <pre><code>from aea.helpers.search.models import Query, Constraint, ConstraintType\n# query all the books written by Stephen King published after 1990, and available as an e-book:\nQuery([\nConstraint(\"author\", ConstraintType(\"==\", \"Stephen King\")),\nConstraint(\"year\", ConstraintType(\"&gt;=\", 1990)),\nConstraint(\"ebook_available\", ConstraintType(\"==\", True))\n], book_model)\n</code></pre> <p>Where <code>book_model</code> is the <code>DataModel</code> object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it.</p>"},{"location":"aea-framework-documentation/query-language/#the-check-method","title":"The <code>check</code> Method","text":"<p>The <code>Query</code> class supports a way to check whether a <code>Description</code> matches with the query. This method is called <code>Query.check</code>.</p> <p>Examples:</p> <pre><code>from aea.helpers.search.models import Query, Constraint, ConstraintType\nfrom aea.helpers.search.models import Description\nq = Query([\nConstraint(\"author\", ConstraintType(\"==\", \"Stephen King\")),\nConstraint(\"year\", ConstraintType(\"&gt;=\", 1990)),\nConstraint(\"ebook_available\", ConstraintType(\"==\", True))\n])\n# With a query, you can check that a `Description` object satisfies the constraints.\nq.check(Description({\"author\": \"Stephen King\", \"year\": 1991, \"ebook_available\": True}))  # True\nq.check(Description({\"author\": \"George Orwell\", \"year\": 1948, \"ebook_available\": False})) # False\n</code></pre>"},{"location":"aea-framework-documentation/query-language/#validity","title":"Validity","text":"<p>A <code>Query</code> object must satisfy some conditions in order to be instantiated.</p> <ul> <li>The list of constraints expressions can't be empty; must have at least one constraint expression.</li> <li> <p>If the data model is specified:</p> <ul> <li>For every constraint expression that constitute the query, check if they are valid with respect to the data model.</li> </ul> </li> </ul> <p>A <code>ConstraintExpr</code> <code>c</code> (that is, one of <code>And</code>, <code>Or</code>, <code>Not</code>, <code>Constraint</code>) is valid with respect to a <code>DataModel</code> if:</p> <ul> <li>If <code>c</code> is an instance of <code>And</code>, <code>Or</code> or <code>Not</code>, then   every subexpression of <code>c</code> must be valid (with respect to the data model);</li> <li> <p>If <code>c</code> is an instance of <code>Constraint</code>, then:</p> <ul> <li>if the constraint type is one of <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,   <code>&gt;=</code>, the value in the constructor must be one of <code>str</code>, <code>int</code> or <code>float</code>.</li> <li>if the constraint type is a <code>within</code>, then the types in the range must be one of <code>int</code>, <code>str</code>, <code>float</code> or <code>Location</code>.</li> <li>if the constraint type is a <code>distance</code>, then the only valid type is <code>Location</code>.</li> <li>if the constraint type is a <code>in</code>, then the types supported are   <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>Location</code>. Notice though that a set of <code>bool</code> is trivial, so you may find yourself more comfortable by using other alternatives.</li> <li>for the other constraint types, i.e. <code>==</code> and <code>!=</code>, the value can be one of the allowed types for <code>Attribute</code>, that is <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>Location</code>.</li> </ul> </li> <li> <p>Moreover, when <code>c</code> is a <code>Constraint</code>, the attribute must have a consistent type with respect to the data model.   E.g. consider a <code>Constraint</code> like:</p> </li> </ul> <pre><code>Constraint(\"foo\", ConstraintType(\"==\", True))\n</code></pre> <p>Consider a <code>DataModel</code> where there is an <code>Attribute</code> <code>\"foo\"</code> of type <code>str</code>. Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean <code>True</code>, instead of a <code>str</code>.</p>"},{"location":"aea-framework-documentation/questions-and-answers/","title":"Q&amp;A","text":"What is an AEA? <p>AEA stands for \"Autonomous Economic Agent\". An AEA can represent an individual, organisation or object and looks after its owner's interests. AEAs act independently of constant user input and autonomously execute actions to achieve their prescribed goals. Their purpose is to create economic value for their owners.</p> How do AEAs talk to each other when they do not know each other? <p>For an Autonomous Economic Agent (AEA) to talk to other AEAs, it first needs to find them. Once it does, it should ensure that they both use the same protocol for communication, and if so, they then have to send messages to each other.</p> <p>The AEA framework, together with some of the services it provides, address all three problems. You can read more about search and discovery here, protocols here, and the Agent Communication Network (ACN) here.</p> How does an AEA use blockchain? <p>The AEA framework enables agents to interact with blockchains to settle transactions. Currently, the framework has native support for three different networks: Fetch.ai, Ethereum and Cosmos.</p> <p>You can read more about the framework's integration with the different blockchains here and gain a high level overview here.</p> How does one install third party libraries? <p>The framework supports the use of third-party libraries hosted on PyPI. You can directly reference the external dependencies of an AEA package (e.g. skill) in its configuration file. From inside an AEA's project directory, the <code>install</code> command can be used to install all the dependencies of the AEA which are listed in the configuration files belonging to any of its packages.</p> How does one connect to a database? <p>You have two options to connect to a database: using the built-in storage solution or using a custom ORM (object-relational mapping) library and backend.</p> <p>The use of the built-in storage is explained here. For a detailed example of how to use an ORM, follow the ORM guide.</p> How does one connect a frontend? <p>There are multiple options. The most obvious is using an HTTP server connection and creating a client that communicates with this connection.</p> <p>You can find a more detailed discussion here.</p> Is the AEA framework ideal for agent-based modelling? <p>The goal of agent-based modelling (ABM) is to study the unknown (often complex) behaviour of systems comprised of agents with known (much simpler) behaviour. ABM is a popular technique for studying biological and social systems. Despite some similarities between ABM and the AEA framework, the two have fundamentally different goals. ABM's goal is not the design of agents or solving specific practical or engineering problems. Although it would be potentially possible, it would likely be inefficient to use the AEA framework for that kind of problems.</p> <p>You can find more details on the application areas of the AEA framework here.</p> When a new AEA is created, is the <code>vendor</code> folder populated with some default packages? <p>All AEA projects by default hold the <code>fetchai/default:1.1.7</code>, <code>fetchai/state_update:1.1.7</code> and <code>fetchai/signing:1.1.7</code> protocols. These (as all other packages installed from the registry) are placed in the <code>vendor</code> folder.</p> <p>You can find more details about the file structure here.</p> Is there a standardization for private key files? <p>Currently, the private keys are stored in <code>.txt</code> files. This is temporary and will be improved soon.</p> How to use the same protocol in different skills? <p>The details of envelope/message routing by the AEA framework are discussed in this guide.</p> Why does the AEA framework use its own package registry? <p>AEA packages could be described as personalized plugins for the AEA runtime. They are not like a library - they have no direct use outside the context of the framework - and therefore are not suitable for distribution via PyPI.</p>"},{"location":"aea-framework-documentation/quickstart/","title":"AEA Quick Start","text":"<p>If you want to create Autonomous Economic Agents (AEAs) that can act independently of constant user input and autonomously execute actions to achieve their objective, you can use the AEA framework.</p> <p>This example will take you through a simple AEA to familiarise you with the basics of the framework.</p>"},{"location":"aea-framework-documentation/quickstart/#echo-skill-demo","title":"Echo Skill Demo","text":"<p>This is a simple demo that introduces you to the main components of an AEA.</p> <p>The fastest way to have your first AEA is to fetch one that already exists!</p> <pre><code>aea fetch fetchai/my_first_aea:0.28.5\ncd my_first_aea\n</code></pre> <p>To learn more about the folder structure of an AEA project read on here.</p> Alternatively: step by step install: <p>Create a new AEA</p> <p>First, create a new AEA project and enter it.</p> <pre><code>aea create my_first_aea\ncd my_first_aea\n</code></pre> <p>Add the stub connection</p> <p>Second, add the stub connection to the project.</p> <pre><code>aea add connection fetchai/stub:0.21.3\n</code></pre> <p>Add the echo skill</p> <p>Third, add the echo skill to the project.</p> <pre><code>aea add skill fetchai/echo:0.20.6\n</code></pre> <p>This copies the <code>fetchai/echo:0.20.6</code> skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill <code>fetchai/echo:0.20.6</code> consists of the name of the author of the skill, followed by the skill name and its version.</p>"},{"location":"aea-framework-documentation/quickstart/#echo-skill","title":"Echo Skill","text":"<p>Just like humans, AEAs can have skills to achieve their tasks. As an agent developer, you can create skills to add to your own AEAs. You can also choose to publish your skills so others add them to their AEAs. More details on skills can be found on  this page .</p> <p>The above agent has an echo skill, fetched from the registry, which simply echoes any messages it receives back to its sender.</p>"},{"location":"aea-framework-documentation/quickstart/#communication-via-envelopes-and-messages","title":"Communication via Envelopes and Messages","text":"<p>AEAs use envelopes containing messages for communication. To learn more, check out the next section.</p>"},{"location":"aea-framework-documentation/quickstart/#stub-connection","title":"Stub Connection","text":"<p>Besides skills, AEAs may have one or more connections enabling them to interface with entities in the outside world. For example, an HTTP client connection allows an AEA to communicate with HTTP servers. To read more about connections see this page.</p> <p>In this demo, we use the stub connection (<code>fetchai/stub0.15.0</code>) to send envelopes to and receive envelopes from the AEA.</p> <p>A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes.</p> <p>The AEA waits for a new envelope posted to the file <code>my_first_aea/input_file</code>, and adds a response to the file <code>my_first_aea/output_file</code>.</p> <p>The format of each envelope is the following:</p> <pre><code>TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE,\n</code></pre> <p>For example:</p> <pre><code>recipient_aea,sender_aea,fetchai/default:1.0.0,\\x08\\x01\\x12\\x011*\\x07\\n\\x05hello,\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#install-aea-dependencies","title":"Install AEA Dependencies","text":"<pre><code>aea install\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#add-and-create-a-private-key","title":"Add and Create a Private Key","text":"<p>All AEAs need a private key to run. Add one now:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#run-the-aea","title":"Run the AEA","text":"<p>Run the AEA.</p> <pre><code>aea run\n</code></pre> <p>You will see the echo skill running in the terminal window (an output similar to the one below).</p> <pre><code>    _     _____     _\n   / \\   | ____|   / \\\n/ _ \\  |  _|    / _ \\\n/ ___ \\ | |___  / ___ \\\n/_/   \\_\\|_____|/_/   \\_\\\nv1.1.1\n\nStarting AEA 'my_first_aea' in 'async' mode ...\ninfo: Echo Handler: setup method called.\ninfo: Echo Behaviour: setup method called.\ninfo: [my_first_aea]: Start processing messages...\ninfo: Echo Behaviour: act method called.\ninfo: Echo Behaviour: act method called.\ninfo: Echo Behaviour: act method called.\n...\n</code></pre> <p>The framework first calls the <code>setup</code> methods in the skill's <code>Handler</code> and <code>Behaviour</code> classes in that order; after which it repeatedly calls the <code>act</code> method of <code>Behaviour</code> class. This is the main agent loop in action.</p>"},{"location":"aea-framework-documentation/quickstart/#add-a-message-to-the-input-file","title":"Add a Message to the Input File","text":"<p>You can send the AEA a message wrapped in an envelope using the CLI's <code>interact</code> command.</p> <p>From a different terminal and same directory (ensure you are in the same virtual environment: <code>pipenv shell</code>):</p> <pre><code>cd my_first_aea\naea interact\n</code></pre> <p>You can now send messages to this AEA via an interactive tool by typing anything into the prompt and hitting enter twice (once to send the message and once more to check for a response).</p> <p>Let us send <code>hello</code> to this AEA (type <code>hello</code> and press enter twice). In the original terminal, you will see the <code>Echo Handler</code> dealing with this envelope and its contained message. You should see an output similar to the one below but with a different <code>dialogue_reference</code>.</p> <pre><code>info: Echo Behaviour: act method called.\ninfo: Echo Handler: message=Message(dialogue_reference=('1', '') message_id=1 target=0 performative=bytes content=b'hello'), sender=my_first_aea_interact\ninfo: Echo Behaviour: act method called.\ninfo: Echo Behaviour: act method called.\n</code></pre> Manual approach: <p>Optionally, from a different terminal and same directory (i.e. the <code>my_first_aea</code> project), you can send the AEA a message wrapped in an envelope via the input file.</p> <pre><code>echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' &gt;&gt; input_file\n</code></pre> <p>You will see the <code>Echo Handler</code> dealing with the envelope and responding with the same message to the <code>output_file</code>, and also decoding the Base64 encrypted message in this case.</p> <pre><code>info: Echo Behaviour: act method called.\nEcho Handler: message=Message(sender=sender_aea,to=my_first_aea,content=b'hello',dialogue_reference=('1', ''),message_id=1,performative=bytes,target=0), sender=sender_aea\ninfo: Echo Behaviour: act method called.\ninfo: Echo Behaviour: act method called.\n</code></pre> <p>Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the <code>aea interact</code> command.</p>"},{"location":"aea-framework-documentation/quickstart/#stop-the-aea","title":"Stop the AEA","text":"<p>You can stop an AEA by pressing <code>CTRL C</code>.</p> <p>Once you do, you should see the AEA being interrupted and then calling the <code>teardown()</code> methods:</p> <pre><code>info: Echo Behaviour: act method called.\ninfo: Echo Behaviour: act method called.\n^C my_first_aea interrupted!\nmy_first_aea stopping ...\ninfo: Echo Handler: teardown method called.\ninfo: Echo Behaviour: teardown method called.\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#write-a-test-for-the-aea","title":"Write a Test for the AEA","text":"<p>We can write an end-to-end test for the AEA utilising helper classes provided by the framework.</p> Writing tests: <p>The following test class replicates the preceding demo and tests its correct behaviour. The <code>AEATestCase</code> classes are a tool for AEA developers to write useful end-to-end tests of their AEAs.</p> <p>First, get the <code>packages</code> directory from the AEA repository (execute from the working directory which contains the <code>my_first_aea</code> folder):</p> <pre><code>svn export https://github.com/fetchai/agents-aea.git/trunk/packages\n</code></pre> <p>Then write the test:</p> <pre><code>import signal\nimport time\nfrom aea.common import Address\nfrom aea.mail.base import Envelope\nfrom aea.protocols.base import Message\nfrom aea.protocols.dialogue.base import Dialogue\nfrom packages.fetchai.protocols.default.dialogues import DefaultDialogue, DefaultDialogues\nfrom packages.fetchai.protocols.default.message import DefaultMessage\nfrom packages.fetchai.protocols.default.serialization import DefaultSerializer\nfrom aea.test_tools.test_cases import AEATestCase\nclass TestEchoSkill(AEATestCase):\n\"\"\"Test that echo skill works.\"\"\"\ndef test_echo(self):\n\"\"\"Run the echo skill sequence.\"\"\"\nprocess = self.run_agent()\nis_running = self.is_running(process)\nassert is_running, \"AEA not running within timeout!\"\n# add sending and receiving envelope from input/output files\nsender_aea = \"sender_aea\"\ndef role_from_first_message(\nmessage: Message, receiver_address: Address\n) -&gt; Dialogue.Role:\nreturn DefaultDialogue.Role.AGENT\ndialogues = DefaultDialogues(sender_aea, role_from_first_message)\nmessage_content = b\"hello\"\nmessage = DefaultMessage(\nperformative=DefaultMessage.Performative.BYTES,\ndialogue_reference=dialogues.new_self_initiated_dialogue_reference(),\ncontent=message_content,\n)\nsent_envelope = Envelope(\nto=self.agent_name,\nsender=sender_aea,\nprotocol_id=message.protocol_id,\nmessage=DefaultSerializer().encode(message),\n)\nself.send_envelope_to_agent(sent_envelope, self.agent_name)\ntime.sleep(2.0)\nreceived_envelope = self.read_envelope_from_agent(self.agent_name)\nassert sent_envelope.to == received_envelope.sender\nassert sent_envelope.sender == received_envelope.to\nassert sent_envelope.protocol_id == received_envelope.protocol_id\nreceived_message = DefaultMessage.serializer.decode(received_envelope.message)\nassert message.content == received_message.content\ncheck_strings = (\n\"Echo Handler: setup method called.\",\n\"Echo Behaviour: setup method called.\",\n\"Echo Behaviour: act method called.\",\n\"content={}\".format(message_content),\n)\nmissing_strings = self.missing_from_output(process, check_strings)\nassert (\nmissing_strings == []\n), \"Strings {} didn't appear in agent output.\".format(missing_strings)\nassert (\nself.is_successfully_terminated()\n), \"Echo agent wasn't successfully terminated.\"\n</code></pre> <p>Place the above code into a file <code>test.py</code> in your AEA project directory (the same level as the <code>aea-config.yaml</code> file).</p> <p>To run, execute the following:</p> <pre><code>pytest test.py\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#delete-the-aea","title":"Delete the AEA","text":"<p>Delete the AEA from the parent directory (<code>cd ..</code> to go to the parent directory).</p> <pre><code>aea delete my_first_aea\n</code></pre>"},{"location":"aea-framework-documentation/quickstart/#next-steps","title":"Next Steps","text":"<p>To gain an understanding of the core components of the framework, please continue to the next page:</p> <ul> <li>Core components - Part 1</li> </ul> <p>For more demos, use cases or step-by-step guides, please check the following:</p> <ul> <li>Generic skill use case</li> <li>Weather skill demo</li> <li> Generic step by step guide </li> </ul>"},{"location":"aea-framework-documentation/raspberry-set-up/","title":"Build an AEA on a Raspberry Pi","text":"<p>This guide explains how to run an AEA inside a Raspberry Pi.</p>"},{"location":"aea-framework-documentation/raspberry-set-up/#prerequisites","title":"Prerequisites","text":"<ul> <li>Raspberry Pi 4 (You can also use Raspberry Pi3 b or Raspberry Pi3 b+)</li> <li>Internet connection (preferably wireless to minimise the number of wires connecting into your device)</li> </ul>"},{"location":"aea-framework-documentation/raspberry-set-up/#preparing-the-raspberry-pi","title":"Preparing the Raspberry Pi","text":"<p>The easiest and recommended way to get started is to download and unzip our custom AEA Raspberry Pi Image, which includes the AEA installation as well as the most common dependencies.</p> <p>However, you can also do the installation manually, and if you have a new Raspberry Pi, you can boot the system using the included SD card and skip the next section.</p>"},{"location":"aea-framework-documentation/raspberry-set-up/#raspberry-pi-imager","title":"Raspberry Pi Imager","text":"<p>Raspberry Pi Imager is a way to write to an SD card for easy installation on a Raspberry Pi.</p> <p>First download the tool from this link.</p> <p>Then follow this guide to set up your SD card. When you get to the step of choosing an operating system, select the downloaded and unzipped AEA Raspberry Pi Image (<code>AEA_RPI.IMG</code>), or for a manual installation, select the latest Raspberry Pi OS.</p> <p>Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up.</p>"},{"location":"aea-framework-documentation/raspberry-set-up/#booting-up-with-the-aea-raspberry-pi-image","title":"Booting up with the AEA Raspberry Pi Image","text":"<p>After booting up, you may be prompted to log in as the <code>aea</code> user and the password is <code>fetch</code>. Next, navigate to settings menu to set up your internet connection. Your Raspberry Pi is now ready to run an AEA! You can find some preloaded demos in the folder <code>~/aea/demos</code>. To run these demos, navigate to one of the sub-folders and enter <code>aea run</code>.</p>"},{"location":"aea-framework-documentation/raspberry-set-up/#booting-up-with-the-raspberry-pi-os-for-manual-installation","title":"Booting up with the Raspberry Pi OS for Manual Installation","text":"<p>When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your Wi-Fi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart.</p> <p>Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up-to-date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process):</p> <pre><code>sudo apt update -y sudo apt-get update\nsudo apt-get dist-upgrade </code></pre>"},{"location":"aea-framework-documentation/raspberry-set-up/#install-common-dependencies","title":"Install Common Dependencies","text":"<pre><code>sudo apt install cmake golang -y\n</code></pre>"},{"location":"aea-framework-documentation/raspberry-set-up/#install-less-common-dependencies-optional","title":"Install Less Common Dependencies (optional)","text":"<p>For some of the more advanced AEAs that make use of SciPy, such as the Car Park Detector, you will need some additional dependencies.</p> Install additional dependencies with the enclosed steps: <p>Install additional dependencies</p> <pre><code>sudo apt install gfortran libatlas-base-dev libopenblas-dev -y\n</code></pre> <p>Increase the swap space for the SciPy installation:</p> <pre><code>sudo /bin/dd if=/dev/zero of=/var/swap.1 bs=1M count=1024\nsudo /sbin/mkswap /var/swap.1\nsudo chmod 600 /var/swap.1\nsudo /sbin/swapon /var/swap.1\n</code></pre> <p>Install NumPy and scikit-image (including SciPy)</p> <pre><code>pip install numpy --upgrade\npip install scikit-image\n</code></pre> <p>Revert to default swap space</p> <pre><code>sudo swapoff /var/swap.1\nsudo rm /var/swap.1\n</code></pre>"},{"location":"aea-framework-documentation/raspberry-set-up/#install-the-aea-framework","title":"Install the AEA Framework","text":"<p>Add to the local <code>PATH</code> environment variable (this will happen automatically the next time you log in):</p> <pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre> <p>Finally, install the AEA framework from PyPI:</p> <pre><code>pip install aea[all]\n</code></pre> <p>Check to make sure installation was successful:</p> <pre><code>aea --version\n</code></pre> <p>Your Raspberry Pi is now ready to run an AEA!</p>"},{"location":"aea-framework-documentation/runtime-cost/","title":"Profiling","text":""},{"location":"aea-framework-documentation/runtime-cost/#measuring-runtime-cost","title":"Measuring Runtime Cost","text":"<p>It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components.</p> <p>These observations can provide guidance on what to report as part of the cost of running an AEA.</p> <p>Here is a list of suggestion on how to measure the cost of running an AEA:</p> <ul> <li>the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline.</li> <li>the cost of interconnecting components: by running an agent with a basic skill (e.g. <code>fetchai/echo</code>) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth.</li> <li>the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage</li> </ul> <p>The <code>aea run --profiling SECONDS</code> command can be used to report measures in all of the above scenarios.</p>"},{"location":"aea-framework-documentation/scaffolding/","title":"Scaffolding Packages","text":""},{"location":"aea-framework-documentation/scaffolding/#scaffold-generator","title":"Scaffold Generator","text":"<p>The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA.</p> <p>For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the <code>aea</code> package).</p> <pre><code>aea create my_aea --author \"fetchai\"\ncd my_aea\n</code></pre> <p>Then, enter into your project directory and scaffold your project skill, protocol, or connection.</p>"},{"location":"aea-framework-documentation/scaffolding/#scaffold-a-skill","title":"Scaffold a Skill","text":"<pre><code>aea scaffold skill my_skill\n</code></pre>"},{"location":"aea-framework-documentation/scaffolding/#scaffold-a-protocol","title":"Scaffold a Protocol","text":"<pre><code>aea scaffold protocol my_protocol\n</code></pre>"},{"location":"aea-framework-documentation/scaffolding/#scaffold-a-contract","title":"Scaffold a Contract","text":"<pre><code>aea scaffold contract my_contract\n</code></pre>"},{"location":"aea-framework-documentation/scaffolding/#scaffold-a-connection","title":"Scaffold a Connection","text":"<pre><code>aea scaffold connection my_connection\n</code></pre> <p>After running the above commands, you are able to develop your own skill, protocol, contract and connection.</p> <p>Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package:</p> <pre><code>aea fingerprint [package_name] [public_id]\n</code></pre> <p>Then you are ready to run the AEA.</p>"},{"location":"aea-framework-documentation/security/","title":"Security","text":"<p>The AEA framework takes every care to follow best practice around security.</p> <p>The following advice will help you when writing your own code:</p> <ul> <li> <p>Many potential common security vulnerabilities can be caught by static code analysis. We recommend you use <code>safety</code>, <code>pylint</code> and <code>bandit</code> to analyse your code.</p> </li> <li> <p>Don't use relative import paths, these can lead to malicious code being executed.</p> </li> <li> <p>Try to avoid using the <code>subprocess</code> module. If needed, make sure you sanitise commands passed to <code>subprocess</code>.</p> </li> <li> <p>Try to avoid using the <code>pickle</code> module. Pickle should never be used for agent-to-agent communication protocols.</p> </li> <li> <p>By design, the framework prevents skill code from accessing private keys directly, as they are not reachable from the skill execution context through attribute getters. However, if the flag <code>-p</code> or the option <code>--password</code> are not used when generating private keys for an AEA project via the aea CLI tool, the private keys will be stored in plaintext. This allows the skills to access them via interaction with the OS file system. We recommend to always specify a password to encrypt private keys by using the flag argument.</p> </li> </ul>"},{"location":"aea-framework-documentation/setup/","title":"Setting up","text":"<p>Once you successfully install the AEA framework, you can set it up for agent development.</p>"},{"location":"aea-framework-documentation/setup/#specify-author-handle","title":"Specify Author Handle","text":"<p>You need an author handle before being able to develop agents or agent components. This handle is used in the <code>author</code> field of any agent or component you create.</p> <p>AEAs and their components can be developed by anyone and pushed to the AEA registry for others to use. To publish packages to the registry, you also need to register your author handle.</p>"},{"location":"aea-framework-documentation/setup/#pick-author-handle-and-register","title":"Pick Author Handle and Register","text":"<p>If you are intending to use the registry:</p> <pre><code>aea init --register\n</code></pre> <p>This will let you pick a new author handle and register it at the same time.</p>"},{"location":"aea-framework-documentation/setup/#pick-author-handle-only","title":"Pick Author Handle Only","text":"<p>If you are unsure whether you will need a registry account, or intending not to use it, simply pick a new author handle:</p> <pre><code>aea init\n</code></pre>"},{"location":"aea-framework-documentation/setup/#register-author-handle","title":"Register Author Handle","text":"<p>To register an already created author handle with the AEA registry:</p> <pre><code>aea register\n</code></pre> <p>Note</p> <p>The author handle is your unique author (or developer) name in the AEA ecosystem.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/","title":"SOEF Connection","text":"<p>You can use the SOEF in the agent framework by using the SOEF connection as a package in your agent project.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/#add-the-soef-package","title":"Add the SOEF Package","text":"<p>Check out the CLI guide on details how to add a connection. You will want to add the <code>fetchai/soef:0.27.6</code> connection package.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/#register-your-agent-and-its-services","title":"Register your Agent and its Services","text":""},{"location":"aea-framework-documentation/simple-oef-usage/#register-agent-location","title":"Register Agent Location","text":"<p>To register your agent's location, you have to send a message in the <code>fetchai/oef_search:1.0.0</code> protocol to the SOEF connection.</p> <p>First, define a data model for location data:</p> <pre><code>from aea.helpers.search.models import Attribute, DataModel, Location\nAGENT_LOCATION_MODEL = DataModel(\n\"location_agent\",\n[Attribute(\"location\", Location, True, \"The location where the agent is.\")],\n\"A data model to describe location of an agent.\",\n)\n</code></pre> <p>It is important to use this exact data model, as the SOEF connection can only process specific data models.</p> <p>Second, create a location object:</p> <pre><code>from aea.helpers.search.models import Location\nagent_location = Location(52.2057092, 2.1183431)\n</code></pre> <p>Third, construct a service description instance with location and data model:</p> <pre><code>from aea.helpers.search.models import Description\nservice_instance = {\"location\": agent_location}\nservice_description = Description(\nservice_instance, data_model=AGENT_LOCATION_MODEL\n)\n</code></pre> <p>Finally, construct a message and send it:</p> <pre><code>from packages.fetchai.protocols.oef_search.message import OefSearchMessage\nmessage = OefSearchMessage(\nperformative=OefSearchMessage.Performative.REGISTER_SERVICE,\nservice_description=service_description,\n)\n</code></pre> <p>In case everything is registered OK, you will not receive any message back.</p> <p>If something goes wrong you will receive an error message with performative <code>OefSearchMessage.Performative.OEF_ERROR</code>.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/#register-personality-pieces","title":"Register Personality Pieces","text":"<p>To register personality pieces, you have to use a specific data model:</p> <pre><code>from aea.helpers.search.models import Attribute, DataModel, Location\nAGENT_PERSONALITY_MODEL = DataModel(\n\"personality_agent\",\n[\nAttribute(\"piece\", str, True, \"The personality piece key.\"),\nAttribute(\"value\", str, True, \"The personality piece value.\"),\n],\n\"A data model to describe the personality of an agent.\",\n)\n</code></pre> <p>An example follows:</p> <pre><code>service_instance = {\"piece\": \"genus\", \"value\": \"service\"}\nservice_description = Description(\nservice_instance, data_model=AGENT_PERSONALITY_MODEL\n)\n</code></pre>"},{"location":"aea-framework-documentation/simple-oef-usage/#register-services","title":"Register Services","text":"<p>To set some service key and value you have to use a specific data model:</p> <pre><code>SET_SERVICE_KEY_MODEL = DataModel(\n\"set_service_key\",\n[\nAttribute(\"key\", str, True, \"Service key name.\"),\nAttribute(\"value\", str, True, \"Service key value.\"),\n],\n\"A data model to set service key.\",\n)\n</code></pre> <p>An example follows:</p> <pre><code>service_instance = {\"key\": \"test\", \"value\": \"test\"}\nservice_description = Description(\nservice_instance, data_model=SET_SERVICE_KEY_MODEL\n)\n</code></pre>"},{"location":"aea-framework-documentation/simple-oef-usage/#remove-service-key","title":"Remove Service Key","text":"<p>To remove service key have to use a specific data model:</p> <pre><code>REMOVE_SERVICE_KEY_MODEL = DataModel(\n\"remove_service_key\",\n[Attribute(\"key\", str, True, \"Service key name.\")],\n\"A data model to remove service key.\",\n)\n</code></pre> <p>An example follows:</p> <pre><code>service_instance = {\"key\": \"test\"}\nservice_description = Description(\nservice_instance, data_model=REMOVE_SERVICE_KEY_MODEL\n)\n</code></pre> <p>Note</p> <p>Currently, the soef does not allow for multiple registrations to be combined into a single command.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/#perform-a-search","title":"Perform a Search","text":"<p>To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional.</p> <p>An example follows:</p> <pre><code>from aea.helpers.search.models import (\nConstraint,\nConstraintType,\nLocation,\nQuery,\n)\nradius = 0.1\nclose_to_my_service = Constraint(\n\"location\", ConstraintType(\"distance\", (agent_location, radius))\n)\npersonality_filters = [\nConstraint(\"genus\", ConstraintType(\"==\", \"vehicle\")),\nConstraint(\n\"classification\", ConstraintType(\"==\", \"mobility.railway.train\")\n),\n]\nservice_key_filters = [\nConstraint(\"test\", ConstraintType(\"==\", \"test\")),\n]\ncloseness_query = Query(\n[close_to_my_service] + personality_filters + service_key_filters\n)\nmessage = OefSearchMessage(\nperformative=OefSearchMessage.Performative.SEARCH_SERVICES,\nquery=closeness_query,\n)\n</code></pre> <p>In case of error, you will receive a message with <code>OefSearchMessage.Performative.OEF_ERROR</code>. In case of successful search you will receive a message with performative <code>OefSearchMessage.Performative.SEARCH_RESULT</code> and the list of matched agents addresses.</p>"},{"location":"aea-framework-documentation/simple-oef-usage/#generic-command","title":"Generic Command","text":"<p>To send a generic command request to the SOEF use the following (here on the example of setting a declared name):</p> <pre><code>import urllib\nAGENT_GENERIC_COMMAND_MODEL = DataModel(\n\"generic_command\",\n[\nAttribute(\"command\", str, True, \"Command name to execute.\"),\nAttribute(\"parameters\", str, False, \"Url encoded parameters string.\"),\n],\n\"A data model to describe the generic soef command.\",\n)\ndeclared_name = \"new_declared_name\"\nservice_description = Description(\n{\n\"command\": \"set_declared_name\",\n\"parameters\": urllib.parse.urlencode({\"name\": declared_name}),\n},\ndata_model=AGENT_GENERIC_COMMAND_MODEL,\n)\nmessage = OefSearchMessage(\nperformative=OefSearchMessage.Performative.REGISTER_SERVICE,\nservice_description=service_description,\n)\n</code></pre>"},{"location":"aea-framework-documentation/simple-oef/","title":"Simple-OEF: Agent Search and Discovery","text":"<p>The full documentation is available here.</p>"},{"location":"aea-framework-documentation/skill-guide/","title":"Build your First Skill - Search &amp; Discovery","text":"<p>This guide will take you through the development of your first skill. It will teach you, how to connect the AEA to the digital world, register the AEA and search for other AEAs.</p> <p>Although one can imagine scenarios where a single AEA pursues its goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs can achieve much more. To do so, an AEA must be seen and found by other AEAs so that they can trade and do other useful things. Fetch.ai\u2019s search-and-discovery mechanism, the simple OEF (or SOEF, for short) lets your agents register, be discovered, and find other agents. You can then negotiate using the AEA framework\u2019s peer-to-peer network (ACN) and trade. This guide covers getting your AEA connected to the SOEF, and describing your AEA to make itself visible.</p> <p>Registering your AEA with the SOEF involves setting a name, a genus (a high-level description of what the agent represents, e.g. <code>vehicle</code>, <code>building</code> or <code>service</code>), a classification (for example <code>infrastructure.railway.train</code>) and other descriptors to further fine-tune the kind of service your AEA offers (for example, the agent's position, whether it buys or sells, and other descriptive items).</p> <p>The more you describe your AEA, the easier it is for others to find it using specific filters.</p>"},{"location":"aea-framework-documentation/skill-guide/#dependencies-required","title":"Dependencies (Required)","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-1-setup","title":"Step 1: Setup","text":"<p>We will first create an AEA and add a scaffold skill, which we call <code>my_search</code>.</p> <pre><code>aea create my_aea &amp;&amp; cd my_aea\naea scaffold skill my_search\n</code></pre> <p>In the following steps, we replace the scaffolded <code>Behaviour</code> and <code>Handler</code> in <code>my_aea/skills/my_search</code> with our implementation. We will build a simple skill which lets the AEA send a search query to the SOEF search node and process the resulting response.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-2-develop-a-behaviour","title":"Step 2: Develop a Behaviour","text":"<p>A <code>Behaviour</code> class contains the business logic specific to actions initiated by the AEA rather than reactions to other events.</p> <p>In this example, we implement a simple search behaviour. Each time, <code>act()</code> gets called by the main agent loop, we will send a search request to the SOEF search node via the P2P communication network.</p> <pre><code>from typing import cast\nfrom aea.helpers.search.models import Constraint, ConstraintType, Location, Query\nfrom aea.skills.behaviours import TickerBehaviour\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.my_search.dialogues import OefSearchDialogues\nDEFAULT_LOCATION = {\"longitude\": 0.1270, \"latitude\": 51.5194}\nDEFAULT_SEARCH_QUERY = {\n\"search_key\": \"seller_service\",\n\"search_value\": \"generic_service\",\n\"constraint_type\": \"==\",\n}\nDEFAULT_SEARCH_RADIUS = 5.0\nclass MySearchBehaviour(TickerBehaviour):\n\"\"\"This class provides a simple search behaviour.\"\"\"\ndef __init__(self, **kwargs):\n\"\"\"Initialize the search behaviour.\"\"\"\nsearch_query = kwargs.pop(\"search_query\", DEFAULT_SEARCH_QUERY)\nlocation = kwargs.pop(\"location\", DEFAULT_LOCATION)\nagent_location = Location(latitude=location[\"latitude\"], longitude=location[\"longitude\"])\nradius = kwargs.pop(\"search_radius\", DEFAULT_SEARCH_RADIUS)\nclose_to_my_service = Constraint(\n\"location\", ConstraintType(\"distance\", (agent_location, radius))\n)\nservice_key_filter = Constraint(\nsearch_query[\"search_key\"],\nConstraintType(\nsearch_query[\"constraint_type\"], search_query[\"search_value\"],\n),\n)\nself.query = Query([close_to_my_service, service_key_filter])\nsuper().__init__(**kwargs)\nself.sent_search_count = 0\ndef setup(self) -&gt; None:\n\"\"\"\n        Implement the setup.\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"setting up MySearchBehaviour\"\n)\ndef act(self) -&gt; None:\n\"\"\"\n        Implement the act.\n        :return: None\n        \"\"\"\nself.sent_search_count += 1\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\nself.context.logger.info(\n\"sending search request to OEF search node, search_count={}\".format(\nself.sent_search_count\n)\n)\nsearch_request, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.SEARCH_SERVICES,\nquery=self.query,\n)\nself.context.outbox.put_message(message=search_request)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Implement the task teardown.\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"tearing down MySearchBehaviour\"\n)\n</code></pre> <p>Searches are proactive and, as such, well placed in a <code>Behaviour</code>. Specifically, we subclass the <code>TickerBehaviour</code> as it allows us to repeatedly search at a defined tick interval.</p> <p>We place this code in <code>my_aea/skills/my_search/behaviours.py</code>. Ensure you replace the <code>fetchai</code> author in this line <code>from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues</code> with your author handle (run <code>aea init</code> to set or check the author name).</p> <p>Note</p> <p>The import paths to agent packages, for example <code>packages.fetchai.skills.my_search.dialogues</code> above, are not actual paths. Package files always reside in your AEA's folder, either under a specific package directory (e.g. connection, protocol, skill) if the package is custom-built, or under <code>vendor</code> if it is pulled from the registry. These paths are virtual and created automatically when an AEA is run. See  this page  for more details.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-3-develop-a-handler","title":"Step 3: Develop a Handler","text":"<p>So far, we have tasked the AEA with sending search requests to the SOEF search node. However, we have no way of handling the responses sent to the AEA by the SOEF search node at the moment. The AEA would simply respond to the SOEF search node via the default <code>error</code> skill which sends all unrecognised envelopes back to the sender.</p> <p>Let us now implement a <code>Handler</code> to deal with the incoming search responses.</p> <pre><code>from typing import Optional, cast\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.my_search.dialogues import (\nOefSearchDialogue,\nOefSearchDialogues,\n)\nclass MySearchHandler(Handler):\n\"\"\"This class provides a simple search handler.\"\"\"\nSUPPORTED_PROTOCOL = OefSearchMessage.protocol_id\ndef __init__(self, **kwargs):\n\"\"\"Initialize the handler.\"\"\"\nsuper().__init__(**kwargs)\nself.received_search_count = 0\ndef setup(self) -&gt; None:\n\"\"\"Set up the handler.\"\"\"\nself.context.logger.info(\n\"setting up MySearchHandler\"\n)\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        :return: None\n        \"\"\"\noef_search_msg = cast(OefSearchMessage, message)\n# recover dialogue\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_dialogue = cast(\nOptional[OefSearchDialogue], oef_search_dialogues.update(oef_search_msg)\n)\nif oef_search_dialogue is None:\nself._handle_unidentified_dialogue(oef_search_msg)\nreturn\n# handle message\nif oef_search_msg.performative is OefSearchMessage.Performative.OEF_ERROR:\nself._handle_error(oef_search_msg, oef_search_dialogue)\nelif oef_search_msg.performative is OefSearchMessage.Performative.SEARCH_RESULT:\nself._handle_search(oef_search_msg, oef_search_dialogue)\nelse:\nself._handle_invalid(oef_search_msg, oef_search_dialogue)\ndef _handle_unidentified_dialogue(self, oef_search_msg: OefSearchMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid oef_search message={}, unidentified dialogue.\".format(\noef_search_msg\n)\n)\ndef _handle_error(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"received oef_search error message={} in dialogue={}.\".format(\noef_search_msg, oef_search_dialogue\n)\n)\ndef _handle_search(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle the search response.\n        :param agents: the agents returned by the search\n        :return: None\n        \"\"\"\nself.received_search_count += 1\nnb_agents_found = len(oef_search_msg.agents)\nself.context.logger.info(\n\"found number of agents={}, received search count={}\".format(\nnb_agents_found, self.received_search_count\n)\n)\nself.context.logger.info(\n\"number of search requests sent={} vs. number of search responses received={}\".format(\nself.context.behaviours.my_search_behaviour.sent_search_count,\nself.received_search_count,\n)\n)\ndef _handle_invalid(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle oef_search message of performative={} in dialogue={}.\".format(\noef_search_msg.performative, oef_search_dialogue,\n)\n)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Teardown the handler.\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"tearing down MySearchHandler\"\n)\n</code></pre> <p>We create a handler which is registered for the <code>oef_search</code> protocol. Whenever it receives a search result, we log the number of agents returned by the search - the agents matching the search query - and update the counter of received searches.</p> <p>We also implement a trivial check on the difference between the amount of search requests sent and responses received.</p> <p>Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event.</p> <p>Also note, how we have access to other objects in the skill via <code>self.context</code>, the <code>SkillContext</code>.</p> <p>We place this code in <code>my_aea/skills/my_search/handlers.py</code>. Ensure you replace the <code>fetchai</code> author in this line <code>from packages.fetchai.skills.my_search.dialogues import (</code> with your author handle (run <code>aea init</code> to set or check the author name).</p>"},{"location":"aea-framework-documentation/skill-guide/#step-4-add-dialogues-model","title":"Step 4: Add Dialogues Model","text":"<p>We have implemented a behaviour and a handler. We now implement a <code>Model</code>, in particular we implement the <code>Dialogue</code> and <code>Dialogues</code> classes. These ensure that the message flow satisfies the <code>fetchai/oef_search:1.0.0</code> protocol and keep track of the individual messages being sent and received.</p> <pre><code>from aea.protocols.base import Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.skills.base import Address, Model\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogue as BaseOefSearchDialogue,\n)\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogues as BaseOefSearchDialogues,\n)\nOefSearchDialogue = BaseOefSearchDialogue\nclass OefSearchDialogues(Model, BaseOefSearchDialogues):\n\"\"\"This class keeps track of all oef_search dialogues.\"\"\"\ndef __init__(self, **kwargs) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param agent_address: the address of the agent for whom dialogues are maintained\n        :return: None\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseOefSearchDialogue.Role.AGENT\nBaseOefSearchDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\n</code></pre> <p>We add this code in the file <code>my_aea/skills/my_search/my_model.py</code>, replacing its original content. We then rename <code>my_aea/skills/my_search/my_model.py</code> to <code>my_aea/skills/my_search/dialogues.py</code>.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-5-create-the-configuration-file","title":"Step 5: Create the Configuration File","text":"<p>Based on our skill components above, we create the following configuration file.</p> <pre><code>name: my_search\nauthor: fetchai\nversion: 0.1.0\ntype: skill\ndescription: A simple search skill utilising the SOEF search node.\nlicense: Apache-2.0\naea_version: '&gt;=1.0.0, &lt;2.0.0'\nfingerprint: {}\nfingerprint_ignore_patterns: []\nconnections: []\ncontracts: []\nprotocols:\n- fetchai/oef_search:1.1.7\nskills: []\nbehaviours:\nmy_search_behaviour:\nargs:\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\nsearch_query:\nconstraint_type: ==\nsearch_key: seller_service\nsearch_value: generic_service\nsearch_radius: 5.0\ntick_interval: 5\nclass_name: MySearchBehaviour\nhandlers:\nmy_search_handler:\nargs: {}\nclass_name: MySearchHandler\nmodels:\noef_search_dialogues:\nargs: {}\nclass_name: OefSearchDialogues\ndependencies:\naea-ledger-fetchai:\nversion: &lt;2.0.0,&gt;=1.0.0\nis_abstract: false\n</code></pre> <p>Ensure, you replace the author field with your author name! (Run <code>aea init</code> to set or check the author name.)</p> <p>Importantly, the keys <code>my_search_behaviour</code> and <code>my_search_handler</code> are used in the above handler to access these skill components at runtime via the context. We also set the <code>tick_interval</code> of the <code>TickerBehaviour</code> to <code>5</code> seconds.</p> <p>We place this code in <code>my_aea/skills/my_search/skill.yaml</code>.</p> <p>Similarly, we replace <code>my_aea/skills/my_search/__init__.py</code> as follows:</p> <pre><code># -*- coding: utf-8 -*-\n# ------------------------------------------------------------------------------\n#\n#   Copyright 2018-2019 Fetch.AI Limited\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\n\"\"\"This module contains the implementation of the error skill.\"\"\"\nfrom aea.configurations.base import PublicId\nPUBLIC_ID = PublicId.from_str(\"fetchai/my_search:0.1.0\")\n</code></pre> <p>Again, ensure the author field matches your own.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-6-update-fingerprint","title":"Step 6: Update Fingerprint","text":"<p>To run an AEA with new or modified code, you need to update the fingerprint of the new/modified components. In this case, we need to fingerprint our skill:</p> <pre><code>aea fingerprint skill fetchai/my_search:0.1.0\n</code></pre> <p>Ensure, you use the correct author name to reference your skill (here we use <code>fetchai</code> as the author.)</p>"},{"location":"aea-framework-documentation/skill-guide/#step-7-add-the-oef-protocol-and-connection","title":"Step 7: Add the OEF Protocol and Connection","text":"<p>Our AEA does not have the OEF protocol yet so let's add it.</p> <pre><code>aea add protocol fetchai/oef_search:1.1.7\n</code></pre> <p>This adds the protocol to our AEA and makes it available on the path <code>packages.fetchai.protocols...</code>.</p> <p>At this point we need to add the SOEF and P2P connections to allow the AEA to communicate with the SOEF node and other AEAs, install the AEA's dependencies, and configure the AEA:</p> <pre><code>aea add connection fetchai/soef:0.27.6\naea add connection fetchai/p2p_libp2p:0.27.5\naea install\naea build\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\n</code></pre> <p>The last command will ensure that search requests are processed by the correct connection.</p>"},{"location":"aea-framework-documentation/skill-guide/#step-8-run-a-service-provider-aea","title":"Step 8: Run a Service Provider AEA","text":"<p>In order for this AEA to find another AEA when searching, the second AEA (let's call it the service provider AEA) must exist and have been registered with the SOEF.</p> <p>From a different terminal window, we fetch a finished service provider AEA and install its Python dependencies:</p> <pre><code>aea fetch fetchai/simple_service_registration:0.32.5 &amp;&amp; cd simple_service_registration &amp;&amp; aea install &amp;&amp; aea build\n</code></pre> <p>This AEA will simply register a location service on the SOEF search node so we can search for it.</p> <p>We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre> <p>Then we run the AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr: ['SOME_ADDRESS']</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the <code>simple_service_registration</code> (service provider) AEA.</p> Click here to see full code and guide for this AEA: <p>We use a <code>TickerBehaviour</code> to update the service registration at regular intervals. The following code is placed in <code>behaviours.py</code>.</p> <pre><code>from typing import Any, Optional, cast\nfrom aea.helpers.search.models import Description\nfrom aea.skills.behaviours import TickerBehaviour\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.simple_service_registration.dialogues import (\nOefSearchDialogues,\n)\nfrom packages.fetchai.skills.simple_service_registration.strategy import Strategy\nDEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5\nDEFAULT_SERVICES_INTERVAL = 30.0\nclass ServiceRegistrationBehaviour(TickerBehaviour):\n\"\"\"This class implements a behaviour.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"Initialise the behaviour.\"\"\"\nservices_interval = kwargs.pop(\n\"services_interval\", DEFAULT_SERVICES_INTERVAL\n)  # type: int\nself._max_soef_registration_retries = kwargs.pop(\n\"max_soef_registration_retries\", DEFAULT_MAX_SOEF_REGISTRATION_RETRIES\n)  # type: int\nsuper().__init__(tick_interval=services_interval, **kwargs)\nself.failed_registration_msg = None  # type: Optional[OefSearchMessage]\nself._nb_retries = 0\ndef setup(self) -&gt; None:\n\"\"\"\n        Implement the setup.\n        :return: None\n        \"\"\"\nself._register_agent()\ndef act(self) -&gt; None:\n\"\"\"\n        Implement the act.\n        :return: None\n        \"\"\"\nself._retry_failed_registration()\ndef teardown(self) -&gt; None:\n\"\"\"\n        Implement the task teardown.\n        :return: None\n        \"\"\"\nself._unregister_service()\nself._unregister_agent()\ndef _retry_failed_registration(self) -&gt; None:\n\"\"\"\n        Retry a failed registration.\n        :return: None\n        \"\"\"\nif self.failed_registration_msg is not None:\nself._nb_retries += 1\nif self._nb_retries &gt; self._max_soef_registration_retries:\nself.context.is_active = False\nreturn\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.failed_registration_msg.to,\nperformative=self.failed_registration_msg.performative,\nservice_description=self.failed_registration_msg.service_description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\nf\"Retrying registration on SOEF. Retry {self._nb_retries} out of {self._max_soef_registration_retries}.\"\n)\nself.failed_registration_msg = None\ndef _register(self, description: Description, logger_msg: str) -&gt; None:\n\"\"\"\n        Register something on the SOEF.\n        :param description: the description of what is being registered\n        :param logger_msg: the logger message to print after the registration\n        :return: None\n        \"\"\"\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.REGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(logger_msg)\ndef _register_agent(self) -&gt; None:\n\"\"\"\n        Register the agent's location.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_location_description()\nself._register(description, \"registering agent on SOEF.\")\ndef register_service(self) -&gt; None:\n\"\"\"\n        Register the agent's service.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_register_service_description()\nself._register(description, \"registering agent's service on the SOEF.\")\ndef register_genus(self) -&gt; None:\n\"\"\"\n        Register the agent's personality genus.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_register_personality_description()\nself._register(\ndescription, \"registering agent's personality genus on the SOEF.\"\n)\ndef register_classification(self) -&gt; None:\n\"\"\"\n        Register the agent's personality classification.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_register_classification_description()\nself._register(\ndescription, \"registering agent's personality classification on the SOEF.\"\n)\ndef _unregister_service(self) -&gt; None:\n\"\"\"\n        Unregister service from the SOEF.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_unregister_service_description()\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.UNREGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\"unregistering service from SOEF.\")\ndef _unregister_agent(self) -&gt; None:\n\"\"\"\n        Unregister agent from the SOEF.\n        :return: None\n        \"\"\"\nstrategy = cast(Strategy, self.context.strategy)\ndescription = strategy.get_location_description()\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_msg, _ = oef_search_dialogues.create(\ncounterparty=self.context.search_service_address,\nperformative=OefSearchMessage.Performative.UNREGISTER_SERVICE,\nservice_description=description,\n)\nself.context.outbox.put_message(message=oef_search_msg)\nself.context.logger.info(\"unregistering agent from SOEF.\")\n</code></pre> <p>We create a <code>Model</code> type strategy class and place it in <code>strategy.py</code>. We use a generic data model to register the service. As part of the registration we register a location and a key pair describing our service.</p> <pre><code>from typing import Any\nfrom aea.exceptions import enforce\nfrom aea.helpers.search.generic import (\nAGENT_LOCATION_MODEL,\nAGENT_PERSONALITY_MODEL,\nAGENT_REMOVE_SERVICE_MODEL,\nAGENT_SET_SERVICE_MODEL,\n)\nfrom aea.helpers.search.models import Description, Location\nfrom aea.skills.base import Model\nDEFAULT_LOCATION = {\"longitude\": 0.1270, \"latitude\": 51.5194}\nDEFAULT_SERVICE_DATA = {\"key\": \"seller_service\", \"value\": \"generic_service\"}\nDEFAULT_PERSONALITY_DATA = {\"piece\": \"genus\", \"value\": \"data\"}\nDEFAULT_CLASSIFICATION = {\"piece\": \"classification\", \"value\": \"seller\"}\nclass Strategy(Model):\n\"\"\"This class defines a strategy for the agent.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize the strategy of the agent.\n        :return: None\n        \"\"\"\nlocation = kwargs.pop(\"location\", DEFAULT_LOCATION)\nself._agent_location = {\n\"location\": Location(\nlatitude=location[\"latitude\"], longitude=location[\"longitude\"]\n)\n}\nself._set_personality_data = kwargs.pop(\n\"personality_data\", DEFAULT_PERSONALITY_DATA\n)\nenforce(\nlen(self._set_personality_data) == 2\nand \"piece\" in self._set_personality_data\nand \"value\" in self._set_personality_data,\n\"personality_data must contain keys `key` and `value`\",\n)\nself._set_classification = kwargs.pop(\"classification\", DEFAULT_CLASSIFICATION)\nenforce(\nlen(self._set_classification) == 2\nand \"piece\" in self._set_classification\nand \"value\" in self._set_classification,\n\"classification must contain keys `key` and `value`\",\n)\nself._set_service_data = kwargs.pop(\"service_data\", DEFAULT_SERVICE_DATA)\nenforce(\nlen(self._set_service_data) == 2\nand \"key\" in self._set_service_data\nand \"value\" in self._set_service_data,\n\"service_data must contain keys `key` and `value`\",\n)\nself._remove_service_data = {\"key\": self._set_service_data[\"key\"]}\nsuper().__init__(**kwargs)\ndef get_location_description(self) -&gt; Description:\n\"\"\"\n        Get the location description.\n        :return: a description of the agent's location\n        \"\"\"\ndescription = Description(\nself._agent_location, data_model=AGENT_LOCATION_MODEL,\n)\nreturn description\ndef get_register_service_description(self) -&gt; Description:\n\"\"\"\n        Get the register service description.\n        :return: a description of the offered services\n        \"\"\"\ndescription = Description(\nself._set_service_data, data_model=AGENT_SET_SERVICE_MODEL,\n)\nreturn description\ndef get_register_personality_description(self) -&gt; Description:\n\"\"\"\n        Get the register personality description.\n        :return: a description of the personality\n        \"\"\"\ndescription = Description(\nself._set_personality_data, data_model=AGENT_PERSONALITY_MODEL,\n)\nreturn description\ndef get_register_classification_description(self) -&gt; Description:\n\"\"\"\n        Get the register classification description.\n        :return: a description of the classification\n        \"\"\"\ndescription = Description(\nself._set_classification, data_model=AGENT_PERSONALITY_MODEL,\n)\nreturn description\ndef get_unregister_service_description(self) -&gt; Description:\n\"\"\"\n        Get the unregister service description.\n        :return: a description of the to be removed service\n        \"\"\"\ndescription = Description(\nself._remove_service_data, data_model=AGENT_REMOVE_SERVICE_MODEL,\n)\nreturn description\n</code></pre> <p>We create a <code>Model</code> type dialogue class and place it in <code>dialogues.py</code>. These classes ensure that the message flow satisfies the <code>fetchai/oef_search:1.0.0</code> protocol and keep track of the individual messages being sent and received.</p> <pre><code>from typing import Any\nfrom aea.protocols.base import Address, Message\nfrom aea.protocols.dialogue.base import Dialogue as BaseDialogue\nfrom aea.skills.base import Model\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogue as BaseOefSearchDialogue,\n)\nfrom packages.fetchai.protocols.oef_search.dialogues import (\nOefSearchDialogues as BaseOefSearchDialogues,\n)\nOefSearchDialogue = BaseOefSearchDialogue\nclass OefSearchDialogues(Model, BaseOefSearchDialogues):\n\"\"\"This class keeps track of all oef_search dialogues.\"\"\"\ndef __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Initialize dialogues.\n        :param agent_address: the address of the agent for whom dialogues are maintained\n        :return: None\n        \"\"\"\nModel.__init__(self, **kwargs)\ndef role_from_first_message(  # pylint: disable=unused-argument\nmessage: Message, receiver_address: Address\n) -&gt; BaseDialogue.Role:\n\"\"\"Infer the role of the agent from an incoming/outgoing first message\n            :param message: an incoming/outgoing first message\n            :param receiver_address: the address of the receiving agent\n            :return: The role of the agent\n            \"\"\"\nreturn BaseOefSearchDialogue.Role.AGENT\nBaseOefSearchDialogues.__init__(\nself,\nself_address=str(self.skill_id),\nrole_from_first_message=role_from_first_message,\n)\n</code></pre> <p>Finally, we have a handler, placed in <code>handlers.py</code>. The handler deals with handling any error messages which might occur during service registration:</p> <pre><code>from typing import Optional, cast\nfrom aea.configurations.base import PublicId\nfrom aea.protocols.base import Message\nfrom aea.skills.base import Handler\nfrom packages.fetchai.protocols.oef_search.message import OefSearchMessage\nfrom packages.fetchai.skills.simple_service_registration.behaviours import (\nServiceRegistrationBehaviour,\n)\nfrom packages.fetchai.skills.simple_service_registration.dialogues import (\nOefSearchDialogue,\nOefSearchDialogues,\n)\nclass OefSearchHandler(Handler):\n\"\"\"This class implements an OEF search handler.\"\"\"\nSUPPORTED_PROTOCOL = OefSearchMessage.protocol_id  # type: Optional[PublicId]\ndef setup(self) -&gt; None:\n\"\"\"Call to setup the handler.\"\"\"\ndef handle(self, message: Message) -&gt; None:\n\"\"\"\n        Implement the reaction to a message.\n        :param message: the message\n        :return: None\n        \"\"\"\noef_search_msg = cast(OefSearchMessage, message)\n# recover dialogue\noef_search_dialogues = cast(\nOefSearchDialogues, self.context.oef_search_dialogues\n)\noef_search_dialogue = cast(\nOptional[OefSearchDialogue], oef_search_dialogues.update(oef_search_msg)\n)\nif oef_search_dialogue is None:\nself._handle_unidentified_dialogue(oef_search_msg)\nreturn\n# handle message\nif oef_search_msg.performative == OefSearchMessage.Performative.SUCCESS:\nself._handle_success(oef_search_msg, oef_search_dialogue)\nelif oef_search_msg.performative == OefSearchMessage.Performative.OEF_ERROR:\nself._handle_error(oef_search_msg, oef_search_dialogue)\nelse:\nself._handle_invalid(oef_search_msg, oef_search_dialogue)\ndef teardown(self) -&gt; None:\n\"\"\"\n        Implement the handler teardown.\n        :return: None\n        \"\"\"\ndef _handle_unidentified_dialogue(self, oef_search_msg: OefSearchMessage) -&gt; None:\n\"\"\"\n        Handle an unidentified dialogue.\n        :param msg: the message\n        \"\"\"\nself.context.logger.info(\n\"received invalid oef_search message={}, unidentified dialogue.\".format(\noef_search_msg\n)\n)\ndef _handle_success(\nself,\noef_search_success_msg: OefSearchMessage,\noef_search_dialogue: OefSearchDialogue,\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_success_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"received oef_search success message={} in dialogue={}.\".format(\noef_search_success_msg, oef_search_dialogue\n)\n)\ntarget_message = cast(\nOefSearchMessage,\noef_search_dialogue.get_message_by_id(oef_search_success_msg.target),\n)\nif (\ntarget_message.performative\n== OefSearchMessage.Performative.REGISTER_SERVICE\n):\ndescription = target_message.service_description\ndata_model_name = description.data_model.name\nregistration_behaviour = cast(\nServiceRegistrationBehaviour, self.context.behaviours.service,\n)\nif \"location_agent\" in data_model_name:\nregistration_behaviour.register_service()\nelif \"set_service_key\" in data_model_name:\nregistration_behaviour.register_genus()\nelif (\n\"personality_agent\" in data_model_name\nand description.values[\"piece\"] == \"genus\"\n):\nregistration_behaviour.register_classification()\nelif (\n\"personality_agent\" in data_model_name\nand description.values[\"piece\"] == \"classification\"\n):\nself.context.logger.info(\n\"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\"\n)\nelse:\nself.context.logger.warning(\nf\"received soef SUCCESS message as a reply to the following unexpected message: {target_message}\"\n)\ndef _handle_error(\nself,\noef_search_error_msg: OefSearchMessage,\noef_search_dialogue: OefSearchDialogue,\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_error_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.info(\n\"received oef_search error message={} in dialogue={}.\".format(\noef_search_error_msg, oef_search_dialogue\n)\n)\ntarget_message = cast(\nOefSearchMessage,\noef_search_dialogue.get_message_by_id(oef_search_error_msg.target),\n)\nif (\ntarget_message.performative\n== OefSearchMessage.Performative.REGISTER_SERVICE\n):\nregistration_behaviour = cast(\nServiceRegistrationBehaviour, self.context.behaviours.service,\n)\nregistration_behaviour.failed_registration_msg = target_message\ndef _handle_invalid(\nself, oef_search_msg: OefSearchMessage, oef_search_dialogue: OefSearchDialogue\n) -&gt; None:\n\"\"\"\n        Handle an oef search message.\n        :param oef_search_msg: the oef search message\n        :param oef_search_dialogue: the dialogue\n        :return: None\n        \"\"\"\nself.context.logger.warning(\n\"cannot handle oef_search message of performative={} in dialogue={}.\".format(\noef_search_msg.performative, oef_search_dialogue,\n)\n)\n</code></pre> <p>The associated <code>skill.yaml</code> is:</p> <pre><code>name: simple_service_registration\nauthor: fetchai\nversion: 0.20.0\ntype: skill\ndescription: The simple service registration skills is a skill to register a service.\nlicense: Apache-2.0\naea_version: '&gt;=1.0.0, &lt;2.0.0'\nfingerprint:\nREADME.md: QmUgCcR7sDBQeeCBRKwDT7tPBTi3t4zSibyEqR3xdQUKmh\n__init__.py: QmZd48HmYDr7FMxNaVeGfWRvVtieEdEV78hd7h7roTceP2\nbehaviours.py: QmQHf6QL5aBtLJ34D2tdcbjJLbzom9gaA3HWgRn3rWyigM\ndialogues.py: QmTT9dvFhWt6qvxjwBfMFDTrgEtgWbvgANYafyRg2BXwcR\nhandlers.py: QmZqPt8toGbJgTT6NZBLxjkusrQCZ8GmUEwcmqZ1sd7DpG\nstrategy.py: QmVXfQpk4cjDw576H2ELE12tEiN5brPkwvffvcTeMbsugA\nfingerprint_ignore_patterns: []\nconnections: []\ncontracts: []\nprotocols:\n- fetchai/oef_search:1.1.7\nskills: []\nbehaviours:\nservice:\nargs:\nmax_soef_registration_retries: 5\nservices_interval: 30\nclass_name: ServiceRegistrationBehaviour\nhandlers:\noef_search:\nargs: {}\nclass_name: OefSearchHandler\nmodels:\noef_search_dialogues:\nargs: {}\nclass_name: OefSearchDialogues\nstrategy:\nargs:\nclassification:\npiece: classification\nvalue: seller\nlocation:\nlatitude: 51.5194\nlongitude: 0.127\npersonality_data:\npiece: genus\nvalue: data\nservice_data:\nkey: seller_service\nvalue: generic_service\nclass_name: Strategy\ndependencies: {}\nis_abstract: false\n</code></pre>"},{"location":"aea-framework-documentation/skill-guide/#step-9-run-the-search-aea","title":"Step 9: Run the Search AEA","text":"<p>First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre> <p>Then, in the search AEA, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm1uJpFsqSgHStJdtTBPpDme1fo8uFEvvY182D2y89jQuj\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>This allows the search AEA to connect to the same local agent communication network as the service registration AEA.</p> <p>We can then launch our AEA.</p> <pre><code>aea run\n</code></pre> <p>We can see that the AEA sends search requests to the SOEF search node and receives search responses from the SOEF search node. The search response returns one or more agents (the service provider and potentially other agents which match the query).</p> <p>We stop the AEA with <code>CTRL + C</code>.</p>"},{"location":"aea-framework-documentation/skill-guide/#next-steps","title":"Next Steps","text":""},{"location":"aea-framework-documentation/skill-guide/#recommended","title":"Recommended","text":"<p>We recommend you continue with the next step in the 'Getting Started' series:</p> <ul> <li>Core components (Part 2)</li> </ul>"},{"location":"aea-framework-documentation/skill-guide/#relevant-deep-dives","title":"Relevant Deep-Dives","text":"<p> This guide  goes through a more elaborate scenario than the one on this page, where after finding each other, the two AEAs negotiate and trade via a ledger.</p>"},{"location":"aea-framework-documentation/skill-testing/","title":"Testing Skills","text":"<p>In this guide, we describe some of the tools the framework offers for testing skills.</p>"},{"location":"aea-framework-documentation/skill-testing/#the-baseskilltestcase-class","title":"The <code>BaseSkillTestCase</code> Class","text":"<p>The framework offers a <code>BaseSkillTestCase</code> class which you can subclass and write your test cases with.</p> <p>Let us assume you want to test the <code>my_behaviour</code> behaviour of a <code>CustomSkill</code> skill you have developed.</p> <p>You can create a <code>TestMyBehaviour</code> class which inherits <code>BaseSkillTestCase</code> as below:</p> <pre><code>import asyncio\nfrom asyncio import Queue\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom typing import cast\nfrom aea.configurations.constants import DEFAULT_LEDGER\nfrom aea.context.base import AgentContext\nfrom aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS\nfrom aea.identity.base import Identity\nfrom aea.multiplexer import AsyncMultiplexer, OutBox, Multiplexer\nfrom aea.skills.tasks import TaskManager\nfrom aea.test_tools.test_skill import BaseSkillTestCase\nclass TestMyBehaviour(BaseSkillTestCase):\n\"\"\"Test my_behaviours of the custom skill.\"\"\"\npath_to_skill = Path(\"path_to_this_skill\")\n</code></pre>"},{"location":"aea-framework-documentation/skill-testing/#specifying-skill-path","title":"Specifying Skill Path","text":"<p>You must then specify the path to your skill directory via <code>path_to_skill</code> to allow the skill to be loaded and tested. This must be the directory in which <code>skill.yaml</code> of your skill resides.</p>"},{"location":"aea-framework-documentation/skill-testing/#setting-up-each-test","title":"Setting up Each Test","text":"<p>You can add a <code>setup()</code> class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the <code>setup()</code> method of the <code>BaseSkillTestCase</code> class via <code>super().setup()</code>.</p> <pre><code>@classmethod\ndef setup(cls):\n\"\"\"Setup the test class.\"\"\"\nsuper().setup()\ncls.my_behaviour = cast(\nMyBehaviour, cls._skill.skill_context.behaviours.my_behaviour\n)\n</code></pre> <p>In the above, we make the <code>my_behaviour</code> behaviour object accessible for every test.</p>"},{"location":"aea-framework-documentation/skill-testing/#skill-and-skill-context","title":"Skill and Skill Context","text":"<p>The skill object itself is exposed via a property. So you can access the skill object by <code>self.skill</code> and by extension all of its attributes. This crucially includes the complete <code>skill_context</code>. This means that for example, every component of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context.</p> <p>In the above code snippet, <code>my_behavior</code> is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via <code>self.skill.skill_context.behaviours.my_behaviour</code>.</p>"},{"location":"aea-framework-documentation/skill-testing/#dummy-agent-context","title":"Dummy Agent Context","text":"<p>The loaded skill is also fed a dummy <code>agent_context</code> complete with an <code>identity</code>, <code>outbox</code>, <code>decision_maker_queue</code> and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The <code>agent_context</code> object fed to the skill is shown below:</p> <pre><code>_multiplexer = AsyncMultiplexer()\n_multiplexer._out_queue = (asyncio.Queue())\nagent_context = AgentContext(\nidentity=Identity(\"test_agent_name\", \"test_agent_address\", \"test_agent_public_key\"),\nconnection_status=_multiplexer.connection_status,\noutbox=OutBox(cast(Multiplexer, cls._multiplexer)),\ndecision_maker_message_queue=Queue(),\ndecision_maker_handler_context=SimpleNamespace(),\ntask_manager=TaskManager(),\ndefault_ledger_id=DEFAULT_LEDGER,\ncurrency_denominations={},\ndefault_connection=None,\ndefault_routing={},\nsearch_service_address=\"dummy_search_service_address\",\ndecision_maker_address=\"dummy_decision_maker_address\",\ndata_dir=\".\"\n)\n</code></pre>"},{"location":"aea-framework-documentation/skill-testing/#some-useful-skill-attributes","title":"Some Useful Skill Attributes","text":"<p>Some of the useful objects you can access in your test class for the loaded skill are below:</p> <ul> <li><code>self.skill.skill_context.agent_address</code>: this is the agent identity the skill uses and is set to <code>\"test_agent_address\"</code>.</li> <li><code>self.skill.skill_context.search_service_address</code>: this is the address of the search service and is set to <code>\"dummy_search_service_address\"</code>.</li> <li><code>self.skill.skill_context.skill_id</code>: this is the id of the skill.</li> <li><code>self.skill.skill_context.decision_maker_address</code>: this is the address of the decision maker and is set to <code>\"dummy_decision_maker_address\"</code>.</li> </ul>"},{"location":"aea-framework-documentation/skill-testing/#some-useful-baseskilltestcase-methods","title":"Some Useful <code>BaseSkillTestCase</code> Methods","text":"<p>There are a number of methods that <code>BaseSkillTestCase</code> offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for <code>BaseSkillTestCase</code>:</p> <ul> <li><code>self.get_quantity_in_outbox()</code>: gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent.</li> <li><code>self.get_message_from_outbox()</code>: gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message.</li> <li><code>self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,)</code>: you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using <code>self.get_message_from_outbox()</code>), specify its expected type (e.g. <code>FipaMessage</code>), and any other attribute you expect the message to have (e.g. <code>message_id</code> is 1) may be provided via keyword arguments.</li> <li><code>self.build_incoming_message</code>: this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution.</li> </ul>"},{"location":"aea-framework-documentation/skill-testing/#checking-logger-output","title":"Checking Logger Output","text":"<p>You can check the output of your skill's <code>logger</code> by mocking it using <code>unittest.mock</code> before executing a part of your skill as such:</p> <pre><code>import logging\nfrom unittest import mock\nwith mock.patch.object(self.my_behaviour.context.logger, \"log\") as mock_logger:\nself.my_behaviour.act()\nmock_logger.assert_any_call(logging.INFO, \"some_logger_message\")\n</code></pre> <p>In the above, we mock the logger before running <code>my_behaviour</code>'s <code>act()</code> method and check that  the string <code>\"some_logger_message\"</code> is indeed passed to the logger.</p>"},{"location":"aea-framework-documentation/skill-testing/#next-steps","title":"Next Steps","text":"<p>You can consult the <code>fetchai/generic_buyer</code> and <code>fetchai/generic_seller</code> skills and their associated tests here to study how <code>BaseSkillTestCase</code> can help you in testing your skills.</p> <p>You can also refer to the API to study the different methods <code>BaseSkillTestCase</code> makes available to make testing your skills easier.</p>"},{"location":"aea-framework-documentation/skill/","title":"Skills","text":"<p><code>Skills</code> are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations.</p> <p></p> <p>A skill encapsulates implementations of the three abstract base classes <code>Handler</code>, <code>Behaviour</code>, <code>Model</code>, and is closely related with the abstract base class <code>Task</code>:</p> <ul> <li><code>Handler</code>: each skill has zero, one or more <code>Handler</code> objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received <code>Envelope</code>, the <code>Handler</code> reacts appropriately to the corresponding message. Each <code>Handler</code> is responsible for only one protocol. A <code>Handler</code> is also capable of dealing with internal messages (see next section).</li> <li><code>Behaviour</code>: zero, one or more <code>Behaviours</code> encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness. The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.).</li> <li><code>Model</code>: zero, one or more <code>Models</code> that inherit from the <code>Model</code> class. <code>Models</code> encapsulate custom objects which are made accessible to any part of a skill via the <code>SkillContext</code>.</li> <li><code>Task</code>: zero, one or more <code>Tasks</code> encapsulate background work internal to the AEA. <code>Task</code> differs from the other three in that it is not a part of skills, but <code>Task</code>s are declared in or from skills if a packaging approach for AEA creation is used.</li> </ul> <p>A skill can read (parts of) the state of the AEA (as summarised in the <code>AgentContext</code>), and propose actions to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means skills are horizontally arranged.</p> <p>For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy.  The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions.</p> <p>The framework places no limits on the complexity of skills. They can implement simple (e.g. <code>if-this-then-that</code>) or complex (e.g. a deep learning model or reinforcement learning agent).</p> <p>The framework provides one default skill, called <code>error</code>. Additional skills can be added as packages.</p>"},{"location":"aea-framework-documentation/skill/#independence-of-skills","title":"Independence of Skills","text":"<p>Skills are <code>horizontally layered</code>, that is they run independently of each other. They also cannot access each other's state.</p> <p>Two skills can communicate with each other in two ways. The skill context provides access via <code>self.context.shared_state</code> to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker.</p>"},{"location":"aea-framework-documentation/skill/#context","title":"Context","text":"<p>The skill has a <code>SkillContext</code> object which is shared by all <code>Handler</code>, <code>Behaviour</code>, and <code>Model</code> objects. The skill context also has a link to the <code>AgentContext</code>. The <code>AgentContext</code> provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the <code>OutBox</code>.</p> <p>This means it is possible to, at any point, grab the <code>context</code> and have access to the code in other parts of the skill and the AEA.</p> <p>For example, in the <code>ErrorHandler(Handler)</code> class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an <code>OutBox</code> for putting messages into.</p> <pre><code>self.context.outbox.put_message(message=reply)\n</code></pre> <p>Moreover, you can read/write to the agent context namespace by accessing the attribute <code>SkillContext.namespace</code>.</p> <p>Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the <code>DecisionMaker</code>.</p>"},{"location":"aea-framework-documentation/skill/#what-to-code","title":"What to Code","text":"<p>Each of the skill classes has three methods that must be implemented. All of them include a <code>setup()</code> and <code>teardown()</code> method which the developer must implement.</p> <p>Then there is a specific method that the framework requires for each class.</p>"},{"location":"aea-framework-documentation/skill/#handlerspy","title":"<code>handlers.py</code>","text":"<p>There can be none, one or more <code>Handler</code> class per skill.</p> <p><code>Handler</code> classes can receive <code>Message</code> objects of one protocol type only. However, <code>Handler</code> classes can send <code>Envelope</code> objects of any type of protocol they require.</p> <ul> <li><code>handle(self, message: Message)</code>: is where the skill receives a <code>Message</code> of the specified protocol and decides what to do with it.</li> </ul> <p>A handler can be registered in one way:</p> <ul> <li>By declaring it in the skill configuration file <code>skill.yaml</code> (see below).</li> </ul> <p>It is possible to register new handlers dynamically by enqueuing new <code>Handler</code> instances in the queue <code>context.new_handlers</code>, e.g. in a skill component we can write:</p> <pre><code>self.context.new_handlers.put(MyHandler(name=\"my_handler\", skill_context=self.context))\n</code></pre>"},{"location":"aea-framework-documentation/skill/#behaviourspy","title":"<code>behaviours.py</code>","text":"<p>Conceptually, a <code>Behaviour</code>  class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events.</p> <p>There can be one or more <code>Behaviour</code> classes per skill. The developer must create a subclass from the abstract class <code>Behaviour</code> to create a new <code>Behaviour</code>.</p> <ul> <li><code>act(self)</code>: is how the framework calls the <code>Behaviour</code> code.</li> </ul> <p>A behaviour can be registered in two ways:</p> <ul> <li>By declaring it in the skill configuration file <code>skill.yaml</code> (see below)</li> <li>In any part of the code of the skill, by enqueuing new <code>Behaviour</code> instances in the queue <code>context.new_behaviours</code>. In that case, <code>setup</code>is not called by the framework, as the behaviour will be added after the AEA setup is complete.</li> </ul> <p>The framework supports different types of behaviours:</p> <ul> <li><code>OneShotBehaviour</code>: this behaviour is executed only once.</li> <li><code>TickerBehaviour</code>: the <code>act()</code> method is called every <code>tick_interval</code>. E.g. if the <code>TickerBehaviour</code> subclass is instantiated</li> </ul> <p>There is another category of behaviours, called <code>CompositeBehaviour</code>:</p> <ul> <li><code>SequenceBehaviour</code>: a sequence of <code>Behaviour</code> classes, executed   one after the other.</li> <li><code>FSMBehaviour</code>: a state machine of <code>State</code> behaviours. A state is in charge of scheduling the next state.</li> </ul> <p>If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose <code>Behaviour</code> class.</p> <p>Follows an example of a custom behaviour:</p> <pre><code>from aea.skills.behaviours import OneShotBehaviour\nclass HelloWorldBehaviour(OneShotBehaviour):\ndef setup(self):\n\"\"\"This method is called once, when the behaviour gets loaded.\"\"\"\ndef act(self):\n\"\"\"This methods is called in every iteration of the agent main loop.\"\"\"\nprint(\"Hello, World!\")\ndef teardown(self):\n\"\"\"This method is called once, when the behaviour is teared down.\"\"\"\n</code></pre> <p>If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write:</p> <pre><code>self.context.new_behaviours.put(HelloWorldBehaviour(name=\"hello_world\", skill_context=self.context))\n</code></pre> <p>Or, equivalently to the previous two code blocks:</p> <pre><code>def hello():\nprint(\"Hello, World!\")\nself.context.new_behaviours.put(OneShotBehaviour(act=hello, name=\"hello_world\", skill_context=self.context))\n</code></pre> <p>The callable passed to the <code>act</code> parameter is equivalent to the implementation of the <code>act</code> method described above.</p> <p>The framework is then in charge of registering the behaviour and scheduling it for execution.</p>"},{"location":"aea-framework-documentation/skill/#taskspy","title":"<code>tasks.py</code>","text":"<p>Conceptually, a <code>Task</code> is where the developer codes any internal tasks the AEA requires.</p> <p>There can be one or more <code>Task</code> classes per skill. The developer subclasses abstract class <code>Task</code> to create a new <code>Task</code>.</p> <ul> <li><code>execute(self)</code>: is how the framework calls a <code>Task</code>.</li> </ul> <p>The <code>Task</code> class implements the functor pattern. An instance of the <code>Task</code> class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property <code>result</code>. Raises error if the task has not been executed yet, or an error occurred during computation.</p> <p>We suggest using the <code>task_manager</code>, accessible through the skill context, to manage long-running tasks. The task manager uses <code>multiprocessing</code> to schedule tasks, so be aware that the changes on the task object will not be updated.</p> <p>Here's an example:</p> <p>In <code>tasks.py</code>:</p> <pre><code>from aea.skills.tasks import Task\ndef nth_prime_number(n: int) -&gt; int:\n\"\"\"A naive algorithm to find the n_th prime number.\"\"\"\nassert n &gt; 0\nprimes = [2]\nnum = 3\nwhile len(primes) &lt; n:\nfor p in primes:\nif num % p == 0:\nbreak\nelse:\nprimes.append(num)\nnum += 2\nreturn primes[-1]\nclass LongTask(Task):\ndef setup(self):\n\"\"\"Set the task up before execution.\"\"\"\ndef execute(self, n: int):\nreturn nth_prime_number(n)\ndef teardown(self):\n\"\"\"Clean the task up after execution.\"\"\"\n</code></pre> <p>In <code>behaviours.py</code>:</p> <pre><code>from aea.skills.behaviours import TickerBehaviour\nfrom packages.my_author_name.skills.my_skill.tasks import LongTask\nclass MyBehaviour(TickerBehaviour):\ndef setup(self):\n\"\"\"Setup behaviour.\"\"\"\nmy_task = LongTask()\ntask_id = self.context.task_manager.enqueue_task(my_task, args=(10000, ))\nself.async_result = self.context.task_manager.get_task_result(task_id)  # type: multiprocessing.pool.AsyncResult\ndef act(self):\n\"\"\"Act implementation.\"\"\"\nif self.async_result.ready() is False:\nprint(\"The task is not finished yet.\")\nelse:\ncompleted_task = self.async_result.get()  # type: LongTask\nprint(\"The result is:\", completed_task.result)\n# Stop the skill\nself.context.is_active = False\ndef teardown(self):\n\"\"\"Teardown behaviour.\"\"\"\n</code></pre>"},{"location":"aea-framework-documentation/skill/#models","title":"Models","text":"<p>The developer might want to add other classes on the context level which are shared equally across the <code>Handler</code>, <code>Behaviour</code> and <code>Task</code> classes. To this end, the developer can subclass an abstract <code>Model</code>. These models are made available on the context level upon initialization of the AEA.</p> <p>Say, the developer has a class called <code>SomeModel</code></p> <pre><code>class SomeModel(Model):\n...\n</code></pre> <p>Then, an instance of this class is available on the context level like so:</p> <pre><code>some_model = self.context.some_model\n</code></pre>"},{"location":"aea-framework-documentation/skill/#skill-configuration","title":"Skill Configuration","text":"<p>Each skill has a <code>skill.yaml</code> configuration file which lists all <code>Behaviour</code>, <code>Handler</code>, and <code>Task</code> objects pertaining to the skill.</p> <p>It also details the protocol types used in the skill and points to shared modules, i.e. modules of type <code>Model</code>, which allow custom classes within the skill to be accessible in the skill context.</p> <pre><code>name: echo\nauthors: fetchai\nversion: 0.1.0\nlicense: Apache-2.0\nbehaviours:\necho:\nclass_name: EchoBehaviour\nargs:\ntick_interval: 1.0\nhandlers:\necho:\nclass_name: EchoHandler\nargs:\nfoo: bar\nmodels: {}\ndependencies: {}\nprotocols:\n- fetchai/default:1.1.7\n</code></pre>"},{"location":"aea-framework-documentation/skill/#error-skill","title":"Error Skill","text":"<p>All AEAs have a default <code>error</code> skill that contains error handling code for a number of scenarios:</p> <ul> <li>Received envelopes with unsupported protocols</li> <li>Received envelopes with unsupported skills (i.e. protocols for which no handler is registered)</li> <li>Envelopes with decoding errors</li> <li>Invalid messages with respect to the registered protocol</li> </ul> <p>The error skill relies on the <code>fetchai/default:1.0.0</code> protocol which provides error codes for the above.</p>"},{"location":"aea-framework-documentation/skill/#custom-error-handler","title":"Custom Error Handler","text":"<p>The framework implements a default <code>ErrorHandler</code>. You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom <code>ErrorHandler</code>:</p> <pre><code>aea scaffold error-handler\n</code></pre> <p>Now you will see a file called <code>error_handler.py</code> in the AEA project root. You can then implement your own custom logic to process messages.</p>"},{"location":"aea-framework-documentation/standalone-transaction/","title":"Create Stand-Alone Transaction","text":"<p>In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer</p> <p>This guide requires the <code>aea-ledger-fetchai</code> plug-in installed in your Python environment:</p> <pre><code>pip install aea-ledger-fetchai\n</code></pre> <p>First, import the python and application specific libraries and set the static variables.</p> <pre><code>import logging\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.crypto.helpers import create_private_key, try_generate_testnet_wealth\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.crypto.wallet import Wallet\nlogger = logging.getLogger(\"aea\")\nlogging.basicConfig(level=logging.INFO)\nFETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\"\nFETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\"\n</code></pre>"},{"location":"aea-framework-documentation/standalone-transaction/#create-the-private-keys","title":"Create the Private Keys","text":"<pre><code>    # Create a private keys\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_1\n)\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_2\n)\n</code></pre>"},{"location":"aea-framework-documentation/standalone-transaction/#create-the-wallets","title":"Create the Wallets","text":"<p>Once we created the private keys we need to generate the wallets.</p> <pre><code>    # Set up the wallets\nwallet_1 = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_1})\nwallet_2 = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_2})\n</code></pre>"},{"location":"aea-framework-documentation/standalone-transaction/#generate-wealth","title":"Generate Wealth","text":"<p>Since we want to send funds from <code>wallet_1</code> to <code>wallet_2</code>, we need to generate some wealth for the <code>wallet_1</code>. We can do this with the following code</p> <pre><code>    # Generate some wealth\ntry_generate_testnet_wealth(\nFetchAICrypto.identifier, wallet_1.addresses[FetchAICrypto.identifier]\n)\n</code></pre>"},{"location":"aea-framework-documentation/standalone-transaction/#send-transaction","title":"Send Transaction","text":"<p>Finally, we create a transaction that sends the funds to the <code>wallet_2</code></p> <pre><code>    # Create the transaction and send it to the ledger.\ntx_nonce = LedgerApis.generate_tx_nonce(\nFetchAICrypto.identifier,\nwallet_2.addresses.get(FetchAICrypto.identifier),\nwallet_1.addresses.get(FetchAICrypto.identifier),\n)\ntransaction = LedgerApis.get_transfer_transaction(\nidentifier=FetchAICrypto.identifier,\nsender_address=wallet_1.addresses.get(FetchAICrypto.identifier),\ndestination_address=wallet_2.addresses.get(FetchAICrypto.identifier),\namount=1,\ntx_fee=1,\ntx_nonce=tx_nonce,\n)\nsigned_transaction = wallet_1.sign_transaction(\nFetchAICrypto.identifier, transaction\n)\ntransaction_digest = LedgerApis.send_signed_transaction(\nFetchAICrypto.identifier, signed_transaction\n)\nlogger.info(\"Transaction complete.\")\nlogger.info(\"The transaction digest is {}\".format(transaction_digest))\n</code></pre> Stand-alone transaction full code: <pre><code>import logging\nfrom aea_ledger_fetchai import FetchAICrypto\nfrom aea.crypto.helpers import create_private_key, try_generate_testnet_wealth\nfrom aea.crypto.ledger_apis import LedgerApis\nfrom aea.crypto.wallet import Wallet\nlogger = logging.getLogger(\"aea\")\nlogging.basicConfig(level=logging.INFO)\nFETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\"\nFETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\"\ndef run():\n\"\"\"Run demo.\"\"\"\n# Create a private keys\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_1\n)\ncreate_private_key(\nFetchAICrypto.identifier, private_key_file=FETCHAI_PRIVATE_KEY_FILE_2\n)\n# Set up the wallets\nwallet_1 = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_1})\nwallet_2 = Wallet({FetchAICrypto.identifier: FETCHAI_PRIVATE_KEY_FILE_2})\n# Generate some wealth\ntry_generate_testnet_wealth(\nFetchAICrypto.identifier, wallet_1.addresses[FetchAICrypto.identifier]\n)\nlogger.info(\n\"Sending amount to {}\".format(wallet_2.addresses.get(FetchAICrypto.identifier))\n)\n# Create the transaction and send it to the ledger.\ntx_nonce = LedgerApis.generate_tx_nonce(\nFetchAICrypto.identifier,\nwallet_2.addresses.get(FetchAICrypto.identifier),\nwallet_1.addresses.get(FetchAICrypto.identifier),\n)\ntransaction = LedgerApis.get_transfer_transaction(\nidentifier=FetchAICrypto.identifier,\nsender_address=wallet_1.addresses.get(FetchAICrypto.identifier),\ndestination_address=wallet_2.addresses.get(FetchAICrypto.identifier),\namount=1,\ntx_fee=1,\ntx_nonce=tx_nonce,\n)\nsigned_transaction = wallet_1.sign_transaction(\nFetchAICrypto.identifier, transaction\n)\ntransaction_digest = LedgerApis.send_signed_transaction(\nFetchAICrypto.identifier, signed_transaction\n)\nlogger.info(\"Transaction complete.\")\nlogger.info(\"The transaction digest is {}\".format(transaction_digest))\nif __name__ == \"__main__\":\nrun()\n</code></pre>"},{"location":"aea-framework-documentation/step-one/","title":"Ways to Build an AEA","text":"<p>There are a number of ways to build an AEA:</p> <ul> <li>To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here.</li> <li>Using the CLI <code>aea fetch</code> command, pull in an already built project and run as is or extend it to your needs.</li> <li>The last option is to build an AEA programmatically as described here.</li> </ul> <p>Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides:</p> <ul> <li>the AEA vs Agents guide shows the difference between an agent and an AEA in code,</li> <li>the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.</li> </ul>"},{"location":"aea-framework-documentation/tac-skills-contract/","title":"TAC Skills Ledger-Based","text":"<p>The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game.</p> <p>There are two types of AEAs:</p> <ul> <li>The <code>tac_controller</code> which coordinates the game.</li> <li>The <code>tac_participant</code> AEAs which compete in the game. The <code>tac_participant</code> AEAs trade tokens with each other to maximize their utility.</li> </ul>"},{"location":"aea-framework-documentation/tac-skills-contract/#discussion","title":"Discussion","text":"<p>This demo shows how agents negotiate autonomously with each other while they pursue their goals by participating in the Trading Agents Competition (TAC). The demo can be run against Fetchai or Ethereum ledger. Transactions are validated on an ERC1155 smart contract on the Fetchai Dorado or a local Ganache Ethereum testnet.</p> <p>In the following video we discuss the framework and TAC in more detail:</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#communication","title":"Communication","text":"<p>There are two types of interactions:</p> <ul> <li>between the controller and participants (game management communication)</li> <li>between the participants (negotiations)</li> </ul>"},{"location":"aea-framework-documentation/tac-skills-contract/#registration-communication","title":"Registration Communication","text":"<p>This diagram shows the communication between the various entities during the registration phase.</p> <pre><code>    sequenceDiagram\n        participant Agent_2\n        participant Agent_1\n        participant Search\n        participant Controller\n\n        activate Search\n        activate Controller\n\n        Controller-&gt;&gt;Search: register_service\n        activate Agent_1\n        Agent_1-&gt;&gt;Search: search\n        Search--&gt;&gt;Agent_1: controller\n        Agent_1-&gt;&gt;Controller: register\n        activate Agent_2\n        Agent_2-&gt;&gt;Search: search\n        Search--&gt;&gt;Agent_2: controller\n        Agent_2-&gt;&gt;Controller: register\n        Controller-&gt;&gt;Agent_1: game_data\n        Controller-&gt;&gt;Agent_2: game_data\n\n        deactivate Agent_1\n        deactivate Agent_2\n        deactivate Search\n        deactivate Controller</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#transaction-communication","title":"Transaction Communication","text":"<p>This diagram shows the communication between two AEAs and a controller. In this case, we have a <code>Seller_Agent</code> which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the <code>Searching_Agent</code> which is set up to search for sellers.</p> <pre><code>    sequenceDiagram\n        participant Buyer_Agent\n        participant Seller_Agent\n        participant Search\n        participant Controller\n\n        activate Buyer_Agent\n        activate Seller_Agent\n        activate Search\n        activate Controller\n\n        Seller_Agent-&gt;&gt;Search: register_service\n        Buyer_Agent-&gt;&gt;Search: search\n        Search--&gt;&gt;Buyer_Agent: list_of_agents\n        Buyer_Agent-&gt;&gt;Seller_Agent: call_for_proposal\n        Seller_Agent-&gt;&gt;Buyer_Agent: proposal\n        Buyer_Agent-&gt;&gt;Seller_Agent: accept\n        Seller_Agent-&gt;&gt;Buyer_Agent: match_accept\n        Seller_Agent-&gt;&gt;Controller: transaction\n        Controller-&gt;&gt;Controller: transaction_execution\n        Controller-&gt;&gt;Seller_Agent: confirm_transaction\n        Controller-&gt;&gt;Buyer_Agent: confirm_transaction\n\n        deactivate Buyer_Agent\n        deactivate Seller_Agent\n        deactivate Search\n        deactivate Controller</code></pre> <p>In the above case, the proposal received contains a set of goods to sell and an associated price. The buyer AEA needs to determine if this is a good deal for them, and if so, it accepts.</p> <p>There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#preparation-instructions","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/tac-skills-contract/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#demo-instructions-fetchai","title":"Demo Instructions (Fetchai)","text":"<p>Follow this instruction to run TAC against the fetch.ai Dorado testnet.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#fetch-tac-controller-aea","title":"Fetch TAC Controller AEA","text":"<p>In the root directory, fetch the controller AEA:</p> <pre><code>aea fetch fetchai/tac_controller_contract:0.32.5\ncd tac_controller_contract\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the controller from scratch:</p> <pre><code>aea create tac_controller_contract\ncd tac_controller_contract\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_control_contract:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc\naea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#fetch-the-tac-participant-aeas","title":"Fetch the TAC Participant AEAs","text":"<p>In separate terminals, in the root directory, fetch at least two participants:</p> <pre><code>aea fetch fetchai/tac_participant_contract:0.22.5 --alias tac_participant_one\ncd tac_participant_one\naea install\naea build\ncd ..\naea fetch fetchai/tac_participant_contract:0.22.5 --alias tac_participant_two\ncd tac_participant_two\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>In a separate terminal, in the root directory, create at least two tac participant AEAs:</p> <pre><code>aea create tac_participant_one\naea create tac_participant_two\n</code></pre> <p>Build participant one:</p> <pre><code>cd tac_participant_one\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc\naea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool\naea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"'{public_key}'\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'''\naea install\naea build\n</code></pre> <p>Then, build participant two:</p> <pre><code>cd tac_participant_two\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc\naea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool\naea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"'{public_key}'\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'''\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#add-keys-for-all-aeas","title":"Add Keys for All AEAs","text":"<p>For every AEA in the competition (controller and participants):</p> <p>First generate and add a private key:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then create and add a separate private key for secure communication:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#update-the-game-parameters-in-the-controller","title":"Update the Game Parameters in the Controller","text":"<p>In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future):</p> <pre><code>aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time\naea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020  00:01'\n</code></pre> <p>To set the registration time, you may find handy the following command:</p> <pre><code>aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \"$(date -d \"5 minutes\" +'%d %m %Y %H:%M')\"\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#update-the-connection-parameters","title":"Update the Connection Parameters","text":"<p>Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller.</p> <p>First, retrieve controller's local ACN address by running the following in the controller agent's project terminal:</p> <pre><code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri\n</code></pre> <p>Then, in participant one, run this command (replace <code>SOME_ADDRESS</code> with the value you retrieved above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Do the same in participant two (beware of the different port numbers):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11002\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9002\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9002\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#fund-agents-accounts","title":"Fund Agents' Accounts","text":"<p>Retrieve the address of each agent (in each terminal):</p> <pre><code>aea get-address fetchai\n</code></pre> <p>Go to the Dorado block explorer and request some test tokens via <code>Get Funds</code>.</p> <p>To check the wealth of an AEA, use:</p> <pre><code>aea get-wealth fetchai\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#run-the-aeas","title":"Run the AEAs","text":"<p>First, launch the <code>tac_contract_controller</code> then the participants by executing the following from their respective terminals:</p> <pre><code>aea run\n</code></pre> <p>The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above):</p> <pre><code>aea launch tac_participant_one tac_participant_two\n</code></pre> <p>You may want to try <code>--multithreaded</code> option in order to run the agents in the same process.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#cleaning-up","title":"Cleaning up","text":"<p>When you're finished, delete your AEAs:</p> <pre><code>aea delete tac_controller_contract\naea delete tac_participant_one\naea delete tac_participant_two\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#demo-instructions-ethereum","title":"Demo Instructions (Ethereum)","text":"<p>Follow this instruction to run TAC against a local Ganache Ethereum test-net.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#create-tac-controller-aea","title":"Create TAC Controller AEA","text":"<p>In the root directory, fetch the controller AEA:</p> <pre><code>aea fetch fetchai/tac_controller_contract:0.32.5\ncd tac_controller_contract\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the controller from scratch:</p> <pre><code>aea create tac_controller_contract\ncd tac_controller_contract\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_control_contract:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger ethereum\naea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum\naea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#fetch-the-tac-participant-aeas_1","title":"Fetch the TAC Participant AEAs","text":"<p>In separate terminals, in the root directory, fetch at least two participants:</p> <pre><code>aea fetch fetchai/tac_participant_contract:0.22.5 --alias tac_participant_one\ncd tac_participant_one\naea install\naea build\ncd ..\naea fetch fetchai/tac_participant_contract:0.22.5 --alias tac_participant_two\ncd tac_participant_two\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>In a separate terminal, in the root directory, create at least two tac participant AEAs:</p> <pre><code>aea create tac_participant_one\naea create tac_participant_two\n</code></pre> <p>Build participant one:</p> <pre><code>cd tac_participant_one\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger ethereum\naea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum\naea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool\naea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"'{public_key}'\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'''\naea install\naea build\n</code></pre> <p>Then, build participant two:</p> <pre><code>cd tac_participant_two\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"},\n  \"aea-ledger-ethereum\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger ethereum\naea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum\naea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool\naea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/contract_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\\n'''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"'{public_key}'\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]'''\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#configure-the-agents-to-use-ethereum","title":"Configure the Agents to Use Ethereum","text":"<p>Run the following in every AEA's terminal:</p> <pre><code>aea config set agent.default_ledger ethereum\njson=$(printf '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2023-01-01\", \"not_before\": \"2022-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]')\naea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \"$json\"\naea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#add-keys-for-all-aeas_1","title":"Add Keys for All AEAs","text":"<p>For every AEA in the competition (controller and participants):</p> <p>First generate and add a private key:</p> <pre><code>aea generate-key ethereum\naea add-key ethereum ethereum_private_key.txt\n</code></pre> <p>Then create and add a separate private key for secure communication:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#update-the-game-parameters-in-the-controller_1","title":"Update the Game Parameters in the Controller","text":"<p>In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future):</p> <pre><code>aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time\naea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020  00:01'\n</code></pre> <p>To set the registration time, you may find handy the following command:</p> <pre><code>aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \"$(date -d \"5 minutes\" +'%d %m %Y %H:%M')\"\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#update-the-connection-parameters_1","title":"Update the Connection Parameters","text":"<p>Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller.</p> <p>First, retrieve controller's local ACN address by running the following in the controller agent's project terminal:</p> <pre><code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri\n</code></pre> <p>Then, in participant one, run this command (replace <code>SOME_ADDRESS</code> with the value you retrieved above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Do the same in participant two (beware of the different port numbers):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11002\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9002\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9002\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills-contract/#fund-agents-accounts_1","title":"Fund Agents' Accounts","text":"<p>Run a local Ganache Ethereum test-net with funds for the addresses of the three AEAs in this demo:</p> <pre><code>docker run -p 8545:8545 trufflesuite/ganache-cli:latest --verbose --gasPrice=0 --gasLimit=0x1fffffffffffff --account=\"$(cat tac_controller_contract/ethereum_private_key.txt),1000000000000000000000\" --account=\"$(cat tac_participant_one/ethereum_private_key.txt),1000000000000000000000\" --account=\"$(cat tac_participant_two/ethereum_private_key.txt),1000000000000000000000\"\n</code></pre> <p>To check the wealth of an AEA, use:</p> <pre><code>aea get-wealth ethereum\n</code></pre> <p>You should get <code>1000000000000000000000</code>.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#run-the-aeas_1","title":"Run the AEAs","text":"<p>First, launch the <code>tac_contract_controller</code> then the participants by executing the following from their respective terminals:</p> <pre><code>aea run\n</code></pre> <p>The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above):</p> <pre><code>aea launch tac_participant_one tac_participant_two\n</code></pre> <p>You may want to try <code>--multithreaded</code> option in order to run the agents in the same process.</p>"},{"location":"aea-framework-documentation/tac-skills-contract/#cleaning-up_1","title":"Cleaning up","text":"<p>When you're finished, delete your AEAs:</p> <pre><code>aea delete tac_controller_contract\naea delete tac_participant_one\naea delete tac_participant_two\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills/","title":"TAC Skills","text":"<p>The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game.</p> <p>There are two types of AEAs:</p> <ul> <li>The <code>tac_controller</code> which coordinates the game.</li> <li>The <code>tac_participant</code> AEAs which compete in the game. The <code>tac_participant</code> AEAs trade tokens with each other to maximize their utility.</li> </ul>"},{"location":"aea-framework-documentation/tac-skills/#discussion","title":"Discussion","text":"<p>The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller, responsible for calculating the revenue for each participant and checking if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger.</p>"},{"location":"aea-framework-documentation/tac-skills/#communication","title":"Communication","text":"<p>There are two types of interactions:</p> <ul> <li>between the participants and the controller, the game communication</li> <li>between the participants, the negotiation</li> </ul>"},{"location":"aea-framework-documentation/tac-skills/#registration-communication","title":"Registration Communication","text":"<p>This diagram shows the communication between the various entities during the registration phase.</p> <pre><code>    sequenceDiagram\n        participant Agent_2\n        participant Agent_1\n        participant Search\n        participant Controller\n\n        activate Search\n        activate Controller\n\n        Controller-&gt;&gt;Search: register_service\n        activate Agent_1\n        Agent_1-&gt;&gt;Search: search\n        Search--&gt;&gt;Agent_1: controller\n        Agent_1-&gt;&gt;Controller: register\n        activate Agent_2\n        Agent_2-&gt;&gt;Search: search\n        Search--&gt;&gt;Agent_2: controller\n        Agent_2-&gt;&gt;Controller: register\n        Controller-&gt;&gt;Controller: start_game\n        Controller-&gt;&gt;Agent_1: game_data\n        Controller-&gt;&gt;Agent_2: game_data\n\n        deactivate Agent_1\n        deactivate Agent_2\n        deactivate Search\n        deactivate Controller</code></pre>"},{"location":"aea-framework-documentation/tac-skills/#transaction-communication","title":"Transaction Communication","text":"<p>This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as <code>Seller_Agent</code>. We also have an AEA in the role of the buyer, referred to as <code>Buyer_Agent</code>. During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions.</p> <pre><code>    sequenceDiagram\n        participant Buyer_Agent\n        participant Seller_Agent\n        participant Search\n        participant Controller\n\n        activate Buyer_Agent\n        activate Seller_Agent\n        activate Search\n        activate Controller\n\n        Seller_Agent-&gt;&gt;Search: register_service\n        Buyer_Agent-&gt;&gt;Search: search\n        Search--&gt;&gt;Buyer_Agent: list_of_agents\n        Buyer_Agent-&gt;&gt;Seller_Agent: call_for_proposal\n        Seller_Agent-&gt;&gt;Buyer_Agent: proposal\n        Buyer_Agent-&gt;&gt;Seller_Agent: accept\n        Seller_Agent-&gt;&gt;Buyer_Agent: match_accept\n        Seller_Agent-&gt;&gt;Controller: transaction\n        Controller-&gt;&gt;Controller: transaction_execution\n        Controller-&gt;&gt;Seller_Agent: confirm_transaction\n        Controller-&gt;&gt;Buyer_Agent: confirm_transaction\n\n        deactivate Buyer_Agent\n        deactivate Seller_Agent\n        deactivate Search\n        deactivate Controller</code></pre> <p>In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts.</p> <p>There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.</p>"},{"location":"aea-framework-documentation/tac-skills/#option-1-aea-manager-approach","title":"Option 1: AEA Manager Approach","text":"<p>Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.</p>"},{"location":"aea-framework-documentation/tac-skills/#preparation-instructions","title":"Preparation Instructions","text":"<p>Install the AEA Manager.</p>"},{"location":"aea-framework-documentation/tac-skills/#demo-instructions","title":"Demo Instructions","text":"<p>The following steps assume you have launched the AEA Manager Desktop app.</p> <ol> <li> <p>Add a new AEA called <code>controller</code> with public id <code>fetchai/tac_controller:0.26.0</code>.</p> </li> <li> <p>Add another new AEA called <code>participant_1</code> with public id <code>fetchai/tac_participant:0.28.0</code>.</p> </li> <li> <p>Add another new AEA called <code>participant_2</code> with public id <code>fetchai/tac_participant:0.28.0</code>.</p> </li> <li> <p>Navigate to the settings of <code>controller</code> and under <code>components &gt; skill &gt;</code> <code>fetchai/fetchai/tac_controller:0.22.0</code> <code>&gt; models &gt; parameters &gt; args</code> update <code>registration_start_time</code> to the time you want TAC to begin (e.g. 2 minutes in the future)</p> </li> <li> <p>Run the <code>controller</code> AEA. Navigate to its logs and copy the multiaddress displayed. Stop the <code>controller</code>.</p> </li> <li> <p>Navigate to the settings of <code>participant_1</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}\n</code></pre> </li> <li> <p>Navigate to the settings of <code>participant_2</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11002\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9002\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9002\"\n}\n</code></pre> </li> <li> <p>You may add more participants by repeating steps 3 (with an updated name) and 6 (bumping the port numbers. See the difference between steps 5 and 6).</p> </li> <li> <p>Run the <code>controller</code>, then <code>participant_1</code> and <code>participant_2</code> (and any other participants you added).</p> </li> </ol> <p>In the <code>controller</code>'s log, you should see the details of the transactions participants submit as well as changes in their scores and holdings. In participants' logs, you should see the agents trading.</p>"},{"location":"aea-framework-documentation/tac-skills/#option-2-cli-approach","title":"Option 2: CLI Approach","text":"<p>Follow this approach when using the <code>aea</code> CLI.</p>"},{"location":"aea-framework-documentation/tac-skills/#preparation-instructions_1","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/tac-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/tac-skills/#demo-instructions_1","title":"Demo Instructions","text":""},{"location":"aea-framework-documentation/tac-skills/#create-tac-controller-aea","title":"Create TAC Controller AEA","text":"<p>In the root directory, fetch the controller AEA:</p> <pre><code>aea fetch fetchai/tac_controller:0.30.5\ncd tac_controller\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the controller from scratch:</p> <pre><code>aea create tac_controller\ncd tac_controller\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_control:0.25.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills/#create-the-tac-participant-aeas","title":"Create the TAC Participant AEAs","text":"<p>In a separate terminal, in the root directory, fetch at least two participants:</p> <pre><code>aea fetch fetchai/tac_participant:0.32.5 --alias tac_participant_one\ncd tac_participant_one\naea install\naea build\ncd ..\naea fetch fetchai/tac_participant:0.32.5 --alias tac_participant_two\ncd tac_participant_two\naea build\n</code></pre> Alternatively, create from scratch: <p>In a separate terminal, in the root directory, create at least two tac participant AEAs:</p> <pre><code>aea create tac_participant_one\naea create tac_participant_two\n</code></pre> <p>Build participant one:</p> <pre><code>cd tac_participant_one\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea install\naea build\n</code></pre> <p>Then, build participant two:</p> <pre><code>cd tac_participant_two\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/tac_participation:0.25.6\naea add skill fetchai/tac_negotiation:0.29.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set agent.default_ledger fetchai\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea config set --type dict agent.decision_maker_handler \\\n'{\n  \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\",\n  \"file_path\": null\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills/#add-keys-for-all-aeas","title":"Add Keys for All AEAs","text":"<p>Create the private key for the AEA for Fetch.ai <code>Dorado</code>:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills/#update-the-game-parameters-in-the-controller","title":"Update the Game Parameters in the Controller","text":"<p>Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future):</p> <pre><code>aea config get vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time\naea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time '01 01 2020  00:01'\n</code></pre> <p>To set the registration time, you may find handy the following command:</p> <pre><code>aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time \"$(date -d \"2 minutes\" +'%d %m %Y %H:%M')\"\n</code></pre>"},{"location":"aea-framework-documentation/tac-skills/#update-the-connection-parameters","title":"Update the Connection Parameters","text":"<p>Briefly run the controller AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.)</p> <p>Then, in the participant one, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>Do the same in participant two (beware of the different port numbers):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11002\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9002\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9002\"\n}'\n</code></pre> <p>This allows the TAC participants to connect to the same local agent communication network as the TAC controller.</p>"},{"location":"aea-framework-documentation/tac-skills/#run-the-aeas","title":"Run the AEAs","text":"<p>First, launch the <code>tac_controller</code>:</p> <pre><code>aea run\n</code></pre> <p>The CLI tool supports the launch of several agents at once.</p> <p>For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory:</p> <pre><code>aea launch tac_participant_one tac_participant_two\n</code></pre> <p>You may want to try <code>--multithreaded</code> option in order to run the agents in the same process.</p>"},{"location":"aea-framework-documentation/tac-skills/#cleaning-up","title":"Cleaning up","text":"<p>When you're finished, delete your AEAs:</p> <pre><code>aea delete tac_controller\naea delete tac_participant_one\naea delete tac_participant_two\n</code></pre>"},{"location":"aea-framework-documentation/tac/","title":"TAC External App","text":"<p>Note</p> <p>This app is no longer maintained.</p> <p>The original TAC has its own repo.</p> <p>Follow the instructions below to build and run the TAC demo.</p>"},{"location":"aea-framework-documentation/tac/#requirements","title":"Requirements","text":"<p>Make sure you are running Docker and Docker Compose.</p>"},{"location":"aea-framework-documentation/tac/#quick-start","title":"Quick Start","text":"<p>Clone the repo to include submodules.</p> <pre><code>git clone git@github.com:fetchai/agents-tac.git --recursive &amp;&amp; cd agents-tac\n</code></pre> <p>Check you have <code>pipenv</code>.</p> <pre><code>which pipenv\n</code></pre> <p>If you don't have it, install it. Instructions are here.</p> <p>Create and launch a virtual environment.</p> <pre><code>pipenv --python 3.7 &amp;&amp; pipenv shell\n</code></pre> <p>Install the dependencies.</p> <pre><code>pipenv install\n</code></pre> <p>Install the package.</p> <pre><code>python setup.py install\n</code></pre> <p>Run the launch script. This may take a while.</p> <pre><code>python scripts/launch.py\n</code></pre> <p>The Visdom server is now running.</p> <p>The controller GUI at http://localhost:8097 provides real time insights.</p> <p>In the Environment tab, make sure you have the <code>tac_controller</code> environment selected.</p> <p></p>"},{"location":"aea-framework-documentation/tac/#alternative-build-and-run","title":"Alternative Build and Run","text":"<p>In a new terminal window, clone the repo, build the sandbox, and launch it.</p> <pre><code>git clone git@github.com:fetchai/agents-tac.git --recursive &amp;&amp; cd agents-tac\npipenv --python 3.7 &amp;&amp; pipenv shell\npython setup.py install\ncd sandbox &amp;&amp; docker-compose build\ndocker-compose up\n</code></pre> <p>In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox.</p> <pre><code>pipenv shell\npython templates/v1/basic.py --name my_agent --dashboard\n</code></pre> <p>Click through to the controller GUI.</p>"},{"location":"aea-framework-documentation/tac/#possible-gotchas","title":"Possible Gotchas","text":"<p>Stop all running containers before restart.</p> <pre><code>docker stop $(docker ps -q)\n</code></pre> <p>To remove all images, run the following command.</p> <pre><code># mac\ndocker ps -q | xargs docker stop ; docker system prune -a\n</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/","title":"Thermometer Skills","text":"<p>The AEA thermometer skills demonstrate an interaction between two AEAs, one purchasing temperature data from the other.</p> <ul> <li>The provider of thermometer data (the <code>thermometer</code>).</li> <li>The buyer of thermometer data (the <code>thermometer_client</code>).</li> </ul>"},{"location":"aea-framework-documentation/thermometer-skills/#discussion","title":"Discussion","text":"<p>This demo aims to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests the data and will deliver it to the client upon payment. To keep the demo simple, we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, the ledger interaction is only for completing a transaction.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#communication","title":"Communication","text":"<p>This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client AEA.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Client_AEA\n        participant Thermometer_AEA\n        participant Blockchain\n\n        activate Client_AEA\n        activate Search\n        activate Thermometer_AEA\n        activate Blockchain\n\n        Thermometer_AEA-&gt;&gt;Search: register_service\n        Client_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Client_AEA: list_of_agents\n        Client_AEA-&gt;&gt;Thermometer_AEA: call_for_proposal\n        Thermometer_AEA-&gt;&gt;Client_AEA: propose\n        Client_AEA-&gt;&gt;Thermometer_AEA: accept\n        Thermometer_AEA-&gt;&gt;Client_AEA: match_accept\n        Client_AEA-&gt;&gt;Blockchain: transfer_funds\n        Client_AEA-&gt;&gt;Thermometer_AEA: send_transaction_hash\n        Thermometer_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Thermometer_AEA-&gt;&gt;Client_AEA: send_data\n\n        deactivate Client_AEA\n        deactivate Search\n        deactivate Thermometer_AEA\n        deactivate Blockchain</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/#option-1-aea-manager-approach","title":"Option 1: AEA Manager Approach","text":"<p>Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#preparation-instructions","title":"Preparation Instructions","text":"<p>Install the AEA Manager.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#demo-instructions","title":"Demo Instructions","text":"<p>The following steps assume you have launched the AEA Manager Desktop app.</p> <ol> <li> <p>Add a new AEA called <code>my_thermometer_aea</code> with public id <code>fetchai/thermometer_aea:0.30.5</code>.</p> </li> <li> <p>Add another new AEA called <code>my_thermometer_client</code> with public id <code>fetchai/thermometer_client:0.32.5</code>.</p> </li> <li> <p>Copy the address from the <code>my_thermometer_client</code> into your clip board. Then go to the Dorado block explorer and request some test tokens via <code>Get Funds</code>.</p> </li> <li> <p>Run the <code>my_thermometer_aea</code> AEA. Navigate to its logs and copy the multiaddress displayed.</p> </li> <li> <p>Navigate to the settings of the <code>my_thermometer_client</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}\n</code></pre> </li> <li> <p>Run the <code>my_thermometer_client</code>.</p> </li> </ol> <p>In the AEA's logs, you should see the agent trading successfully.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#option-2-cli-approach","title":"Option 2: CLI Approach","text":"<p>Follow this approach when using the <code>aea</code> CLI.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#preparation-instructions_1","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/thermometer-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#demo-instructions_1","title":"Demo Instructions","text":"<p>A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#create-thermometer-aea","title":"Create Thermometer AEA","text":"<p>First, fetch the thermometer AEA:</p> <pre><code>aea fetch fetchai/thermometer_aea:0.30.5 --alias my_thermometer_aea\ncd my_thermometer_aea\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the thermometer AEA from scratch:</p> <pre><code>aea create my_thermometer_aea\ncd my_thermometer_aea\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/thermometer:0.27.6\naea install\naea build\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/#create-thermometer-client","title":"Create Thermometer Client","text":"<p>Then, fetch the thermometer client AEA:</p> <pre><code>aea fetch fetchai/thermometer_client:0.32.5 --alias my_thermometer_client\ncd my_thermometer_client\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the thermometer client from scratch:</p> <pre><code>aea create my_thermometer_client\ncd my_thermometer_client\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/thermometer_client:0.26.6\naea install\naea build\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\n</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/#add-keys-for-the-thermometer-aea","title":"Add Keys for the Thermometer AEA","text":"<p>First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/#add-keys-and-generate-wealth-for-the-thermometer-client-aea","title":"Add Keys and Generate Wealth for the Thermometer Client AEA","text":"<p>The thermometer client needs to have some wealth to purchase the thermometer information.</p> <p>First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai <code>testnet</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/thermometer-skills/#run-both-aeas","title":"Run both AEAs","text":"<p>Run both AEAs from their respective terminals.</p> <p>First, run the thermometer AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA.</p> <p>Then, in the thermometer client, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA.</p> <p>Then run the thermometer client AEA:</p> <pre><code>aea run\n</code></pre> <p>You can see that the AEAs find each other, negotiate and eventually trade.</p>"},{"location":"aea-framework-documentation/thermometer-skills/#cleaning-up","title":"Cleaning up","text":"<p>When you're done, go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete my_thermometer_aea\naea delete my_thermometer_client\n</code></pre>"},{"location":"aea-framework-documentation/trust/","title":"Trust Minimisation","text":"<p>AEA applications have different requirements for trustlessness or trust minimisation.</p> <p>For example, using the AEA weather skills demo without ledger payments means that the client has to trust the weather station to send the weather data it purchased and that this data is in fact valid. Similarly, the weather station must trust that the client somehow sends the payment amount to which they agreed.</p> <p>A step-up, if you run the weather skills demo with a ledger (e.g. Fetch.ai or Ethereum) then the client must still trust that the weather station sends valid data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the client for payment and can verify whether the transactions take place on the public ledger.</p> <p>We can further minimise trust requirements by incorporating a third party as an arbitrator or escrow implemented in a smart contract to further reduce trust requirements. However, in the current weather skills demo, there are limits to trustlessness as the station ultimately offers unverifiable data.</p> <p>Another example of minimising trust, is applications with (non-fungible) token transactions involving atomic swaps where trustlessness is clearly satisfied (e.g. in the TAC demo).</p>"},{"location":"aea-framework-documentation/upgrading/","title":"Upgrading","text":"<p>This page provides some tips on how to upgrade AEA projects between different versions of the AEA framework. For full release notes check the AEA repo.</p> <p>The primary tool for upgrading AEA projects is the <code>aea upgrade</code> command in the CLI.</p> <p>Below we describe the additional manual steps required to upgrade between different versions:</p>"},{"location":"aea-framework-documentation/upgrading/#v122-to-v123","title":"<code>v1.2.2</code> to <code>v1.2.3</code>","text":"<p>Ensure you update the plugins to their latest version (all plugins are changed in this release)</p> <p>Update the packages to the latest versions (especially protocols).</p> <p>Update development environment</p>"},{"location":"aea-framework-documentation/upgrading/#v120-to-v122","title":"<code>v1.2.0</code> to <code>v1.2.2</code>","text":"<p>Ensure you update the plugins to their latest version (all plugins are changed in this release)</p> <p>Update the packages to the latest versions (especially protocols).</p> <p>Regenerate your own written protocols (protocol generator was updated)</p>"},{"location":"aea-framework-documentation/upgrading/#v111-to-v120","title":"<code>v1.1.1</code> to <code>v1.2.0</code>","text":"<p>Ensure you update the plugins to their latest version (fetchai and cosmos plugins are changed in this release)</p> <p>Update the packages to the latest versions (especially p2p_libp2p related packages are updated)</p> <p>Check packages\u2019 and agents\u2019 configurations are correct (e.g. the fetchai test-net name is changed for the Dorado network)</p>"},{"location":"aea-framework-documentation/upgrading/#v110-to-v111","title":"<code>v1.1.0</code> to <code>v1.1.1</code>","text":"<p>No backwards incompatible changes.</p> <p>Upgrade fetchai/p2p_libp2p connection package to the latest version which fixes a slow DHT lookup problem</p> <p>We advise everyone to upgrade their <code>fetchai</code> packages and plugins to get the latest fixes.</p>"},{"location":"aea-framework-documentation/upgrading/#v102-to-v110","title":"<code>v1.0.2</code> to <code>v1.1.0</code>","text":"<p>No backwards incompatible changes.</p> <p>We advise everyone to upgrade their <code>fetchai</code> packages and plugins to get the latest fixes.</p>"},{"location":"aea-framework-documentation/upgrading/#v101-to-v102","title":"<code>v1.0.1</code> to <code>v1.0.2</code>","text":"<p>No backwards incompatible changes.</p> <p>We advise everyone to upgrade their <code>fetchai</code> packages and plugins to get the latest fixes.</p>"},{"location":"aea-framework-documentation/upgrading/#v100-to-v101","title":"<code>v1.0.0</code> to <code>v1.0.1</code>","text":"<p>No backwards incompatible changes.</p> <p>We advise everyone to upgrade their <code>fetchai</code> packages to get the latest fixes.</p>"},{"location":"aea-framework-documentation/upgrading/#v100rc2-to-v100","title":"<code>v1.0.0rc2</code> to <code>v1.0.0</code>","text":"<p>No backwards incompatible changes to component development.</p> <p>We advise everyone to upgrade to <code>v1</code> as soon as possible. When upgrading from versions below <code>v1.0.0rc1</code> first upgrade to the first release candidate, then to <code>v1</code>.</p>"},{"location":"aea-framework-documentation/upgrading/#v100rc1-to-v100rc2","title":"<code>v1.0.0rc1</code> to <code>v1.0.0rc2</code>","text":"<p>No backwards incompatible changes to component development.</p> <p>Various configuration changes introduced in <code>v1.0.0rc1</code> are now enforced strictly.</p>"},{"location":"aea-framework-documentation/upgrading/#v0111-to-v100rc1","title":"<code>v0.11.1</code> to <code>v1.0.0rc1</code>","text":"<p>No backwards incompatible changes to component development.</p> <p>The <code>aea-config.yaml</code> now requires the field <code>required_ledgers</code> which must specify all ledgers for which private keys are required to run the agent. Please add it to your project.</p> <p>The <code>registry_path</code> field has been removed from the <code>aea-config.yaml</code>. Please remove it from your project.</p> <p>All packages provided by author <code>fetchai</code> must be upgraded.</p>"},{"location":"aea-framework-documentation/upgrading/#v0110-to-v0111","title":"<code>v0.11.0</code> to <code>v0.11.1</code>","text":"<p>No backwards incompatible changes.</p>"},{"location":"aea-framework-documentation/upgrading/#v0101-to-v0110","title":"<code>v0.10.1</code> to <code>v0.11.0</code>","text":"<p>Take special care when upgrading to <code>v0.11.0</code>. We introduced several breaking changes in preparation for <code>v1</code>!</p>"},{"location":"aea-framework-documentation/upgrading/#cli-gui","title":"CLI GUI","text":"<p>We removed the CLI GUI. It was not used by anyone as far as we know and needs to be significantly improved. Soon we will release the AEA Manager App to make up for this.</p>"},{"location":"aea-framework-documentation/upgrading/#message-routing","title":"Message Routing","text":"<p>Routing has been completely revised and simplified. The new message routing logic is described here.</p> <p>When upgrading take the following steps:</p> <ul> <li> <p>For agent-to-agent communication: ensure the default routing and default connection are correctly defined and that the dialogues used specify the agent's address as the <code>self_address</code>. This is most likely already the case. Only in some edge cases will you need to use an <code>EnvelopeContext</code> to target a connection different from the one specified in the <code>default_routing</code> map.</p> </li> <li> <p>For component-to-component communication: there is now only one single way to route component to component (skill to skill, skill to connection, connection to skill) messages, this is by specifying the component id in string form in the <code>sender</code>/<code>to</code> field. The <code>EnvelopeContext</code> can no longer be used, messages are routed based on their target (<code>to</code> field). Ensure that dialogues in skills set the <code>skill_id</code> as the <code>self_address</code> (in connections they need to set the <code>connection_id</code>).</p> </li> </ul>"},{"location":"aea-framework-documentation/upgrading/#agent-configuration-and-ledger-plugins","title":"Agent Configuration and Ledger Plugins","text":"<p>Agent configuration files have a new optional field, <code>dependencies</code>,  analogous to <code>dependencies</code> field in other AEA packages. The default value is the empty object <code>{}</code>. The field will be made mandatory in the next release.</p> <p>Crypto modules have been extracted and released as independent plug-ins, released on PyPI. In particular:</p> <ul> <li>Fetch.ai crypto classes have been released in the <code>aea-ledger-fetchai</code> package;</li> <li>Ethereum crypto classes have been released in the <code>aea-ledger-ethereum</code> package;</li> <li>Cosmos crypto classes have been released in the <code>aea-ledger-cosmos</code> package.</li> </ul> <p>If an AEA project, or an AEA package, makes use of crypto functionalities, it will be needed to add the above packages as PyPI dependencies with version specifiers ranging from the latest minor and the latest minor + 1 (excluded). E.g. if the latest version if <code>0.1.0</code>, the version specifier should be <code>&lt;0.2.0,&gt;=0.1.0</code>:</p> <pre><code>dependencies:\naea-ledger-cosmos:\nversion: &lt;2.0.0,&gt;=1.0.0\naea-ledger-ethereum:\nversion: &lt;2.0.0,&gt;=1.0.0\naea-ledger-fetchai:\nversion: &lt;2.0.0,&gt;=1.0.0\n</code></pre> <p>The version specifier sets are important, as these plug-ins, at version <code>0.1.0</code>, depend on a specific range of the <code>aea</code> package.</p> <p>Then, running <code>aea install</code> inside the AEA project should install them in the current Python environment.</p> <p>For more, read the guide on ledger plugins.</p>"},{"location":"aea-framework-documentation/upgrading/#v0100-to-v0101","title":"<code>v0.10.0</code> to <code>v0.10.1</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v092-to-v0100","title":"<code>v0.9.2</code> to <code>v0.10.0</code>","text":"<p>Skill development sees no backward incompatible changes.</p> <p>Connection development requires updating the keyword arguments of the constructor: the new <code>data_dir</code> argument must be defined.</p> <p>Protocol specifications now need to contain a <code>protocol_specification_id</code> in addition to the public id. The <code>protocol_specification_id</code> is used for identifying Envelopes during transport. By being able to set the id independently of the protocol id, backwards compatibility in the specification (and therefore wire format) can be maintained even when the Python implementation changes.</p> <p>Please update to the latest packages by running <code>aea upgrade</code> and then re-generating your own protocols.</p>"},{"location":"aea-framework-documentation/upgrading/#v091-to-v092","title":"<code>v0.9.1</code> to <code>v0.9.2</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v090-to-v091","title":"<code>v0.9.0</code> to <code>v0.9.1</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v080-to-v090","title":"<code>v0.8.0</code> to <code>v0.9.0</code>","text":"<p>This release introduces proof of representation in the ACN. You will need to upgrade to the latest <code>fetchai/p2p_libp2p</code> or <code>fetchai/p2p_libp2p_client</code> connection and then use two key pairs, one for your AEA's decision maker and one for the connection.</p> <p>Please update to the latest packages by running <code>aea upgrade</code>.</p>"},{"location":"aea-framework-documentation/upgrading/#v075-to-v080","title":"<code>v0.7.5</code> to <code>v0.8.0</code>","text":"<p>Minimal backwards incompatible changes for skill and connection development:</p> <ul> <li>The semantics of the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> relations in <code>ConstraintTypes</code> are simplified.</li> <li>Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid.</li> </ul> <p>Please update to the latest packages by running <code>aea upgrade</code>.</p>"},{"location":"aea-framework-documentation/upgrading/#v074-to-v075","title":"<code>v0.7.4</code> to <code>v0.7.5</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v073-to-v074","title":"<code>v0.7.3</code> to <code>v0.7.4</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v072-to-v073","title":"<code>v0.7.2</code> to <code>v0.7.3</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v071-to-v072","title":"<code>v0.7.1</code> to <code>v0.7.2</code>","text":"<p>No backwards incompatible changes for skill and connection development.</p>"},{"location":"aea-framework-documentation/upgrading/#v070-to-v071","title":"<code>v0.7.0</code> to <code>v0.7.1</code>","text":"<p>To improve performance, in particular optimize memory usage, we refactored the <code>Message</code> and <code>Dialogue</code> classes. This means all protocols need to be bumped to the latest version or regenerated using the <code>aea generate protocol</code> command in the CLI.</p>"},{"location":"aea-framework-documentation/upgrading/#v063-to-v070","title":"<code>v0.6.3</code> to <code>v0.7.0</code>","text":"<p>Multiple breaking changes require action in this order:</p> <ul> <li> <p>Custom configuration overrides in <code>aea-config.yaml</code> are now identified via <code>public_id</code> rather than <code>author</code>, <code>name</code> and <code>version</code> individually. Please replace the three fields with the equivalent <code>public_id</code>.</p> </li> <li> <p>Run <code>aea upgrade</code> command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under <code>default_routing</code> and <code>default_connection</code> in <code>aea-config.yaml</code> as well as the public ids in the non-vendor packages.</p> </li> <li> <p>Previously, connection <code>fetchai/stub</code>, skill <code>fetchai/error</code> and protocols <code>fetchai/default</code>, <code>fetchai/signing</code> and <code>fetchai/state_update</code> where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with <code>aea create</code> then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows:</p> <ul> <li><code>aea.connections.stub</code> &gt; <code>packages.fetchai.connections.stub</code></li> <li><code>aea.protocols.default</code> &gt; <code>packages.fetchai.protocols.default</code></li> <li><code>aea.protocols.signing</code> &gt; <code>packages.fetchai.protocols.signing</code></li> <li><code>aea.protocols.state_update</code> &gt; <code>packages.fetchai.protocols.state_update</code></li> <li><code>aea.skills.error</code> &gt; <code>packages.fetchai.skills.error</code></li> </ul> </li> <li> <p>If you use custom protocols, regenerate them.</p> </li> <li> <p>In your own skills' <code>__init__.py</code> files add the public id (updating the string as appropriate):</p> </li> </ul> <pre><code>from aea.configurations.base import PublicId\nPUBLIC_ID = PublicId.from_str(\"author/name:0.1.0\")\n</code></pre> <ul> <li> <p>The <code>fetchai/http</code> protocol's <code>bodyy</code> field has been renamed to <code>body</code>.</p> </li> <li> <p>Skills can now specify <code>connections</code> as dependencies in the configuration YAML.</p> </li> </ul>"},{"location":"aea-framework-documentation/upgrading/#v062-to-v063","title":"<code>v0.6.2</code> to <code>v0.6.3</code>","text":"<p>A new <code>upgrade</code> command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run <code>aea upgrade</code>. The project's vendor dependencies will be updated where possible.</p>"},{"location":"aea-framework-documentation/upgrading/#v061-to-v062","title":"<code>v0.6.1</code> to <code>v0.6.2</code>","text":"<p>No public APIs have been changed.</p>"},{"location":"aea-framework-documentation/upgrading/#v060-to-v061","title":"<code>v0.6.0</code> to <code>v0.6.1</code>","text":"<p>The <code>soef</code> connection and <code>oef_search</code> protocol have backward incompatible changes.</p>"},{"location":"aea-framework-documentation/upgrading/#v054-to-v060","title":"<code>v0.5.4</code> to <code>v0.6.0</code>","text":""},{"location":"aea-framework-documentation/upgrading/#dialogue-and-dialogues-api-updates","title":"<code>Dialogue</code> and <code>Dialogues</code> API Updates","text":"<p>The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer:</p> <ul> <li><code>Dialogues.create</code>: this method is used to create a new dialogue and message:</li> </ul> <pre><code>cfp_msg, fipa_dialogue = fipa_dialogues.create(\ncounterparty=opponent_address,\nperformative=FipaMessage.Performative.CFP,\nquery=query,\n)\n</code></pre> <p>The method will raise if the provided arguments are inconsistent.</p> <ul> <li><code>Dialogues.create_with_message</code>: this method is used to create a new dialogue from a message:</li> </ul> <pre><code>fipa_dialogue = fipa_dialogues.create_with_message(\ncounterparty=opponent_address,\ninitial_message=cfp_msg\n)\n</code></pre> <p>The method will raise if the provided arguments are inconsistent.</p> <ul> <li><code>Dialogues.update</code>: this method is used to handle messages passed by the framework:</li> </ul> <pre><code>fipa_dialogue = fipa_dialogues.update(\nmessage=cfp_msg\n)\n</code></pre> <p>The method will return a valid dialogue if it is a valid message, otherwise it will return <code>None</code>.</p> <ul> <li><code>Dialogue.reply</code>: this method is used to reply within a dialogue:</li> </ul> <pre><code>proposal_msg = fipa_dialogue.reply(\nperformative=FipaMessage.Performative.PROPOSE,\ntarget_message=cfp_msg,\nproposal=proposal,\n)\n</code></pre> <p>The method will raise if the provided arguments are inconsistent.</p> <p>The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages.</p>"},{"location":"aea-framework-documentation/upgrading/#fetchaicrypto-default-crypto","title":"<code>FetchAICrypto</code> - Default Crypto","text":"<p>The <code>FetchAICrypto</code> has been upgraded to the default crypto. Update your <code>default_ledger</code> to <code>fetchai</code>.</p>"},{"location":"aea-framework-documentation/upgrading/#private-key-file-naming","title":"Private Key File Naming","text":"<p>The private key files are now consistently named with the <code>ledger_id</code> followed by <code>_private_key.txt</code> (e.g. <code>fetchai_private_key.txt</code>). Rename your existing files to match this pattern.</p>"},{"location":"aea-framework-documentation/upgrading/#type-in-package-yaml","title":"Type in Package YAML","text":"<p>The package YAML files now contain a type field. This must be added for the loading mechanism to work properly.</p>"},{"location":"aea-framework-documentation/upgrading/#moved-address-type","title":"Moved Address Type","text":"<p>The address type has moved to <code>aea.common</code>. The import paths must be updated.</p>"},{"location":"aea-framework-documentation/upgrading/#v053-to-v054","title":"<code>v0.5.3</code> to <code>v0.5.4</code>","text":"<p>The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly.</p> <p>The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail.</p>"},{"location":"aea-framework-documentation/upgrading/#v052-to-v053","title":"<code>v0.5.2</code> to <code>v0.5.3</code>","text":"<p>Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly.</p> <p>Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail.</p>"},{"location":"aea-framework-documentation/upgrading/#v051-to-052","title":"<code>v0.5.1</code> to <code>0.5.2</code>","text":"<p>No public APIs have been changed.</p>"},{"location":"aea-framework-documentation/upgrading/#v050-to-051","title":"<code>v0.5.0</code> to <code>0.5.1</code>","text":"<p>No public APIs have been changed.</p>"},{"location":"aea-framework-documentation/upgrading/#v041-to-050","title":"<code>v0.4.1</code> to <code>0.5.0</code>","text":"<p>A number of breaking changes where introduced which make backwards compatibility of skills rare.</p> <ul> <li>Ledger APIs <code>LedgerApis</code> have been removed from the AEA constructor and skill context. <code>LedgerApis</code> are now exposed in the <code>LedgerConnection</code> (<code>fetchai/ledger</code>). To communicate with the <code>LedgerApis</code> use the <code>fetchai/ledger_api</code> protocol. This allows for more flexibility (anyone can add another <code>LedgerAPI</code> to the registry and execute it with the connection) and removes dependencies from the core framework.</li> <li>Skills can now depend on other skills. As a result, skills have a new required configuration field in <code>skill.yaml</code> files, by default empty: <code>skills: []</code>.</li> </ul>"},{"location":"aea-framework-documentation/upgrading/#v040-to-v041","title":"<code>v0.4.0</code> to <code>v0.4.1</code>","text":"<p>There are no upgrade requirements if you use the CLI based approach to AEA development.</p> <p>Connections are now added via <code>Resources</code> to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources.</p>"},{"location":"aea-framework-documentation/upgrading/#v033-to-v040","title":"<code>v0.3.3</code> to <code>v0.4.0</code>","text":"<ul> <li> <p>Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope:</p> <pre><code>cfp_msg = FipaMessage(...)\nself.context.outbox.put_message(\nto=opponent_addr,\nsender=self.context.agent_address,\nprotocol_id=FipaMessage.protocol_id,\nmessage=FipaSerializer().encode(cfp_msg),\n)\n# or\ncfp_msg = FipaMessage(...)\nenvelope = Envelope(\nto=opponent_addr,\nsender=self.context.agent_address,\nprotocol_id=FipaMessage.protocol_id,\nmessage=FipaSerializer().encode(cfp_msg),\n)\nself.context.outbox.put(envelope)\n</code></pre> <p>Now this has been simplified to:</p> <pre><code>cfp_msg = FipaMessage(...)\ncfp_msg.counterparty = opponent_addr\nself.context.outbox.put_message(message=cfp_msg)\n</code></pre> <p>You must update your skills as the old implementation is no longer supported.</p> </li> <li> <p>Connection constructors have been simplified. In the past you had to implement both the <code>__init__</code> as well as the <code>from_config</code> methods of a Connection. Now you only have to implement the <code>__init__</code> method which by default at load time now receives the following keyword arguments: <code>configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore</code>. See for example in the scaffold connection:</p> <pre><code>class MyScaffoldConnection(Connection):\n\"\"\"Proxy to the functionality of the SDK or API.\"\"\"\nconnection_id = PublicId.from_str(\"fetchai/scaffold:0.1.0\")\ndef __init__(\nself,\nconfiguration: ConnectionConfig,\nidentity: Identity,\ncrypto_store: CryptoStore,\n):\n\"\"\"\n        Initialize a connection to an SDK or API.\n        :param configuration: the connection configuration.\n        :param crypto_store: object to access the connection crypto objects.\n        :param identity: the identity object.\n        \"\"\"\nsuper().__init__(\nconfiguration=configuration, crypto_store=crypto_store, identity=identity\n)\n</code></pre> <p>As a result of this feature, you are now able to pass key-pairs to your connections via the <code>CryptoStore</code>.</p> <p>You must update your connections as the old implementation is no longer supported.</p> </li> </ul>"},{"location":"aea-framework-documentation/wealth/","title":"Generating Wealth","text":"<p>To fund an AEA for testing on a test-net you need to request some test tokens from a faucet.</p> <p>First, make sure you have installed the crypto plugin of the target test-net. E.g. for Fetch.AI:</p> <pre><code>pip install aea-ledger-fetchai\n</code></pre> <p>And for Ethereum:</p> <pre><code>pip install aea-ledger-ethereum\n</code></pre> <p>Add a private key to the agent</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>or</p> <pre><code>aea generate-key ethereum\naea add-key ethereum ethereum_private_key.txt\n</code></pre> <p>Note</p> <p>If you already have keys in your project, the commands prompt you to confirm whether to replace the existing keys.</p>"},{"location":"aea-framework-documentation/wealth/#using-a-faucet-website","title":"Using a Faucet Website","text":"<p>First, print the address:</p> <pre><code>aea get-address fetchai\n</code></pre> <p>or</p> <pre><code>aea get-address ethereum\n</code></pre> <p>This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum. It will take a while for the tokens to become available.</p> <p>Second, after some time, check the wealth associated with the address:</p> <pre><code>aea get-wealth fetchai\n</code></pre> <p>or</p> <pre><code>aea get-wealth ethereum\n</code></pre>"},{"location":"aea-framework-documentation/wealth/#using-the-cli","title":"Using the CLI","text":"<p>Simply generate wealth via the CLI:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>or</p> <pre><code>aea generate-wealth ethereum\n</code></pre> <p>Note</p> <p>This approach can be unreliable for non-fetchai test nets.</p>"},{"location":"aea-framework-documentation/weather-skills/","title":"Weather Skills","text":"<p>The AEA weather skills demonstrate an interaction between two AEAs.</p> <ul> <li>The provider of weather data (the <code>weather_station</code>).</li> <li>The buyer of weather data (the <code>weather_client</code>).</li> </ul>"},{"location":"aea-framework-documentation/weather-skills/#discussion","title":"Discussion","text":"<p>The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The <code>weather_station</code> AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction.</p> <p>You can use this AEA as an example of how to read data from a database and advertise these to possible clients.  </p>"},{"location":"aea-framework-documentation/weather-skills/#communication","title":"Communication","text":"<p>This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client.</p> <pre><code>    sequenceDiagram\n        participant Search\n        participant Client_AEA\n        participant Weather_AEA\n        participant Blockchain\n\n        activate Client_AEA\n        activate Search\n        activate Weather_AEA\n        activate Blockchain\n\n        Weather_AEA-&gt;&gt;Search: register_service\n        Client_AEA-&gt;&gt;Search: search\n        Search--&gt;&gt;Client_AEA: list_of_agents\n        Client_AEA-&gt;&gt;Weather_AEA: call_for_proposal\n        Weather_AEA-&gt;&gt;Client_AEA: propose\n        Client_AEA-&gt;&gt;Weather_AEA: accept\n        Weather_AEA-&gt;&gt;Client_AEA: match_accept\n        Client_AEA-&gt;&gt;Blockchain: transfer_funds\n        Client_AEA-&gt;&gt;Weather_AEA: send_transaction_hash\n        Weather_AEA-&gt;&gt;Blockchain: check_transaction_status\n        Weather_AEA-&gt;&gt;Client_AEA: send_data\n\n        deactivate Client_AEA\n        deactivate Search\n        deactivate Weather_AEA\n        deactivate Blockchain  </code></pre>"},{"location":"aea-framework-documentation/weather-skills/#option-1-aea-manager-approach","title":"Option 1: AEA Manager Approach","text":"<p>Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.</p>"},{"location":"aea-framework-documentation/weather-skills/#preparation-instructions","title":"Preparation Instructions","text":"<p>Install the AEA Manager.</p>"},{"location":"aea-framework-documentation/weather-skills/#demo-instructions","title":"Demo Instructions","text":"<p>The following steps assume you have launched the AEA Manager Desktop app.</p> <ol> <li> <p>Add a new AEA called <code>my_weather_station</code> with public id <code>fetchai/weather_station:0.32.5</code>.</p> </li> <li> <p>Add another new AEA called <code>my_weather_client</code> with public id <code>fetchai/weather_client:0.33.5</code>.</p> </li> <li> <p>Copy the address from the <code>my_weather_client</code> into your clip board. Then go to the Dorado block explorer and request some test tokens via <code>Get Funds</code>.</p> </li> <li> <p>Run the <code>my_weather_station</code> AEA. Navigate to its logs and copy the multiaddress displayed.</p> </li> <li> <p>Navigate to the settings of the <code>my_weather_client</code> and under <code>components &gt; connection &gt;</code> <code>fetchai/p2p_libp2p:0.22.0</code> update as follows (make sure to replace the placeholder with the multiaddress):</p> <pre><code>{\n\"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"REPLACE_WITH_MULTI_ADDRESS_HERE\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}\n</code></pre> </li> <li> <p>Run the <code>my_weather_client</code>.</p> </li> </ol> <p>In the AEA's logs, you should see the agent trading successfully.</p>"},{"location":"aea-framework-documentation/weather-skills/#option-2-cli-approach","title":"Option 2: CLI Approach","text":"<p>Follow this approach when using the <code>aea</code> CLI.</p>"},{"location":"aea-framework-documentation/weather-skills/#preparation-instructions_1","title":"Preparation Instructions","text":""},{"location":"aea-framework-documentation/weather-skills/#dependencies","title":"Dependencies","text":"<p>Follow the Preliminaries and Installation sections from the AEA quick start.</p>"},{"location":"aea-framework-documentation/weather-skills/#demo-instructions_1","title":"Demo Instructions","text":"<p>A demo to run the same scenario but with a true ledger transaction on Fetch.ai <code>testnet</code> or Ethereum <code>ropsten</code> network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.</p>"},{"location":"aea-framework-documentation/weather-skills/#create-the-weather-station","title":"Create the Weather Station","text":"<p>First, fetch the AEA that will provide weather measurements:</p> <pre><code>aea fetch fetchai/weather_station:0.32.5 --alias my_weather_station\ncd my_weather_station\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the weather station from scratch:</p> <pre><code>aea create my_weather_station\ncd my_weather_station\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/weather_station:0.27.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/weather-skills/#create-the-weather-client","title":"Create the Weather Client","text":"<p>In another terminal, fetch the AEA that will query the weather station:</p> <pre><code>aea fetch fetchai/weather_client:0.33.5 --alias my_weather_client\ncd my_weather_client\naea install\naea build\n</code></pre> Alternatively, create from scratch: <p>The following steps create the weather client from scratch:</p> <pre><code>aea create my_weather_client\ncd my_weather_client\naea add connection fetchai/p2p_libp2p:0.27.5\naea add connection fetchai/soef:0.27.6\naea add connection fetchai/ledger:0.21.5\naea add skill fetchai/weather_client:0.26.6\naea config set --type dict agent.dependencies \\\n'{\n  \"aea-ledger-fetchai\": {\"version\": \"&lt;2.0.0,&gt;=1.0.0\"}\n}'\naea config set agent.default_connection fetchai/p2p_libp2p:0.27.5\naea config set --type dict agent.default_routing \\\n'{\n  \"fetchai/ledger_api:1.1.7\": \"fetchai/ledger:0.21.5\",\n  \"fetchai/oef_search:1.1.7\": \"fetchai/soef:0.27.6\"\n}'\naea install\naea build\n</code></pre>"},{"location":"aea-framework-documentation/weather-skills/#add-keys-for-the-weather-station-aea","title":"Add Keys for the Weather Station AEA","text":"<p>First, create the private key for the weather station AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/weather-skills/#add-keys-and-generate-wealth-for-the-weather-client-aea","title":"Add Keys and Generate Wealth for the Weather Client AEA","text":"<p>The weather client needs to have some wealth to purchase the service from the weather station.</p> <p>First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai <code>Dorado</code> use:</p> <pre><code>aea generate-key fetchai\naea add-key fetchai fetchai_private_key.txt\n</code></pre> <p>Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai <code>Dorado</code> network:</p> <pre><code>aea generate-wealth fetchai\n</code></pre> <p>Next, create a private key used to secure the AEA's communications:</p> <pre><code>aea generate-key fetchai fetchai_connection_private_key.txt\naea add-key fetchai fetchai_connection_private_key.txt --connection\n</code></pre> <p>Finally, certify the key for use by the connections that request that:</p> <pre><code>aea issue-certificates\n</code></pre>"},{"location":"aea-framework-documentation/weather-skills/#run-the-aeas","title":"Run the AEAs","text":"<p>Run both AEAs from their respective terminals.</p> <p>First, run the weather station AEA:</p> <pre><code>aea run\n</code></pre> <p>Once you see a message of the form <code>To join its network use multiaddr 'SOME_ADDRESS'</code> take note of the address. (Alternatively, use <code>aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.27.5 -u public_uri</code> to retrieve the address.) This is the entry peer address for the local agent communication network created by the weather station.</p> <p>Then, in the weather client, run this command (replace <code>SOME_ADDRESS</code> with the correct value as described above):</p> <pre><code>aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\\n'{\n  \"delegate_uri\": \"127.0.0.1:11001\",\n  \"entry_peers\": [\"SOME_ADDRESS\"],\n  \"local_uri\": \"127.0.0.1:9001\",\n  \"log_file\": \"libp2p_node.log\",\n  \"public_uri\": \"127.0.0.1:9001\"\n}'\n</code></pre> <p>This allows the weather client to connect to the same local agent communication network as the weather station.</p> <p>Then run the weather client AEA:</p> <pre><code>aea run\n</code></pre> <p>You will see that the AEAs negotiate and then transact using the selected ledger.</p>"},{"location":"aea-framework-documentation/weather-skills/#cleaning-up","title":"Cleaning up","text":"<p>When you're done, go up a level and delete the AEAs.</p> <pre><code>cd ..\naea delete my_weather_station\naea delete my_weather_client\n</code></pre>"},{"location":"aea-framework-documentation/api/abstract_agent/","title":"AbstractAgent","text":""},{"location":"aea-framework-documentation/api/abstract_agent/#aeaabstract_agent","title":"aea.abstract<code>_</code>agent","text":"<p>This module contains the interface definition of the abstract agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#abstractagent-objects","title":"AbstractAgent Objects","text":"<pre><code>class AbstractAgent(ABC)\n</code></pre> <p>This class provides an abstract base  interface for an agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#name","title":"name","text":"<pre><code>@property\n@abstractmethod\ndef name() -&gt; str\n</code></pre> <p>Get agent's name.</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#storage_uri","title":"storage<code>_</code>uri","text":"<pre><code>@property\n@abstractmethod\ndef storage_uri() -&gt; Optional[str]\n</code></pre> <p>Return storage uri.</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#start","title":"start","text":"<pre><code>@abstractmethod\ndef start() -&gt; None\n</code></pre> <p>Start the agent.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#stop","title":"stop","text":"<pre><code>@abstractmethod\ndef stop() -&gt; None\n</code></pre> <p>Stop the agent.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#setup","title":"setup","text":"<pre><code>@abstractmethod\ndef setup() -&gt; None\n</code></pre> <p>Set up the agent.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#act","title":"act","text":"<pre><code>@abstractmethod\ndef act() -&gt; None\n</code></pre> <p>Perform actions on period.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#handle_envelope","title":"handle<code>_</code>envelope","text":"<pre><code>@abstractmethod\ndef handle_envelope(envelope: Envelope) -&gt; None\n</code></pre> <p>Handle an envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to handle.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#get_periodic_tasks","title":"get<code>_</code>periodic<code>_</code>tasks","text":"<pre><code>@abstractmethod\ndef get_periodic_tasks(\n) -&gt; Dict[Callable, Tuple[float, Optional[datetime.datetime]]]\n</code></pre> <p>Get all periodic tasks for agent.</p> <p>Returns:</p> <p>dict of callable with period specified</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#get_message_handlers","title":"get<code>_</code>message<code>_</code>handlers","text":"<pre><code>@abstractmethod\ndef get_message_handlers() -&gt; List[Tuple[Callable[[Any], None], Callable]]\n</code></pre> <p>Get handlers with message getters.</p> <p>Returns:</p> <p>List of tuples of callables: handler and coroutine to get a message</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#exception_handler","title":"exception<code>_</code>handler","text":"<pre><code>@abstractmethod\ndef exception_handler(exception: Exception,\nfunction: Callable) -&gt; Optional[bool]\n</code></pre> <p>Handle exception raised during agent main loop execution.</p> <p>Arguments:</p> <ul> <li><code>exception</code>: exception raised</li> <li><code>function</code>: a callable exception raised in.</li> </ul> <p>Returns:</p> <p>skip exception if True, otherwise re-raise it</p> <p></p>"},{"location":"aea-framework-documentation/api/abstract_agent/#teardown","title":"teardown","text":"<pre><code>@abstractmethod\ndef teardown() -&gt; None\n</code></pre> <p>Tear down the agent.</p> <p>Returns:</p> <p>None</p>"},{"location":"aea-framework-documentation/api/aea/","title":"AEA","text":""},{"location":"aea-framework-documentation/api/aea/#aeaaea","title":"aea.aea","text":"<p>This module contains the implementation of an autonomous economic agent (AEA).</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#aea-objects","title":"AEA Objects","text":"<pre><code>class AEA(Agent)\n</code></pre> <p>This class implements an autonomous economic agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nidentity: Identity,\nwallet: Wallet,\nresources: Resources,\ndata_dir: str,\nloop: Optional[AbstractEventLoop] = None,\nperiod: float = 0.05,\nexecution_timeout: float = 0,\nmax_reactions: int = 20,\nerror_handler_class: Optional[Type[AbstractErrorHandler]] = None,\nerror_handler_config: Optional[Dict[str, Any]] = None,\ndecision_maker_handler_class: Optional[\nType[DecisionMakerHandler]] = None,\ndecision_maker_handler_config: Optional[Dict[str, Any]] = None,\nskill_exception_policy: ExceptionPolicyEnum = ExceptionPolicyEnum.\npropagate,\nconnection_exception_policy: ExceptionPolicyEnum = ExceptionPolicyEnum.\npropagate,\nloop_mode: Optional[str] = None,\nruntime_mode: Optional[str] = None,\ndefault_ledger: Optional[str] = None,\ncurrency_denominations: Optional[Dict[str, str]] = None,\ndefault_connection: Optional[PublicId] = None,\ndefault_routing: Optional[Dict[PublicId, PublicId]] = None,\nconnection_ids: Optional[Collection[PublicId]] = None,\nsearch_service_address: str = DEFAULT_SEARCH_SERVICE_ADDRESS,\nstorage_uri: Optional[str] = None,\ntask_manager_mode: Optional[str] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Instantiate the agent.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity of the agent</li> <li><code>wallet</code>: the wallet of the agent.</li> <li><code>resources</code>: the resources (protocols and skills) of the agent.</li> <li><code>data_dir</code>: directory where to put local files.</li> <li><code>loop</code>: the event loop to run the connections.</li> <li><code>period</code>: period to call agent's act</li> <li><code>execution_timeout</code>: amount of time to limit single act/handle to execute.</li> <li><code>max_reactions</code>: the processing rate of envelopes per tick (i.e. single loop).</li> <li><code>error_handler_class</code>: the class implementing the error handler</li> <li><code>error_handler_config</code>: the configuration of the error handler</li> <li><code>decision_maker_handler_class</code>: the class implementing the decision maker handler to be used.</li> <li><code>decision_maker_handler_config</code>: the configuration of the decision maker handler</li> <li><code>skill_exception_policy</code>: the skill exception policy enum</li> <li><code>connection_exception_policy</code>: the connection exception policy enum</li> <li><code>loop_mode</code>: loop_mode to choose agent run loop.</li> <li><code>runtime_mode</code>: runtime mode (async, threaded) to run AEA in.</li> <li><code>default_ledger</code>: default ledger id</li> <li><code>currency_denominations</code>: mapping from ledger id to currency denomination</li> <li><code>default_connection</code>: public id to the default connection</li> <li><code>default_routing</code>: dictionary for default routing.</li> <li><code>connection_ids</code>: active connection ids. Default: consider all the ones in the resources.</li> <li><code>search_service_address</code>: the address of the search service used.</li> <li><code>storage_uri</code>: optional uri to set generic storage</li> <li><code>task_manager_mode</code>: task manager mode (threaded) to run tasks with.</li> <li><code>kwargs</code>: keyword arguments to be attached in the agent context namespace.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea/#get_build_dir","title":"get<code>_</code>build<code>_</code>dir","text":"<pre><code>@classmethod\ndef get_build_dir(cls) -&gt; str\n</code></pre> <p>Get agent build directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#context","title":"context","text":"<pre><code>@property\ndef context() -&gt; AgentContext\n</code></pre> <p>Get (agent) context.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#resources","title":"resources","text":"<pre><code>@property\ndef resources() -&gt; Resources\n</code></pre> <p>Get resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#resources_1","title":"resources","text":"<pre><code>@resources.setter\ndef resources(resources: \"Resources\") -&gt; None\n</code></pre> <p>Set resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#filter","title":"filter","text":"<pre><code>@property\ndef filter() -&gt; Filter\n</code></pre> <p>Get the filter.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#active_behaviours","title":"active<code>_</code>behaviours","text":"<pre><code>@property\ndef active_behaviours() -&gt; List[Behaviour]\n</code></pre> <p>Get all active behaviours to use in act.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the agent.</p> <p>Calls setup() on the resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#act","title":"act","text":"<pre><code>def act() -&gt; None\n</code></pre> <p>Perform actions.</p> <p>Adds new handlers and behaviours for use/execution by the runtime.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#handle_envelope","title":"handle<code>_</code>envelope","text":"<pre><code>def handle_envelope(envelope: Envelope) -&gt; None\n</code></pre> <p>Handle an envelope.</p> <p>Performs the following:</p> <ul> <li>fetching the protocol referenced by the envelope, and</li> <li>handling if the protocol is unsupported, using the error handler, or</li> <li>handling if there is a decoding error, using the error handler, or</li> <li>handling if no active handler is available for the specified protocol, using the error handler, or</li> <li>handling the message recovered from the envelope with all active handlers for the specified protocol.</li> </ul> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to handle.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#get_periodic_tasks","title":"get<code>_</code>periodic<code>_</code>tasks","text":"<pre><code>def get_periodic_tasks(\n) -&gt; Dict[Callable, Tuple[float, Optional[datetime.datetime]]]\n</code></pre> <p>Get all periodic tasks for agent.</p> <p>Returns:</p> <p>dict of callable with period specified</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#get_message_handlers","title":"get<code>_</code>message<code>_</code>handlers","text":"<pre><code>def get_message_handlers() -&gt; List[Tuple[Callable[[Any], None], Callable]]\n</code></pre> <p>Get handlers with message getters.</p> <p>Returns:</p> <p>List of tuples of callables: handler and coroutine to get a message</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#exception_handler","title":"exception<code>_</code>handler","text":"<pre><code>def exception_handler(exception: Exception, function: Callable) -&gt; bool\n</code></pre> <p>Handle exception raised during agent main loop execution.</p> <p>Arguments:</p> <ul> <li><code>exception</code>: exception raised</li> <li><code>function</code>: a callable exception raised in.</li> </ul> <p>Returns:</p> <p>bool, propagate exception if True otherwise skip it.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down the agent.</p> <p>Performs the following:</p> <ul> <li>tears down the resources.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea/#get_task_result","title":"get<code>_</code>task<code>_</code>result","text":"<pre><code>def get_task_result(task_id: int) -&gt; AsyncResult\n</code></pre> <p>Get the result from a task.</p> <p>Arguments:</p> <ul> <li><code>task_id</code>: the id of the task</li> </ul> <p>Returns:</p> <p>async result for task_id</p> <p></p>"},{"location":"aea-framework-documentation/api/aea/#enqueue_task","title":"enqueue<code>_</code>task","text":"<pre><code>def enqueue_task(func: Callable,\nargs: Sequence = (),\nkwargs: Optional[Dict[str, Any]] = None) -&gt; int\n</code></pre> <p>Enqueue a task with the task manager.</p> <p>Arguments:</p> <ul> <li><code>func</code>: the callable instance to be enqueued</li> <li><code>args</code>: the positional arguments to be passed to the function.</li> <li><code>kwargs</code>: the keyword arguments to be passed to the function.</li> </ul> <p>Returns:</p> <p>the task id to get the the result.</p>"},{"location":"aea-framework-documentation/api/aea_builder/","title":"AEA Builder","text":""},{"location":"aea-framework-documentation/api/aea_builder/#aeaaea_builder","title":"aea.aea<code>_</code>builder","text":"<p>This module contains utilities for building an AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#_dependenciesmanager-objects","title":"<code>_</code>DependenciesManager Objects","text":"<pre><code>class _DependenciesManager()\n</code></pre> <p>Class to manage dependencies of agent packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Initialize the dependency graph.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#all_dependencies","title":"all<code>_</code>dependencies","text":"<pre><code>@property\ndef all_dependencies() -&gt; Set[ComponentId]\n</code></pre> <p>Get all dependencies.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#dependencies_highest_version","title":"dependencies<code>_</code>highest<code>_</code>version","text":"<pre><code>@property\ndef dependencies_highest_version() -&gt; Set[ComponentId]\n</code></pre> <p>Get the dependencies with highest version.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#get_components_by_type","title":"get<code>_</code>components<code>_</code>by<code>_</code>type","text":"<pre><code>def get_components_by_type(\ncomponent_type: ComponentType\n) -&gt; Dict[ComponentId, ComponentConfiguration]\n</code></pre> <p>Get the components by type.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#protocols","title":"protocols","text":"<pre><code>@property\ndef protocols() -&gt; Dict[ComponentId, ProtocolConfig]\n</code></pre> <p>Get the protocols.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#connections","title":"connections","text":"<pre><code>@property\ndef connections() -&gt; Dict[ComponentId, ConnectionConfig]\n</code></pre> <p>Get the connections.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#skills","title":"skills","text":"<pre><code>@property\ndef skills() -&gt; Dict[ComponentId, SkillConfig]\n</code></pre> <p>Get the skills.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#contracts","title":"contracts","text":"<pre><code>@property\ndef contracts() -&gt; Dict[ComponentId, ContractConfig]\n</code></pre> <p>Get the contracts.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_component","title":"add<code>_</code>component","text":"<pre><code>def add_component(configuration: ComponentConfiguration) -&gt; None\n</code></pre> <p>Add a component to the dependency manager.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the component configuration to add.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_component","title":"remove<code>_</code>component","text":"<pre><code>def remove_component(component_id: ComponentId) -&gt; None\n</code></pre> <p>Remove a component.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the component id</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if some component depends on this package.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#pypi_dependencies","title":"pypi<code>_</code>dependencies","text":"<pre><code>@property\ndef pypi_dependencies() -&gt; Dependencies\n</code></pre> <p>Get all the PyPI dependencies.</p> <p>We currently consider only dependency that have the default PyPI index url and that specify only the version field.</p> <p>Returns:</p> <p>the merged PyPI dependencies</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#install_dependencies","title":"install<code>_</code>dependencies","text":"<pre><code>def install_dependencies() -&gt; None\n</code></pre> <p>Install extra dependencies for components.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#aeabuilder-objects","title":"AEABuilder Objects","text":"<pre><code>class AEABuilder(WithLogger)\n</code></pre> <p>This class helps to build an AEA.</p> <p>It follows the fluent interface. Every method of the builder returns the instance of the builder itself.</p> <p>Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.:</p> <p>builder = AEABuilder() builder.add_component(...) ...</p>"},{"location":"aea-framework-documentation/api/aea_builder/#first-call","title":"first call","text":"<p>my_aea_1 = builder.build()</p>"},{"location":"aea-framework-documentation/api/aea_builder/#following-agents-will-have-different-components","title":"following agents will have different components.","text":"<p>my_aea_2 = builder.build()  # all good</p> <p>However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented:</p> <p>builder = AEABuilder() builder.add_component_instance(...) ...  # other initialization code</p>"},{"location":"aea-framework-documentation/api/aea_builder/#first-call_1","title":"first call","text":"<p>my_aea_1 = builder.build()</p>"},{"location":"aea-framework-documentation/api/aea_builder/#second-call-to-build-would-raise-a-value-error","title":"second call to <code>build()</code> would raise a Value Error.","text":""},{"location":"aea-framework-documentation/api/aea_builder/#call-reset","title":"call reset","text":"<p>builder.reset()</p>"},{"location":"aea-framework-documentation/api/aea_builder/#re-add-the-component-and-private-keys","title":"re-add the component and private keys","text":"<p>builder.add_component_instance(...) ... # add private keys</p>"},{"location":"aea-framework-documentation/api/aea_builder/#second-call","title":"second call","text":"<p>my_aea_2 = builder.builder()</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(with_default_packages: bool = True,\nregistry_dir: str = DEFAULT_REGISTRY_NAME,\nbuild_dir_root: Optional[str] = None) -&gt; None\n</code></pre> <p>Initialize the builder.</p> <p>Arguments:</p> <ul> <li><code>with_default_packages</code>: add the default packages.</li> <li><code>registry_dir</code>: the registry directory.</li> <li><code>build_dir_root</code>: the root of the build directory.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#reset","title":"reset","text":"<pre><code>def reset(is_full_reset: bool = False) -&gt; None\n</code></pre> <p>Reset the builder.</p> <p>A full reset causes a reset of all data on the builder. A partial reset only resets:     - name,     - private keys, and     - component instances</p> <p>Arguments:</p> <ul> <li><code>is_full_reset</code>: whether it is a full reset or not.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_period","title":"set<code>_</code>period","text":"<pre><code>def set_period(period: Optional[float]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set agent act period.</p> <p>Arguments:</p> <ul> <li><code>period</code>: period in seconds</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_execution_timeout","title":"set<code>_</code>execution<code>_</code>timeout","text":"<pre><code>def set_execution_timeout(execution_timeout: Optional[float]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set agent execution timeout in seconds.</p> <p>Arguments:</p> <ul> <li><code>execution_timeout</code>: execution_timeout in seconds</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_max_reactions","title":"set<code>_</code>max<code>_</code>reactions","text":"<pre><code>def set_max_reactions(max_reactions: Optional[int]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set agent max reaction in one react.</p> <p>Arguments:</p> <ul> <li><code>max_reactions</code>: int</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_decision_maker_handler_details","title":"set<code>_</code>decision<code>_</code>maker<code>_</code>handler<code>_</code>details","text":"<pre><code>def set_decision_maker_handler_details(decision_maker_handler_dotted_path: str,\nfile_path: str,\nconfig: Dict[str, Any]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set error handler details.</p> <p>Arguments:</p> <ul> <li><code>decision_maker_handler_dotted_path</code>: the dotted path to the decision maker handler</li> <li><code>file_path</code>: the file path to the file which contains the decision maker handler</li> <li><code>config</code>: the configuration passed to the decision maker handler on instantiation</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_error_handler_details","title":"set<code>_</code>error<code>_</code>handler<code>_</code>details","text":"<pre><code>def set_error_handler_details(error_handler_dotted_path: str, file_path: str,\nconfig: Dict[str, Any]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set error handler details.</p> <p>Arguments:</p> <ul> <li><code>error_handler_dotted_path</code>: the dotted path to the error handler</li> <li><code>file_path</code>: the file path to the file which contains the error handler</li> <li><code>config</code>: the configuration passed to the error handler on instantiation</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_skill_exception_policy","title":"set<code>_</code>skill<code>_</code>exception<code>_</code>policy","text":"<pre><code>def set_skill_exception_policy(\nskill_exception_policy: Optional[ExceptionPolicyEnum]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set skill exception policy.</p> <p>Arguments:</p> <ul> <li><code>skill_exception_policy</code>: the policy</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_connection_exception_policy","title":"set<code>_</code>connection<code>_</code>exception<code>_</code>policy","text":"<pre><code>def set_connection_exception_policy(\nconnection_exception_policy: Optional[ExceptionPolicyEnum]\n) -&gt; \"AEABuilder\"\n</code></pre> <p>Set connection exception policy.</p> <p>Arguments:</p> <ul> <li><code>connection_exception_policy</code>: the policy</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_default_routing","title":"set<code>_</code>default<code>_</code>routing","text":"<pre><code>def set_default_routing(\ndefault_routing: Dict[PublicId, PublicId]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set default routing.</p> <p>This is a map from public ids (protocols) to public ids (connections).</p> <p>Arguments:</p> <ul> <li><code>default_routing</code>: the default routing mapping</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_loop_mode","title":"set<code>_</code>loop<code>_</code>mode","text":"<pre><code>def set_loop_mode(loop_mode: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the loop mode.</p> <p>Arguments:</p> <ul> <li><code>loop_mode</code>: the agent loop mode</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_runtime_mode","title":"set<code>_</code>runtime<code>_</code>mode","text":"<pre><code>def set_runtime_mode(runtime_mode: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the runtime mode.</p> <p>Arguments:</p> <ul> <li><code>runtime_mode</code>: the agent runtime mode</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_task_manager_mode","title":"set<code>_</code>task<code>_</code>manager<code>_</code>mode","text":"<pre><code>def set_task_manager_mode(task_manager_mode: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the task_manager_mode.</p> <p>Arguments:</p> <ul> <li><code>task_manager_mode</code>: the agent task_manager_mode</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_storage_uri","title":"set<code>_</code>storage<code>_</code>uri","text":"<pre><code>def set_storage_uri(storage_uri: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the storage uri.</p> <p>Arguments:</p> <ul> <li><code>storage_uri</code>: storage uri</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_data_dir","title":"set<code>_</code>data<code>_</code>dir","text":"<pre><code>def set_data_dir(data_dir: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the data directory.</p> <p>Arguments:</p> <ul> <li><code>data_dir</code>: path to directory where to store data.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_logging_config","title":"set<code>_</code>logging<code>_</code>config","text":"<pre><code>def set_logging_config(logging_config: Dict) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the logging configurations.</p> <p>The dictionary must satisfy the following schema:</p> <p>https://docs.python.org/3/library/logging.config.html#logging-config-dictschema</p> <p>Arguments:</p> <ul> <li><code>logging_config</code>: the logging configurations.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_search_service_address","title":"set<code>_</code>search<code>_</code>service<code>_</code>address","text":"<pre><code>def set_search_service_address(search_service_address: str) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the search service address.</p> <p>Arguments:</p> <ul> <li><code>search_service_address</code>: the search service address</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_name","title":"set<code>_</code>name","text":"<pre><code>def set_name(name: str) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the name of the agent.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the agent.</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_default_connection","title":"set<code>_</code>default<code>_</code>connection","text":"<pre><code>def set_default_connection(\npublic_id: Optional[PublicId] = None) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the default connection.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id of the default connection package.</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_private_key","title":"add<code>_</code>private<code>_</code>key","text":"<pre><code>def add_private_key(identifier: str,\nprivate_key_path: Optional[PathLike] = None,\nis_connection: bool = False) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a private key path.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier for that private key path.</li> <li><code>private_key_path</code>: an (optional) path to the private key file. If None, the key will be created at build time.</li> <li><code>is_connection</code>: if the pair is for the connection cryptos</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_private_key","title":"remove<code>_</code>private<code>_</code>key","text":"<pre><code>def remove_private_key(identifier: str,\nis_connection: bool = False) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove a private key path by identifier, if present.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the private key.</li> <li><code>is_connection</code>: if the pair is for the connection cryptos</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#private_key_paths","title":"private<code>_</code>key<code>_</code>paths","text":"<pre><code>@property\ndef private_key_paths() -&gt; Dict[str, Optional[str]]\n</code></pre> <p>Get the private key paths.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#connection_private_key_paths","title":"connection<code>_</code>private<code>_</code>key<code>_</code>paths","text":"<pre><code>@property\ndef connection_private_key_paths() -&gt; Dict[str, Optional[str]]\n</code></pre> <p>Get the connection private key paths.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_default_ledger","title":"set<code>_</code>default<code>_</code>ledger","text":"<pre><code>def set_default_ledger(identifier: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set a default ledger API to use.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger api</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_required_ledgers","title":"set<code>_</code>required<code>_</code>ledgers","text":"<pre><code>def set_required_ledgers(\nrequired_ledgers: Optional[List[str]]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the required ledger identifiers.</p> <p>These are the ledgers for which the AEA requires a key pair.</p> <p>Arguments:</p> <ul> <li><code>required_ledgers</code>: the required ledgers.</li> </ul> <p>Returns:</p> <p>the AEABuilder.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_build_entrypoint","title":"set<code>_</code>build<code>_</code>entrypoint","text":"<pre><code>def set_build_entrypoint(build_entrypoint: Optional[str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set build entrypoint.</p> <p>Arguments:</p> <ul> <li><code>build_entrypoint</code>: path to the builder script.</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_currency_denominations","title":"set<code>_</code>currency<code>_</code>denominations","text":"<pre><code>def set_currency_denominations(\ncurrency_denominations: Dict[str, str]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the mapping from ledger ids to currency denominations.</p> <p>Arguments:</p> <ul> <li><code>currency_denominations</code>: the mapping</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_component_1","title":"add<code>_</code>component","text":"<pre><code>def add_component(component_type: ComponentType,\ndirectory: PathLike,\nskip_consistency_check: bool = False) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a component, given its type and the directory.</p> <p>Arguments:</p> <ul> <li><code>component_type</code>: the component type.</li> <li><code>directory</code>: the directory path.</li> <li><code>skip_consistency_check</code>: if True, the consistency check are skipped.</li> </ul> <p>Raises:</p> <ul> <li><code>AEAException</code>: if a component is already registered with the same component id.   # noqa: DAR402 | or if there's a missing dependency.  # noqa: DAR402</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_component_instance","title":"add<code>_</code>component<code>_</code>instance","text":"<pre><code>def add_component_instance(component: Component) -&gt; \"AEABuilder\"\n</code></pre> <p>Add already initialized component object to resources or connections.</p> <p>Please, pay attention, all dependencies have to be already loaded.</p> <p>Notice also that this will make the call to 'build()' non re-entrant. You will have to <code>reset()</code> the builder before calling <code>build()</code> again.</p> <p>Arguments:</p> <ul> <li><code>component</code>: Component instance already initialized.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_context_namespace","title":"set<code>_</code>context<code>_</code>namespace","text":"<pre><code>def set_context_namespace(context_namespace: Dict[str, Any]) -&gt; \"AEABuilder\"\n</code></pre> <p>Set the context namespace.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_agent_pypi_dependencies","title":"set<code>_</code>agent<code>_</code>pypi<code>_</code>dependencies","text":"<pre><code>def set_agent_pypi_dependencies(dependencies: Dependencies) -&gt; \"AEABuilder\"\n</code></pre> <p>Set agent PyPI dependencies.</p> <p>Arguments:</p> <ul> <li><code>dependencies</code>: PyPI dependencies for the agent.</li> </ul> <p>Returns:</p> <p>the AEABuilder.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_component_1","title":"remove<code>_</code>component","text":"<pre><code>def remove_component(component_id: ComponentId) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove a component.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the public id of the component.</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_protocol","title":"add<code>_</code>protocol","text":"<pre><code>def add_protocol(directory: PathLike) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a protocol to the agent.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the path to the protocol directory</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_protocol","title":"remove<code>_</code>protocol","text":"<pre><code>def remove_protocol(public_id: PublicId) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove protocol.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id of the protocol</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_connection","title":"add<code>_</code>connection","text":"<pre><code>def add_connection(directory: PathLike) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a connection to the agent.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the path to the connection directory</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_connection","title":"remove<code>_</code>connection","text":"<pre><code>def remove_connection(public_id: PublicId) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove a connection.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id of the connection</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_skill","title":"add<code>_</code>skill","text":"<pre><code>def add_skill(directory: PathLike) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a skill to the agent.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the path to the skill directory</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_skill","title":"remove<code>_</code>skill","text":"<pre><code>def remove_skill(public_id: PublicId) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove protocol.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id of the skill</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#add_contract","title":"add<code>_</code>contract","text":"<pre><code>def add_contract(directory: PathLike) -&gt; \"AEABuilder\"\n</code></pre> <p>Add a contract to the agent.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the path to the contract directory</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#remove_contract","title":"remove<code>_</code>contract","text":"<pre><code>def remove_contract(public_id: PublicId) -&gt; \"AEABuilder\"\n</code></pre> <p>Remove protocol.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id of the contract</li> </ul> <p>Returns:</p> <p>the AEABuilder</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#call_all_build_entrypoints","title":"call<code>_</code>all<code>_</code>build<code>_</code>entrypoints","text":"<pre><code>def call_all_build_entrypoints() -&gt; None\n</code></pre> <p>Call all the build entrypoints.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#get_build_root_directory","title":"get<code>_</code>build<code>_</code>root<code>_</code>directory","text":"<pre><code>def get_build_root_directory() -&gt; str\n</code></pre> <p>Get build directory root.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#run_build_for_component_configuration","title":"run<code>_</code>build<code>_</code>for<code>_</code>component<code>_</code>configuration","text":"<pre><code>@classmethod\ndef run_build_for_component_configuration(\ncls,\nconfig: ComponentConfiguration,\nlogger: Optional[logging.Logger] = None) -&gt; None\n</code></pre> <p>Run a build entrypoint script for component configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#install_pypi_dependencies","title":"install<code>_</code>pypi<code>_</code>dependencies","text":"<pre><code>def install_pypi_dependencies() -&gt; None\n</code></pre> <p>Install components extra dependencies.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#build","title":"build","text":"<pre><code>def build(connection_ids: Optional[Collection[PublicId]] = None,\npassword: Optional[str] = None) -&gt; AEA\n</code></pre> <p>Build the AEA.</p> <p>This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys.</p> <p>Arguments:</p> <ul> <li><code>connection_ids</code>: select only these connections to run the AEA.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the AEA object.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#get_default_ledger","title":"get<code>_</code>default<code>_</code>ledger","text":"<pre><code>def get_default_ledger() -&gt; str\n</code></pre> <p>Return default ledger.</p> <p>Returns:</p> <p>the default ledger identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#get_required_ledgers","title":"get<code>_</code>required<code>_</code>ledgers","text":"<pre><code>def get_required_ledgers() -&gt; List[str]\n</code></pre> <p>Get the required ledger identifiers.</p> <p>These are the ledgers for which the AEA requires a key pair.</p> <p>Returns:</p> <p>the list of required ledgers.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#try_to_load_agent_configuration_file","title":"try<code>_</code>to<code>_</code>load<code>_</code>agent<code>_</code>configuration<code>_</code>file","text":"<pre><code>@classmethod\ndef try_to_load_agent_configuration_file(\ncls, aea_project_path: Union[str, Path]) -&gt; AgentConfig\n</code></pre> <p>Try to load the agent configuration file..</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#set_from_configuration","title":"set<code>_</code>from<code>_</code>configuration","text":"<pre><code>def set_from_configuration(agent_configuration: AgentConfig,\naea_project_path: Path,\nskip_consistency_check: bool = False) -&gt; None\n</code></pre> <p>Set builder variables from AgentConfig.</p> <p>Arguments:</p> <ul> <li><code>agent_configuration</code>: AgentConfig to get values from.</li> <li><code>aea_project_path</code>: PathLike root directory of the agent project.</li> <li><code>skip_consistency_check</code>: if True, the consistency check are skipped.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#from_aea_project","title":"from<code>_</code>aea<code>_</code>project","text":"<pre><code>@classmethod\ndef from_aea_project(cls,\naea_project_path: PathLike,\nskip_consistency_check: bool = False,\npassword: Optional[str] = None) -&gt; \"AEABuilder\"\n</code></pre> <p>Construct the builder from an AEA project.</p> <ul> <li>load agent configuration file</li> <li>set name and default configurations</li> <li>load private keys</li> <li>load ledger API configurations</li> <li>set default ledger</li> <li>load every component</li> </ul> <p>Arguments:</p> <ul> <li><code>aea_project_path</code>: path to the AEA project.</li> <li><code>skip_consistency_check</code>: if True, the consistency check are skipped.</li> <li><code>password</code>: the password to encrypt/decrypt private keys.</li> </ul> <p>Returns:</p> <p>an AEABuilder.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#get_configuration_file_path","title":"get<code>_</code>configuration<code>_</code>file<code>_</code>path","text":"<pre><code>@staticmethod\ndef get_configuration_file_path(aea_project_path: Union[Path, str]) -&gt; Path\n</code></pre> <p>Return path to aea-config file for the given aea project path.</p> <p></p>"},{"location":"aea-framework-documentation/api/aea_builder/#make_component_logger","title":"make<code>_</code>component<code>_</code>logger","text":"<pre><code>def make_component_logger(configuration: ComponentConfiguration,\nagent_name: str) -&gt; Optional[logging.Logger]\n</code></pre> <p>Make the logger for a component.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the component configuration</li> <li><code>agent_name</code>: the agent name</li> </ul> <p>Returns:</p> <p>the logger.</p>"},{"location":"aea-framework-documentation/api/agent/","title":"Agent","text":""},{"location":"aea-framework-documentation/api/agent/#aeaagent","title":"aea.agent","text":"<p>This module contains the implementation of a generic agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#agent-objects","title":"Agent Objects","text":"<pre><code>class Agent(AbstractAgent, WithLogger)\n</code></pre> <p>This class provides an abstract base class for a generic agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(identity: Identity,\nconnections: List[Connection],\nloop: Optional[AbstractEventLoop] = None,\nperiod: float = 1.0,\nloop_mode: Optional[str] = None,\nruntime_mode: Optional[str] = None,\nstorage_uri: Optional[str] = None,\nlogger: Logger = _default_logger,\ntask_manager_mode: Optional[str] = None) -&gt; None\n</code></pre> <p>Instantiate the agent.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity of the agent.</li> <li><code>connections</code>: the list of connections of the agent.</li> <li><code>loop</code>: the event loop to run the connections.</li> <li><code>period</code>: period to call agent's act</li> <li><code>loop_mode</code>: loop_mode to choose agent run loop.</li> <li><code>runtime_mode</code>: runtime mode to up agent.</li> <li><code>storage_uri</code>: optional uri to set generic storage</li> <li><code>task_manager_mode</code>: task manager mode.</li> <li><code>logger</code>: the logger.</li> <li><code>task_manager_mode</code>: mode of the task manager.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent/#storage_uri","title":"storage<code>_</code>uri","text":"<pre><code>@property\ndef storage_uri() -&gt; Optional[str]\n</code></pre> <p>Return storage uri.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Get running state of the runtime and agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#is_stopped","title":"is<code>_</code>stopped","text":"<pre><code>@property\ndef is_stopped() -&gt; bool\n</code></pre> <p>Get running state of the runtime and agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#identity","title":"identity","text":"<pre><code>@property\ndef identity() -&gt; Identity\n</code></pre> <p>Get the identity.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#inbox","title":"inbox","text":"<pre><code>@property\ndef inbox() -&gt; InBox\n</code></pre> <p>Get the inbox.</p> <p>The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing.</p> <p>Returns:</p> <p>InBox instance</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#outbox","title":"outbox","text":"<pre><code>@property\ndef outbox() -&gt; OutBox\n</code></pre> <p>Get the outbox.</p> <p>The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer.</p> <p>Returns:</p> <p>OutBox instance</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#tick","title":"tick","text":"<pre><code>@property\ndef tick() -&gt; int\n</code></pre> <p>Get the tick or agent loop count.</p> <p>Each agent loop (one call to each one of act(), react(), update()) increments the tick.</p> <p>Returns:</p> <p>tick count</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#state","title":"state","text":"<pre><code>@property\ndef state() -&gt; RuntimeStates\n</code></pre> <p>Get state of the agent's runtime.</p> <p>Returns:</p> <p>RuntimeStates</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#period","title":"period","text":"<pre><code>@property\ndef period() -&gt; float\n</code></pre> <p>Get a period to call act.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#runtime","title":"runtime","text":"<pre><code>@property\ndef runtime() -&gt; BaseRuntime\n</code></pre> <p>Get the runtime.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start the agent.</p> <p>Performs the following:</p> <ul> <li>calls start() on runtime.</li> <li>waits for runtime to complete running (blocking)</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent/#handle_envelope","title":"handle<code>_</code>envelope","text":"<pre><code>def handle_envelope(envelope: Envelope) -&gt; None\n</code></pre> <p>Handle an envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to handle.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent/#act","title":"act","text":"<pre><code>def act() -&gt; None\n</code></pre> <p>Perform actions on period.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop the agent.</p> <p>Performs the following:</p> <ul> <li>calls stop() on runtime</li> <li>waits for runtime to stop (blocking)</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down the agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#get_periodic_tasks","title":"get<code>_</code>periodic<code>_</code>tasks","text":"<pre><code>def get_periodic_tasks(\n) -&gt; Dict[Callable, Tuple[float, Optional[datetime.datetime]]]\n</code></pre> <p>Get all periodic tasks for agent.</p> <p>Returns:</p> <p>dict of callable with period specified</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#get_message_handlers","title":"get<code>_</code>message<code>_</code>handlers","text":"<pre><code>def get_message_handlers() -&gt; List[Tuple[Callable[[Any], None], Callable]]\n</code></pre> <p>Get handlers with message getters.</p> <p>Returns:</p> <p>List of tuples of callables: handler and coroutine to get a message</p> <p></p>"},{"location":"aea-framework-documentation/api/agent/#exception_handler","title":"exception<code>_</code>handler","text":"<pre><code>def exception_handler(exception: Exception, function: Callable) -&gt; bool\n</code></pre> <p>Handle exception raised during agent main loop execution.</p> <p>Arguments:</p> <ul> <li><code>exception</code>: exception raised</li> <li><code>function</code>: a callable exception raised in.</li> </ul> <p>Returns:</p> <p>bool, propagate exception if True otherwise skip it.</p>"},{"location":"aea-framework-documentation/api/agent_loop/","title":"Agent Loop","text":""},{"location":"aea-framework-documentation/api/agent_loop/#aeaagent_loop","title":"aea.agent<code>_</code>loop","text":"<p>This module contains the implementation of an agent loop using asyncio.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#agentloopexception-objects","title":"AgentLoopException Objects","text":"<pre><code>class AgentLoopException(AEAException)\n</code></pre> <p>Exception for agent loop runtime errors.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#agentloopstates-objects","title":"AgentLoopStates Objects","text":"<pre><code>class AgentLoopStates(Enum)\n</code></pre> <p>Internal agent loop states.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#baseagentloop-objects","title":"BaseAgentLoop Objects","text":"<pre><code>class BaseAgentLoop(Runnable, WithLogger, ABC)\n</code></pre> <p>Base abstract  agent loop class.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AbstractAgent,\nloop: Optional[AbstractEventLoop] = None,\nthreaded: bool = False) -&gt; None\n</code></pre> <p>Init loop.</p> <p>Arguments:</p> <ul> <li><code>agent</code>: Agent or AEA to run.</li> <li><code>loop</code>: optional asyncio event loop. if not specified a new loop will be created.</li> <li><code>threaded</code>: if True, run in threaded mode, else async</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#agent","title":"agent","text":"<pre><code>@property\ndef agent() -&gt; AbstractAgent\n</code></pre> <p>Get agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#state","title":"state","text":"<pre><code>@property\ndef state() -&gt; AgentLoopStates\n</code></pre> <p>Get current main loop state.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#wait_state","title":"wait<code>_</code>state","text":"<pre><code>async def wait_state(\nstate_or_states: Union[Any, Sequence[Any]]) -&gt; Tuple[Any, Any]\n</code></pre> <p>Wait state to be set.</p> <p>Arguments:</p> <ul> <li><code>state_or_states</code>: state or list of states.</li> </ul> <p>Returns:</p> <p>tuple of previous state and new state.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Get running state of the loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#set_loop","title":"set<code>_</code>loop","text":"<pre><code>def set_loop(loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Set event loop and all event loop related objects.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Run agent loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#send_to_skill","title":"send<code>_</code>to<code>_</code>skill","text":"<pre><code>@abstractmethod\ndef send_to_skill(message_or_envelope: Union[Message, Envelope],\ncontext: Optional[EnvelopeContext] = None) -&gt; None\n</code></pre> <p>Send message or envelope to another skill.</p> <p>If message passed it will be wrapped into envelope with optional envelope context.</p> <p>Arguments:</p> <ul> <li><code>message_or_envelope</code>: envelope to send to another skill.</li> <li><code>context</code>: envelope context</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#skill2skill_queue","title":"skill2skill<code>_</code>queue","text":"<pre><code>@property\n@abstractmethod\ndef skill2skill_queue() -&gt; Queue\n</code></pre> <p>Get skill to skill message queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#asyncagentloop-objects","title":"AsyncAgentLoop Objects","text":"<pre><code>class AsyncAgentLoop(BaseAgentLoop)\n</code></pre> <p>Asyncio based agent loop suitable only for AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AbstractAgent,\nloop: AbstractEventLoop = None,\nthreaded: bool = False) -&gt; None\n</code></pre> <p>Init agent loop.</p> <p>Arguments:</p> <ul> <li><code>agent</code>: AEA instance</li> <li><code>loop</code>: asyncio loop to use. optional</li> <li><code>threaded</code>: is a new thread to be started for the agent loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#skill2skill_queue_1","title":"skill2skill<code>_</code>queue","text":"<pre><code>@property\ndef skill2skill_queue() -&gt; Queue\n</code></pre> <p>Get skill to skill message queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/agent_loop/#send_to_skill_1","title":"send<code>_</code>to<code>_</code>skill","text":"<pre><code>def send_to_skill(message_or_envelope: Union[Message, Envelope],\ncontext: Optional[EnvelopeContext] = None) -&gt; None\n</code></pre> <p>Send message or envelope to another skill.</p> <p>If message passed it will be wrapped into envelope with optional envelope context.</p> <p>Arguments:</p> <ul> <li><code>message_or_envelope</code>: envelope to send to another skill.</li> <li><code>context</code>: envelope context</li> </ul>"},{"location":"aea-framework-documentation/api/common/","title":"Common","text":""},{"location":"aea-framework-documentation/api/common/#aeacommon","title":"aea.common","text":"<p>This module contains the common types and interfaces used in the aea framework.</p>"},{"location":"aea-framework-documentation/api/exceptions/","title":"Exceptions","text":""},{"location":"aea-framework-documentation/api/exceptions/#aeaexceptions","title":"aea.exceptions","text":"<p>Exceptions for the AEA package.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeaexception-objects","title":"AEAException Objects","text":"<pre><code>class AEAException(Exception)\n</code></pre> <p>User-defined exception for the AEA framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeapackageloadingerror-objects","title":"AEAPackageLoadingError Objects","text":"<pre><code>class AEAPackageLoadingError(AEAException)\n</code></pre> <p>Class for exceptions that are raised for loading errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeasetuperror-objects","title":"AEASetupError Objects","text":"<pre><code>class AEASetupError(AEAException)\n</code></pre> <p>Class for exceptions that are raised for setup errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeateardownerror-objects","title":"AEATeardownError Objects","text":"<pre><code>class AEATeardownError(AEAException)\n</code></pre> <p>Class for exceptions that are raised for teardown errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeaactexception-objects","title":"AEAActException Objects","text":"<pre><code>class AEAActException(AEAException)\n</code></pre> <p>Class for exceptions that are raised for act errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeahandleexception-objects","title":"AEAHandleException Objects","text":"<pre><code>class AEAHandleException(AEAException)\n</code></pre> <p>Class for exceptions that are raised for handler errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeainstantiationexception-objects","title":"AEAInstantiationException Objects","text":"<pre><code>class AEAInstantiationException(AEAException)\n</code></pre> <p>Class for exceptions that are raised for instantiation errors of AEA packages.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeapluginerror-objects","title":"AEAPluginError Objects","text":"<pre><code>class AEAPluginError(AEAException)\n</code></pre> <p>Class for exceptions that are raised for wrong plugin setup of the working set.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeaenforceerror-objects","title":"AEAEnforceError Objects","text":"<pre><code>class AEAEnforceError(AEAException)\n</code></pre> <p>Class for enforcement errors.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeavalidationerror-objects","title":"AEAValidationError Objects","text":"<pre><code>class AEAValidationError(AEAException)\n</code></pre> <p>Class for validation errors of an AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeacomponentloadexception-objects","title":"AEAComponentLoadException Objects","text":"<pre><code>class AEAComponentLoadException(AEAException)\n</code></pre> <p>Class for component loading errors of an AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#aeawalletnoaddressexception-objects","title":"AEAWalletNoAddressException Objects","text":"<pre><code>class AEAWalletNoAddressException(AEAException)\n</code></pre> <p>Class for attempts to instantiate a wallet without addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#_stopruntime-objects","title":"<code>_</code>StopRuntime Objects","text":"<pre><code>class _StopRuntime(Exception)\n</code></pre> <p>Exception to stop runtime.</p> <p>For internal usage only! Used to perform asyncio call from sync callbacks.</p> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(reraise: Optional[Exception] = None) -&gt; None\n</code></pre> <p>Init _StopRuntime exception.</p> <p>Arguments:</p> <ul> <li><code>reraise</code>: exception to reraise.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#enforce","title":"enforce","text":"<pre><code>def enforce(is_valid_condition: bool,\nexception_text: str,\nexception_class: Type[Exception] = AEAEnforceError) -&gt; None\n</code></pre> <p>Evaluate a condition and raise an exception with the provided text if it is not satisfied.</p> <p>Arguments:</p> <ul> <li><code>is_valid_condition</code>: the valid condition</li> <li><code>exception_text</code>: the exception to be raised</li> <li><code>exception_class</code>: the class of exception</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/exceptions/#parse_exception","title":"parse<code>_</code>exception","text":"<pre><code>def parse_exception(exception: Exception, limit: int = -1) -&gt; str\n</code></pre> <p>Parse an exception to get the relevant lines.</p> <p>Arguments:</p> <ul> <li><code>exception</code>: the exception to be parsed</li> <li><code>limit</code>: the limit</li> </ul> <p>Returns:</p> <p>exception as string</p>"},{"location":"aea-framework-documentation/api/launcher/","title":"Launcher","text":""},{"location":"aea-framework-documentation/api/launcher/#aealauncher","title":"aea.launcher","text":"<p>This module contains the implementation of multiple AEA configs launcher.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#load_agent","title":"load<code>_</code>agent","text":"<pre><code>def load_agent(agent_dir: Union[PathLike, str],\npassword: Optional[str] = None) -&gt; AEA\n</code></pre> <p>Load AEA from directory.</p> <p>Arguments:</p> <ul> <li><code>agent_dir</code>: agent configuration directory</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>AEA instance</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#aeadirtask-objects","title":"AEADirTask Objects","text":"<pre><code>class AEADirTask(AbstractExecutorTask)\n</code></pre> <p>Task to run agent from agent configuration directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_dir: Union[PathLike, str],\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Init aea config dir task.</p> <p>Arguments:</p> <ul> <li><code>agent_dir</code>: directory with aea config.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#id","title":"id","text":"<pre><code>@property\ndef id() -&gt; Union[PathLike, str]\n</code></pre> <p>Return agent_dir.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start task.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop task.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#create_async_task","title":"create<code>_</code>async<code>_</code>task","text":"<pre><code>def create_async_task(loop: AbstractEventLoop) -&gt; TaskAwaitable\n</code></pre> <p>Return asyncio Task for task run in asyncio loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#aeadirmultiprocesstask-objects","title":"AEADirMultiprocessTask Objects","text":"<pre><code>class AEADirMultiprocessTask(AbstractMultiprocessExecutorTask)\n</code></pre> <p>Task to run agent from agent configuration directory.</p> <p>Version for multiprocess executor mode.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_dir: Union[PathLike, str],\nlog_level: Optional[str] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Init aea config dir task.</p> <p>Arguments:</p> <ul> <li><code>agent_dir</code>: directory with aea config.</li> <li><code>log_level</code>: debug level applied for AEA in subprocess</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#id_1","title":"id","text":"<pre><code>@property\ndef id() -&gt; Union[PathLike, str]\n</code></pre> <p>Return agent_dir.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#failed","title":"failed","text":"<pre><code>@property\ndef failed() -&gt; bool\n</code></pre> <p>Return was exception failed or not.</p> <p>If it's running it's not failed.</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#start_1","title":"start","text":"<pre><code>def start() -&gt; Tuple[Callable, Sequence[Any]]\n</code></pre> <p>Return function and arguments to call within subprocess.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#stop_1","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop task.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#aealauncher-objects","title":"AEALauncher Objects","text":"<pre><code>class AEALauncher(AbstractMultipleRunner)\n</code></pre> <p>Run multiple AEA instances.</p> <p></p>"},{"location":"aea-framework-documentation/api/launcher/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_dirs: Sequence[Union[PathLike, str]],\nmode: str,\nfail_policy: ExecutorExceptionPolicies = ExecutorExceptionPolicies\n.propagate,\nlog_level: Optional[str] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Init AEALauncher.</p> <p>Arguments:</p> <ul> <li><code>agent_dirs</code>: sequence of AEA config directories.</li> <li><code>mode</code>: executor name to use.</li> <li><code>fail_policy</code>: one of ExecutorExceptionPolicies to be used with Executor</li> <li><code>log_level</code>: debug level applied for AEA in subprocesses</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul>"},{"location":"aea-framework-documentation/api/multiplexer/","title":"Multiplexer","text":""},{"location":"aea-framework-documentation/api/multiplexer/#aeamultiplexer","title":"aea.multiplexer","text":"<p>Module for the multiplexer class and related classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#multiplexerstatus-objects","title":"MultiplexerStatus Objects","text":"<pre><code>class MultiplexerStatus(AsyncState)\n</code></pre> <p>The connection status class.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Initialize the connection status.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#is_connected","title":"is<code>_</code>connected","text":"<pre><code>@property\ndef is_connected() -&gt; bool\n</code></pre> <p>Return is connected.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#is_connecting","title":"is<code>_</code>connecting","text":"<pre><code>@property\ndef is_connecting() -&gt; bool\n</code></pre> <p>Return is connecting.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#is_disconnected","title":"is<code>_</code>disconnected","text":"<pre><code>@property\ndef is_disconnected() -&gt; bool\n</code></pre> <p>Return is disconnected.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#is_disconnecting","title":"is<code>_</code>disconnecting","text":"<pre><code>@property\ndef is_disconnecting() -&gt; bool\n</code></pre> <p>Return is disconnected.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#asyncmultiplexer-objects","title":"AsyncMultiplexer Objects","text":"<pre><code>class AsyncMultiplexer(Runnable, WithLogger)\n</code></pre> <p>This class can handle multiple connections at once.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nconnections: Optional[Sequence[Connection]] = None,\ndefault_connection_index: int = 0,\nloop: Optional[AbstractEventLoop] = None,\nexception_policy: ExceptionPolicyEnum = ExceptionPolicyEnum.propagate,\nthreaded: bool = False,\nagent_name: str = \"standalone\",\ndefault_routing: Optional[Dict[PublicId, PublicId]] = None,\ndefault_connection: Optional[PublicId] = None,\nprotocols: Optional[List[Union[Protocol, Message]]] = None) -&gt; None\n</code></pre> <p>Initialize the connection multiplexer.</p> <p>Arguments:</p> <ul> <li><code>connections</code>: a sequence of connections.</li> <li><code>default_connection_index</code>: the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored.</li> <li><code>loop</code>: the event loop to run the multiplexer. If None, a new event loop is created.</li> <li><code>exception_policy</code>: the exception policy used for connections.</li> <li><code>threaded</code>: if True, run in threaded mode, else async</li> <li><code>agent_name</code>: the name of the agent that owns the multiplexer, for logging purposes.</li> <li><code>default_routing</code>: default routing map</li> <li><code>default_connection</code>: default connection</li> <li><code>protocols</code>: protocols used</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#default_connection","title":"default<code>_</code>connection","text":"<pre><code>@property\ndef default_connection() -&gt; Optional[Connection]\n</code></pre> <p>Get the default connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#in_queue","title":"in<code>_</code>queue","text":"<pre><code>@property\ndef in_queue() -&gt; AsyncFriendlyQueue\n</code></pre> <p>Get the in queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#out_queue","title":"out<code>_</code>queue","text":"<pre><code>@property\ndef out_queue() -&gt; asyncio.Queue\n</code></pre> <p>Get the out queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#connections","title":"connections","text":"<pre><code>@property\ndef connections() -&gt; Tuple[Connection, ...]\n</code></pre> <p>Get the connections.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#is_connected_1","title":"is<code>_</code>connected","text":"<pre><code>@property\ndef is_connected() -&gt; bool\n</code></pre> <p>Check whether the multiplexer is processing envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#default_routing","title":"default<code>_</code>routing","text":"<pre><code>@property\ndef default_routing() -&gt; Dict[PublicId, PublicId]\n</code></pre> <p>Get the default routing.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#default_routing_1","title":"default<code>_</code>routing","text":"<pre><code>@default_routing.setter\ndef default_routing(default_routing: Dict[PublicId, PublicId]) -&gt; None\n</code></pre> <p>Set the default routing.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#connection_status","title":"connection<code>_</code>status","text":"<pre><code>@property\ndef connection_status() -&gt; MultiplexerStatus\n</code></pre> <p>Get the connection status.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Run multiplexer connect and receive/send tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#set_loop","title":"set<code>_</code>loop","text":"<pre><code>def set_loop(loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Set event loop and all event loop related objects.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: asyncio event loop.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#add_connection","title":"add<code>_</code>connection","text":"<pre><code>def add_connection(connection: Connection, is_default: bool = False) -&gt; None\n</code></pre> <p>Add a connection to the multiplexer.</p> <p>Arguments:</p> <ul> <li><code>connection</code>: the connection to add.</li> <li><code>is_default</code>: whether the connection added should be the default one.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#connect","title":"connect","text":"<pre><code>async def connect() -&gt; None\n</code></pre> <p>Connect the multiplexer.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#disconnect","title":"disconnect","text":"<pre><code>async def disconnect() -&gt; None\n</code></pre> <p>Disconnect the multiplexer.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#get","title":"get","text":"<pre><code>def get(block: bool = False,\ntimeout: Optional[float] = None) -&gt; Optional[Envelope]\n</code></pre> <p>Get an envelope within a timeout.</p> <p>Arguments:</p> <ul> <li><code>block</code>: make the call blocking (ignore the timeout).</li> <li><code>timeout</code>: the timeout to wait until an envelope is received.</li> </ul> <p>Returns:</p> <p>the envelope, or None if no envelope is available within a timeout.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#async_get","title":"async<code>_</code>get","text":"<pre><code>async def async_get() -&gt; Envelope\n</code></pre> <p>Get an envelope async way.</p> <p>Returns:</p> <p>the envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#async_wait","title":"async<code>_</code>wait","text":"<pre><code>async def async_wait() -&gt; None\n</code></pre> <p>Get an envelope async way.</p> <p>Returns:</p> <p>the envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#put","title":"put","text":"<pre><code>def put(envelope: Envelope) -&gt; None\n</code></pre> <p>Schedule an envelope for sending it.</p> <p>Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to be sent.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#multiplexer-objects","title":"Multiplexer Objects","text":"<pre><code>class Multiplexer(AsyncMultiplexer)\n</code></pre> <p>Transit sync multiplexer for compatibility.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the connection multiplexer.</p> <p>Arguments:</p> <ul> <li><code>args</code>: arguments</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#set_loop_1","title":"set<code>_</code>loop","text":"<pre><code>def set_loop(loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Set event loop and all event loop related objects.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: asyncio event loop.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#connect_1","title":"connect","text":"<pre><code>def connect() -&gt; None\n</code></pre> <p>Connect the multiplexer.</p> <p>Synchronously in thread spawned if new loop created.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#disconnect_1","title":"disconnect","text":"<pre><code>def disconnect() -&gt; None\n</code></pre> <p>Disconnect the multiplexer.</p> <p>Also stops a dedicated thread for event loop if spawned on connect.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#put_1","title":"put","text":"<pre><code>def put(envelope: Envelope) -&gt; None\n</code></pre> <p>Schedule an envelope for sending it.</p> <p>Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to be sent.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#inbox-objects","title":"InBox Objects","text":"<pre><code>class InBox()\n</code></pre> <p>A queue from where you can only consume envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(multiplexer: AsyncMultiplexer) -&gt; None\n</code></pre> <p>Initialize the inbox.</p> <p>Arguments:</p> <ul> <li><code>multiplexer</code>: the multiplexer</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#empty","title":"empty","text":"<pre><code>def empty() -&gt; bool\n</code></pre> <p>Check for a envelope on the in queue.</p> <p>Returns:</p> <p>boolean indicating whether there is an envelope or not</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#get_1","title":"get","text":"<pre><code>def get(block: bool = False, timeout: Optional[float] = None) -&gt; Envelope\n</code></pre> <p>Check for a envelope on the in queue.</p> <p>Arguments:</p> <ul> <li><code>block</code>: make the call blocking (ignore the timeout).</li> <li><code>timeout</code>: times out the block after timeout seconds.</li> </ul> <p>Raises:</p> <ul> <li><code>Empty</code>: if the attempt to get an envelope fails.</li> </ul> <p>Returns:</p> <p>the envelope object.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#get_nowait","title":"get<code>_</code>nowait","text":"<pre><code>def get_nowait() -&gt; Optional[Envelope]\n</code></pre> <p>Check for a envelope on the in queue and wait for no time.</p> <p>Returns:</p> <p>the envelope object</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#async_get_1","title":"async<code>_</code>get","text":"<pre><code>async def async_get() -&gt; Envelope\n</code></pre> <p>Check for a envelope on the in queue.</p> <p>Returns:</p> <p>the envelope object.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#async_wait_1","title":"async<code>_</code>wait","text":"<pre><code>async def async_wait() -&gt; None\n</code></pre> <p>Check for a envelope on the in queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#outbox-objects","title":"OutBox Objects","text":"<pre><code>class OutBox()\n</code></pre> <p>A queue from where you can only enqueue envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(multiplexer: AsyncMultiplexer) -&gt; None\n</code></pre> <p>Initialize the outbox.</p> <p>Arguments:</p> <ul> <li><code>multiplexer</code>: the multiplexer</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#empty_1","title":"empty","text":"<pre><code>def empty() -&gt; bool\n</code></pre> <p>Check for a envelope on the in queue.</p> <p>Returns:</p> <p>boolean indicating whether there is an envelope or not</p> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#put_2","title":"put","text":"<pre><code>def put(envelope: Envelope) -&gt; None\n</code></pre> <p>Put an envelope into the queue.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/multiplexer/#put_message","title":"put<code>_</code>message","text":"<pre><code>def put_message(message: Message,\ncontext: Optional[EnvelopeContext] = None) -&gt; None\n</code></pre> <p>Put a message in the outbox.</p> <p>This constructs an envelope with the input arguments.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message</li> <li><code>context</code>: the envelope context</li> </ul>"},{"location":"aea-framework-documentation/api/runner/","title":"Runner","text":""},{"location":"aea-framework-documentation/api/runner/#aearunner","title":"aea.runner","text":"<p>This module contains the implementation of AEA multiple instances runner.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#aeainstancetask-objects","title":"AEAInstanceTask Objects","text":"<pre><code>class AEAInstanceTask(AbstractExecutorTask)\n</code></pre> <p>Task to run agent instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AEA) -&gt; None\n</code></pre> <p>Init aea instance task.</p> <p>Arguments:</p> <ul> <li><code>agent</code>: AEA instance to run within task.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/runner/#id","title":"id","text":"<pre><code>@property\ndef id() -&gt; str\n</code></pre> <p>Return agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start task.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop task.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#create_async_task","title":"create<code>_</code>async<code>_</code>task","text":"<pre><code>def create_async_task(loop: AbstractEventLoop) -&gt; TaskAwaitable\n</code></pre> <p>Return asyncio Task for task run in asyncio loop.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: abstract event loop</li> </ul> <p>Returns:</p> <p>task to run runtime</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#aearunner-objects","title":"AEARunner Objects","text":"<pre><code>class AEARunner(AbstractMultipleRunner)\n</code></pre> <p>Run multiple AEA instances.</p> <p></p>"},{"location":"aea-framework-documentation/api/runner/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nagents: Sequence[AEA],\nmode: str,\nfail_policy: ExecutorExceptionPolicies = ExecutorExceptionPolicies.\npropagate\n) -&gt; None\n</code></pre> <p>Init AEARunner.</p> <p>Arguments:</p> <ul> <li><code>agents</code>: sequence of AEA instances to run.</li> <li><code>mode</code>: executor name to use.</li> <li><code>fail_policy</code>: one of ExecutorExceptionPolicies to be used with Executor</li> </ul>"},{"location":"aea-framework-documentation/api/runtime/","title":"Runtime","text":""},{"location":"aea-framework-documentation/api/runtime/#aearuntime","title":"aea.runtime","text":"<p>This module contains the implementation of runtime for economic agent (AEA).</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#runtimestates-objects","title":"RuntimeStates Objects","text":"<pre><code>class RuntimeStates(Enum)\n</code></pre> <p>Runtime states.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#baseruntime-objects","title":"BaseRuntime Objects","text":"<pre><code>class BaseRuntime(Runnable, WithLogger)\n</code></pre> <p>Abstract runtime class to create implementations.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AbstractAgent,\nmultiplexer_options: Dict,\nloop_mode: Optional[str] = None,\nloop: Optional[AbstractEventLoop] = None,\nthreaded: bool = False,\ntask_manager_mode: Optional[str] = None) -&gt; None\n</code></pre> <p>Init runtime.</p> <p>Arguments:</p> <ul> <li><code>agent</code>: Agent to run.</li> <li><code>multiplexer_options</code>: options for the multiplexer.</li> <li><code>loop_mode</code>: agent main loop mode.</li> <li><code>loop</code>: optional event loop. if not provided a new one will be created.</li> <li><code>threaded</code>: if True, run in threaded mode, else async</li> <li><code>task_manager_mode</code>: mode of the task manager.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#storage","title":"storage","text":"<pre><code>@property\ndef storage() -&gt; Optional[Storage]\n</code></pre> <p>Get optional storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#loop_mode","title":"loop<code>_</code>mode","text":"<pre><code>@property\ndef loop_mode() -&gt; str\n</code></pre> <p>Get current loop mode.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#task_manager","title":"task<code>_</code>manager","text":"<pre><code>@property\ndef task_manager() -&gt; TaskManager\n</code></pre> <p>Get the task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#loop","title":"loop","text":"<pre><code>@property\ndef loop() -&gt; Optional[AbstractEventLoop]\n</code></pre> <p>Get event loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#agent_loop","title":"agent<code>_</code>loop","text":"<pre><code>@property\ndef agent_loop() -&gt; BaseAgentLoop\n</code></pre> <p>Get the agent loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#multiplexer","title":"multiplexer","text":"<pre><code>@property\ndef multiplexer() -&gt; AsyncMultiplexer\n</code></pre> <p>Get multiplexer.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Get running state of the runtime.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#is_stopped","title":"is<code>_</code>stopped","text":"<pre><code>@property\ndef is_stopped() -&gt; bool\n</code></pre> <p>Get stopped state of the runtime.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#state","title":"state","text":"<pre><code>@property\ndef state() -&gt; RuntimeStates\n</code></pre> <p>Get runtime state.</p> <p>Returns:</p> <p>RuntimeStates</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#decision_maker","title":"decision<code>_</code>maker","text":"<pre><code>@property\ndef decision_maker() -&gt; DecisionMaker\n</code></pre> <p>Return decision maker if set.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#set_decision_maker","title":"set<code>_</code>decision<code>_</code>maker","text":"<pre><code>def set_decision_maker(decision_maker_handler: DecisionMakerHandler) -&gt; None\n</code></pre> <p>Set decision maker with handler provided.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#set_loop","title":"set<code>_</code>loop","text":"<pre><code>def set_loop(loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Set event loop to be used.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: event loop to use.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#asyncruntime-objects","title":"AsyncRuntime Objects","text":"<pre><code>class AsyncRuntime(BaseRuntime)\n</code></pre> <p>Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AbstractAgent,\nmultiplexer_options: Dict,\nloop_mode: Optional[str] = None,\nloop: Optional[AbstractEventLoop] = None,\nthreaded: bool = False,\ntask_manager_mode: Optional[str] = None) -&gt; None\n</code></pre> <p>Init runtime.</p> <p>Arguments:</p> <ul> <li><code>agent</code>: Agent to run.</li> <li><code>multiplexer_options</code>: options for the multiplexer.</li> <li><code>loop_mode</code>: agent main loop mode.</li> <li><code>loop</code>: optional event loop. if not provided a new one will be created.</li> <li><code>threaded</code>: if True, run in threaded mode, else async</li> <li><code>task_manager_mode</code>: mode of the task manager.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#set_loop_1","title":"set<code>_</code>loop","text":"<pre><code>def set_loop(loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Set event loop to be used.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: event loop to use.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Start runtime task.</p> <p>Starts multiplexer and agent loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#stop_runtime","title":"stop<code>_</code>runtime","text":"<pre><code>async def stop_runtime() -&gt; None\n</code></pre> <p>Stop runtime coroutine.</p> <p>Stop main loop. Tear down the agent.. Disconnect multiplexer.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#run_runtime","title":"run<code>_</code>runtime","text":"<pre><code>async def run_runtime() -&gt; None\n</code></pre> <p>Run runtime which means start agent loop, multiplexer and storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/runtime/#threadedruntime-objects","title":"ThreadedRuntime Objects","text":"<pre><code>class ThreadedRuntime(AsyncRuntime)\n</code></pre> <p>Run agent and multiplexer in different threads with own asyncio loops.</p>"},{"location":"aea-framework-documentation/api/components/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/components/base/#aeacomponentsbase","title":"aea.components.base","text":"<p>This module contains definitions of agent components.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#component-objects","title":"Component Objects","text":"<pre><code>class Component(ABC, WithLogger)\n</code></pre> <p>Abstract class for an agent component.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: Optional[ComponentConfiguration] = None,\nis_vendor: bool = False,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a package.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the package configuration.</li> <li><code>is_vendor</code>: whether the package is vendorized.</li> <li><code>kwargs</code>: the keyword arguments for the logger.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#component_type","title":"component<code>_</code>type","text":"<pre><code>@property\ndef component_type() -&gt; ComponentType\n</code></pre> <p>Get the component type.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#is_vendor","title":"is<code>_</code>vendor","text":"<pre><code>@property\ndef is_vendor() -&gt; bool\n</code></pre> <p>Get whether the component is vendorized or not.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#prefix_import_path","title":"prefix<code>_</code>import<code>_</code>path","text":"<pre><code>@property\ndef prefix_import_path() -&gt; str\n</code></pre> <p>Get the prefix import path for this component.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#component_id","title":"component<code>_</code>id","text":"<pre><code>@property\ndef component_id() -&gt; ComponentId\n</code></pre> <p>Ge the package id.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#public_id","title":"public<code>_</code>id","text":"<pre><code>@property\ndef public_id() -&gt; PublicId\n</code></pre> <p>Get the public id.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#configuration","title":"configuration","text":"<pre><code>@property\ndef configuration() -&gt; ComponentConfiguration\n</code></pre> <p>Get the component configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#directory","title":"directory","text":"<pre><code>@property\ndef directory() -&gt; Path\n</code></pre> <p>Get the directory. Raise error if it has not been set yet.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#directory_1","title":"directory","text":"<pre><code>@directory.setter\ndef directory(path: Path) -&gt; None\n</code></pre> <p>Set the directory. Raise error if already set.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#build_directory","title":"build<code>_</code>directory","text":"<pre><code>@property\ndef build_directory() -&gt; Optional[str]\n</code></pre> <p>Get build directory for the component.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#load_aea_package","title":"load<code>_</code>aea<code>_</code>package","text":"<pre><code>def load_aea_package(configuration: ComponentConfiguration) -&gt; None\n</code></pre> <p>Load the AEA package from configuration.</p> <p>It adds all the init.py modules into <code>sys.modules</code>.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the configuration object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/components/base/#perform_load_aea_package","title":"perform<code>_</code>load<code>_</code>aea<code>_</code>package","text":"<pre><code>def perform_load_aea_package(dir_: Path, author: str, package_type_plural: str,\npackage_name: str) -&gt; None\n</code></pre> <p>Load the AEA package from values provided.</p> <p>It adds all the init.py modules into <code>sys.modules</code>.</p> <p>Arguments:</p> <ul> <li><code>dir_</code>: path of the component.</li> <li><code>author</code>: str</li> <li><code>package_type_plural</code>: str</li> <li><code>package_name</code>: str</li> </ul>"},{"location":"aea-framework-documentation/api/components/loader/","title":"Loader","text":""},{"location":"aea-framework-documentation/api/components/loader/#aeacomponentsloader","title":"aea.components.loader","text":"<p>This module contains utilities for loading components.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/loader/#component_type_to_class","title":"component<code>_</code>type<code>_</code>to<code>_</code>class","text":"<pre><code>def component_type_to_class(component_type: ComponentType) -&gt; Type[Component]\n</code></pre> <p>Get the component class from the component type.</p> <p>Arguments:</p> <ul> <li><code>component_type</code>: the component type</li> </ul> <p>Returns:</p> <p>the component class</p> <p></p>"},{"location":"aea-framework-documentation/api/components/loader/#load_component_from_config","title":"load<code>_</code>component<code>_</code>from<code>_</code>config","text":"<pre><code>def load_component_from_config(configuration: ComponentConfiguration, *args,\n**kwargs) -&gt; Component\n</code></pre> <p>Load a component from a directory.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the component configuration.</li> <li><code>args</code>: the positional arguments.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the component instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/components/loader/#aeapackagenotfound-objects","title":"AEAPackageNotFound Objects","text":"<pre><code>class AEAPackageNotFound(Exception)\n</code></pre> <p>Exception when failed to import package, cause not exists.</p>"},{"location":"aea-framework-documentation/api/components/utils/","title":"Utils","text":""},{"location":"aea-framework-documentation/api/components/utils/#aeacomponentsutils","title":"aea.components.utils","text":"<p>This module contains the component loading utils.</p>"},{"location":"aea-framework-documentation/api/configurations/constants/","title":"Constants","text":""},{"location":"aea-framework-documentation/api/configurations/constants/#aeaconfigurationsconstants","title":"aea.configurations.constants","text":"<p>Module to declare constants.</p>"},{"location":"aea-framework-documentation/api/configurations/data_types/","title":"Data Types","text":""},{"location":"aea-framework-documentation/api/configurations/data_types/#aeaconfigurationsdata_types","title":"aea.configurations.data<code>_</code>types","text":"<p>Base config data types.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#jsonserializable-objects","title":"JSONSerializable Objects","text":"<pre><code>class JSONSerializable(ABC)\n</code></pre> <p>Interface for JSON-serializable objects.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#json","title":"json","text":"<pre><code>@property\n@abstractmethod\ndef json() -&gt; Dict\n</code></pre> <p>Compute the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_json","title":"from<code>_</code>json","text":"<pre><code>@classmethod\n@abstractmethod\ndef from_json(cls, obj: Dict) -&gt; \"JSONSerializable\"\n</code></pre> <p>Build from a JSON object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#packageversion-objects","title":"PackageVersion Objects","text":"<pre><code>@functools.total_ordering\nclass PackageVersion()\n</code></pre> <p>A package version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(version_like: PackageVersionLike) -&gt; None\n</code></pre> <p>Initialize a package version.</p> <p>Arguments:</p> <ul> <li><code>version_like</code>: a string, os a semver.VersionInfo object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#is_latest","title":"is<code>_</code>latest","text":"<pre><code>@property\ndef is_latest() -&gt; bool\n</code></pre> <p>Check whether the version is 'latest'.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__lt__","title":"<code>__</code>lt<code>__</code>","text":"<pre><code>def __lt__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#packagetype-objects","title":"PackageType Objects","text":"<pre><code>class PackageType(Enum)\n</code></pre> <p>Package types.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_plural","title":"to<code>_</code>plural","text":"<pre><code>def to_plural() -&gt; str\n</code></pre> <p>Get the plural name.</p> <p>PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts'</p> <p>Returns:</p> <p>pluralised package type</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str___1","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Convert to string.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#componenttype-objects","title":"ComponentType Objects","text":"<pre><code>class ComponentType(Enum)\n</code></pre> <p>Enum of component types supported.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_package_type","title":"to<code>_</code>package<code>_</code>type","text":"<pre><code>def to_package_type() -&gt; PackageType\n</code></pre> <p>Get package type for component type.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#plurals","title":"plurals","text":"<pre><code>@staticmethod\ndef plurals() -&gt; Collection[str]\n</code></pre> <p>Get the collection of type names, plural.</p> <p>ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts']</p> <p>Returns:</p> <p>list of all pluralised component types</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_plural_1","title":"to<code>_</code>plural","text":"<pre><code>def to_plural() -&gt; str\n</code></pre> <p>Get the plural version of the component type.</p> <p>ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts'</p> <p>Returns:</p> <p>pluralised component type</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str___2","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#publicid-objects","title":"PublicId Objects","text":"<pre><code>class PublicId(JSONSerializable)\n</code></pre> <p>This class implement a public identifier.</p> <p>A public identifier is composed of three elements: - author - name - version</p> <p>The concatenation of those three elements gives the public identifier:</p> <pre><code>author/name:version\n</code></pre> <p>public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id  latest_public_id.package_version.is_latest True <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(author: SimpleIdOrStr,\nname: SimpleIdOrStr,\nversion: Optional[PackageVersionLike] = None) -&gt; None\n</code></pre> <p>Initialize the public identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#author","title":"author","text":"<pre><code>@property\ndef author() -&gt; str\n</code></pre> <p>Get the author.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the name.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#version","title":"version","text":"<pre><code>@property\ndef version() -&gt; str\n</code></pre> <p>Get the version string.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#package_version","title":"package<code>_</code>version","text":"<pre><code>@property\ndef package_version() -&gt; PackageVersion\n</code></pre> <p>Get the package version object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_any","title":"to<code>_</code>any","text":"<pre><code>def to_any() -&gt; \"PublicId\"\n</code></pre> <p>Return the same public id, but with any version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#same_prefix","title":"same<code>_</code>prefix","text":"<pre><code>def same_prefix(other: \"PublicId\") -&gt; bool\n</code></pre> <p>Check if the other public id has the same author and name of this.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_latest","title":"to<code>_</code>latest","text":"<pre><code>def to_latest() -&gt; \"PublicId\"\n</code></pre> <p>Return the same public id, but with latest version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#is_valid_str","title":"is<code>_</code>valid<code>_</code>str","text":"<pre><code>@classmethod\ndef is_valid_str(cls, public_id_string: str) -&gt; bool\n</code></pre> <p>Check if a string is a public id.</p> <p>Arguments:</p> <ul> <li><code>public_id_string</code>: the public id in string format.</li> </ul> <p>Returns:</p> <p>bool indicating validity</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_str","title":"from<code>_</code>str","text":"<pre><code>@classmethod\ndef from_str(cls, public_id_string: str) -&gt; \"PublicId\"\n</code></pre> <p>Initialize the public id from the string.</p> <p>str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0'</p> <p>A bad formatted input raises value error:</p> <p>PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted.</p> <p>Arguments:</p> <ul> <li><code>public_id_string</code>: the public id in string format.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the string in input is not well formatted.</li> </ul> <p>Returns:</p> <p>the public id object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#try_from_str","title":"try<code>_</code>from<code>_</code>str","text":"<pre><code>@classmethod\ndef try_from_str(cls, public_id_string: str) -&gt; Optional[\"PublicId\"]\n</code></pre> <p>Safely try to get public id from string.</p> <p>Arguments:</p> <ul> <li><code>public_id_string</code>: the public id in string format.</li> </ul> <p>Returns:</p> <p>the public id object or None</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_uri_path","title":"from<code>_</code>uri<code>_</code>path","text":"<pre><code>@classmethod\ndef from_uri_path(cls, public_id_uri_path: str) -&gt; \"PublicId\"\n</code></pre> <p>Initialize the public id from the string.</p> <p>str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0'</p> <p>A bad formatted input raises value error:</p> <p>PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted.</p> <p>Arguments:</p> <ul> <li><code>public_id_uri_path</code>: the public id in uri path string format.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the string in input is not well formatted.</li> </ul> <p>Returns:</p> <p>the public id object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_uri_path","title":"to<code>_</code>uri<code>_</code>path","text":"<pre><code>@property\ndef to_uri_path() -&gt; str\n</code></pre> <p>Turn the public id into a uri path string.</p> <p>Returns:</p> <p>uri path string</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#json_1","title":"json","text":"<pre><code>@property\ndef json() -&gt; Dict\n</code></pre> <p>Compute the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_json_1","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, obj: Dict) -&gt; \"PublicId\"\n</code></pre> <p>Build from a JSON object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__hash__","title":"<code>__</code>hash<code>__</code>","text":"<pre><code>def __hash__() -&gt; int\n</code></pre> <p>Get the hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str___3","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__repr__","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get the representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__eq___1","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__lt___1","title":"<code>__</code>lt<code>__</code>","text":"<pre><code>def __lt__(other: Any) -&gt; bool\n</code></pre> <p>Compare two public ids.</p> <p>public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 &gt; public_id_2 False public_id_1 &lt; public_id_2 True</p> <p>public_id_1 &lt; public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different.</p> <p>Arguments:</p> <ul> <li><code>other</code>: the object to compate to</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the public ids cannot be confirmed</li> </ul> <p>Returns:</p> <p>whether or not the inequality is satisfied</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#packageid-objects","title":"PackageId Objects","text":"<pre><code>class PackageId()\n</code></pre> <p>A package identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(package_type: Union[PackageType, str],\npublic_id: PublicId) -&gt; None\n</code></pre> <p>Initialize the package id.</p> <p>Arguments:</p> <ul> <li><code>package_type</code>: the package type.</li> <li><code>public_id</code>: the public id.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#package_type","title":"package<code>_</code>type","text":"<pre><code>@property\ndef package_type() -&gt; PackageType\n</code></pre> <p>Get the package type.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#public_id","title":"public<code>_</code>id","text":"<pre><code>@property\ndef public_id() -&gt; PublicId\n</code></pre> <p>Get the public id.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#author_1","title":"author","text":"<pre><code>@property\ndef author() -&gt; str\n</code></pre> <p>Get the author of the package.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#name_1","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the name of the package.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#version_1","title":"version","text":"<pre><code>@property\ndef version() -&gt; str\n</code></pre> <p>Get the version of the package.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#package_prefix","title":"package<code>_</code>prefix","text":"<pre><code>@property\ndef package_prefix() -&gt; Tuple[PackageType, str, str]\n</code></pre> <p>Get the package identifier without the version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_uri_path_1","title":"from<code>_</code>uri<code>_</code>path","text":"<pre><code>@classmethod\ndef from_uri_path(cls, package_id_uri_path: str) -&gt; \"PackageId\"\n</code></pre> <p>Initialize the package id from the string.</p> <p>str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)'</p> <p>A bad formatted input raises value error:</p> <p>PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted.</p> <p>Arguments:</p> <ul> <li><code>package_id_uri_path</code>: the package id in uri path string format.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the string in input is not well formatted.</li> </ul> <p>Returns:</p> <p>the package id object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_uri_path_1","title":"to<code>_</code>uri<code>_</code>path","text":"<pre><code>@property\ndef to_uri_path() -&gt; str\n</code></pre> <p>Turn the package id into a uri path string.</p> <p>Returns:</p> <p>uri path string</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__hash___1","title":"<code>__</code>hash<code>__</code>","text":"<pre><code>def __hash__() -&gt; int\n</code></pre> <p>Get the hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str___4","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__repr___1","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get the object representation in string.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__eq___2","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__lt___2","title":"<code>__</code>lt<code>__</code>","text":"<pre><code>def __lt__(other: Any) -&gt; bool\n</code></pre> <p>Compare two public ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#componentid-objects","title":"ComponentId Objects","text":"<pre><code>class ComponentId(PackageId)\n</code></pre> <p>Class to represent a component identifier.</p> <p>A component id is a package id, but excludes the case when the package is an agent.</p> <p>pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True</p> <p>component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(component_type: Union[ComponentType, str],\npublic_id: PublicId) -&gt; None\n</code></pre> <p>Initialize the component id.</p> <p>Arguments:</p> <ul> <li><code>component_type</code>: the component type.</li> <li><code>public_id</code>: the public id.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#component_type","title":"component<code>_</code>type","text":"<pre><code>@property\ndef component_type() -&gt; ComponentType\n</code></pre> <p>Get the component type.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#component_prefix","title":"component<code>_</code>prefix","text":"<pre><code>@property\ndef component_prefix() -&gt; PackageIdPrefix\n</code></pre> <p>Get the component identifier without the version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#same_prefix_1","title":"same<code>_</code>prefix","text":"<pre><code>def same_prefix(other: \"ComponentId\") -&gt; bool\n</code></pre> <p>Check if the other component id has the same type, author and name of this.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#prefix_import_path","title":"prefix<code>_</code>import<code>_</code>path","text":"<pre><code>@property\ndef prefix_import_path() -&gt; str\n</code></pre> <p>Get the prefix import path for this component.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#json_2","title":"json","text":"<pre><code>@property\ndef json() -&gt; Dict\n</code></pre> <p>Get the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_json_2","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, json_data: Dict) -&gt; \"ComponentId\"\n</code></pre> <p>Create  component id from json data.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#pypipackagename-objects","title":"PyPIPackageName Objects","text":"<pre><code>class PyPIPackageName(RegexConstrainedString)\n</code></pre> <p>A PyPI Package name.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#gitref-objects","title":"GitRef Objects","text":"<pre><code>class GitRef(RegexConstrainedString)\n</code></pre> <p>A Git reference.</p> <p>It can be a branch name, a commit hash or a tag.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#dependency-objects","title":"Dependency Objects","text":"<pre><code>class Dependency()\n</code></pre> <p>This class represents a PyPI dependency.</p> <p>It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.)</p> <p>If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(name: Union[PyPIPackageName, str],\nversion: Union[str, SpecifierSet] = \"\",\nindex: Optional[str] = None,\ngit: Optional[str] = None,\nref: Optional[Union[GitRef, str]] = None) -&gt; None\n</code></pre> <p>Initialize a PyPI dependency.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the package name.</li> <li><code>version</code>: the specifier set object</li> <li><code>index</code>: the URL to the PyPI server.</li> <li><code>git</code>: the URL to a git repository.</li> <li><code>ref</code>: the Git reference (branch/commit/tag).</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#name_2","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the name.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#version_2","title":"version","text":"<pre><code>@property\ndef version() -&gt; str\n</code></pre> <p>Get the version.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#index","title":"index","text":"<pre><code>@property\ndef index() -&gt; Optional[str]\n</code></pre> <p>Get the index.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#git","title":"git","text":"<pre><code>@property\ndef git() -&gt; Optional[str]\n</code></pre> <p>Get the git.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#ref","title":"ref","text":"<pre><code>@property\ndef ref() -&gt; Optional[str]\n</code></pre> <p>Get the ref.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#from_json_3","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, obj: Dict[str, Dict[str, str]]) -&gt; \"Dependency\"\n</code></pre> <p>Parse a dependency object from a dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#to_json","title":"to<code>_</code>json","text":"<pre><code>def to_json() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Transform the object to JSON.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#get_pip_install_args","title":"get<code>_</code>pip<code>_</code>install<code>_</code>args","text":"<pre><code>def get_pip_install_args() -&gt; List[str]\n</code></pre> <p>Get 'pip install' arguments.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__str___5","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__eq___3","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#dependencies","title":"Dependencies","text":"<p>A dictionary from package name to dependency data structure (see above). The package name must satisfy  the constraints on Python packages names.</p> <p>The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#crudcollection-objects","title":"CRUDCollection Objects","text":"<pre><code>class CRUDCollection(Generic[T])\n</code></pre> <p>Interface of a CRUD collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Instantiate a CRUD collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#create","title":"create","text":"<pre><code>def create(item_id: str, item: T) -&gt; None\n</code></pre> <p>Add an item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the item id.</li> <li><code>item</code>: the item to be added.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the item with the same id is already in the collection.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#read","title":"read","text":"<pre><code>def read(item_id: str) -&gt; Optional[T]\n</code></pre> <p>Get an item by its name.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the item id.</li> </ul> <p>Returns:</p> <p>the associated item, or None if the item id is not present.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#update","title":"update","text":"<pre><code>def update(item_id: str, item: T) -&gt; None\n</code></pre> <p>Update an existing item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the item id.</li> <li><code>item</code>: the item to be added.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#delete","title":"delete","text":"<pre><code>def delete(item_id: str) -&gt; None\n</code></pre> <p>Delete an item.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#read_all","title":"read<code>_</code>all","text":"<pre><code>def read_all() -&gt; List[Tuple[str, T]]\n</code></pre> <p>Read all the items.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/data_types/#keys","title":"keys","text":"<pre><code>def keys() -&gt; Set[str]\n</code></pre> <p>Get the set of keys.</p>"},{"location":"aea-framework-documentation/api/configurations/manager/","title":"Manager","text":""},{"location":"aea-framework-documentation/api/configurations/manager/#aeaconfigurationsmanager","title":"aea.configurations.manager","text":"<p>Implementation of the AgentConfigManager.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#variabledoesnotexist-objects","title":"VariableDoesNotExist Objects","text":"<pre><code>class VariableDoesNotExist(ValueError)\n</code></pre> <p>Variable does not exist in a config exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#handle_dotted_path","title":"handle<code>_</code>dotted<code>_</code>path","text":"<pre><code>def handle_dotted_path(\nvalue: str,\nauthor: str,\naea_project_path: Union[str, Path] = \".\"\n) -&gt; Tuple[List[str], Path, ConfigLoader, Optional[ComponentId]]\n</code></pre> <p>Separate the path between path to resource and json path to attribute.</p> <p>Allowed values:     'agent.an_attribute_name'     'protocols.my_protocol.an_attribute_name'     'connections.my_connection.an_attribute_name'     'contracts.my_contract.an_attribute_name'     'skills.my_skill.an_attribute_name'     'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name</p> <p>We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name).</p> <p>Arguments:</p> <ul> <li><code>value</code>: dotted path.</li> <li><code>author</code>: the author string.</li> <li><code>aea_project_path</code>: project path</li> </ul> <p>Returns:</p> <p>Tuple[list of settings dict keys, filepath, config loader, component id].</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#find_component_directory_from_component_id","title":"find<code>_</code>component<code>_</code>directory<code>_</code>from<code>_</code>component<code>_</code>id","text":"<pre><code>def find_component_directory_from_component_id(\naea_project_directory: Path, component_id: ComponentId) -&gt; Path\n</code></pre> <p>Find a component directory from component id.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#agentconfigmanager-objects","title":"AgentConfigManager Objects","text":"<pre><code>class AgentConfigManager()\n</code></pre> <p>AeaConfig manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_config: AgentConfig,\naea_project_directory: Union[str, Path],\nenv_vars_friendly: bool = False) -&gt; None\n</code></pre> <p>Init manager.</p> <p>Arguments:</p> <ul> <li><code>agent_config</code>: AgentConfig to manage.</li> <li><code>aea_project_directory</code>: directory where project for agent_config placed.</li> <li><code>env_vars_friendly</code>: whether or not it is env vars friendly</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#load_component_configuration","title":"load<code>_</code>component<code>_</code>configuration","text":"<pre><code>def load_component_configuration(\ncomponent_id: ComponentId,\nskip_consistency_check: bool = True) -&gt; ComponentConfiguration\n</code></pre> <p>Load component configuration from the project directory.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: Id of the component to load config for.</li> <li><code>skip_consistency_check</code>: bool.</li> </ul> <p>Returns:</p> <p>ComponentConfiguration</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#agent_config_file_path","title":"agent<code>_</code>config<code>_</code>file<code>_</code>path","text":"<pre><code>@property\ndef agent_config_file_path() -&gt; Path\n</code></pre> <p>Return agent config file path.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#load","title":"load","text":"<pre><code>@classmethod\ndef load(cls,\naea_project_path: Union[Path, str],\nsubstitude_env_vars: bool = False) -&gt; \"AgentConfigManager\"\n</code></pre> <p>Create AgentConfigManager instance from agent project path.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#set_variable","title":"set<code>_</code>variable","text":"<pre><code>def set_variable(path: VariablePath, value: JSON_TYPES) -&gt; None\n</code></pre> <p>Set config variable.</p> <p>Arguments:</p> <ul> <li><code>path</code>: str dotted path  or List[Union[ComponentId, str]]</li> <li><code>value</code>: one of the json friendly objects.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#get_variable","title":"get<code>_</code>variable","text":"<pre><code>def get_variable(path: VariablePath) -&gt; JSON_TYPES\n</code></pre> <p>Set config variable.</p> <p>Arguments:</p> <ul> <li><code>path</code>: str dotted path or List[Union[ComponentId, str]]</li> </ul> <p>Returns:</p> <p>json friendly value.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#update_config","title":"update<code>_</code>config","text":"<pre><code>def update_config(overrides: Dict) -&gt; None\n</code></pre> <p>Apply overrides for agent config.</p> <p>Validates and applies agent config and component overrides. Does not save it on the disc!</p> <p>Arguments:</p> <ul> <li><code>overrides</code>: overridden values dictionary</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#validate_current_config","title":"validate<code>_</code>current<code>_</code>config","text":"<pre><code>def validate_current_config() -&gt; None\n</code></pre> <p>Check is current config valid.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#json","title":"json","text":"<pre><code>@property\ndef json() -&gt; Dict\n</code></pre> <p>Return current agent config json representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#dump_config","title":"dump<code>_</code>config","text":"<pre><code>def dump_config() -&gt; None\n</code></pre> <p>Save agent config on the disc.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#verify_private_keys","title":"verify<code>_</code>private<code>_</code>keys","text":"<pre><code>@classmethod\ndef verify_private_keys(\ncls,\naea_project_path: Union[Path, str],\nprivate_key_helper: Callable[[AgentConfig, Path, Optional[str]], None],\nsubstitude_env_vars: bool = False,\npassword: Optional[str] = None) -&gt; \"AgentConfigManager\"\n</code></pre> <p>Verify private keys.</p> <p>Does not saves the config! Use AgentConfigManager.dump_config()</p> <p>Arguments:</p> <ul> <li><code>aea_project_path</code>: path to an AEA project.</li> <li><code>private_key_helper</code>: private_key_helper is a function that use agent config to check the keys</li> <li><code>substitude_env_vars</code>: replace env vars with values, does not dump config</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the agent configuration manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/manager/#get_overridables","title":"get<code>_</code>overridables","text":"<pre><code>def get_overridables() -&gt; Tuple[Dict, Dict[ComponentId, Dict]]\n</code></pre> <p>Get config overridables.</p>"},{"location":"aea-framework-documentation/api/configurations/pypi/","title":"Pypi","text":""},{"location":"aea-framework-documentation/api/configurations/pypi/#aeaconfigurationspypi","title":"aea.configurations.pypi","text":"<p>This module contains a checker for PyPI version consistency.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#and_","title":"and<code>_</code>","text":"<pre><code>def and_(s1: SpecifierSet, s2: SpecifierSet) -&gt; SpecifierSet\n</code></pre> <p>Do the and between two specifier sets.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#is_satisfiable","title":"is<code>_</code>satisfiable","text":"<pre><code>def is_satisfiable(specifier_set: SpecifierSet) -&gt; bool\n</code></pre> <p>Check if the specifier set is satisfiable.</p> <p>Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists.</p> <p>from packaging.specifiers import SpecifierSet</p> <p>The specifier set \"&gt;0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints</p> <p>s1 = SpecifierSet(\"&gt;0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True</p> <p>The specifier set \"==1.0, &gt;1.1\" is not satisfiable:</p> <p>s1 = SpecifierSet(\"==1.0,&gt;1.1\") is_satisfiable(s1) False</p> <p>For other details, please refer to PEP440:</p> <pre><code>https://www.python.org/dev/peps/pep-0440\n</code></pre> <p>Arguments:</p> <ul> <li><code>specifier_set</code>: the specifier set.</li> </ul> <p>Returns:</p> <p>False if the constraints are surely non-satisfiable, True if we don't know.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#is_simple_dep","title":"is<code>_</code>simple<code>_</code>dep","text":"<pre><code>def is_simple_dep(dep: Dependency) -&gt; bool\n</code></pre> <p>Check if it is a simple dependency.</p> <p>Namely, if it has no field specified, or only the 'version' field set.</p> <p>Arguments:</p> <ul> <li><code>dep</code>: the dependency</li> </ul> <p>Returns:</p> <p>whether it is a simple dependency or not</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#to_set_specifier","title":"to<code>_</code>set<code>_</code>specifier","text":"<pre><code>def to_set_specifier(dep: Dependency) -&gt; SpecifierSet\n</code></pre> <p>Get the set specifier. It assumes to be a simple dependency (see above).</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#merge_dependencies","title":"merge<code>_</code>dependencies","text":"<pre><code>def merge_dependencies(dep1: Dependencies, dep2: Dependencies) -&gt; Dependencies\n</code></pre> <p>Merge two groups of dependencies.</p> <p>If some of them are not \"simple\" (see above), and there is no risk   of conflict because there is no other package with the same name,   we leave them; otherwise we raise an error.</p> <p>Arguments:</p> <ul> <li><code>dep1</code>: the first operand</li> <li><code>dep2</code>: the second operand.</li> </ul> <p>Returns:</p> <p>the merged dependencies.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/pypi/#merge_dependencies_list","title":"merge<code>_</code>dependencies<code>_</code>list","text":"<pre><code>def merge_dependencies_list(*deps: Dependencies) -&gt; Dependencies\n</code></pre> <p>Merge a list of dependencies.</p> <p>Arguments:</p> <ul> <li><code>deps</code>: the list of dependencies</li> </ul> <p>Returns:</p> <p>the merged dependencies.</p>"},{"location":"aea-framework-documentation/api/configurations/utils/","title":"Utils","text":""},{"location":"aea-framework-documentation/api/configurations/utils/#aeaconfigurationsutils","title":"aea.configurations.utils","text":"<p>AEA configuration utils.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#replace_component_ids","title":"replace<code>_</code>component<code>_</code>ids","text":"<pre><code>@singledispatch\ndef replace_component_ids(\n_arg: PackageConfiguration,\n_replacements: Dict[ComponentType, Dict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Update public id references in a package configuration.</p> <p>This depends on the actual configuration being considered.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#_","title":"<code>_</code>","text":"<pre><code>@replace_component_ids.register(AgentConfig)  # type: ignore\ndef _(arg: AgentConfig, replacements: Dict[ComponentType,\nDict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Replace references in agent configuration.</p> <p>It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations.</p> <p>Arguments:</p> <ul> <li><code>arg</code>: the agent configuration.</li> <li><code>replacements</code>: the replacement mapping.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#__1","title":"<code>_</code>","text":"<pre><code>@replace_component_ids.register(ProtocolConfig)  # type: ignore\ndef _(_arg: ProtocolConfig,\n_replacements: Dict[ComponentType, Dict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Do nothing - protocols have no references.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#__2","title":"<code>_</code>","text":"<pre><code>@replace_component_ids.register(ConnectionConfig)  # type: ignore\ndef _(arg: ConnectionConfig,\nreplacements: Dict[ComponentType, Dict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Replace references in a connection configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#__3","title":"<code>_</code>","text":"<pre><code>@replace_component_ids.register(ContractConfig)  # type: ignore\ndef _(_arg: ContractConfig,\n_replacements: Dict[ComponentType, Dict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Do nothing - contracts have no references.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#__4","title":"<code>_</code>","text":"<pre><code>@replace_component_ids.register(SkillConfig)  # type: ignore\ndef _(arg: SkillConfig, replacements: Dict[ComponentType,\nDict[PublicId, PublicId]]) -&gt; None\n</code></pre> <p>Replace references in a skill configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/utils/#get_latest_component_id_from_prefix","title":"get<code>_</code>latest<code>_</code>component<code>_</code>id<code>_</code>from<code>_</code>prefix","text":"<pre><code>def get_latest_component_id_from_prefix(\nagent_config: AgentConfig,\ncomponent_prefix: PackageIdPrefix) -&gt; Optional[ComponentId]\n</code></pre> <p>Get component id with the greatest version in an agent configuration given its prefix.</p> <p>Arguments:</p> <ul> <li><code>agent_config</code>: the agent configuration.</li> <li><code>component_prefix</code>: the package prefix.</li> </ul> <p>Returns:</p> <p>the package id with the greatest version, or None if not found.</p>"},{"location":"aea-framework-documentation/api/configurations/validation/","title":"Validation","text":""},{"location":"aea-framework-documentation/api/configurations/validation/#aeaconfigurationsvalidation","title":"aea.configurations.validation","text":"<p>Implementation of the configuration validation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#make_jsonschema_base_uri","title":"make<code>_</code>jsonschema<code>_</code>base<code>_</code>uri","text":"<pre><code>def make_jsonschema_base_uri(base_uri_path: Path) -&gt; str\n</code></pre> <p>Make the JSONSchema base URI, cross-platform.</p> <p>Arguments:</p> <ul> <li><code>base_uri_path</code>: the path to the base directory.</li> </ul> <p>Returns:</p> <p>the string in URI form.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#extrapropertieserror-objects","title":"ExtraPropertiesError Objects","text":"<pre><code>class ExtraPropertiesError(ValueError)\n</code></pre> <p>Extra properties exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation of the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#__repr__","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get string representation of the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#customtypechecker-objects","title":"CustomTypeChecker Objects","text":"<pre><code>class CustomTypeChecker(TypeChecker)\n</code></pre> <p>Custom type checker to handle env variables.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#is_type","title":"is<code>_</code>type","text":"<pre><code>def is_type(instance, type) -&gt; bool\n</code></pre> <p>Check is instance of type.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#own_additional_properties","title":"own<code>_</code>additional<code>_</code>properties","text":"<pre><code>def own_additional_properties(validator, aP, instance, schema) -&gt; Iterator\n</code></pre> <p>Additional properties validator.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#configvalidator-objects","title":"ConfigValidator Objects","text":"<pre><code>class ConfigValidator()\n</code></pre> <p>Configuration validator implementation.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(schema_filename: str, env_vars_friendly: bool = False) -&gt; None\n</code></pre> <p>Initialize the parser for configuration files.</p> <p>Arguments:</p> <ul> <li><code>schema_filename</code>: the path to the JSON-schema file in 'aea/configurations/schemas'.</li> <li><code>env_vars_friendly</code>: whether or not it is env var friendly.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#split_component_id_and_config","title":"split<code>_</code>component<code>_</code>id<code>_</code>and<code>_</code>config","text":"<pre><code>@staticmethod\ndef split_component_id_and_config(\ncomponent_index: int,\ncomponent_configuration_json: Dict) -&gt; ComponentId\n</code></pre> <p>Split component id and configuration.</p> <p>Arguments:</p> <ul> <li><code>component_index</code>: the position of the component configuration in the agent config file..</li> <li><code>component_configuration_json</code>: the JSON object to process.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the component id cannot be extracted.</li> </ul> <p>Returns:</p> <p>the component id and the configuration object.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#validate_component_configuration","title":"validate<code>_</code>component<code>_</code>configuration","text":"<pre><code>@classmethod\ndef validate_component_configuration(cls,\ncomponent_id: ComponentId,\nconfiguration: Dict,\nenv_vars_friendly: bool = False) -&gt; None\n</code></pre> <p>Validate the component configuration of an agent configuration file.</p> <p>This check is to detect inconsistencies in the specified fields.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the component id.</li> <li><code>configuration</code>: the configuration dictionary.</li> <li><code>env_vars_friendly</code>: bool, if set True, will not raise errors over the env variable definitions.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the configuration is not valid.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#validate","title":"validate","text":"<pre><code>def validate(json_data: Dict) -&gt; None\n</code></pre> <p>Validate a JSON object against the right JSON schema.</p> <p>Arguments:</p> <ul> <li><code>json_data</code>: the JSON data.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#validate_agent_components_configuration","title":"validate<code>_</code>agent<code>_</code>components<code>_</code>configuration","text":"<pre><code>def validate_agent_components_configuration(\ncomponent_configurations: Dict) -&gt; None\n</code></pre> <p>Validate agent component configurations overrides.</p> <p>Arguments:</p> <ul> <li><code>component_configurations</code>: the component configurations to validate.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#required_fields","title":"required<code>_</code>fields","text":"<pre><code>@property\ndef required_fields() -&gt; List[str]\n</code></pre> <p>Get the required fields.</p> <p>Returns:</p> <p>list of required fields.</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#validate_data_with_pattern","title":"validate<code>_</code>data<code>_</code>with<code>_</code>pattern","text":"<pre><code>def validate_data_with_pattern(data: dict,\npattern: dict,\nexcludes: Optional[List[Tuple[str]]] = None,\nskip_env_vars: bool = False) -&gt; List[str]\n</code></pre> <p>Validate data dict with pattern dict for attributes present and type match.</p> <p>Arguments:</p> <ul> <li><code>data</code>: data dict to validate</li> <li><code>pattern</code>: dict with pattern to check over</li> <li><code>excludes</code>: list of tuples of str of paths to be skipped during the check</li> <li><code>skip_env_vars</code>: is set True will not check data type over env variables.</li> </ul> <p>Returns:</p> <p>list of str with error descriptions</p> <p></p>"},{"location":"aea-framework-documentation/api/configurations/validation/#filter_data","title":"filter<code>_</code>data","text":"<pre><code>def filter_data(base: Any, updates: Any) -&gt; Any\n</code></pre> <p>Return difference in values or <code>SAME_MARK</code> object if values are the same.</p>"},{"location":"aea-framework-documentation/api/connections/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/connections/base/#aeaconnectionsbase","title":"aea.connections.base","text":"<p>The base connection package.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#connectionstates-objects","title":"ConnectionStates Objects","text":"<pre><code>class ConnectionStates(Enum)\n</code></pre> <p>Connection states enum.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#connection-objects","title":"Connection Objects","text":"<pre><code>class Connection(Component, ABC)\n</code></pre> <p>Abstract definition of a connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: ConnectionConfig,\ndata_dir: str,\nidentity: Optional[Identity] = None,\ncrypto_store: Optional[CryptoStore] = None,\nrestricted_to_protocols: Optional[Set[PublicId]] = None,\nexcluded_protocols: Optional[Set[PublicId]] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the connection.</p> <p>The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the connection configuration.</li> <li><code>data_dir</code>: directory where to put local files.</li> <li><code>identity</code>: the identity object held by the agent.</li> <li><code>crypto_store</code>: the crypto store for encrypted communication.</li> <li><code>restricted_to_protocols</code>: the set of protocols ids of the only supported protocols for this connection.</li> <li><code>excluded_protocols</code>: the set of protocols ids that we want to exclude for this connection.</li> <li><code>kwargs</code>: keyword arguments passed to component base</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#loop","title":"loop","text":"<pre><code>@property\ndef loop() -&gt; asyncio.AbstractEventLoop\n</code></pre> <p>Get the event loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; \"Address\"\n</code></pre> <p>Get the address.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#crypto_store","title":"crypto<code>_</code>store","text":"<pre><code>@property\ndef crypto_store() -&gt; CryptoStore\n</code></pre> <p>Get the crypto store.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#has_crypto_store","title":"has<code>_</code>crypto<code>_</code>store","text":"<pre><code>@property\ndef has_crypto_store() -&gt; bool\n</code></pre> <p>Check if the connection has the crypto store.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#data_dir","title":"data<code>_</code>dir","text":"<pre><code>@property\ndef data_dir() -&gt; str\n</code></pre> <p>Get the data directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#component_type","title":"component<code>_</code>type","text":"<pre><code>@property\ndef component_type() -&gt; ComponentType\n</code></pre> <p>Get the component type.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#configuration","title":"configuration","text":"<pre><code>@property\ndef configuration() -&gt; ConnectionConfig\n</code></pre> <p>Get the connection configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#restricted_to_protocols","title":"restricted<code>_</code>to<code>_</code>protocols","text":"<pre><code>@property\ndef restricted_to_protocols() -&gt; Set[PublicId]\n</code></pre> <p>Get the ids of the protocols this connection is restricted to.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#excluded_protocols","title":"excluded<code>_</code>protocols","text":"<pre><code>@property\ndef excluded_protocols() -&gt; Set[PublicId]\n</code></pre> <p>Get the ids of the excluded protocols for this connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#state","title":"state","text":"<pre><code>@property\ndef state() -&gt; ConnectionStates\n</code></pre> <p>Get the connection status.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#state_1","title":"state","text":"<pre><code>@state.setter\ndef state(value: ConnectionStates) -&gt; None\n</code></pre> <p>Set the connection status.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#connect","title":"connect","text":"<pre><code>@abstractmethod\nasync def connect() -&gt; None\n</code></pre> <p>Set up the connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#disconnect","title":"disconnect","text":"<pre><code>@abstractmethod\nasync def disconnect() -&gt; None\n</code></pre> <p>Tear down the connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#send","title":"send","text":"<pre><code>@abstractmethod\nasync def send(envelope: \"Envelope\") -&gt; None\n</code></pre> <p>Send an envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to send.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#receive","title":"receive","text":"<pre><code>@abstractmethod\nasync def receive(*args: Any, **kwargs: Any) -&gt; Optional[\"Envelope\"]\n</code></pre> <p>Receive an envelope.</p> <p>Arguments:</p> <ul> <li><code>args</code>: positional arguments</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p>Returns:</p> <p>the received envelope, or None if an error occurred.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#from_dir","title":"from<code>_</code>dir","text":"<pre><code>@classmethod\ndef from_dir(cls, directory: str, identity: Identity,\ncrypto_store: CryptoStore, data_dir: str,\n**kwargs: Any) -&gt; \"Connection\"\n</code></pre> <p>Load the connection from a directory.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the directory to the connection package.</li> <li><code>identity</code>: the identity object.</li> <li><code>crypto_store</code>: object to access the connection crypto objects.</li> <li><code>data_dir</code>: the assets directory.</li> <li><code>kwargs</code>: keyword arguments passed to connection base</li> </ul> <p>Returns:</p> <p>the connection object.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#from_config","title":"from<code>_</code>config","text":"<pre><code>@classmethod\ndef from_config(cls, configuration: ConnectionConfig, identity: Identity,\ncrypto_store: CryptoStore, data_dir: str,\n**kwargs: Any) -&gt; \"Connection\"\n</code></pre> <p>Load a connection from a configuration.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the connection configuration.</li> <li><code>identity</code>: the identity object.</li> <li><code>crypto_store</code>: object to access the connection crypto objects.</li> <li><code>data_dir</code>: the directory of the AEA project data.</li> <li><code>kwargs</code>: keyword arguments passed to component base</li> </ul> <p>Returns:</p> <p>an instance of the concrete connection class.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#is_connected","title":"is<code>_</code>connected","text":"<pre><code>@property\ndef is_connected() -&gt; bool\n</code></pre> <p>Return is connected state.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#is_connecting","title":"is<code>_</code>connecting","text":"<pre><code>@property\ndef is_connecting() -&gt; bool\n</code></pre> <p>Return is connecting state.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#is_disconnected","title":"is<code>_</code>disconnected","text":"<pre><code>@property\ndef is_disconnected() -&gt; bool\n</code></pre> <p>Return is disconnected state.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#basesyncconnection-objects","title":"BaseSyncConnection Objects","text":"<pre><code>class BaseSyncConnection(Connection)\n</code></pre> <p>Base sync connection class to write connections with sync code.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: ConnectionConfig,\ndata_dir: str,\nidentity: Optional[Identity] = None,\ncrypto_store: Optional[CryptoStore] = None,\nrestricted_to_protocols: Optional[Set[PublicId]] = None,\nexcluded_protocols: Optional[Set[PublicId]] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the connection.</p> <p>The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the connection configuration.</li> <li><code>data_dir</code>: directory where to put local files.</li> <li><code>identity</code>: the identity object held by the agent.</li> <li><code>crypto_store</code>: the crypto store for encrypted communication.</li> <li><code>restricted_to_protocols</code>: the set of protocols ids of the only supported protocols for this connection.</li> <li><code>excluded_protocols</code>: the set of protocols ids that we want to exclude for this connection.</li> <li><code>kwargs</code>: keyword arguments passed to connection base</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#put_envelope","title":"put<code>_</code>envelope","text":"<pre><code>def put_envelope(envelope: Optional[\"Envelope\"]) -&gt; None\n</code></pre> <p>Put envelope in to the incoming queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#connect_1","title":"connect","text":"<pre><code>async def connect() -&gt; None\n</code></pre> <p>Connect connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#disconnect_1","title":"disconnect","text":"<pre><code>async def disconnect() -&gt; None\n</code></pre> <p>Disconnect connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#send_1","title":"send","text":"<pre><code>async def send(envelope: \"Envelope\") -&gt; None\n</code></pre> <p>Send envelope to connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#receive_1","title":"receive","text":"<pre><code>async def receive(*args: Any, **kwargs: Any) -&gt; Optional[\"Envelope\"]\n</code></pre> <p>Get an envelope from the connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#start_main","title":"start<code>_</code>main","text":"<pre><code>def start_main() -&gt; None\n</code></pre> <p>Start main function of the connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#main","title":"main","text":"<pre><code>def main() -&gt; None\n</code></pre> <p>Run main body of the connection in dedicated thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#on_connect","title":"on<code>_</code>connect","text":"<pre><code>@abstractmethod\ndef on_connect() -&gt; None\n</code></pre> <p>Run on connect method called.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#on_disconnect","title":"on<code>_</code>disconnect","text":"<pre><code>@abstractmethod\ndef on_disconnect() -&gt; None\n</code></pre> <p>Run on disconnect method called.</p> <p></p>"},{"location":"aea-framework-documentation/api/connections/base/#on_send","title":"on<code>_</code>send","text":"<pre><code>@abstractmethod\ndef on_send(envelope: \"Envelope\") -&gt; None\n</code></pre> <p>Run on send method called.</p>"},{"location":"aea-framework-documentation/api/context/base/","title":"Context","text":""},{"location":"aea-framework-documentation/api/context/base/#aeacontextbase","title":"aea.context.base","text":"<p>This module contains the agent context class.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#agentcontext-objects","title":"AgentContext Objects","text":"<pre><code>class AgentContext()\n</code></pre> <p>Provide read access to relevant objects of the agent for the skills.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(identity: Identity,\nconnection_status: MultiplexerStatus,\noutbox: OutBox,\ndecision_maker_message_queue: Queue,\ndecision_maker_handler_context: SimpleNamespace,\ntask_manager: TaskManager,\ndefault_ledger_id: str,\ncurrency_denominations: Dict[str, str],\ndefault_connection: Optional[PublicId],\ndefault_routing: Dict[PublicId, PublicId],\nsearch_service_address: Address,\ndecision_maker_address: Address,\ndata_dir: str,\nstorage_callable: Callable[[], Optional[Storage]] = lambda: None,\nsend_to_skill: Optional[Callable] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize an agent context.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity object</li> <li><code>connection_status</code>: the connection status of the multiplexer</li> <li><code>outbox</code>: the outbox</li> <li><code>decision_maker_message_queue</code>: the (in) queue of the decision maker</li> <li><code>decision_maker_handler_context</code>: the decision maker's name space</li> <li><code>task_manager</code>: the task manager</li> <li><code>default_ledger_id</code>: the default ledger id</li> <li><code>currency_denominations</code>: mapping from ledger ids to currency denominations</li> <li><code>default_connection</code>: the default connection</li> <li><code>default_routing</code>: the default routing</li> <li><code>search_service_address</code>: the address of the search service</li> <li><code>decision_maker_address</code>: the address of the decision maker</li> <li><code>data_dir</code>: directory where to put local files.</li> <li><code>storage_callable</code>: function that returns optional storage attached to agent.</li> <li><code>send_to_skill</code>: callable for sending envelopes to skills.</li> <li><code>kwargs</code>: keyword arguments to be attached in the agent context namespace.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#send_to_skill","title":"send<code>_</code>to<code>_</code>skill","text":"<pre><code>def send_to_skill(message_or_envelope: Union[Message, Envelope],\ncontext: Optional[EnvelopeContext] = None) -&gt; None\n</code></pre> <p>Send message or envelope to another skill.</p> <p>If message passed it will be wrapped into envelope with optional envelope context.</p> <p>Arguments:</p> <ul> <li><code>message_or_envelope</code>: envelope to send to another skill.</li> <li><code>context</code>: the optional envelope context</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#storage","title":"storage","text":"<pre><code>@property\ndef storage() -&gt; Optional[Storage]\n</code></pre> <p>Return storage instance if enabled in AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#data_dir","title":"data<code>_</code>dir","text":"<pre><code>@property\ndef data_dir() -&gt; str\n</code></pre> <p>Return assets directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#shared_state","title":"shared<code>_</code>state","text":"<pre><code>@property\ndef shared_state() -&gt; Dict[str, Any]\n</code></pre> <p>Get the shared state dictionary.</p> <p>The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills.</p> <p>Returns:</p> <p>dictionary of the shared state.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#identity","title":"identity","text":"<pre><code>@property\ndef identity() -&gt; Identity\n</code></pre> <p>Get the identity.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#agent_name","title":"agent<code>_</code>name","text":"<pre><code>@property\ndef agent_name() -&gt; str\n</code></pre> <p>Get agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#addresses","title":"addresses","text":"<pre><code>@property\ndef addresses() -&gt; Dict[str, Address]\n</code></pre> <p>Get addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#public_keys","title":"public<code>_</code>keys","text":"<pre><code>@property\ndef public_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get public keys.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; Address\n</code></pre> <p>Get the default address.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Get the default public key.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#connection_status","title":"connection<code>_</code>status","text":"<pre><code>@property\ndef connection_status() -&gt; MultiplexerStatus\n</code></pre> <p>Get connection status of the multiplexer.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#outbox","title":"outbox","text":"<pre><code>@property\ndef outbox() -&gt; OutBox\n</code></pre> <p>Get outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#decision_maker_message_queue","title":"decision<code>_</code>maker<code>_</code>message<code>_</code>queue","text":"<pre><code>@property\ndef decision_maker_message_queue() -&gt; Queue\n</code></pre> <p>Get decision maker queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#decision_maker_handler_context","title":"decision<code>_</code>maker<code>_</code>handler<code>_</code>context","text":"<pre><code>@property\ndef decision_maker_handler_context() -&gt; SimpleNamespace\n</code></pre> <p>Get the decision maker handler context.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#task_manager","title":"task<code>_</code>manager","text":"<pre><code>@property\ndef task_manager() -&gt; TaskManager\n</code></pre> <p>Get the task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#search_service_address","title":"search<code>_</code>service<code>_</code>address","text":"<pre><code>@property\ndef search_service_address() -&gt; Address\n</code></pre> <p>Get the address of the search service.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#decision_maker_address","title":"decision<code>_</code>maker<code>_</code>address","text":"<pre><code>@property\ndef decision_maker_address() -&gt; Address\n</code></pre> <p>Get the address of the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#default_ledger_id","title":"default<code>_</code>ledger<code>_</code>id","text":"<pre><code>@property\ndef default_ledger_id() -&gt; str\n</code></pre> <p>Get the default ledger id.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#currency_denominations","title":"currency<code>_</code>denominations","text":"<pre><code>@property\ndef currency_denominations() -&gt; Dict[str, str]\n</code></pre> <p>Get a dictionary mapping ledger ids to currency denominations.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#default_connection","title":"default<code>_</code>connection","text":"<pre><code>@property\ndef default_connection() -&gt; Optional[PublicId]\n</code></pre> <p>Get the default connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#default_routing","title":"default<code>_</code>routing","text":"<pre><code>@property\ndef default_routing() -&gt; Dict[PublicId, PublicId]\n</code></pre> <p>Get the default routing.</p> <p></p>"},{"location":"aea-framework-documentation/api/context/base/#namespace","title":"namespace","text":"<pre><code>@property\ndef namespace() -&gt; SimpleNamespace\n</code></pre> <p>Get the agent context namespace.</p>"},{"location":"aea-framework-documentation/api/contracts/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/contracts/base/#aeacontractsbase","title":"aea.contracts.base","text":"<p>The base contract.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#contract-objects","title":"Contract Objects","text":"<pre><code>class Contract(Component)\n</code></pre> <p>Abstract definition of a contract.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(contract_config: ContractConfig, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the contract.</p> <p>Arguments:</p> <ul> <li><code>contract_config</code>: the contract configurations.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#id","title":"id","text":"<pre><code>@property\ndef id() -&gt; PublicId\n</code></pre> <p>Get the name.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#configuration","title":"configuration","text":"<pre><code>@property\ndef configuration() -&gt; ContractConfig\n</code></pre> <p>Get the configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#get_instance","title":"get<code>_</code>instance","text":"<pre><code>@classmethod\ndef get_instance(cls,\nledger_api: LedgerApi,\ncontract_address: Optional[str] = None) -&gt; Any\n</code></pre> <p>Get the instance.</p> <p>Arguments:</p> <ul> <li><code>ledger_api</code>: the ledger api we are using.</li> <li><code>contract_address</code>: the contract address.</li> </ul> <p>Returns:</p> <p>the contract instance</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#from_dir","title":"from<code>_</code>dir","text":"<pre><code>@classmethod\ndef from_dir(cls, directory: str, **kwargs: Any) -&gt; \"Contract\"\n</code></pre> <p>Load the protocol from a directory.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the directory to the skill package.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the contract object.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#from_config","title":"from<code>_</code>config","text":"<pre><code>@classmethod\ndef from_config(cls, configuration: ContractConfig,\n**kwargs: Any) -&gt; \"Contract\"\n</code></pre> <p>Load contract from configuration.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the contract configuration.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the contract object.</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#get_deploy_transaction","title":"get<code>_</code>deploy<code>_</code>transaction","text":"<pre><code>@classmethod\ndef get_deploy_transaction(cls, ledger_api: LedgerApi, deployer_address: str,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Handler method for the 'GET_DEPLOY_TRANSACTION' requests.</p> <p>Implement this method in the sub class if you want to handle the contract requests manually.</p> <p>Arguments:</p> <ul> <li><code>ledger_api</code>: the ledger apis.</li> <li><code>deployer_address</code>: The address that will deploy the contract.</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p>Returns:</p> <p>the tx</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#get_raw_transaction","title":"get<code>_</code>raw<code>_</code>transaction","text":"<pre><code>@classmethod\ndef get_raw_transaction(cls, ledger_api: LedgerApi, contract_address: str,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Handler method for the 'GET_RAW_TRANSACTION' requests.</p> <p>Implement this method in the sub class if you want to handle the contract requests manually.</p> <p>Arguments:</p> <ul> <li><code>ledger_api</code>: the ledger apis.</li> <li><code>contract_address</code>: the contract address.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the tx  # noqa: DAR202</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#get_raw_message","title":"get<code>_</code>raw<code>_</code>message","text":"<pre><code>@classmethod\ndef get_raw_message(cls, ledger_api: LedgerApi, contract_address: str,\n**kwargs: Any) -&gt; Optional[bytes]\n</code></pre> <p>Handler method for the 'GET_RAW_MESSAGE' requests.</p> <p>Implement this method in the sub class if you want to handle the contract requests manually.</p> <p>Arguments:</p> <ul> <li><code>ledger_api</code>: the ledger apis.</li> <li><code>contract_address</code>: the contract address.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the tx  # noqa: DAR202</p> <p></p>"},{"location":"aea-framework-documentation/api/contracts/base/#get_state","title":"get<code>_</code>state","text":"<pre><code>@classmethod\ndef get_state(cls, ledger_api: LedgerApi, contract_address: str,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Handler method for the 'GET_STATE' requests.</p> <p>Implement this method in the sub class if you want to handle the contract requests manually.</p> <p>Arguments:</p> <ul> <li><code>ledger_api</code>: the ledger apis.</li> <li><code>contract_address</code>: the contract address.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the tx  # noqa: DAR202</p>"},{"location":"aea-framework-documentation/api/crypto/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/crypto/base/#aeacryptobase","title":"aea.crypto.base","text":"<p>Abstract module wrapping the public and private key cryptography and ledger api.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#crypto-objects","title":"Crypto Objects","text":"<pre><code>class Crypto(Generic[EntityClass], ABC)\n</code></pre> <p>Base class for a crypto object.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(private_key_path: Optional[str] = None,\npassword: Optional[str] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the crypto object.</p> <p>The actual behaviour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property.</p> <p>Arguments:</p> <ul> <li><code>private_key_path</code>: the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#generate_private_key","title":"generate<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\n@abstractmethod\ndef generate_private_key(cls) -&gt; EntityClass\n</code></pre> <p>Generate a private key.</p> <p>Returns:</p> <p>the entity object. Implementation dependent.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#load_private_key_from_path","title":"load<code>_</code>private<code>_</code>key<code>_</code>from<code>_</code>path","text":"<pre><code>@classmethod\n@abstractmethod\ndef load_private_key_from_path(cls,\nfile_name: str,\npassword: Optional[str] = None) -&gt; EntityClass\n</code></pre> <p>Load a private key in hex format for raw private key and json format for encrypted private key from a file.</p> <p>Arguments:</p> <ul> <li><code>file_name</code>: the path to the hex/json file.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the entity object.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#entity","title":"entity","text":"<pre><code>@property\ndef entity() -&gt; EntityClass\n</code></pre> <p>Return an entity object.</p> <p>Returns:</p> <p>an entity object</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#private_key","title":"private<code>_</code>key","text":"<pre><code>@property\n@abstractmethod\ndef private_key() -&gt; str\n</code></pre> <p>Return a private key.</p> <p>Returns:</p> <p>a private key string</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\n@abstractmethod\ndef public_key() -&gt; str\n</code></pre> <p>Return a public key.</p> <p>Returns:</p> <p>a public key string</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#address","title":"address","text":"<pre><code>@property\n@abstractmethod\ndef address() -&gt; str\n</code></pre> <p>Return the address.</p> <p>Returns:</p> <p>an address string</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#sign_message","title":"sign<code>_</code>message","text":"<pre><code>@abstractmethod\ndef sign_message(message: bytes, is_deprecated_mode: bool = False) -&gt; str\n</code></pre> <p>Sign a message in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be signed</li> <li><code>is_deprecated_mode</code>: if the deprecated signing is used</li> </ul> <p>Returns:</p> <p>signature of the message in string form</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#sign_transaction","title":"sign<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef sign_transaction(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Sign a transaction in dict form.</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction to be signed</li> </ul> <p>Returns:</p> <p>signed transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#load","title":"load","text":"<pre><code>@classmethod\ndef load(cls, private_key_file: str, password: Optional[str] = None) -&gt; str\n</code></pre> <p>Load private key from file.</p> <p>Arguments:</p> <ul> <li><code>private_key_file</code>: the file where the key is stored.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>private_key in hex string format</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#dump","title":"dump","text":"<pre><code>def dump(private_key_file: str, password: Optional[str] = None) -&gt; None\n</code></pre> <p>Dump private key to file.</p> <p>Arguments:</p> <ul> <li><code>private_key_file</code>: the file where the key is stored.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#encrypt","title":"encrypt","text":"<pre><code>@abstractmethod\ndef encrypt(password: str) -&gt; str\n</code></pre> <p>Encrypt the private key and return in json.</p> <p>Arguments:</p> <ul> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>json string containing encrypted private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#decrypt","title":"decrypt","text":"<pre><code>@classmethod\n@abstractmethod\ndef decrypt(cls, keyfile_json: str, password: str) -&gt; str\n</code></pre> <p>Decrypt the private key and return in raw form.</p> <p>Arguments:</p> <ul> <li><code>keyfile_json</code>: json string containing encrypted private key.</li> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>the raw private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#helper-objects","title":"Helper Objects","text":"<pre><code>class Helper(ABC)\n</code></pre> <p>Interface for helper class usable as Mixin for LedgerApi or as standalone class.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#is_transaction_settled","title":"is<code>_</code>transaction<code>_</code>settled","text":"<pre><code>@staticmethod\n@abstractmethod\ndef is_transaction_settled(tx_receipt: JSONLike) -&gt; bool\n</code></pre> <p>Check whether a transaction is settled or not.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt associated to the transaction.</li> </ul> <p>Returns:</p> <p>True if the transaction has been settled, False o/w.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#is_transaction_valid","title":"is<code>_</code>transaction<code>_</code>valid","text":"<pre><code>@staticmethod\n@abstractmethod\ndef is_transaction_valid(tx: JSONLike, seller: Address, client: Address,\ntx_nonce: str, amount: int) -&gt; bool\n</code></pre> <p>Check whether a transaction is valid or not.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction.</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> <li><code>tx_nonce</code>: the transaction nonce.</li> <li><code>amount</code>: the amount we expect to get from the transaction.</li> </ul> <p>Returns:</p> <p>True if the random_message is equals to tx['input']</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_contract_address","title":"get<code>_</code>contract<code>_</code>address","text":"<pre><code>@staticmethod\n@abstractmethod\ndef get_contract_address(tx_receipt: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Get the contract address from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the transaction digest</li> </ul> <p>Returns:</p> <p>the contract address if successful</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#generate_tx_nonce","title":"generate<code>_</code>tx<code>_</code>nonce","text":"<pre><code>@staticmethod\n@abstractmethod\ndef generate_tx_nonce(seller: Address, client: Address) -&gt; str\n</code></pre> <p>Generate a unique hash to distinguish transactions with the same terms.</p> <p>Arguments:</p> <ul> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> </ul> <p>Returns:</p> <p>return the hash in hex.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_address_from_public_key","title":"get<code>_</code>address<code>_</code>from<code>_</code>public<code>_</code>key","text":"<pre><code>@classmethod\n@abstractmethod\ndef get_address_from_public_key(cls, public_key: str) -&gt; str\n</code></pre> <p>Get the address from the public key.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key</li> </ul> <p>Returns:</p> <p>str</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#recover_message","title":"recover<code>_</code>message","text":"<pre><code>@classmethod\n@abstractmethod\ndef recover_message(cls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[Address, ...]\n</code></pre> <p>Recover the addresses from the hash.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message we expect</li> <li><code>signature</code>: the transaction signature</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered addresses</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#recover_public_keys_from_message","title":"recover<code>_</code>public<code>_</code>keys<code>_</code>from<code>_</code>message","text":"<pre><code>@classmethod\n@abstractmethod\ndef recover_public_keys_from_message(\ncls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[str, ...]\n</code></pre> <p>Get the public key used to produce the <code>signature</code> of the <code>message</code></p> <p>Arguments:</p> <ul> <li><code>message</code>: raw bytes used to produce signature</li> <li><code>signature</code>: signature of the message</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered public keys</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\n@abstractmethod\ndef get_hash(message: bytes) -&gt; str\n</code></pre> <p>Get the hash of a message.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be hashed.</li> </ul> <p>Returns:</p> <p>the hash of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#is_valid_address","title":"is<code>_</code>valid<code>_</code>address","text":"<pre><code>@classmethod\n@abstractmethod\ndef is_valid_address(cls, address: Address) -&gt; bool\n</code></pre> <p>Check if the address is valid.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address to validate</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#load_contract_interface","title":"load<code>_</code>contract<code>_</code>interface","text":"<pre><code>@classmethod\n@abstractmethod\ndef load_contract_interface(cls, file_path: Path) -&gt; Dict[str, str]\n</code></pre> <p>Load contract interface.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path to the interface</li> </ul> <p>Returns:</p> <p>the interface</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#ledgerapi-objects","title":"LedgerApi Objects","text":"<pre><code>class LedgerApi(Helper, ABC)\n</code></pre> <p>Interface for ledger APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#api","title":"api","text":"<pre><code>@property\n@abstractmethod\ndef api() -&gt; Any\n</code></pre> <p>Get the underlying API object.</p> <p>This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_balance","title":"get<code>_</code>balance","text":"<pre><code>@abstractmethod\ndef get_balance(address: Address) -&gt; Optional[int]\n</code></pre> <p>Get the balance of a given account.</p> <p>This usually takes the form of a web request to be waited synchronously.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> </ul> <p>Returns:</p> <p>the balance.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_state","title":"get<code>_</code>state","text":"<pre><code>@abstractmethod\ndef get_state(callable_name: str, *args: Any,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Call a specified function on the underlying ledger API.</p> <p>This usually takes the form of a web request to be waited synchronously.</p> <p>Arguments:</p> <ul> <li><code>callable_name</code>: the name of the API function to be called.</li> <li><code>args</code>: the positional arguments for the API function.</li> <li><code>kwargs</code>: the keyword arguments for the API function.</li> </ul> <p>Returns:</p> <p>the ledger API response.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_transfer_transaction","title":"get<code>_</code>transfer<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef get_transfer_transaction(sender_address: Address,\ndestination_address: Address, amount: int,\ntx_fee: int, tx_nonce: str,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Submit a transfer transaction to the ledger.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the payer.</li> <li><code>destination_address</code>: the destination address of the payee.</li> <li><code>amount</code>: the amount of wealth to be transferred.</li> <li><code>tx_fee</code>: the transaction fee.</li> <li><code>tx_nonce</code>: verifies the authenticity of the tx</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the transfer transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#send_signed_transaction","title":"send<code>_</code>signed<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef send_signed_transaction(tx_signed: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Send a signed transaction and wait for confirmation.</p> <p>Use keyword arguments for the specifying the signed transaction payload.</p> <p>Arguments:</p> <ul> <li><code>tx_signed</code>: the signed transaction</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_transaction_receipt","title":"get<code>_</code>transaction<code>_</code>receipt","text":"<pre><code>@abstractmethod\ndef get_transaction_receipt(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction receipt for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx receipt, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_transaction","title":"get<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef get_transaction(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_contract_instance","title":"get<code>_</code>contract<code>_</code>instance","text":"<pre><code>@abstractmethod\ndef get_contract_instance(contract_interface: Dict[str, str],\ncontract_address: Optional[str] = None) -&gt; Any\n</code></pre> <p>Get the instance of a contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>contract_address</code>: the contract address.</li> </ul> <p>Returns:</p> <p>the contract instance</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_deploy_transaction","title":"get<code>_</code>deploy<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef get_deploy_transaction(contract_interface: Dict[str, str],\ndeployer_address: Address,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction to deploy the smart contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>deployer_address</code>: The address that will deploy the contract.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p><code>tx</code>: the transaction dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#update_with_gas_estimate","title":"update<code>_</code>with<code>_</code>gas<code>_</code>estimate","text":"<pre><code>@abstractmethod\ndef update_with_gas_estimate(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Attempts to update the transaction with a gas estimate</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction</li> </ul> <p>Returns:</p> <p>the updated transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#faucetapi-objects","title":"FaucetApi Objects","text":"<pre><code>class FaucetApi(ABC)\n</code></pre> <p>Interface for testnet faucet APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/base/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>@abstractmethod\ndef get_wealth(address: Address, url: Optional[str] = None) -&gt; None\n</code></pre> <p>Get wealth from the faucet for the provided address.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> <li><code>url</code>: the url</li> </ul> <p>Returns:</p> <p>None</p>"},{"location":"aea-framework-documentation/api/crypto/helpers/","title":"Helpers","text":""},{"location":"aea-framework-documentation/api/crypto/helpers/#aeacryptohelpers","title":"aea.crypto.helpers","text":"<p>Module wrapping the helpers of public and private key cryptography.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#try_validate_private_key_path","title":"try<code>_</code>validate<code>_</code>private<code>_</code>key<code>_</code>path","text":"<pre><code>def try_validate_private_key_path(ledger_id: str,\nprivate_key_path: str,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Try validate a private key path.</p> <p>Arguments:</p> <ul> <li><code>ledger_id</code>: one of 'fetchai', 'ethereum'</li> <li><code>private_key_path</code>: the path to the private key.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if the identifier is invalid.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#create_private_key","title":"create<code>_</code>private<code>_</code>key","text":"<pre><code>def create_private_key(ledger_id: str,\nprivate_key_file: str,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Create a private key for the specified ledger identifier.</p> <p>Arguments:</p> <ul> <li><code>ledger_id</code>: the ledger identifier.</li> <li><code>private_key_file</code>: the private key file.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if the identifier is invalid.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#try_generate_testnet_wealth","title":"try<code>_</code>generate<code>_</code>testnet<code>_</code>wealth","text":"<pre><code>def try_generate_testnet_wealth(identifier: str,\naddress: str,\nurl: Optional[str] = None,\n_sync: bool = True) -&gt; None\n</code></pre> <p>Try generate wealth on a testnet.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>address</code>: the address to check for</li> <li><code>url</code>: the url</li> <li><code>_sync</code>: whether to wait to sync or not; currently unused</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#private_key_verify","title":"private<code>_</code>key<code>_</code>verify","text":"<pre><code>def private_key_verify(aea_conf: AgentConfig,\naea_project_path: Path,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Check key.</p> <p>Arguments:</p> <ul> <li><code>aea_conf</code>: AgentConfig</li> <li><code>aea_project_path</code>: Path, where project placed.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#make_certificate","title":"make<code>_</code>certificate","text":"<pre><code>def make_certificate(ledger_id: str,\ncrypto_private_key_path: str,\nmessage: bytes,\noutput_path: str,\npassword: Optional[str] = None) -&gt; str\n</code></pre> <p>Create certificate.</p> <p>Arguments:</p> <ul> <li><code>ledger_id</code>: the ledger id</li> <li><code>crypto_private_key_path</code>: the path to the private key.</li> <li><code>message</code>: the message to be signed.</li> <li><code>output_path</code>: the location where to save the certificate.</li> <li><code>password</code>: the password to encrypt/decrypt the private keys.</li> </ul> <p>Returns:</p> <p>the signature/certificate</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#get_wallet_from_agent_config","title":"get<code>_</code>wallet<code>_</code>from<code>_</code>agent<code>_</code>config","text":"<pre><code>def get_wallet_from_agent_config(agent_config: AgentConfig,\npassword: Optional[str] = None) -&gt; Wallet\n</code></pre> <p>Get wallet from agent_cofig provided.</p> <p>Arguments:</p> <ul> <li><code>agent_config</code>: the agent configuration object</li> <li><code>password</code>: the password to encrypt/decrypt the private keys.</li> </ul> <p>Returns:</p> <p>wallet</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#decrypterror-objects","title":"DecryptError Objects","text":"<pre><code>class DecryptError(ValueError)\n</code></pre> <p>Error on bytes decryption with password.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(msg: Optional[str] = None) -&gt; None\n</code></pre> <p>Init exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#keyisincorrect-objects","title":"KeyIsIncorrect Objects","text":"<pre><code>class KeyIsIncorrect(ValueError)\n</code></pre> <p>Error decoding hex string to bytes for private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/helpers/#hex_to_bytes_for_key","title":"hex<code>_</code>to<code>_</code>bytes<code>_</code>for<code>_</code>key","text":"<pre><code>def hex_to_bytes_for_key(data: str) -&gt; bytes\n</code></pre> <p>Convert hex string to bytes with error handling.</p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/","title":"LedgerApis","text":""},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#aeacryptoledger_apis","title":"aea.crypto.ledger<code>_</code>apis","text":"<p>Module wrapping all the public and private keys cryptography.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#ledgerapis-objects","title":"LedgerApis Objects","text":"<pre><code>class LedgerApis()\n</code></pre> <p>Store all the ledger apis we initialise.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#has_ledger","title":"has<code>_</code>ledger","text":"<pre><code>@staticmethod\ndef has_ledger(identifier: str) -&gt; bool\n</code></pre> <p>Check if it has the api.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_api","title":"get<code>_</code>api","text":"<pre><code>@classmethod\ndef get_api(cls, identifier: str) -&gt; LedgerApi\n</code></pre> <p>Get the ledger API.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_balance","title":"get<code>_</code>balance","text":"<pre><code>@classmethod\ndef get_balance(cls, identifier: str, address: str) -&gt; Optional[int]\n</code></pre> <p>Get the token balance.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>address</code>: the address to check for</li> </ul> <p>Returns:</p> <p>the token balance</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_transfer_transaction","title":"get<code>_</code>transfer<code>_</code>transaction","text":"<pre><code>@classmethod\ndef get_transfer_transaction(cls, identifier: str, sender_address: str,\ndestination_address: str, amount: int,\ntx_fee: int, tx_nonce: str,\n**kwargs: Any) -&gt; Optional[Any]\n</code></pre> <p>Get a transaction to transfer from self to destination.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>sender_address</code>: the address of the sender</li> <li><code>destination_address</code>: the address of the receiver</li> <li><code>amount</code>: the amount</li> <li><code>tx_nonce</code>: verifies the authenticity of the tx</li> <li><code>tx_fee</code>: the tx fee</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>tx</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#send_signed_transaction","title":"send<code>_</code>signed<code>_</code>transaction","text":"<pre><code>@classmethod\ndef send_signed_transaction(cls, identifier: str,\ntx_signed: Any) -&gt; Optional[str]\n</code></pre> <p>Send a signed transaction and wait for confirmation.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>tx_signed</code>: the signed transaction</li> </ul> <p>Returns:</p> <p>the tx_digest, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_transaction_receipt","title":"get<code>_</code>transaction<code>_</code>receipt","text":"<pre><code>@classmethod\ndef get_transaction_receipt(cls, identifier: str,\ntx_digest: str) -&gt; Optional[Any]\n</code></pre> <p>Get the transaction receipt for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx receipt, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_transaction","title":"get<code>_</code>transaction","text":"<pre><code>@classmethod\ndef get_transaction(cls, identifier: str, tx_digest: str) -&gt; Optional[Any]\n</code></pre> <p>Get the transaction for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_contract_address","title":"get<code>_</code>contract<code>_</code>address","text":"<pre><code>@staticmethod\ndef get_contract_address(identifier: str,\ntx_receipt: Any) -&gt; Optional[Address]\n</code></pre> <p>Get the contract address from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>tx_receipt</code>: the transaction receipt</li> </ul> <p>Returns:</p> <p>the contract address if successful</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#is_transaction_settled","title":"is<code>_</code>transaction<code>_</code>settled","text":"<pre><code>@staticmethod\ndef is_transaction_settled(identifier: str, tx_receipt: Any) -&gt; bool\n</code></pre> <p>Check whether the transaction is settled and correct.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: the identifier of the ledger</li> <li><code>tx_receipt</code>: the transaction digest</li> </ul> <p>Returns:</p> <p>True if correctly settled, False otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#is_transaction_valid","title":"is<code>_</code>transaction<code>_</code>valid","text":"<pre><code>@staticmethod\ndef is_transaction_valid(identifier: str, tx: Any, seller: Address,\nclient: Address, tx_nonce: str, amount: int) -&gt; bool\n</code></pre> <p>Check whether the transaction is valid.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: Ledger identifier</li> <li><code>tx</code>: the transaction</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> <li><code>tx_nonce</code>: the transaction nonce.</li> <li><code>amount</code>: the amount we expect to get from the transaction.</li> </ul> <p>Returns:</p> <p>True if is valid , False otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#generate_tx_nonce","title":"generate<code>_</code>tx<code>_</code>nonce","text":"<pre><code>@staticmethod\ndef generate_tx_nonce(identifier: str, seller: Address,\nclient: Address) -&gt; str\n</code></pre> <p>Generate a random str message.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: ledger identifier.</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> </ul> <p>Returns:</p> <p>return the hash in hex.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#recover_message","title":"recover<code>_</code>message","text":"<pre><code>@staticmethod\ndef recover_message(identifier: str,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[Address, ...]\n</code></pre> <p>Recover the addresses from the hash.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: ledger identifier.</li> <li><code>message</code>: the message we expect</li> <li><code>signature</code>: the transaction signature</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered addresses</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\ndef get_hash(identifier: str, message: bytes) -&gt; str\n</code></pre> <p>Get the hash of a message.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: ledger identifier.</li> <li><code>message</code>: the message to be hashed.</li> </ul> <p>Returns:</p> <p>the hash of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/ledger_apis/#is_valid_address","title":"is<code>_</code>valid<code>_</code>address","text":"<pre><code>@staticmethod\ndef is_valid_address(identifier: str, address: Address) -&gt; bool\n</code></pre> <p>Check if the address is valid.</p> <p>Arguments:</p> <ul> <li><code>identifier</code>: ledger identifier.</li> <li><code>address</code>: the address to validate.</li> </ul> <p>Returns:</p> <p>whether it is a valid address or not.</p>"},{"location":"aea-framework-documentation/api/crypto/plugin/","title":"Plugin","text":""},{"location":"aea-framework-documentation/api/crypto/plugin/#aeacryptoplugin","title":"aea.crypto.plugin","text":"<p>Implementation of plug-in mechanism for cryptos.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#plugin-objects","title":"Plugin Objects","text":"<pre><code>class Plugin()\n</code></pre> <p>Class that implements an AEA plugin.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(group: str, entry_point: EntryPoint)\n</code></pre> <p>Initialize the plugin.</p> <p>Arguments:</p> <ul> <li><code>group</code>: the group the plugin belongs to.</li> <li><code>entry_point</code>: the entrypoint.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the plugin identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#group","title":"group","text":"<pre><code>@property\ndef group() -&gt; str\n</code></pre> <p>Get the group.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#attr","title":"attr","text":"<pre><code>@property\ndef attr() -&gt; str\n</code></pre> <p>Get the class name.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#entry_point_path","title":"entry<code>_</code>point<code>_</code>path","text":"<pre><code>@property\ndef entry_point_path() -&gt; str\n</code></pre> <p>Get the entry point path.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/plugin/#load_all_plugins","title":"load<code>_</code>all<code>_</code>plugins","text":"<pre><code>def load_all_plugins(is_raising_exception: bool = True) -&gt; None\n</code></pre> <p>Load all plugins.</p>"},{"location":"aea-framework-documentation/api/crypto/wallet/","title":"Wallet","text":""},{"location":"aea-framework-documentation/api/crypto/wallet/#aeacryptowallet","title":"aea.crypto.wallet","text":"<p>Module wrapping all the public and private keys cryptography.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#cryptostore-objects","title":"CryptoStore Objects","text":"<pre><code>class CryptoStore()\n</code></pre> <p>Utility class to store and retrieve crypto objects.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(crypto_id_to_path: Optional[Dict[str, Optional[str]]] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Initialize the crypto store.</p> <p>Arguments:</p> <ul> <li><code>crypto_id_to_path</code>: dictionary from crypto id to an (optional) path to the private key.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#public_keys","title":"public<code>_</code>keys","text":"<pre><code>@property\ndef public_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get the public_key dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#crypto_objects","title":"crypto<code>_</code>objects","text":"<pre><code>@property\ndef crypto_objects() -&gt; Dict[str, Crypto]\n</code></pre> <p>Get the crypto objects (key pair).</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#addresses","title":"addresses","text":"<pre><code>@property\ndef addresses() -&gt; Dict[str, str]\n</code></pre> <p>Get the crypto addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#private_keys","title":"private<code>_</code>keys","text":"<pre><code>@property\ndef private_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get the crypto addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#wallet-objects","title":"Wallet Objects","text":"<pre><code>class Wallet()\n</code></pre> <p>Container for crypto objects.</p> <p>The cryptos are separated into two categories:</p> <ul> <li>main cryptos: used by the AEA for the economic side (i.e. signing transaction)</li> <li>connection cryptos: exposed to the connection objects for encrypted communication.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nprivate_key_paths: Dict[str, Optional[str]],\nconnection_private_key_paths: Optional[Dict[str,\nOptional[str]]] = None,\npassword: Optional[str] = None)\n</code></pre> <p>Instantiate a wallet object.</p> <p>Arguments:</p> <ul> <li><code>private_key_paths</code>: the private key paths</li> <li><code>connection_private_key_paths</code>: the private key paths for the connections.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#public_keys_1","title":"public<code>_</code>keys","text":"<pre><code>@property\ndef public_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get the public_key dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#crypto_objects_1","title":"crypto<code>_</code>objects","text":"<pre><code>@property\ndef crypto_objects() -&gt; Dict[str, Crypto]\n</code></pre> <p>Get the crypto objects (key pair).</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#addresses_1","title":"addresses","text":"<pre><code>@property\ndef addresses() -&gt; Dict[str, str]\n</code></pre> <p>Get the crypto addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#private_keys_1","title":"private<code>_</code>keys","text":"<pre><code>@property\ndef private_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get the crypto addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#main_cryptos","title":"main<code>_</code>cryptos","text":"<pre><code>@property\ndef main_cryptos() -&gt; CryptoStore\n</code></pre> <p>Get the main crypto store.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#connection_cryptos","title":"connection<code>_</code>cryptos","text":"<pre><code>@property\ndef connection_cryptos() -&gt; CryptoStore\n</code></pre> <p>Get the connection crypto store.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#sign_message","title":"sign<code>_</code>message","text":"<pre><code>def sign_message(crypto_id: str,\nmessage: bytes,\nis_deprecated_mode: bool = False) -&gt; Optional[str]\n</code></pre> <p>Sign a message.</p> <p>Arguments:</p> <ul> <li><code>crypto_id</code>: the id of the crypto</li> <li><code>message</code>: the message to be signed</li> <li><code>is_deprecated_mode</code>: what signing mode to use</li> </ul> <p>Returns:</p> <p>the signature of the message</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/wallet/#sign_transaction","title":"sign<code>_</code>transaction","text":"<pre><code>def sign_transaction(crypto_id: str, transaction: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Sign a tx.</p> <p>Arguments:</p> <ul> <li><code>crypto_id</code>: the id of the crypto</li> <li><code>transaction</code>: the transaction to be signed</li> </ul> <p>Returns:</p> <p>the signed tx</p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/crypto/registries/base/#aeacryptoregistriesbase","title":"aea.crypto.registries.base","text":"<p>This module implements the base registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#itemid-objects","title":"ItemId Objects","text":"<pre><code>class ItemId(RegexConstrainedString)\n</code></pre> <p>The identifier of an item class.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the id name.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#entrypoint-objects","title":"EntryPoint Objects","text":"<pre><code>class EntryPoint(Generic[ItemType], RegexConstrainedString)\n</code></pre> <p>The entry point for a resource.</p> <p>The regular expression matches the strings in the following format:</p> <pre><code>path.to.module:className\n</code></pre> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(seq: Union[\"EntryPoint\", str]) -&gt; None\n</code></pre> <p>Initialize the entrypoint.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#import_path","title":"import<code>_</code>path","text":"<pre><code>@property\ndef import_path() -&gt; str\n</code></pre> <p>Get the import path.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#class_name","title":"class<code>_</code>name","text":"<pre><code>@property\ndef class_name() -&gt; str\n</code></pre> <p>Get the class name.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#load","title":"load","text":"<pre><code>def load() -&gt; Type[ItemType]\n</code></pre> <p>Load the item object.</p> <p>Returns:</p> <p>the crypto object, loaded following the spec.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#itemspec-objects","title":"ItemSpec Objects","text":"<pre><code>class ItemSpec(Generic[ItemType])\n</code></pre> <p>A specification for a particular instance of an object.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(id_: ItemId,\nentry_point: EntryPoint[ItemType],\nclass_kwargs: Optional[Dict[str, Any]] = None,\n**kwargs: Dict) -&gt; None\n</code></pre> <p>Initialize an item specification.</p> <p>Arguments:</p> <ul> <li><code>id_</code>: the id associated to this specification</li> <li><code>entry_point</code>: The Python entry_point of the environment class (e.g. module.name:Class).</li> <li><code>class_kwargs</code>: keyword arguments to be attached on the class as class variables.</li> <li><code>kwargs</code>: other custom keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#make","title":"make","text":"<pre><code>def make(**kwargs: Any) -&gt; ItemType\n</code></pre> <p>Instantiate an instance of the item object with appropriate arguments.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: the key word arguments</li> </ul> <p>Returns:</p> <p>an item</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#get_class","title":"get<code>_</code>class","text":"<pre><code>def get_class() -&gt; Type[ItemType]\n</code></pre> <p>Get the class of the item with class variables instantiated.</p> <p>Returns:</p> <p>an item class</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#registry-objects","title":"Registry Objects","text":"<pre><code>class Registry(Generic[ItemType])\n</code></pre> <p>Registry for generic classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Initialize the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#supported_ids","title":"supported<code>_</code>ids","text":"<pre><code>@property\ndef supported_ids() -&gt; Set[str]\n</code></pre> <p>Get the supported item ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#register","title":"register","text":"<pre><code>def register(id_: Union[ItemId, str],\nentry_point: Union[EntryPoint[ItemType], str],\nclass_kwargs: Optional[Dict[str, Any]] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Register an item type.</p> <p>Arguments:</p> <ul> <li><code>id_</code>: the identifier for the crypto type.</li> <li><code>entry_point</code>: the entry point to load the crypto object.</li> <li><code>class_kwargs</code>: keyword arguments to be attached on the class as class variables.</li> <li><code>kwargs</code>: arguments to provide to the crypto class.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#make_1","title":"make","text":"<pre><code>def make(id_: Union[ItemId, str],\nmodule: Optional[str] = None,\n**kwargs: Any) -&gt; ItemType\n</code></pre> <p>Create an instance of the associated type item id.</p> <p>Arguments:</p> <ul> <li><code>id_</code>: the id of the item class. Make sure it has been registered earlier before calling this function.</li> <li><code>module</code>: dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/init.py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier.</li> <li><code>kwargs</code>: keyword arguments to be forwarded to the object.</li> </ul> <p>Returns:</p> <p>the new item instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#make_cls","title":"make<code>_</code>cls","text":"<pre><code>def make_cls(id_: Union[ItemId, str],\nmodule: Optional[str] = None) -&gt; Type[ItemType]\n</code></pre> <p>Load a class of the associated type item id.</p> <p>Arguments:</p> <ul> <li><code>id_</code>: the id of the item class. Make sure it has been registered earlier before calling this function.</li> <li><code>module</code>: dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/init.py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier.</li> </ul> <p>Returns:</p> <p>the new item class.</p> <p></p>"},{"location":"aea-framework-documentation/api/crypto/registries/base/#has_spec","title":"has<code>_</code>spec","text":"<pre><code>def has_spec(item_id: ItemId) -&gt; bool\n</code></pre> <p>Check whether there exist a spec associated with an item id.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the item identifier.</li> </ul> <p>Returns:</p> <p>True if it is registered, False otherwise.</p>"},{"location":"aea-framework-documentation/api/decision_maker/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/decision_maker/base/#aeadecision_makerbase","title":"aea.decision<code>_</code>maker.base","text":"<p>This module contains the decision maker class.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#ownershipstate-objects","title":"OwnershipState Objects","text":"<pre><code>class OwnershipState(ABC)\n</code></pre> <p>Represent the ownership state of an agent (can proxy a ledger).</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#set","title":"set","text":"<pre><code>@abstractmethod\ndef set(**kwargs: Any) -&gt; None\n</code></pre> <p>Set values on the ownership state.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: the relevant keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#apply_delta","title":"apply<code>_</code>delta","text":"<pre><code>@abstractmethod\ndef apply_delta(**kwargs: Any) -&gt; None\n</code></pre> <p>Apply a state update to the ownership state.</p> <p>This method is used to apply a raw state update without a transaction.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: the relevant keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#is_initialized","title":"is<code>_</code>initialized","text":"<pre><code>@property\n@abstractmethod\ndef is_initialized() -&gt; bool\n</code></pre> <p>Get the initialization status.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#is_affordable_transaction","title":"is<code>_</code>affordable<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef is_affordable_transaction(terms: Terms) -&gt; bool\n</code></pre> <p>Check if the transaction is affordable (and consistent).</p> <p>Arguments:</p> <ul> <li><code>terms</code>: the transaction terms</li> </ul> <p>Returns:</p> <p>True if the transaction is legal wrt the current state, false otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#apply_transactions","title":"apply<code>_</code>transactions","text":"<pre><code>@abstractmethod\ndef apply_transactions(list_of_terms: List[Terms]) -&gt; \"OwnershipState\"\n</code></pre> <p>Apply a list of transactions to (a copy of) the current state.</p> <p>Arguments:</p> <ul> <li><code>list_of_terms</code>: the sequence of transaction terms.</li> </ul> <p>Returns:</p> <p>the final state.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#__copy__","title":"<code>__</code>copy<code>__</code>","text":"<pre><code>@abstractmethod\ndef __copy__() -&gt; \"OwnershipState\"\n</code></pre> <p>Copy the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#preferences-objects","title":"Preferences Objects","text":"<pre><code>class Preferences(ABC)\n</code></pre> <p>Class to represent the preferences.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#set_1","title":"set","text":"<pre><code>@abstractmethod\ndef set(**kwargs: Any) -&gt; None\n</code></pre> <p>Set values on the preferences.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: the relevant key word arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#is_initialized_1","title":"is<code>_</code>initialized","text":"<pre><code>@property\n@abstractmethod\ndef is_initialized() -&gt; bool\n</code></pre> <p>Get the initialization status.</p> <p>Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#marginal_utility","title":"marginal<code>_</code>utility","text":"<pre><code>@abstractmethod\ndef marginal_utility(ownership_state: OwnershipState, **kwargs: Any) -&gt; float\n</code></pre> <p>Compute the marginal utility.</p> <p>Arguments:</p> <ul> <li><code>ownership_state</code>: the ownership state against which to compute the marginal utility.</li> <li><code>kwargs</code>: optional keyword arguments</li> </ul> <p>Returns:</p> <p>the marginal utility score</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#utility_diff_from_transaction","title":"utility<code>_</code>diff<code>_</code>from<code>_</code>transaction","text":"<pre><code>@abstractmethod\ndef utility_diff_from_transaction(ownership_state: OwnershipState,\nterms: Terms) -&gt; float\n</code></pre> <p>Simulate a transaction and get the resulting utility difference (taking into account the fee).</p> <p>Arguments:</p> <ul> <li><code>ownership_state</code>: the ownership state against which to apply the transaction.</li> <li><code>terms</code>: the transaction terms.</li> </ul> <p>Returns:</p> <p>the score.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#__copy___1","title":"<code>__</code>copy<code>__</code>","text":"<pre><code>@abstractmethod\ndef __copy__() -&gt; \"Preferences\"\n</code></pre> <p>Copy the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#protectedqueue-objects","title":"ProtectedQueue Objects","text":"<pre><code>class ProtectedQueue(Queue)\n</code></pre> <p>A wrapper of a queue to protect which object can read from it.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(access_code: str) -&gt; None\n</code></pre> <p>Initialize the protected queue.</p> <p>Arguments:</p> <ul> <li><code>access_code</code>: the access code to read from the queue</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#put","title":"put","text":"<pre><code>def put(internal_message: Optional[Message],\nblock: bool = True,\ntimeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Put an internal message on the queue.</p> <p>If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).</p> <p>Arguments:</p> <ul> <li><code>internal_message</code>: the internal message to put on the queue</li> <li><code>block</code>: whether to block or not</li> <li><code>timeout</code>: timeout on block</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError, if the item is not an internal message</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#put_nowait","title":"put<code>_</code>nowait","text":"<pre><code>def put_nowait(internal_message: Optional[Message]) -&gt; None\n</code></pre> <p>Put an internal message on the queue.</p> <p>Equivalent to put(item, False).</p> <p>Arguments:</p> <ul> <li><code>internal_message</code>: the internal message to put on the queue</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError, if the item is not an internal message</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#get","title":"get","text":"<pre><code>def get(block: bool = True, timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Inaccessible get method.</p> <p>Arguments:</p> <ul> <li><code>block</code>: whether to block or not</li> <li><code>timeout</code>: timeout on block</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError, access not permitted.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#get_nowait","title":"get<code>_</code>nowait","text":"<pre><code>def get_nowait() -&gt; None\n</code></pre> <p>Inaccessible get_nowait method.</p> <p>Raises:</p> <ul> <li><code>None</code>: ValueError, access not permitted.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#protected_get","title":"protected<code>_</code>get","text":"<pre><code>def protected_get(access_code: str,\nblock: bool = True,\ntimeout: Optional[float] = None) -&gt; Optional[Message]\n</code></pre> <p>Access protected get method.</p> <p>Arguments:</p> <ul> <li><code>access_code</code>: the access code</li> <li><code>block</code>: If optional args block is true and timeout is None (the default), block if necessary until an item is available.</li> <li><code>timeout</code>: If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError, if caller is not permitted</li> </ul> <p>Returns:</p> <p>internal message</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#decisionmakerhandler-objects","title":"DecisionMakerHandler Objects","text":"<pre><code>class DecisionMakerHandler(WithLogger, ABC)\n</code></pre> <p>This class implements the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(identity: Identity, wallet: Wallet, config: Dict[str, Any],\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the decision maker handler.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity</li> <li><code>wallet</code>: the wallet</li> <li><code>config</code>: the user defined configuration of the handler</li> <li><code>kwargs</code>: the key word arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#agent_name","title":"agent<code>_</code>name","text":"<pre><code>@property\ndef agent_name() -&gt; str\n</code></pre> <p>Get the agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#identity","title":"identity","text":"<pre><code>@property\ndef identity() -&gt; Identity\n</code></pre> <p>Get identity of the agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#wallet","title":"wallet","text":"<pre><code>@property\ndef wallet() -&gt; Wallet\n</code></pre> <p>Get wallet of the agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#config","title":"config","text":"<pre><code>@property\ndef config() -&gt; Dict[str, Any]\n</code></pre> <p>Get user defined configuration</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#context","title":"context","text":"<pre><code>@property\ndef context() -&gt; SimpleNamespace\n</code></pre> <p>Get the context.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#message_out_queue","title":"message<code>_</code>out<code>_</code>queue","text":"<pre><code>@property\ndef message_out_queue() -&gt; AsyncFriendlyQueue\n</code></pre> <p>Get (out) queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#handle","title":"handle","text":"<pre><code>@abstractmethod\ndef handle(message: Message) -&gt; None\n</code></pre> <p>Handle an internal message from the skills.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the internal message</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#decisionmaker-objects","title":"DecisionMaker Objects","text":"<pre><code>class DecisionMaker(WithLogger)\n</code></pre> <p>This class implements the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(decision_maker_handler: DecisionMakerHandler) -&gt; None\n</code></pre> <p>Initialize the decision maker.</p> <p>Arguments:</p> <ul> <li><code>decision_maker_handler</code>: the decision maker handler</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#agent_name_1","title":"agent<code>_</code>name","text":"<pre><code>@property\ndef agent_name() -&gt; str\n</code></pre> <p>Get the agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#message_in_queue","title":"message<code>_</code>in<code>_</code>queue","text":"<pre><code>@property\ndef message_in_queue() -&gt; ProtectedQueue\n</code></pre> <p>Get (in) queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#message_out_queue_1","title":"message<code>_</code>out<code>_</code>queue","text":"<pre><code>@property\ndef message_out_queue() -&gt; AsyncFriendlyQueue\n</code></pre> <p>Get (out) queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#decision_maker_handler","title":"decision<code>_</code>maker<code>_</code>handler","text":"<pre><code>@property\ndef decision_maker_handler() -&gt; DecisionMakerHandler\n</code></pre> <p>Get the decision maker handler.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#execute","title":"execute","text":"<pre><code>def execute() -&gt; None\n</code></pre> <p>Execute the decision maker.</p> <p>Performs the following while not stopped:</p> <ul> <li>gets internal messages from the in queue and calls handle() on them</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/base/#handle_1","title":"handle","text":"<pre><code>def handle(message: Message) -&gt; None\n</code></pre> <p>Handle an internal message from the skills.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the internal message</li> </ul>"},{"location":"aea-framework-documentation/api/decision_maker/default/","title":"Default","text":""},{"location":"aea-framework-documentation/api/decision_maker/default/#aeadecision_makerdefault","title":"aea.decision<code>_</code>maker.default","text":"<p>This module contains the decision maker class.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/default/#decisionmakerhandler-objects","title":"DecisionMakerHandler Objects","text":"<pre><code>class DecisionMakerHandler(BaseDecisionMakerHandler)\n</code></pre> <p>This class implements the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/default/#signingdialogues-objects","title":"SigningDialogues Objects","text":"<pre><code>class SigningDialogues(BaseSigningDialogues)\n</code></pre> <p>This class keeps track of all oef_search dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/default/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/default/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(identity: Identity, wallet: Wallet, config: Dict[str,\nAny]) -&gt; None\n</code></pre> <p>Initialize the decision maker.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity</li> <li><code>wallet</code>: the wallet</li> <li><code>config</code>: the user defined configuration of the handler</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/default/#handle","title":"handle","text":"<pre><code>def handle(message: Message) -&gt; None\n</code></pre> <p>Handle an internal message from the skills.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the internal message</li> </ul>"},{"location":"aea-framework-documentation/api/decision_maker/gop/","title":"GOP","text":""},{"location":"aea-framework-documentation/api/decision_maker/gop/#aeadecision_makergop","title":"aea.decision<code>_</code>maker.gop","text":"<p>This module contains the decision maker class.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#goalpursuitreadiness-objects","title":"GoalPursuitReadiness Objects","text":"<pre><code>class GoalPursuitReadiness()\n</code></pre> <p>The goal pursuit readiness.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#status-objects","title":"Status Objects","text":"<pre><code>class Status(Enum)\n</code></pre> <p>The enum of the readiness status.</p> <p>In particular, it can be one of the following:</p> <ul> <li>Status.READY: when the agent is ready to pursuit its goal</li> <li>Status.NOT_READY: when the agent is not ready to pursuit its goal</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Instantiate the goal pursuit readiness.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_ready","title":"is<code>_</code>ready","text":"<pre><code>@property\ndef is_ready() -&gt; bool\n</code></pre> <p>Get the readiness.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#update","title":"update","text":"<pre><code>def update(new_status: Status) -&gt; None\n</code></pre> <p>Update the goal pursuit readiness.</p> <p>Arguments:</p> <ul> <li><code>new_status</code>: the new status</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#ownershipstate-objects","title":"OwnershipState Objects","text":"<pre><code>class OwnershipState(BaseOwnershipState)\n</code></pre> <p>Represent the ownership state of an agent (can proxy a ledger).</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Instantiate an ownership state object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#set","title":"set","text":"<pre><code>def set(amount_by_currency_id: CurrencyHoldings = None,\nquantities_by_good_id: GoodHoldings = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Set values on the ownership state.</p> <p>Arguments:</p> <ul> <li><code>amount_by_currency_id</code>: the currency endowment of the agent in this state.</li> <li><code>quantities_by_good_id</code>: the good endowment of the agent in this state.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#apply_delta","title":"apply<code>_</code>delta","text":"<pre><code>def apply_delta(delta_amount_by_currency_id: Dict[str, int] = None,\ndelta_quantities_by_good_id: Dict[str, int] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Apply a state update to the ownership state.</p> <p>This method is used to apply a raw state update without a transaction.</p> <p>Arguments:</p> <ul> <li><code>delta_amount_by_currency_id</code>: the delta in the currency amounts</li> <li><code>delta_quantities_by_good_id</code>: the delta in the quantities by good</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_initialized","title":"is<code>_</code>initialized","text":"<pre><code>@property\ndef is_initialized() -&gt; bool\n</code></pre> <p>Get the initialization status.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#amount_by_currency_id","title":"amount<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef amount_by_currency_id() -&gt; CurrencyHoldings\n</code></pre> <p>Get currency holdings in this state.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#quantities_by_good_id","title":"quantities<code>_</code>by<code>_</code>good<code>_</code>id","text":"<pre><code>@property\ndef quantities_by_good_id() -&gt; GoodHoldings\n</code></pre> <p>Get good holdings in this state.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_affordable_transaction","title":"is<code>_</code>affordable<code>_</code>transaction","text":"<pre><code>def is_affordable_transaction(terms: Terms) -&gt; bool\n</code></pre> <p>Check if the transaction is affordable (and consistent).</p> <p>E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design.</p> <p>Arguments:</p> <ul> <li><code>terms</code>: the transaction terms</li> </ul> <p>Returns:</p> <p>True if the transaction is legal wrt the current state, false otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_affordable","title":"is<code>_</code>affordable","text":"<pre><code>def is_affordable(terms: Terms) -&gt; bool\n</code></pre> <p>Check if the tx is affordable.</p> <p>Arguments:</p> <ul> <li><code>terms</code>: the transaction terms</li> </ul> <p>Returns:</p> <p>whether the transaction is affordable or not</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#update_1","title":"update","text":"<pre><code>def update(terms: Terms) -&gt; None\n</code></pre> <p>Update the agent state from a transaction.</p> <p>Arguments:</p> <ul> <li><code>terms</code>: the transaction terms</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#apply_transactions","title":"apply<code>_</code>transactions","text":"<pre><code>def apply_transactions(list_of_terms: List[Terms]) -&gt; \"OwnershipState\"\n</code></pre> <p>Apply a list of transactions to (a copy of) the current state.</p> <p>Arguments:</p> <ul> <li><code>list_of_terms</code>: the sequence of transaction terms.</li> </ul> <p>Returns:</p> <p>the final state.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__copy__","title":"<code>__</code>copy<code>__</code>","text":"<pre><code>def __copy__() -&gt; \"OwnershipState\"\n</code></pre> <p>Copy the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#preferences-objects","title":"Preferences Objects","text":"<pre><code>class Preferences(BasePreferences)\n</code></pre> <p>Class to represent the preferences.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Instantiate an agent preference object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#set_1","title":"set","text":"<pre><code>def set(exchange_params_by_currency_id: ExchangeParams = None,\nutility_params_by_good_id: UtilityParams = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Set values on the preferences.</p> <p>Arguments:</p> <ul> <li><code>exchange_params_by_currency_id</code>: the exchange params.</li> <li><code>utility_params_by_good_id</code>: the utility params for every asset.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_initialized_1","title":"is<code>_</code>initialized","text":"<pre><code>@property\ndef is_initialized() -&gt; bool\n</code></pre> <p>Get the initialization status.</p> <p>Returns:</p> <p>True if exchange_params_by_currency_id and utility_params_by_good_id are not None.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#exchange_params_by_currency_id","title":"exchange<code>_</code>params<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef exchange_params_by_currency_id() -&gt; ExchangeParams\n</code></pre> <p>Get exchange parameter for each currency.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#utility_params_by_good_id","title":"utility<code>_</code>params<code>_</code>by<code>_</code>good<code>_</code>id","text":"<pre><code>@property\ndef utility_params_by_good_id() -&gt; UtilityParams\n</code></pre> <p>Get utility parameter for each good.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#logarithmic_utility","title":"logarithmic<code>_</code>utility","text":"<pre><code>def logarithmic_utility(quantities_by_good_id: GoodHoldings) -&gt; float\n</code></pre> <p>Compute agent's utility given her utility function params and a good bundle.</p> <p>Arguments:</p> <ul> <li><code>quantities_by_good_id</code>: the good holdings (dictionary) with the identifier (key) and quantity (value) for each good</li> </ul> <p>Returns:</p> <p>utility value</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#linear_utility","title":"linear<code>_</code>utility","text":"<pre><code>def linear_utility(amount_by_currency_id: CurrencyHoldings) -&gt; float\n</code></pre> <p>Compute agent's utility given her utility function params and a currency bundle.</p> <p>Arguments:</p> <ul> <li><code>amount_by_currency_id</code>: the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency</li> </ul> <p>Returns:</p> <p>utility value</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#utility","title":"utility","text":"<pre><code>def utility(quantities_by_good_id: GoodHoldings,\namount_by_currency_id: CurrencyHoldings) -&gt; float\n</code></pre> <p>Compute the utility given the good and currency holdings.</p> <p>Arguments:</p> <ul> <li><code>quantities_by_good_id</code>: the good holdings</li> <li><code>amount_by_currency_id</code>: the currency holdings</li> </ul> <p>Returns:</p> <p>the utility value.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#marginal_utility","title":"marginal<code>_</code>utility","text":"<pre><code>def marginal_utility(\nownership_state: BaseOwnershipState,\ndelta_quantities_by_good_id: Optional[GoodHoldings] = None,\ndelta_amount_by_currency_id: Optional[CurrencyHoldings] = None,\n**kwargs: Any) -&gt; float\n</code></pre> <p>Compute the marginal utility.</p> <p>Arguments:</p> <ul> <li><code>ownership_state</code>: the ownership state against which to compute the marginal utility.</li> <li><code>delta_quantities_by_good_id</code>: the change in good holdings</li> <li><code>delta_amount_by_currency_id</code>: the change in money holdings</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p>Returns:</p> <p>the marginal utility score</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#utility_diff_from_transaction","title":"utility<code>_</code>diff<code>_</code>from<code>_</code>transaction","text":"<pre><code>def utility_diff_from_transaction(ownership_state: BaseOwnershipState,\nterms: Terms) -&gt; float\n</code></pre> <p>Simulate a transaction and get the resulting utility difference (taking into account the fee).</p> <p>Arguments:</p> <ul> <li><code>ownership_state</code>: the ownership state against which to apply the transaction.</li> <li><code>terms</code>: the transaction terms.</li> </ul> <p>Returns:</p> <p>the score.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#is_utility_enhancing","title":"is<code>_</code>utility<code>_</code>enhancing","text":"<pre><code>def is_utility_enhancing(ownership_state: BaseOwnershipState,\nterms: Terms) -&gt; bool\n</code></pre> <p>Check if the tx is utility enhancing.</p> <p>Arguments:</p> <ul> <li><code>ownership_state</code>: the ownership state against which to apply the transaction.</li> <li><code>terms</code>: the transaction terms</li> </ul> <p>Returns:</p> <p>whether the transaction is utility enhancing or not</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__copy___1","title":"<code>__</code>copy<code>__</code>","text":"<pre><code>def __copy__() -&gt; \"Preferences\"\n</code></pre> <p>Copy the object.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#decisionmakerhandler-objects","title":"DecisionMakerHandler Objects","text":"<pre><code>class DecisionMakerHandler(BaseDecisionMakerHandler)\n</code></pre> <p>This class implements the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#signingdialogues-objects","title":"SigningDialogues Objects","text":"<pre><code>class SigningDialogues(BaseSigningDialogues)\n</code></pre> <p>This class keeps track of all oef_search dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#stateupdatedialogues-objects","title":"StateUpdateDialogues Objects","text":"<pre><code>class StateUpdateDialogues(BaseStateUpdateDialogues)\n</code></pre> <p>This class keeps track of all oef_search dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(identity: Identity, wallet: Wallet, config: Dict[str,\nAny]) -&gt; None\n</code></pre> <p>Initialize the decision maker.</p> <p>Arguments:</p> <ul> <li><code>identity</code>: the identity</li> <li><code>wallet</code>: the wallet</li> <li><code>config</code>: the user defined configuration of the handler</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/decision_maker/gop/#handle","title":"handle","text":"<pre><code>def handle(message: Message) -&gt; None\n</code></pre> <p>Handle an internal message from the skills.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the internal message</li> </ul>"},{"location":"aea-framework-documentation/api/error_handler/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/error_handler/base/#aeaerror_handlerbase","title":"aea.error<code>_</code>handler.base","text":"<p>This module contains the abstract error handler class.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#abstracterrorhandler-objects","title":"AbstractErrorHandler Objects","text":"<pre><code>class AbstractErrorHandler(ABC)\n</code></pre> <p>Error handler class for handling problematic envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any)\n</code></pre> <p>Instantiate error handler.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#config","title":"config","text":"<pre><code>@property\ndef config() -&gt; Dict[str, Any]\n</code></pre> <p>Get handler config.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#send_unsupported_protocol","title":"send<code>_</code>unsupported<code>_</code>protocol","text":"<pre><code>@abstractmethod\ndef send_unsupported_protocol(envelope: Envelope, logger: Logger) -&gt; None\n</code></pre> <p>Handle the received envelope in case the protocol is not supported.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>logger</code>: the logger</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#send_decoding_error","title":"send<code>_</code>decoding<code>_</code>error","text":"<pre><code>@abstractmethod\ndef send_decoding_error(envelope: Envelope, exception: Exception,\nlogger: Logger) -&gt; None\n</code></pre> <p>Handle a decoding error.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>exception</code>: the exception raised during decoding</li> <li><code>logger</code>: the logger</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/base/#send_no_active_handler","title":"send<code>_</code>no<code>_</code>active<code>_</code>handler","text":"<pre><code>@abstractmethod\ndef send_no_active_handler(envelope: Envelope, reason: str,\nlogger: Logger) -&gt; None\n</code></pre> <p>Handle the received envelope in case the handler is not supported.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>reason</code>: the reason for the failure</li> <li><code>logger</code>: the logger</li> </ul> <p>Returns:</p> <p>None</p>"},{"location":"aea-framework-documentation/api/error_handler/default/","title":"Default","text":""},{"location":"aea-framework-documentation/api/error_handler/default/#aeaerror_handlerdefault","title":"aea.error<code>_</code>handler.default","text":"<p>This module contains the default error handler class.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/default/#errorhandler-objects","title":"ErrorHandler Objects","text":"<pre><code>class ErrorHandler(AbstractErrorHandler)\n</code></pre> <p>Error handler class for handling problematic envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/default/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any)\n</code></pre> <p>Instantiate error handler.</p> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/default/#send_unsupported_protocol","title":"send<code>_</code>unsupported<code>_</code>protocol","text":"<pre><code>def send_unsupported_protocol(envelope: Envelope, logger: Logger) -&gt; None\n</code></pre> <p>Handle the received envelope in case the protocol is not supported.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>logger</code>: the logger</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/default/#send_decoding_error","title":"send<code>_</code>decoding<code>_</code>error","text":"<pre><code>def send_decoding_error(envelope: Envelope, exception: Exception,\nlogger: Logger) -&gt; None\n</code></pre> <p>Handle a decoding error.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>exception</code>: the exception raised during decoding</li> <li><code>logger</code>: the logger</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/error_handler/default/#send_no_active_handler","title":"send<code>_</code>no<code>_</code>active<code>_</code>handler","text":"<pre><code>def send_no_active_handler(envelope: Envelope, reason: str,\nlogger: Logger) -&gt; None\n</code></pre> <p>Handle the received envelope in case the handler is not supported.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope</li> <li><code>reason</code>: the reason for the failure</li> <li><code>logger</code>: the logger</li> </ul>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/","title":"Async Friendly Queue","text":""},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#aeahelpersasync_friendly_queue","title":"aea.helpers.async<code>_</code>friendly<code>_</code>queue","text":"<p>This module contains the implementation of AsyncFriendlyQueue.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#asyncfriendlyqueue-objects","title":"AsyncFriendlyQueue Objects","text":"<pre><code>class AsyncFriendlyQueue(queue.Queue)\n</code></pre> <p>queue.Queue with async_get method.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Init queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#put","title":"put","text":"<pre><code>def put(item: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Put an item into the queue.</p> <p>Arguments:</p> <ul> <li><code>item</code>: item to put in the queue</li> <li><code>args</code>: similar to queue.Queue.put</li> <li><code>kwargs</code>: similar to queue.Queue.put</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#get","title":"get","text":"<pre><code>def get(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Get an item into the queue.</p> <p>Arguments:</p> <ul> <li><code>args</code>: similar to queue.Queue.get</li> <li><code>kwargs</code>: similar to queue.Queue.get</li> </ul> <p>Returns:</p> <p>similar to queue.Queue.get</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#async_wait","title":"async<code>_</code>wait","text":"<pre><code>async def async_wait() -&gt; None\n</code></pre> <p>Wait an item appears in the queue.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_friendly_queue/#async_get","title":"async<code>_</code>get","text":"<pre><code>async def async_get() -&gt; Any\n</code></pre> <p>Wait and get an item from the queue.</p> <p>Returns:</p> <p>item from queue</p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/","title":"Async Utils","text":""},{"location":"aea-framework-documentation/api/helpers/async_utils/#aeahelpersasync_utils","title":"aea.helpers.async<code>_</code>utils","text":"<p>This module contains the misc utils for async code.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#ensure_list","title":"ensure<code>_</code>list","text":"<pre><code>def ensure_list(value: Any) -&gt; List\n</code></pre> <p>Return [value] or list(value) if value is a sequence.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#asyncstate-objects","title":"AsyncState Objects","text":"<pre><code>class AsyncState()\n</code></pre> <p>Awaitable state.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(initial_state: Any = None,\nstates_enum: Optional[Container[Any]] = None) -&gt; None\n</code></pre> <p>Init async state.</p> <p>Arguments:</p> <ul> <li><code>initial_state</code>: state to set on start.</li> <li><code>states_enum</code>: container of valid states if not provided state not checked on set.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#set","title":"set","text":"<pre><code>def set(state: Any) -&gt; None\n</code></pre> <p>Set state.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#add_callback","title":"add<code>_</code>callback","text":"<pre><code>def add_callback(callback_fn: Callable[[Any], None]) -&gt; None\n</code></pre> <p>Add callback to track state changes.</p> <p>Arguments:</p> <ul> <li><code>callback_fn</code>: callable object to be called on state changed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#get","title":"get","text":"<pre><code>def get() -&gt; Any\n</code></pre> <p>Get state.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#wait","title":"wait","text":"<pre><code>async def wait(state_or_states: Union[Any, Sequence[Any]]) -&gt; Tuple[Any, Any]\n</code></pre> <p>Wait state to be set.</p> <p>Arguments:</p> <ul> <li><code>state_or_states</code>: state or list of states.</li> </ul> <p>Returns:</p> <p>tuple of previous state and new state.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#transit","title":"transit","text":"<pre><code>@contextmanager\ndef transit(initial: Any = not_set,\nsuccess: Any = not_set,\nfail: Any = not_set) -&gt; Generator\n</code></pre> <p>Change state context according to success or not.</p> <p>Arguments:</p> <ul> <li><code>initial</code>: set state on context enter, not_set by default</li> <li><code>success</code>: set state on context block done, not_set by default</li> <li><code>fail</code>: set state on context block raises exception, not_set by default</li> </ul> <p>Returns:</p> <p>generator</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#periodiccaller-objects","title":"PeriodicCaller Objects","text":"<pre><code>class PeriodicCaller()\n</code></pre> <p>Schedule a periodic call of callable using event loop.</p> <p>Used for periodic function run using asyncio.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(callback: Callable,\nperiod: float,\nstart_at: Optional[datetime.datetime] = None,\nexception_callback: Optional[Callable[[Callable, Exception],\nNone]] = None,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Init periodic caller.</p> <p>Arguments:</p> <ul> <li><code>callback</code>: function to call periodically</li> <li><code>period</code>: period in seconds.</li> <li><code>start_at</code>: optional first call datetime</li> <li><code>exception_callback</code>: optional handler to call on exception raised.</li> <li><code>loop</code>: optional asyncio event loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Activate period calls.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Remove from schedule.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#anotherthreadtask-objects","title":"AnotherThreadTask Objects","text":"<pre><code>class AnotherThreadTask()\n</code></pre> <p>Schedule a task to run on the loop in another thread.</p> <p>Provides better cancel behaviour: on cancel it will wait till cancelled completely.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(coro: Coroutine[Any, Any, Any], loop: AbstractEventLoop) -&gt; None\n</code></pre> <p>Init the task.</p> <p>Arguments:</p> <ul> <li><code>coro</code>: coroutine to schedule</li> <li><code>loop</code>: an event loop to schedule on.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#result","title":"result","text":"<pre><code>def result(timeout: Optional[float] = None) -&gt; Any\n</code></pre> <p>Wait for coroutine execution result.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: optional timeout to wait in seconds.</li> </ul> <p>Returns:</p> <p>result</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#cancel","title":"cancel","text":"<pre><code>def cancel() -&gt; None\n</code></pre> <p>Cancel coroutine task execution in a target loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#done","title":"done","text":"<pre><code>def done() -&gt; bool\n</code></pre> <p>Check task is done.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#threadedasyncrunner-objects","title":"ThreadedAsyncRunner Objects","text":"<pre><code>class ThreadedAsyncRunner(Thread)\n</code></pre> <p>Util to run thread with event loop and execute coroutines inside.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(loop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Init threaded runner.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: optional event loop. is it's running loop, threaded runner will use it.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#start_1","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start event loop in dedicated thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#run","title":"run","text":"<pre><code>def run() -&gt; None\n</code></pre> <p>Run code inside thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#call","title":"call","text":"<pre><code>def call(coro: Coroutine[Any, Any, Any]) -&gt; Any\n</code></pre> <p>Run a coroutine inside the event loop.</p> <p>Arguments:</p> <ul> <li><code>coro</code>: a coroutine to run.</li> </ul> <p>Returns:</p> <p>task</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#stop_1","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop event loop in thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#runnable-objects","title":"Runnable Objects","text":"<pre><code>class Runnable(ABC)\n</code></pre> <p>Abstract Runnable class.</p> <p>Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(loop: asyncio.AbstractEventLoop = None,\nthreaded: bool = False) -&gt; None\n</code></pre> <p>Init runnable.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: asyncio event loop to use.</li> <li><code>threaded</code>: bool. start in thread if True.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#start_2","title":"start","text":"<pre><code>def start() -&gt; bool\n</code></pre> <p>Start runnable.</p> <p>Returns:</p> <p>bool started or not.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Get running state.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#run_1","title":"run","text":"<pre><code>@abstractmethod\nasync def run() -&gt; Any\n</code></pre> <p>Implement run logic respectful to CancelError on termination.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#wait_completed","title":"wait<code>_</code>completed","text":"<pre><code>def wait_completed(sync: bool = False,\ntimeout: float = None,\nforce_result: bool = False) -&gt; Union[Coroutine, Awaitable]\n</code></pre> <p>Wait runnable execution completed.</p> <p>Arguments:</p> <ul> <li><code>sync</code>: bool. blocking wait</li> <li><code>timeout</code>: float seconds</li> <li><code>force_result</code>: check result even it was waited.</li> </ul> <p>Returns:</p> <p>awaitable if sync is False, otherwise None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#stop_2","title":"stop","text":"<pre><code>def stop(force: bool = False) -&gt; None\n</code></pre> <p>Stop runnable.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/async_utils/#start_and_wait_completed","title":"start<code>_</code>and<code>_</code>wait<code>_</code>completed","text":"<pre><code>def start_and_wait_completed(*args: Any,\n**kwargs: Any) -&gt; Union[Coroutine, Awaitable]\n</code></pre> <p>Alias for start and wait methods.</p>"},{"location":"aea-framework-documentation/api/helpers/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/base/#aeahelpersbase","title":"aea.helpers.base","text":"<p>Miscellaneous helpers.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#locate","title":"locate","text":"<pre><code>def locate(path: str) -&gt; Any\n</code></pre> <p>Locate an object by name or dotted save_path, importing as necessary.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#load_module","title":"load<code>_</code>module","text":"<pre><code>def load_module(dotted_path: str, filepath: Path) -&gt; types.ModuleType\n</code></pre> <p>Load a module.</p> <p>Arguments:</p> <ul> <li><code>dotted_path</code>: the dotted save_path of the package/module.</li> <li><code>filepath</code>: the file to the package/module.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the filepath provided is not a module.  # noqa: DAR402</li> <li><code>Exception</code>: if the execution of the module raises exception.  # noqa: DAR402</li> </ul> <p>Returns:</p> <p>module type</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#load_env_file","title":"load<code>_</code>env<code>_</code>file","text":"<pre><code>def load_env_file(env_file: str) -&gt; None\n</code></pre> <p>Load the content of the environment file into the process environment.</p> <p>Arguments:</p> <ul> <li><code>env_file</code>: save_path to the env file.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#sigint_crossplatform","title":"sigint<code>_</code>crossplatform","text":"<pre><code>def sigint_crossplatform(process: subprocess.Popen) -&gt; None\n</code></pre> <p>Send a SIGINT, cross-platform.</p> <p>The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method.</p> <p>However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms.</p> <p>Arguments:</p> <ul> <li><code>process</code>: the process to send the signal to.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#win_popen_kwargs","title":"win<code>_</code>popen<code>_</code>kwargs","text":"<pre><code>def win_popen_kwargs() -&gt; dict\n</code></pre> <p>Return kwargs to start a process in windows with new process group.</p> <p>Help to handle ctrl c properly. Return empty dict if platform is not win32</p> <p>Returns:</p> <p>windows popen kwargs</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#send_control_c","title":"send<code>_</code>control<code>_</code>c","text":"<pre><code>def send_control_c(process: subprocess.Popen,\nkill_group: bool = False) -&gt; None\n</code></pre> <p>Send ctrl-C cross-platform to terminate a subprocess.</p> <p>Arguments:</p> <ul> <li><code>process</code>: the process to send the signal to.</li> <li><code>kill_group</code>: whether or not to kill group</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#regexconstrainedstring-objects","title":"RegexConstrainedString Objects","text":"<pre><code>class RegexConstrainedString(UserString)\n</code></pre> <p>A string that is constrained by a regex.</p> <p>The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(seq: Union[UserString, str]) -&gt; None\n</code></pre> <p>Initialize a regex constrained string.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#simpleid-objects","title":"SimpleId Objects","text":"<pre><code>class SimpleId(RegexConstrainedString)\n</code></pre> <p>A simple identifier.</p> <p>The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits.</p> <p>Examples of allowed strings:</p> <p>SimpleId(\"an_identifier\") 'an_identifier'</p> <p>Examples of not allowed strings:</p> <p>SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')</p> <p>SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')</p> <p>SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value  does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#cd","title":"cd","text":"<pre><code>@contextlib.contextmanager\ndef cd(path: PathLike) -&gt; Generator\n</code></pre> <p>Change working directory temporarily.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#get_logger_method","title":"get<code>_</code>logger<code>_</code>method","text":"<pre><code>def get_logger_method(fn: Callable,\nlogger_method: Union[str, Callable]) -&gt; Callable\n</code></pre> <p>Get logger method for function.</p> <p>Get logger in <code>fn</code> definition module or creates logger is module.name. Or return logger_method if it's callable.</p> <p>Arguments:</p> <ul> <li><code>fn</code>: function to get logger for.</li> <li><code>logger_method</code>: logger name or callable.</li> </ul> <p>Returns:</p> <p>callable to write log with</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#try_decorator","title":"try<code>_</code>decorator","text":"<pre><code>def try_decorator(error_message: str,\ndefault_return: Callable = None,\nlogger_method: Any = \"error\") -&gt; Callable\n</code></pre> <p>Run function, log and return default value on exception.</p> <p>Does not support async or coroutines!</p> <p>Arguments:</p> <ul> <li><code>error_message</code>: message template with one <code>{}</code> for exception</li> <li><code>default_return</code>: value to return on exception, by default None</li> <li><code>logger_method</code>: name of the logger method or callable to print logs</li> </ul> <p>Returns:</p> <p>the callable</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#maxretrieserror-objects","title":"MaxRetriesError Objects","text":"<pre><code>class MaxRetriesError(Exception)\n</code></pre> <p>Exception for retry decorator.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#retry_decorator","title":"retry<code>_</code>decorator","text":"<pre><code>def retry_decorator(number_of_retries: int,\nerror_message: str,\ndelay: float = 0,\nlogger_method: str = \"error\") -&gt; Callable\n</code></pre> <p>Run function with several attempts.</p> <p>Does not support async or coroutines!</p> <p>Arguments:</p> <ul> <li><code>number_of_retries</code>: amount of attempts</li> <li><code>error_message</code>: message template with one <code>{}</code> for exception</li> <li><code>delay</code>: number of seconds to sleep between retries. default 0</li> <li><code>logger_method</code>: name of the logger method or callable to print logs</li> </ul> <p>Returns:</p> <p>the callable</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#exception_log_and_reraise","title":"exception<code>_</code>log<code>_</code>and<code>_</code>reraise","text":"<pre><code>@contextlib.contextmanager\ndef exception_log_and_reraise(log_method: Callable, message: str) -&gt; Generator\n</code></pre> <p>Run code in context to log and re raise exception.</p> <p>Arguments:</p> <ul> <li><code>log_method</code>: function to print log</li> <li><code>message</code>: message template to add error text.</li> </ul> <p>Returns:</p> <p>the generator</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#recursive_update","title":"recursive<code>_</code>update","text":"<pre><code>def recursive_update(to_update: Dict,\nnew_values: Dict,\nallow_new_values: bool = False) -&gt; None\n</code></pre> <p>Update a dictionary by replacing conflicts with the new values.</p> <p>It does side-effects to the first dictionary.</p> <p>to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}}</p> <p>Arguments:</p> <ul> <li><code>to_update</code>: the dictionary to update.</li> <li><code>new_values</code>: the dictionary of new values to replace.</li> <li><code>allow_new_values</code>: whether or not to allow new values.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#find_topological_order","title":"find<code>_</code>topological<code>_</code>order","text":"<pre><code>def find_topological_order(adjacency_list: Dict[T, Set[T]]) -&gt; List[T]\n</code></pre> <p>Compute the topological order of a graph (using Kahn's algorithm).</p> <p>Arguments:</p> <ul> <li><code>adjacency_list</code>: the adjacency list of the graph.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the graph contains a cycle.</li> </ul> <p>Returns:</p> <p>the topological order for the graph (as a sequence of nodes)</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#reachable_nodes","title":"reachable<code>_</code>nodes","text":"<pre><code>def reachable_nodes(adjacency_list: Dict[T, Set[T]],\nstarting_nodes: Set[T]) -&gt; Dict[T, Set[T]]\n</code></pre> <p>Find the reachable subgraph induced by a set of starting nodes.</p> <p>Arguments:</p> <ul> <li><code>adjacency_list</code>: the adjacency list of the full graph.</li> <li><code>starting_nodes</code>: the starting nodes of the new graph.</li> </ul> <p>Returns:</p> <p>the adjacency list of the subgraph.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#cached_property-objects","title":"cached<code>_</code>property Objects","text":"<pre><code>class cached_property()\n</code></pre> <p>Cached property from python3.8 functools.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(func: Callable) -&gt; None\n</code></pre> <p>Init cached property.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__set_name__","title":"<code>__</code>set<code>_</code>name<code>__</code>","text":"<pre><code>def __set_name__(_: Any, name: Any) -&gt; None\n</code></pre> <p>Set name.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__get__","title":"<code>__</code>get<code>__</code>","text":"<pre><code>def __get__(instance: Any, _: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Get instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#ensure_dir","title":"ensure<code>_</code>dir","text":"<pre><code>def ensure_dir(dir_path: str) -&gt; None\n</code></pre> <p>Check if dir_path is a directory or create it.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#dict_to_path_value","title":"dict<code>_</code>to<code>_</code>path<code>_</code>value","text":"<pre><code>def dict_to_path_value(\ndata: Mapping,\npath: Optional[List] = None) -&gt; Iterable[Tuple[List[str], Any]]\n</code></pre> <p>Convert dict to sequence of terminal path build of  keys and value.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#parse_datetime_from_str","title":"parse<code>_</code>datetime<code>_</code>from<code>_</code>str","text":"<pre><code>def parse_datetime_from_str(date_string: str) -&gt; datetime.datetime\n</code></pre> <p>Parse datetime from string.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#certrequest-objects","title":"CertRequest Objects","text":"<pre><code>class CertRequest()\n</code></pre> <p>Certificate request for proof of representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(public_key: str, identifier: SimpleIdOrStr,\nledger_id: SimpleIdOrStr, not_before: str, not_after: str,\nmessage_format: str, save_path: str) -&gt; None\n</code></pre> <p>Initialize the certificate request.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key, or the key id.</li> <li><code>identifier</code>: certificate identifier.</li> <li><code>ledger_id</code>: ledger identifier the request is referring to.</li> <li><code>not_before</code>: specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0.</li> <li><code>not_after</code>: specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0.</li> <li><code>message_format</code>: message format used for signing</li> <li><code>save_path</code>: the save_path where to save the certificate.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; Optional[str]\n</code></pre> <p>Get the public key.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#ledger_id","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the ledger id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#key_identifier","title":"key<code>_</code>identifier","text":"<pre><code>@property\ndef key_identifier() -&gt; Optional[str]\n</code></pre> <p>Get the key identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#identifier","title":"identifier","text":"<pre><code>@property\ndef identifier() -&gt; str\n</code></pre> <p>Get the identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#not_before_string","title":"not<code>_</code>before<code>_</code>string","text":"<pre><code>@property\ndef not_before_string() -&gt; str\n</code></pre> <p>Get the not_before field as string.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#not_after_string","title":"not<code>_</code>after<code>_</code>string","text":"<pre><code>@property\ndef not_after_string() -&gt; str\n</code></pre> <p>Get the not_after field as string.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#not_before","title":"not<code>_</code>before","text":"<pre><code>@property\ndef not_before() -&gt; datetime.datetime\n</code></pre> <p>Get the not_before field.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#not_after","title":"not<code>_</code>after","text":"<pre><code>@property\ndef not_after() -&gt; datetime.datetime\n</code></pre> <p>Get the not_after field.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#message_format","title":"message<code>_</code>format","text":"<pre><code>@property\ndef message_format() -&gt; str\n</code></pre> <p>Get the message format.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#save_path","title":"save<code>_</code>path","text":"<pre><code>@property\ndef save_path() -&gt; Path\n</code></pre> <p>Get the save path for the certificate.</p> <p>Note: if the path is not absolute, then the actual save path might depend on the context.</p> <p>Returns:</p> <p>the save path</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#get_absolute_save_path","title":"get<code>_</code>absolute<code>_</code>save<code>_</code>path","text":"<pre><code>def get_absolute_save_path(path_prefix: Optional[PathLike] = None) -&gt; Path\n</code></pre> <p>Get the absolute save path.</p> <p>If save_path is an absolute path, then the prefix is ignored. Otherwise, the path prefix is prepended.</p> <p>Arguments:</p> <ul> <li><code>path_prefix</code>: the (absolute) path to prepend to the save path.</li> </ul> <p>Returns:</p> <p>the actual save path.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#public_key_or_identifier","title":"public<code>_</code>key<code>_</code>or<code>_</code>identifier","text":"<pre><code>@property\ndef public_key_or_identifier() -&gt; str\n</code></pre> <p>Get the public key or identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#get_message","title":"get<code>_</code>message","text":"<pre><code>def get_message(public_key: str) -&gt; bytes\n</code></pre> <p>Get the message to sign.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#construct_message","title":"construct<code>_</code>message","text":"<pre><code>@classmethod\ndef construct_message(cls, public_key: str, identifier: SimpleIdOrStr,\nnot_before_string: str, not_after_string: str,\nmessage_format: str) -&gt; bytes\n</code></pre> <p>Construct message for singning.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key</li> <li><code>identifier</code>: identifier to be signed</li> <li><code>not_before_string</code>: signature not valid before</li> <li><code>not_after_string</code>: signature not valid after</li> <li><code>message_format</code>: message format used for signing</li> </ul> <p>Returns:</p> <p>the message</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#get_signature","title":"get<code>_</code>signature","text":"<pre><code>def get_signature(path_prefix: Optional[PathLike] = None) -&gt; str\n</code></pre> <p>Get signature from save_path.</p> <p>Arguments:</p> <ul> <li><code>path_prefix</code>: the path prefix to be prepended to save_path. Defaults to cwd.</li> </ul> <p>Returns:</p> <p>the signature.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#json","title":"json","text":"<pre><code>@property\ndef json() -&gt; Dict\n</code></pre> <p>Compute the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#from_json","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, obj: Dict) -&gt; \"CertRequest\"\n</code></pre> <p>Compute the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#compute_specifier_from_version","title":"compute<code>_</code>specifier<code>_</code>from<code>_</code>version","text":"<pre><code>def compute_specifier_from_version(version: Version) -&gt; str\n</code></pre> <p>Compute the specifier set from a version.</p> <p>version specifier is:  &gt;=major.minor.0, &lt;next_major.0.0</p> <p>Arguments:</p> <ul> <li><code>version</code>: the version</li> </ul> <p>Returns:</p> <p>the specifier set</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#decorator_with_optional_params","title":"decorator<code>_</code>with<code>_</code>optional<code>_</code>params","text":"<pre><code>def decorator_with_optional_params(decorator: Callable) -&gt; Callable\n</code></pre> <p>Make a decorator usable either with or without parameters.</p> <p>In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as:</p> <p>@mydecorator def myfunction():     ...</p> <p>or as:</p> <p>@mydecorator(arg1, kwarg1=\"value\") def myfunction():     ...</p> <p>Arguments:</p> <ul> <li><code>decorator</code>: a decorator callable</li> </ul> <p>Returns:</p> <p>a decorator callable</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#delete_directory_contents","title":"delete<code>_</code>directory<code>_</code>contents","text":"<pre><code>def delete_directory_contents(directory: Path) -&gt; None\n</code></pre> <p>Delete the content of a directory, without deleting it.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/base/#prepend_if_not_absolute","title":"prepend<code>_</code>if<code>_</code>not<code>_</code>absolute","text":"<pre><code>def prepend_if_not_absolute(path: PathLike, prefix: PathLike) -&gt; PathLike\n</code></pre> <p>Prepend a path with a prefix, but only if not absolute</p> <p>Arguments:</p> <ul> <li><code>path</code>: the path to process.</li> <li><code>prefix</code>: the path prefix.</li> </ul> <p>Returns:</p> <p>the same path if absolute, else the prepended path.</p>"},{"location":"aea-framework-documentation/api/helpers/constants/","title":"Constants","text":""},{"location":"aea-framework-documentation/api/helpers/constants/#aeahelpersconstants","title":"aea.helpers.constants","text":"<p>Module with helpers constants.</p>"},{"location":"aea-framework-documentation/api/helpers/env_vars/","title":"Env Vars","text":""},{"location":"aea-framework-documentation/api/helpers/env_vars/#aeahelpersenv_vars","title":"aea.helpers.env<code>_</code>vars","text":"<p>Implementation of the environment variables support.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/env_vars/#is_env_variable","title":"is<code>_</code>env<code>_</code>variable","text":"<pre><code>def is_env_variable(value: Any) -&gt; bool\n</code></pre> <p>Check is variable string with env variable pattern.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/env_vars/#replace_with_env_var","title":"replace<code>_</code>with<code>_</code>env<code>_</code>var","text":"<pre><code>def replace_with_env_var(value: str,\nenv_variables: dict,\ndefault_value: Any = NotSet) -&gt; JSON_TYPES\n</code></pre> <p>Replace env var with value.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/env_vars/#apply_env_variables","title":"apply<code>_</code>env<code>_</code>variables","text":"<pre><code>def apply_env_variables(data: Union[Dict, List[Dict]],\nenv_variables: Mapping[str, Any],\ndefault_value: Any = NotSet) -&gt; JSON_TYPES\n</code></pre> <p>Create new resulting dict with env variables applied.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/env_vars/#convert_value_str_to_type","title":"convert<code>_</code>value<code>_</code>str<code>_</code>to<code>_</code>type","text":"<pre><code>def convert_value_str_to_type(value: str, type_str: str) -&gt; JSON_TYPES\n</code></pre> <p>Convert value by type name to native python type.</p>"},{"location":"aea-framework-documentation/api/helpers/exception_policy/","title":"Exception Policy","text":""},{"location":"aea-framework-documentation/api/helpers/exception_policy/#aeahelpersexception_policy","title":"aea.helpers.exception<code>_</code>policy","text":"<p>This module contains enum of aea exception policies.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exception_policy/#exceptionpolicyenum-objects","title":"ExceptionPolicyEnum Objects","text":"<pre><code>class ExceptionPolicyEnum(Enum)\n</code></pre> <p>AEA Exception policies.</p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/","title":"Exec Timeout","text":""},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#aeahelpersexec_timeout","title":"aea.helpers.exec<code>_</code>timeout","text":"<p>Python code execution time limit tools.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#timeoutresult-objects","title":"TimeoutResult Objects","text":"<pre><code>class TimeoutResult()\n</code></pre> <p>Result of ExecTimeout context manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Init.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#set_cancelled_by_timeout","title":"set<code>_</code>cancelled<code>_</code>by<code>_</code>timeout","text":"<pre><code>def set_cancelled_by_timeout() -&gt; None\n</code></pre> <p>Set code was terminated cause timeout.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#is_cancelled_by_timeout","title":"is<code>_</code>cancelled<code>_</code>by<code>_</code>timeout","text":"<pre><code>def is_cancelled_by_timeout() -&gt; bool\n</code></pre> <p>Return True if code was terminated by ExecTimeout cause timeout.</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#timeoutexception-objects","title":"TimeoutException Objects","text":"<pre><code>class TimeoutException(BaseException)\n</code></pre> <p>TimeoutException raised by ExecTimeout context managers in thread with limited execution time.</p> <p>Used internally, does not propagated outside of context manager</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#baseexectimeout-objects","title":"BaseExecTimeout Objects","text":"<pre><code>class BaseExecTimeout(ABC)\n</code></pre> <p>Base class for implementing context managers to limit python code execution time.</p> <p>exception_class - is exception type to raise in code controlled in case of timeout.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(timeout: float = 0.0) -&gt; None\n</code></pre> <p>Init.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: number of seconds to execute code before interruption</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#__enter__","title":"<code>__</code>enter<code>__</code>","text":"<pre><code>def __enter__() -&gt; TimeoutResult\n</code></pre> <p>Enter context manager.</p> <p>Returns:</p> <p>TimeoutResult</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#__exit__","title":"<code>__</code>exit<code>__</code>","text":"<pre><code>def __exit__(exc_type: Type[Exception], exc_val: Exception,\nexc_tb: TracebackType) -&gt; None\n</code></pre> <p>Exit context manager.</p> <p>Arguments:</p> <ul> <li><code>exc_type</code>: the exception type</li> <li><code>exc_val</code>: the exception</li> <li><code>exc_tb</code>: the traceback</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#exectimeoutsigalarm-objects","title":"ExecTimeoutSigAlarm Objects","text":"<pre><code>class ExecTimeoutSigAlarm(BaseExecTimeout)\n</code></pre> <p>ExecTimeout context manager implementation using signals and SIGALARM.</p> <p>Does not support threads, have to be used only in main thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#exectimeoutthreadguard-objects","title":"ExecTimeoutThreadGuard Objects","text":"<pre><code>class ExecTimeoutThreadGuard(BaseExecTimeout)\n</code></pre> <p>ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc.</p> <p>Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(timeout: float = 0.0) -&gt; None\n</code></pre> <p>Init ExecTimeoutThreadGuard variables.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: number of seconds to execute code before interruption</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#start","title":"start","text":"<pre><code>@classmethod\ndef start(cls) -&gt; None\n</code></pre> <p>Start supervisor thread to check timeouts.</p> <p>Supervisor starts once but number of start counted.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/exec_timeout/#stop","title":"stop","text":"<pre><code>@classmethod\ndef stop(cls, force: bool = False) -&gt; None\n</code></pre> <p>Stop supervisor thread.</p> <p>Actual stop performed on force == True or if  number of stops == number of starts</p> <p>Arguments:</p> <ul> <li><code>force</code>: force stop regardless number of start.</li> </ul>"},{"location":"aea-framework-documentation/api/helpers/file_io/","title":"File IO","text":""},{"location":"aea-framework-documentation/api/helpers/file_io/#aeahelpersfile_io","title":"aea.helpers.file<code>_</code>io","text":"<p>Read to and write from file with envelopes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/file_io/#lock_file","title":"lock<code>_</code>file","text":"<pre><code>@contextmanager\ndef lock_file(file_descriptor: IO[bytes],\nlogger: Logger = _default_logger) -&gt; Generator\n</code></pre> <p>Lock file in context manager.</p> <p>Arguments:</p> <ul> <li><code>file_descriptor</code>: file descriptor of file to lock.</li> <li><code>logger</code>: the logger.</li> </ul> <p>Returns:</p> <p>generator</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/file_io/#write_envelope","title":"write<code>_</code>envelope","text":"<pre><code>def write_envelope(envelope: Envelope,\nfile_pointer: IO[bytes],\nseparator: bytes = SEPARATOR,\nlogger: Logger = _default_logger) -&gt; None\n</code></pre> <p>Write envelope to file.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/file_io/#write_with_lock","title":"write<code>_</code>with<code>_</code>lock","text":"<pre><code>def write_with_lock(file_pointer: IO[bytes],\ndata: Union[bytes],\nlogger: Logger = _default_logger) -&gt; None\n</code></pre> <p>Write bytes to file protected with file lock.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/file_io/#envelope_from_bytes","title":"envelope<code>_</code>from<code>_</code>bytes","text":"<pre><code>def envelope_from_bytes(\nbytes_: bytes,\nseparator: bytes = SEPARATOR,\nlogger: Logger = _default_logger) -&gt; Optional[Envelope]\n</code></pre> <p>Decode bytes to get the envelope.</p> <p>Arguments:</p> <ul> <li><code>bytes_</code>: the encoded envelope</li> <li><code>separator</code>: the separator used</li> <li><code>logger</code>: the logger</li> </ul> <p>Returns:</p> <p>Envelope</p>"},{"location":"aea-framework-documentation/api/helpers/file_lock/","title":"File Lock","text":""},{"location":"aea-framework-documentation/api/helpers/file_lock/#aeahelpersfile_lock","title":"aea.helpers.file<code>_</code>lock","text":"<p>Patch of 'fnctl' to make it compatible with Windows.</p>"},{"location":"aea-framework-documentation/api/helpers/http_requests/","title":"HttpRequests","text":""},{"location":"aea-framework-documentation/api/helpers/http_requests/#aeahelpershttp_requests","title":"aea.helpers.http<code>_</code>requests","text":"<p>Wrapper over requests library.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/http_requests/#add_default_timeout","title":"add<code>_</code>default<code>_</code>timeout","text":"<pre><code>def add_default_timeout(fn: Callable, timeout: float) -&gt; Callable\n</code></pre> <p>Add default timeout for requests methods.</p>"},{"location":"aea-framework-documentation/api/helpers/install_dependency/","title":"Install Dependency","text":""},{"location":"aea-framework-documentation/api/helpers/install_dependency/#aeahelpersinstall_dependency","title":"aea.helpers.install<code>_</code>dependency","text":"<p>Helper to install python dependencies.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/install_dependency/#install_dependency","title":"install<code>_</code>dependency","text":"<pre><code>def install_dependency(dependency_name: str,\ndependency: Dependency,\nlogger: Logger,\ninstall_timeout: float = 300) -&gt; None\n</code></pre> <p>Install python dependency to the current python environment.</p> <p>Arguments:</p> <ul> <li><code>dependency_name</code>: name of the python package</li> <li><code>dependency</code>: Dependency specification</li> <li><code>logger</code>: the logger</li> <li><code>install_timeout</code>: timeout to wait pip to install</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/install_dependency/#install_dependencies","title":"install<code>_</code>dependencies","text":"<pre><code>def install_dependencies(dependencies: List[Dependency],\nlogger: Logger,\ninstall_timeout: float = 300) -&gt; None\n</code></pre> <p>Install python dependencies to the current python environment.</p> <p>Arguments:</p> <ul> <li><code>dependencies</code>: dict of dependency name and specification</li> <li><code>logger</code>: the logger</li> <li><code>install_timeout</code>: timeout to wait pip to install</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/install_dependency/#call_pip","title":"call<code>_</code>pip","text":"<pre><code>def call_pip(pip_args: List[str],\ntimeout: float = 300,\nretry: bool = False) -&gt; None\n</code></pre> <p>Run pip install command.</p> <p>Arguments:</p> <ul> <li><code>pip_args</code>: list strings of the command</li> <li><code>timeout</code>: timeout to wait pip to install</li> <li><code>retry</code>: bool, try one more time if command failed</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/install_dependency/#run_install_subprocess","title":"run<code>_</code>install<code>_</code>subprocess","text":"<pre><code>def run_install_subprocess(install_command: List[str],\ninstall_timeout: float = 300) -&gt; int\n</code></pre> <p>Try executing install command.</p> <p>Arguments:</p> <ul> <li><code>install_command</code>: list strings of the command</li> <li><code>install_timeout</code>: timeout to wait pip to install</li> </ul> <p>Returns:</p> <p>the return code of the subprocess</p>"},{"location":"aea-framework-documentation/api/helpers/io/","title":"IO","text":""},{"location":"aea-framework-documentation/api/helpers/io/#aeahelpersio","title":"aea.helpers.io","text":""},{"location":"aea-framework-documentation/api/helpers/logging/","title":"Logging","text":""},{"location":"aea-framework-documentation/api/helpers/logging/#aeahelperslogging","title":"aea.helpers.logging","text":"<p>Logging helpers.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#get_logger","title":"get<code>_</code>logger","text":"<pre><code>def get_logger(module_path: str, agent_name: str) -&gt; Logger\n</code></pre> <p>Get the logger based on a module path and agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#agentloggeradapter-objects","title":"AgentLoggerAdapter Objects","text":"<pre><code>class AgentLoggerAdapter(LoggerAdapter)\n</code></pre> <p>This class is a logger adapter that prepends the agent name to log messages.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(logger: Logger, agent_name: str) -&gt; None\n</code></pre> <p>Initialize the logger adapter.</p> <p>Arguments:</p> <ul> <li><code>logger</code>: the logger.</li> <li><code>agent_name</code>: the agent name.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#process","title":"process","text":"<pre><code>def process(\nmsg: Any,\nkwargs: MutableMapping[str,\nAny]) -&gt; Tuple[Any, MutableMapping[str, Any]]\n</code></pre> <p>Prepend the agent name to every log message.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#withlogger-objects","title":"WithLogger Objects","text":"<pre><code>class WithLogger()\n</code></pre> <p>Interface to endow subclasses with a logger.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(logger: Optional[Logger] = None,\ndefault_logger_name: str = \"aea\") -&gt; None\n</code></pre> <p>Initialize the logger.</p> <p>Arguments:</p> <ul> <li><code>logger</code>: the logger object.</li> <li><code>default_logger_name</code>: the default logger name, if a logger is not provided.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#logger","title":"logger","text":"<pre><code>@property\ndef logger() -&gt; Logger\n</code></pre> <p>Get the component logger.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/logging/#logger_1","title":"logger","text":"<pre><code>@logger.setter\ndef logger(logger: Optional[Logger]) -&gt; None\n</code></pre> <p>Set the logger.</p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/","title":"MultipleExecutor","text":""},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#aeahelpersmultiple_executor","title":"aea.helpers.multiple<code>_</code>executor","text":"<p>This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess .</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#executorexceptionpolicies-objects","title":"ExecutorExceptionPolicies Objects","text":"<pre><code>class ExecutorExceptionPolicies(Enum)\n</code></pre> <p>Runner exception policy modes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#abstractexecutortask-objects","title":"AbstractExecutorTask Objects","text":"<pre><code>class AbstractExecutorTask(ABC)\n</code></pre> <p>Abstract task class to create Task classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Init task.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#future","title":"future","text":"<pre><code>@property\ndef future() -&gt; Optional[TaskAwaitable]\n</code></pre> <p>Return awaitable to get result of task execution.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#future_1","title":"future","text":"<pre><code>@future.setter\ndef future(future: TaskAwaitable) -&gt; None\n</code></pre> <p>Set awaitable to get result of task execution.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#start","title":"start","text":"<pre><code>@abstractmethod\ndef start() -&gt; Tuple[Callable, Sequence[Any]]\n</code></pre> <p>Implement start task function here.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#stop","title":"stop","text":"<pre><code>@abstractmethod\ndef stop() -&gt; None\n</code></pre> <p>Implement stop task function here.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#create_async_task","title":"create<code>_</code>async<code>_</code>task","text":"<pre><code>@abstractmethod\ndef create_async_task(loop: AbstractEventLoop) -&gt; TaskAwaitable\n</code></pre> <p>Create asyncio task for task run in asyncio loop.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: the event loop</li> </ul> <p>Returns:</p> <p>task to run in asyncio loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#id","title":"id","text":"<pre><code>@property\ndef id() -&gt; Any\n</code></pre> <p>Return task id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#failed","title":"failed","text":"<pre><code>@property\ndef failed() -&gt; bool\n</code></pre> <p>Return was exception failed or not.</p> <p>If it's running it's not failed.</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#abstractmultiprocessexecutortask-objects","title":"AbstractMultiprocessExecutorTask Objects","text":"<pre><code>class AbstractMultiprocessExecutorTask(AbstractExecutorTask)\n</code></pre> <p>Task for multiprocess executor.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#start_1","title":"start","text":"<pre><code>@abstractmethod\ndef start() -&gt; Tuple[Callable, Sequence[Any]]\n</code></pre> <p>Return function and arguments to call within subprocess.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#create_async_task_1","title":"create<code>_</code>async<code>_</code>task","text":"<pre><code>def create_async_task(loop: AbstractEventLoop) -&gt; TaskAwaitable\n</code></pre> <p>Create asyncio task for task run in asyncio loop.</p> <p>Raise error, cause async mode is not supported, cause this task for multiprocess executor only.</p> <p>Arguments:</p> <ul> <li><code>loop</code>: the event loop</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: async task construction not possible</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#abstractmultipleexecutor-objects","title":"AbstractMultipleExecutor Objects","text":"<pre><code>class AbstractMultipleExecutor(ABC)\n</code></pre> <p>Abstract class to create multiple executors classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\ntasks: Sequence[AbstractExecutorTask],\ntask_fail_policy: ExecutorExceptionPolicies = ExecutorExceptionPolicies.\npropagate\n) -&gt; None\n</code></pre> <p>Init executor.</p> <p>Arguments:</p> <ul> <li><code>tasks</code>: sequence of AbstractExecutorTask instances to run.</li> <li><code>task_fail_policy</code>: the exception policy of all the tasks</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Return running state of the executor.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#start_2","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#stop_1","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#num_failed","title":"num<code>_</code>failed","text":"<pre><code>@property\ndef num_failed() -&gt; int\n</code></pre> <p>Return number of failed tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#failed_tasks","title":"failed<code>_</code>tasks","text":"<pre><code>@property\ndef failed_tasks() -&gt; Sequence[AbstractExecutorTask]\n</code></pre> <p>Return sequence failed tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#not_failed_tasks","title":"not<code>_</code>failed<code>_</code>tasks","text":"<pre><code>@property\ndef not_failed_tasks() -&gt; Sequence[AbstractExecutorTask]\n</code></pre> <p>Return sequence successful tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#threadexecutor-objects","title":"ThreadExecutor Objects","text":"<pre><code>class ThreadExecutor(AbstractMultipleExecutor)\n</code></pre> <p>Thread based executor to run multiple agents in threads.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#processexecutor-objects","title":"ProcessExecutor Objects","text":"<pre><code>class ProcessExecutor(ThreadExecutor)\n</code></pre> <p>Subprocess based executor to run multiple agents in threads.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#asyncexecutor-objects","title":"AsyncExecutor Objects","text":"<pre><code>class AsyncExecutor(AbstractMultipleExecutor)\n</code></pre> <p>Thread based executor to run multiple agents in threads.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#abstractmultiplerunner-objects","title":"AbstractMultipleRunner Objects","text":"<pre><code>class AbstractMultipleRunner()\n</code></pre> <p>Abstract multiple runner to create classes to launch tasks with selected mode.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nmode: str,\nfail_policy: ExecutorExceptionPolicies = ExecutorExceptionPolicies.\npropagate\n) -&gt; None\n</code></pre> <p>Init with selected executor mode.</p> <p>Arguments:</p> <ul> <li><code>mode</code>: one of supported executor modes</li> <li><code>fail_policy</code>: one of ExecutorExceptionPolicies to be used with Executor</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#is_running_1","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Return state of the executor.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#start_3","title":"start","text":"<pre><code>def start(threaded: bool = False) -&gt; None\n</code></pre> <p>Run agents.</p> <p>Arguments:</p> <ul> <li><code>threaded</code>: run in dedicated thread without blocking current thread.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#stop_2","title":"stop","text":"<pre><code>def stop(timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Stop agents.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout in seconds to wait thread stopped, only if started in thread mode.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#num_failed_1","title":"num<code>_</code>failed","text":"<pre><code>@property\ndef num_failed() -&gt; int\n</code></pre> <p>Return number of failed tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#failed_1","title":"failed","text":"<pre><code>@property\ndef failed() -&gt; Sequence[Task]\n</code></pre> <p>Return sequence failed tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#not_failed","title":"not<code>_</code>failed","text":"<pre><code>@property\ndef not_failed() -&gt; Sequence[Task]\n</code></pre> <p>Return sequence successful tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiple_executor/#try_join_thread","title":"try<code>_</code>join<code>_</code>thread","text":"<pre><code>def try_join_thread() -&gt; None\n</code></pre> <p>Try to join thread if running in thread mode.</p>"},{"location":"aea-framework-documentation/api/helpers/pipe/","title":"Pipe","text":""},{"location":"aea-framework-documentation/api/helpers/pipe/#aeahelperspipe","title":"aea.helpers.pipe","text":"<p>Portable pipe implementation for Linux, MacOS, and Windows.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#ipcchannelclient-objects","title":"IPCChannelClient Objects","text":"<pre><code>class IPCChannelClient(ABC)\n</code></pre> <p>Multi-platform interprocess communication channel for the client side.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect","title":"connect","text":"<pre><code>@abstractmethod\nasync def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Connect to communication channel</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout for other end to connect</li> </ul> <p>Returns:</p> <p>connection status</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write","title":"write","text":"<pre><code>@abstractmethod\nasync def write(data: bytes) -&gt; None\n</code></pre> <p>Write <code>data</code> bytes to the other end of the channel</p> <p>Will first write the size than the actual data</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read","title":"read","text":"<pre><code>@abstractmethod\nasync def read() -&gt; Optional[bytes]\n</code></pre> <p>Read bytes from the other end of the channel</p> <p>Will first read the size than the actual data</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close","title":"close","text":"<pre><code>@abstractmethod\nasync def close() -&gt; None\n</code></pre> <p>Close the communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#ipcchannel-objects","title":"IPCChannel Objects","text":"<pre><code>class IPCChannel(IPCChannelClient)\n</code></pre> <p>Multi-platform interprocess communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#in_path","title":"in<code>_</code>path","text":"<pre><code>@property\n@abstractmethod\ndef in_path() -&gt; str\n</code></pre> <p>Rendezvous point for incoming communication.</p> <p>Returns:</p> <p>path</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#out_path","title":"out<code>_</code>path","text":"<pre><code>@property\n@abstractmethod\ndef out_path() -&gt; str\n</code></pre> <p>Rendezvous point for outgoing communication.</p> <p>Returns:</p> <p>path</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#posixnamedpipeprotocol-objects","title":"PosixNamedPipeProtocol Objects","text":"<pre><code>class PosixNamedPipeProtocol()\n</code></pre> <p>Posix named pipes async wrapper communication protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(in_path: str,\nout_path: str,\nlogger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize a new posix named pipe.</p> <p>Arguments:</p> <ul> <li><code>in_path</code>: rendezvous point for incoming data</li> <li><code>out_path</code>: rendezvous point for outgoing data</li> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the event loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect_1","title":"connect","text":"<pre><code>async def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Connect to the other end of the pipe</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout before failing</li> </ul> <p>Returns:</p> <p>connection success</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_1","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write to pipe.</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write to pipe</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_1","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read from pipe.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_1","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Disconnect pipe.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#tcpsocketprotocol-objects","title":"TCPSocketProtocol Objects","text":"<pre><code>class TCPSocketProtocol()\n</code></pre> <p>TCP socket communication protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(reader: asyncio.StreamReader,\nwriter: asyncio.StreamWriter,\nlogger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize the tcp socket protocol.</p> <p>Arguments:</p> <ul> <li><code>reader</code>: established asyncio reader</li> <li><code>writer</code>: established asyncio writer</li> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the event loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#writer","title":"writer","text":"<pre><code>@property\ndef writer() -&gt; StreamWriter\n</code></pre> <p>Get a writer associated with  protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_2","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write to socket.</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_2","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read from socket.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_2","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Disconnect socket.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#tcpsocketchannel-objects","title":"TCPSocketChannel Objects","text":"<pre><code>class TCPSocketChannel(IPCChannel)\n</code></pre> <p>Interprocess communication channel implementation using tcp sockets.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(logger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize tcp socket interprocess communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect_2","title":"connect","text":"<pre><code>async def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Setup communication channel and wait for other end to connect.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout for the connection to be established</li> </ul> <p>Returns:</p> <p>connection status</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_3","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write to channel.</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_3","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read from channel.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_3","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Disconnect from channel and clean it up.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#in_path_1","title":"in<code>_</code>path","text":"<pre><code>@property\ndef in_path() -&gt; str\n</code></pre> <p>Rendezvous point for incoming communication.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#out_path_1","title":"out<code>_</code>path","text":"<pre><code>@property\ndef out_path() -&gt; str\n</code></pre> <p>Rendezvous point for outgoing communication.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#posixnamedpipechannel-objects","title":"PosixNamedPipeChannel Objects","text":"<pre><code>class PosixNamedPipeChannel(IPCChannel)\n</code></pre> <p>Interprocess communication channel implementation using Posix named pipes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(logger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize posix named pipe interprocess communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect_3","title":"connect","text":"<pre><code>async def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Setup communication channel and wait for other end to connect.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout for connection to be established</li> </ul> <p>Returns:</p> <p>bool, indicating success</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_4","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write to the channel.</p> <p>Arguments:</p> <ul> <li><code>data</code>: data to write to channel</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_4","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read from the channel.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_4","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Close the channel and clean it up.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#in_path_2","title":"in<code>_</code>path","text":"<pre><code>@property\ndef in_path() -&gt; str\n</code></pre> <p>Rendezvous point for incoming communication.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#out_path_2","title":"out<code>_</code>path","text":"<pre><code>@property\ndef out_path() -&gt; str\n</code></pre> <p>Rendezvous point for outgoing communication.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#tcpsocketchannelclient-objects","title":"TCPSocketChannelClient Objects","text":"<pre><code>class TCPSocketChannelClient(IPCChannelClient)\n</code></pre> <p>Interprocess communication channel client using tcp sockets.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(in_path: str,\nout_path: str,\nlogger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize a tcp socket communication channel client.</p> <p>Arguments:</p> <ul> <li><code>in_path</code>: rendezvous point for incoming data</li> <li><code>out_path</code>: rendezvous point for outgoing data</li> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the event loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect_4","title":"connect","text":"<pre><code>async def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Connect to the other end of the communication channel.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout for connection to be established</li> </ul> <p>Returns:</p> <p>connection status</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_5","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write data to channel.</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_5","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read data from channel.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_5","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Disconnect from communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#posixnamedpipechannelclient-objects","title":"PosixNamedPipeChannelClient Objects","text":"<pre><code>class PosixNamedPipeChannelClient(IPCChannelClient)\n</code></pre> <p>Interprocess communication channel client using Posix named pipes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(in_path: str,\nout_path: str,\nlogger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; None\n</code></pre> <p>Initialize a posix named pipe communication channel client.</p> <p>Arguments:</p> <ul> <li><code>in_path</code>: rendezvous point for incoming data</li> <li><code>out_path</code>: rendezvous point for outgoing data</li> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the event loop</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#connect_5","title":"connect","text":"<pre><code>async def connect(timeout: float = PIPE_CONN_TIMEOUT) -&gt; bool\n</code></pre> <p>Connect to the other end of the communication channel.</p> <p>Arguments:</p> <ul> <li><code>timeout</code>: timeout for connection to be established</li> </ul> <p>Returns:</p> <p>connection status</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#write_6","title":"write","text":"<pre><code>async def write(data: bytes) -&gt; None\n</code></pre> <p>Write data to channel.</p> <p>Arguments:</p> <ul> <li><code>data</code>: bytes to write</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#read_6","title":"read","text":"<pre><code>async def read() -&gt; Optional[bytes]\n</code></pre> <p>Read data from channel.</p> <p>Returns:</p> <p>read bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#close_6","title":"close","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Disconnect from communication channel.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#make_ipc_channel","title":"make<code>_</code>ipc<code>_</code>channel","text":"<pre><code>def make_ipc_channel(logger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; IPCChannel\n</code></pre> <p>Build a portable bidirectional InterProcess Communication channel</p> <p>Arguments:</p> <ul> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the loop</li> </ul> <p>Returns:</p> <p>IPCChannel</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/pipe/#make_ipc_channel_client","title":"make<code>_</code>ipc<code>_</code>channel<code>_</code>client","text":"<pre><code>def make_ipc_channel_client(\nin_path: str,\nout_path: str,\nlogger: logging.Logger = _default_logger,\nloop: Optional[AbstractEventLoop] = None) -&gt; IPCChannelClient\n</code></pre> <p>Build a portable bidirectional InterProcess Communication client channel</p> <p>Arguments:</p> <ul> <li><code>in_path</code>: rendezvous point for incoming communication</li> <li><code>out_path</code>: rendezvous point for outgoing outgoing</li> <li><code>logger</code>: the logger</li> <li><code>loop</code>: the loop</li> </ul> <p>Returns:</p> <p>IPCChannel</p>"},{"location":"aea-framework-documentation/api/helpers/profiling/","title":"Profiling","text":""},{"location":"aea-framework-documentation/api/helpers/profiling/#aeahelpersprofiling","title":"aea.helpers.profiling","text":"<p>Implementation of background profiling daemon.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#profiling-objects","title":"Profiling Objects","text":"<pre><code>class Profiling(Runnable)\n</code></pre> <p>Profiling service.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nperiod: int = 0,\nobjects_instances_to_count: List[Type] = None,\nobjects_created_to_count: List[Type] = None,\noutput_function: Callable[[str], None] = lambda x: print(x, flush=True)\n) -&gt; None\n</code></pre> <p>Init profiler.</p> <p>Arguments:</p> <ul> <li><code>period</code>: delay between profiling output in seconds.</li> <li><code>objects_instances_to_count</code>: object to count</li> <li><code>objects_created_to_count</code>: object created to count</li> <li><code>output_function</code>: function to display output, one str argument.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#set_counters","title":"set<code>_</code>counters","text":"<pre><code>def set_counters() -&gt; None\n</code></pre> <p>Modify obj.new to count objects created created.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Run profiling.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#output_profile_data","title":"output<code>_</code>profile<code>_</code>data","text":"<pre><code>def output_profile_data() -&gt; None\n</code></pre> <p>Render profiling data and call output_function.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#get_profile_data","title":"get<code>_</code>profile<code>_</code>data","text":"<pre><code>def get_profile_data() -&gt; Dict\n</code></pre> <p>Get profiling data dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#get_objects_instances","title":"get<code>_</code>objects<code>_</code>instances","text":"<pre><code>def get_objects_instances() -&gt; Dict\n</code></pre> <p>Return dict with counted object instances present now.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/profiling/#get_objecst_created","title":"get<code>_</code>objecst<code>_</code>created","text":"<pre><code>def get_objecst_created() -&gt; Dict\n</code></pre> <p>Return dict with counted object instances created.</p>"},{"location":"aea-framework-documentation/api/helpers/serializers/","title":"Serializers","text":""},{"location":"aea-framework-documentation/api/helpers/serializers/#aeahelpersserializers","title":"aea.helpers.serializers","text":"<p>This module contains Serializers that can be used for custom types.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/serializers/#dictprotobufstructserializer-objects","title":"DictProtobufStructSerializer Objects","text":"<pre><code>class DictProtobufStructSerializer()\n</code></pre> <p>Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct</p> <p>ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/serializers/#encode","title":"encode","text":"<pre><code>@classmethod\ndef encode(cls, dictionary: Dict[str, Any]) -&gt; bytes\n</code></pre> <p>Serialize compatible dictionary to bytes.</p> <p>Copies entire dictionary in the process.</p> <p>Arguments:</p> <ul> <li><code>dictionary</code>: the dictionary to serialize</li> </ul> <p>Returns:</p> <p>serialized bytes string</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/serializers/#decode","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, buffer: bytes) -&gt; Dict[str, Any]\n</code></pre> <p>Deserialize a compatible dictionary</p>"},{"location":"aea-framework-documentation/api/helpers/sym_link/","title":"Sym Link","text":""},{"location":"aea-framework-documentation/api/helpers/sym_link/#aeahelperssym_link","title":"aea.helpers.sym<code>_</code>link","text":"<p>Sym link implementation for Linux, MacOS, and Windows.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/sym_link/#make_symlink","title":"make<code>_</code>symlink","text":"<pre><code>def make_symlink(link_name: str, target: str) -&gt; None\n</code></pre> <p>Make a symbolic link, cross platform.</p> <p>Arguments:</p> <ul> <li><code>link_name</code>: the link name.</li> <li><code>target</code>: the target.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/sym_link/#cd","title":"cd","text":"<pre><code>@contextlib.contextmanager\ndef cd(path: Path) -&gt; Generator\n</code></pre> <p>Change directory with context manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/sym_link/#create_symlink","title":"create<code>_</code>symlink","text":"<pre><code>def create_symlink(link_path: Path, target_path: Path, root_path: Path) -&gt; int\n</code></pre> <p>Change directory and call the cross-platform script.</p> <p>The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relative path from the symbolic link directory to the target directory.</p> <p>So: 1) from link_path, extract the number of jumps to the parent directory   in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2).</p> <p>For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path</p> <p>we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path'</p> <p>The resulting command on UNIX systems will be:</p> <pre><code>cd directory_1 &amp;&amp; ln -s ../../directory_1/target_path symbolic_link\n</code></pre> <p>Arguments:</p> <ul> <li><code>link_path</code>: the source path</li> <li><code>target_path</code>: the target path</li> <li><code>root_path</code>: the root path</li> </ul> <p>Returns:</p> <p>exit code</p>"},{"location":"aea-framework-documentation/api/helpers/win32/","title":"Win32","text":""},{"location":"aea-framework-documentation/api/helpers/win32/#aeahelperswin32","title":"aea.helpers.win32","text":"<p>Helpers for Windows.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/win32/#enable_ctrl_c_support","title":"enable<code>_</code>ctrl<code>_</code>c<code>_</code>support","text":"<pre><code>def enable_ctrl_c_support() -&gt; None\n</code></pre> <p>Enable ctrl+c support for aea.cli command to be tested on windows platform.</p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/","title":"YamlUtils","text":""},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#aeahelpersyaml_utils","title":"aea.helpers.yaml<code>_</code>utils","text":"<p>Helper functions related to YAML loading/dumping.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#_aeayamlloader-objects","title":"<code>_</code>AEAYamlLoader Objects","text":"<pre><code>class _AEAYamlLoader(yaml.SafeLoader)\n</code></pre> <p>Custom yaml.SafeLoader for the AEA framework.</p> <p>It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields; - resolves the environment variables at loading time.</p> <p>This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the AEAYamlLoader.</p> <p>It adds a YAML Loader constructor to use 'OderedDict' to load the files.</p> <p>Arguments:</p> <ul> <li><code>args</code>: the positional arguments.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#_aeayamldumper-objects","title":"<code>_</code>AEAYamlDumper Objects","text":"<pre><code>class _AEAYamlDumper(yaml.SafeDumper)\n</code></pre> <p>Custom yaml.SafeDumper for the AEA framework.</p> <p>It extends the default SafeDumper so to dump YAML configurations while following the order of the fields.</p> <p>This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the AEAYamlDumper.</p> <p>It adds a YAML Dumper representer to use 'OderedDict' to dump the files.</p> <p>Arguments:</p> <ul> <li><code>args</code>: the positional arguments.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#yaml_load","title":"yaml<code>_</code>load","text":"<pre><code>def yaml_load(stream: TextIO) -&gt; Dict[str, Any]\n</code></pre> <p>Load a yaml from a file pointer in an ordered way.</p> <p>Arguments:</p> <ul> <li><code>stream</code>: file pointer to the input file.</li> </ul> <p>Returns:</p> <p>the dictionary object with the YAML file content.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#yaml_load_all","title":"yaml<code>_</code>load<code>_</code>all","text":"<pre><code>def yaml_load_all(stream: TextIO) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Load a multi-paged yaml from a file pointer in an ordered way.</p> <p>Arguments:</p> <ul> <li><code>stream</code>: file pointer to the input file.</li> </ul> <p>Returns:</p> <p>the list of dictionary objects with the (multi-paged) YAML file content.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#yaml_dump","title":"yaml<code>_</code>dump","text":"<pre><code>def yaml_dump(data: Dict, stream: Optional[TextIO] = None) -&gt; None\n</code></pre> <p>Dump YAML data to a yaml file in an ordered way.</p> <p>Arguments:</p> <ul> <li><code>data</code>: the data to write.</li> <li><code>stream</code>: (optional) the file to write on.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/yaml_utils/#yaml_dump_all","title":"yaml<code>_</code>dump<code>_</code>all","text":"<pre><code>def yaml_dump_all(data: Sequence[Dict],\nstream: Optional[TextIO] = None) -&gt; None\n</code></pre> <p>Dump YAML data to a yaml file in an ordered way.</p> <p>Arguments:</p> <ul> <li><code>data</code>: the data to write.</li> <li><code>stream</code>: (optional) the file to write on.</li> </ul>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/","title":"Agent Record","text":""},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#aeahelpersacnagent_record","title":"aea.helpers.acn.agent<code>_</code>record","text":"<p>This module contains types and helpers for ACN Proof-of-Representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#agentrecord-objects","title":"AgentRecord Objects","text":"<pre><code>class AgentRecord()\n</code></pre> <p>Agent Proof-of-Representation to representative.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(address: str, representative_public_key: str,\nidentifier: SimpleIdOrStr, ledger_id: SimpleIdOrStr,\nnot_before: str, not_after: str, message_format: str,\nsignature: str) -&gt; None\n</code></pre> <p>Initialize the AgentRecord</p> <p>Arguments:</p> <ul> <li><code>address</code>: agent address</li> <li><code>representative_public_key</code>: representative's public key</li> <li><code>identifier</code>: certificate identifier.</li> <li><code>ledger_id</code>: ledger identifier the request is referring to.</li> <li><code>not_before</code>: specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0.</li> <li><code>not_after</code>: specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0.</li> <li><code>message_format</code>: message format used for signing</li> <li><code>signature</code>: proof-of-representation of this AgentRecord</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; str\n</code></pre> <p>Get agent address</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Get agent public key</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#representative_public_key","title":"representative<code>_</code>public<code>_</code>key","text":"<pre><code>@property\ndef representative_public_key() -&gt; str\n</code></pre> <p>Get agent representative's public key</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#signature","title":"signature","text":"<pre><code>@property\ndef signature() -&gt; str\n</code></pre> <p>Get record signature</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#message","title":"message","text":"<pre><code>@property\ndef message() -&gt; bytes\n</code></pre> <p>Get the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#identifier","title":"identifier","text":"<pre><code>@property\ndef identifier() -&gt; SimpleIdOrStr\n</code></pre> <p>Get the identifier.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#ledger_id","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; SimpleIdOrStr\n</code></pre> <p>Get ledger id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#not_before","title":"not<code>_</code>before","text":"<pre><code>@property\ndef not_before() -&gt; str\n</code></pre> <p>Get the not_before field.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#not_after","title":"not<code>_</code>after","text":"<pre><code>@property\ndef not_after() -&gt; str\n</code></pre> <p>Get the not_after field.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#message_format","title":"message<code>_</code>format","text":"<pre><code>@property\ndef message_format() -&gt; str\n</code></pre> <p>Get the message format.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/agent_record/#from_cert_request","title":"from<code>_</code>cert<code>_</code>request","text":"<pre><code>@classmethod\ndef from_cert_request(cls,\ncert_request: CertRequest,\naddress: str,\nrepresentative_public_key: str,\ndata_dir: Optional[PathLike] = None) -&gt; \"AgentRecord\"\n</code></pre> <p>Get agent record from cert request.</p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/","title":"URI","text":""},{"location":"aea-framework-documentation/api/helpers/acn/uri/#aeahelpersacnuri","title":"aea.helpers.acn.uri","text":"<p>This module contains types and helpers for libp2p connections Uris.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#uri-objects","title":"Uri Objects","text":"<pre><code>class Uri()\n</code></pre> <p>Holds a node address in format \"host:port\".</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(uri: Optional[str] = None,\nhost: Optional[str] = None,\nport: Optional[int] = None) -&gt; None\n</code></pre> <p>Initialise Uri.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#__repr__","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get object representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#host","title":"host","text":"<pre><code>@property\ndef host() -&gt; str\n</code></pre> <p>Get host.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/acn/uri/#port","title":"port","text":"<pre><code>@property\ndef port() -&gt; int\n</code></pre> <p>Get port.</p>"},{"location":"aea-framework-documentation/api/helpers/ipfs/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/ipfs/base/#aeahelpersipfsbase","title":"aea.helpers.ipfs.base","text":"<p>This module contains helper methods and classes for the 'aea' package.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/ipfs/base/#chunks","title":"chunks","text":"<pre><code>def chunks(data: Sized, size: int) -&gt; Generator\n</code></pre> <p>Yield successivesize chunks from data.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/ipfs/base/#ipfshashonly-objects","title":"IPFSHashOnly Objects","text":"<pre><code>class IPFSHashOnly()\n</code></pre> <p>A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/ipfs/base/#get","title":"get","text":"<pre><code>def get(file_path: str) -&gt; str\n</code></pre> <p>Get the IPFS hash for a single file.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path</li> </ul> <p>Returns:</p> <p>the ipfs hash</p>"},{"location":"aea-framework-documentation/api/helpers/ipfs/utils/","title":"Utils","text":""},{"location":"aea-framework-documentation/api/helpers/ipfs/utils/#aeahelpersipfsutils","title":"aea.helpers.ipfs.utils","text":"<p>This module contains utility methods for ipfs helpers.</p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#aeahelpersmultiaddrbase","title":"aea.helpers.multiaddr.base","text":"<p>This module contains multiaddress class.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#multiaddr-objects","title":"MultiAddr Objects","text":"<pre><code>class MultiAddr()\n</code></pre> <p>Protocol Labs' Multiaddress representation of a network address.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(host: str,\nport: int,\npublic_key: Optional[str] = None,\nmultihash_id: Optional[str] = None) -&gt; None\n</code></pre> <p>Initialize a multiaddress.</p> <p>Arguments:</p> <ul> <li><code>host</code>: ip host of the address</li> <li><code>port</code>: port number of the address</li> <li><code>public_key</code>: hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1</li> <li><code>multihash_id</code>: a multihash of the public key</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#compute_peerid","title":"compute<code>_</code>peerid","text":"<pre><code>@staticmethod\ndef compute_peerid(public_key: str) -&gt; str\n</code></pre> <p>Compute the peer id from a public key.</p> <p>In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key.</li> </ul> <p>Returns:</p> <p>the peer id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#from_string","title":"from<code>_</code>string","text":"<pre><code>@classmethod\ndef from_string(cls, maddr: str) -&gt; \"MultiAddr\"\n</code></pre> <p>Construct a MultiAddr object from its string format</p> <p>Arguments:</p> <ul> <li><code>maddr</code>: multiaddress string</li> </ul> <p>Returns:</p> <p>multiaddress object</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Get the public key.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#peer_id","title":"peer<code>_</code>id","text":"<pre><code>@property\ndef peer_id() -&gt; str\n</code></pre> <p>Get the peer id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#host","title":"host","text":"<pre><code>@property\ndef host() -&gt; str\n</code></pre> <p>Get the peer host.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#port","title":"port","text":"<pre><code>@property\ndef port() -&gt; int\n</code></pre> <p>Get the peer port.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#format","title":"format","text":"<pre><code>def format() -&gt; str\n</code></pre> <p>Canonical representation of a multiaddress.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/multiaddr/base/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Default string representation of a multiaddress.</p>"},{"location":"aea-framework-documentation/api/helpers/preference_representations/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/preference_representations/base/#aeahelperspreference_representationsbase","title":"aea.helpers.preference<code>_</code>representations.base","text":"<p>Preference representation helpers.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/preference_representations/base/#logarithmic_utility","title":"logarithmic<code>_</code>utility","text":"<pre><code>def logarithmic_utility(utility_params_by_good_id: Dict[str, float],\nquantities_by_good_id: Dict[str, int],\nquantity_shift: int = 100) -&gt; float\n</code></pre> <p>Compute agent's utility given her utility function params and a good bundle.</p> <p>Arguments:</p> <ul> <li><code>utility_params_by_good_id</code>: utility params by good identifier</li> <li><code>quantities_by_good_id</code>: quantities by good identifier</li> <li><code>quantity_shift</code>: a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities)</li> </ul> <p>Returns:</p> <p>utility value</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/preference_representations/base/#linear_utility","title":"linear<code>_</code>utility","text":"<pre><code>def linear_utility(exchange_params_by_currency_id: Dict[str, float],\nbalance_by_currency_id: Dict[str, int]) -&gt; float\n</code></pre> <p>Compute agent's utility given her utility function params and a good bundle.</p> <p>Arguments:</p> <ul> <li><code>exchange_params_by_currency_id</code>: exchange params by currency</li> <li><code>balance_by_currency_id</code>: balance by currency</li> </ul> <p>Returns:</p> <p>utility value</p>"},{"location":"aea-framework-documentation/api/helpers/search/generic/","title":"Generic","text":""},{"location":"aea-framework-documentation/api/helpers/search/generic/#aeahelperssearchgeneric","title":"aea.helpers.search.generic","text":"<p>This module contains a generic data model.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/search/generic/#genericdatamodel-objects","title":"GenericDataModel Objects","text":"<pre><code>class GenericDataModel(DataModel)\n</code></pre> <p>Generic data model.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/search/generic/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(data_model_name: str, data_model_attributes: Dict[str,\nAny]) -&gt; None\n</code></pre> <p>Initialise the dataModel.</p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/","title":"GenericStorage","text":""},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#aeahelpersstoragegeneric_storage","title":"aea.helpers.storage.generic<code>_</code>storage","text":"<p>This module contains the storage implementation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#asynccollection-objects","title":"AsyncCollection Objects","text":"<pre><code>class AsyncCollection()\n</code></pre> <p>Async collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(storage_backend: AbstractStorageBackend,\ncollection_name: str) -&gt; None\n</code></pre> <p>Init collection object.</p> <p>Arguments:</p> <ul> <li><code>storage_backend</code>: storage backed to use.</li> <li><code>collection_name</code>: str</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#put","title":"put","text":"<pre><code>async def put(object_id: str, object_body: JSON_TYPES) -&gt; None\n</code></pre> <p>Put object into collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> <li><code>object_body</code>: python dict, json compatible.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#get","title":"get","text":"<pre><code>async def get(object_id: str) -&gt; Optional[JSON_TYPES]\n</code></pre> <p>Get object from the collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>dict if object exists in collection otherwise None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#remove","title":"remove","text":"<pre><code>async def remove(object_id: str) -&gt; None\n</code></pre> <p>Remove object from the collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#find","title":"find","text":"<pre><code>async def find(field: str, equals: EQUALS_TYPE) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>Get objects from the collection by filtering by field value.</p> <p>Arguments:</p> <ul> <li><code>field</code>: field name to search: example \"parent.field\"</li> <li><code>equals</code>: value field should be equal to</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#list","title":"list","text":"<pre><code>async def list() -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>List all objects with keys from the collection.</p> <p>Returns:</p> <p>Tuple of objects keys, bodies.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#synccollection-objects","title":"SyncCollection Objects","text":"<pre><code>class SyncCollection()\n</code></pre> <p>Async collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(async_collection_coro: Coroutine,\nloop: asyncio.AbstractEventLoop) -&gt; None\n</code></pre> <p>Init collection object.</p> <p>Arguments:</p> <ul> <li><code>async_collection_coro</code>: coroutine returns async collection.</li> <li><code>loop</code>: abstract event loop where storage is running.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#put_1","title":"put","text":"<pre><code>def put(object_id: str, object_body: JSON_TYPES) -&gt; None\n</code></pre> <p>Put object into collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> <li><code>object_body</code>: python dict, json compatible.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#get_1","title":"get","text":"<pre><code>def get(object_id: str) -&gt; Optional[JSON_TYPES]\n</code></pre> <p>Get object from the collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>dict if object exists in collection otherwise None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#remove_1","title":"remove","text":"<pre><code>def remove(object_id: str) -&gt; None\n</code></pre> <p>Remove object from the collection.</p> <p>Arguments:</p> <ul> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#find_1","title":"find","text":"<pre><code>def find(field: str, equals: EQUALS_TYPE) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>Get objects from the collection by filtering by field value.</p> <p>Arguments:</p> <ul> <li><code>field</code>: field name to search: example \"parent.field\"</li> <li><code>equals</code>: value field should be equal to</li> </ul> <p>Returns:</p> <p>List of object bodies</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#list_1","title":"list","text":"<pre><code>def list() -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>List all objects with keys from the collection.</p> <p>Returns:</p> <p>Tuple of objects keys, bodies.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#storage-objects","title":"Storage Objects","text":"<pre><code>class Storage(Runnable)\n</code></pre> <p>Generic storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(storage_uri: str,\nloop: asyncio.AbstractEventLoop = None,\nthreaded: bool = False) -&gt; None\n</code></pre> <p>Init storage.</p> <p>Arguments:</p> <ul> <li><code>storage_uri</code>: configuration string for storage.</li> <li><code>loop</code>: asyncio event loop to use.</li> <li><code>threaded</code>: bool. start in thread if True.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#wait_connected","title":"wait<code>_</code>connected","text":"<pre><code>async def wait_connected() -&gt; None\n</code></pre> <p>Wait generic storage is connected.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#is_connected","title":"is<code>_</code>connected","text":"<pre><code>@property\ndef is_connected() -&gt; bool\n</code></pre> <p>Get running state of the storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Connect storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#get_collection","title":"get<code>_</code>collection","text":"<pre><code>async def get_collection(collection_name: str) -&gt; AsyncCollection\n</code></pre> <p>Get async collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#get_sync_collection","title":"get<code>_</code>sync<code>_</code>collection","text":"<pre><code>def get_sync_collection(collection_name: str) -&gt; SyncCollection\n</code></pre> <p>Get sync collection.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/generic_storage/#__repr__","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get string representation of the storage.</p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#aeahelpersstoragebackendsbase","title":"aea.helpers.storage.backends.base","text":"<p>This module contains storage abstract backend class.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#abstractstoragebackend-objects","title":"AbstractStorageBackend Objects","text":"<pre><code>class AbstractStorageBackend(ABC)\n</code></pre> <p>Abstract base class for storage backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(uri: str) -&gt; None\n</code></pre> <p>Init backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#connect","title":"connect","text":"<pre><code>@abstractmethod\nasync def connect() -&gt; None\n</code></pre> <p>Connect to backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#disconnect","title":"disconnect","text":"<pre><code>@abstractmethod\nasync def disconnect() -&gt; None\n</code></pre> <p>Disconnect the backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#ensure_collection","title":"ensure<code>_</code>collection","text":"<pre><code>@abstractmethod\nasync def ensure_collection(collection_name: str) -&gt; None\n</code></pre> <p>Create collection if not exits.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#put","title":"put","text":"<pre><code>@abstractmethod\nasync def put(collection_name: str, object_id: str,\nobject_body: JSON_TYPES) -&gt; None\n</code></pre> <p>Put object into collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> <li><code>object_body</code>: python dict, json compatible.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#get","title":"get","text":"<pre><code>@abstractmethod\nasync def get(collection_name: str, object_id: str) -&gt; Optional[JSON_TYPES]\n</code></pre> <p>Get object from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>dict if object exists in collection otherwise None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#remove","title":"remove","text":"<pre><code>@abstractmethod\nasync def remove(collection_name: str, object_id: str) -&gt; None\n</code></pre> <p>Remove object from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#find","title":"find","text":"<pre><code>@abstractmethod\nasync def find(collection_name: str, field: str,\nequals: EQUALS_TYPE) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>Get objects from the collection by filtering by field value.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>field</code>: field name to search: example \"parent.field\"</li> <li><code>equals</code>: value field should be equal to</li> </ul> <p>Returns:</p> <p>list of objects bodies</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/base/#list","title":"list","text":"<pre><code>@abstractmethod\nasync def list(collection_name: str) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>List all objects with keys from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> </ul> <p>Returns:</p> <p>Tuple of objects keys, bodies.</p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/","title":"Sqlite","text":""},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#aeahelpersstoragebackendssqlite","title":"aea.helpers.storage.backends.sqlite","text":"<p>This module contains sqlite storage backend implementation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#sqlitestoragebackend-objects","title":"SqliteStorageBackend Objects","text":"<pre><code>class SqliteStorageBackend(AbstractStorageBackend)\n</code></pre> <p>Sqlite storage backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(uri: str) -&gt; None\n</code></pre> <p>Init backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#connect","title":"connect","text":"<pre><code>async def connect() -&gt; None\n</code></pre> <p>Connect to backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#disconnect","title":"disconnect","text":"<pre><code>async def disconnect() -&gt; None\n</code></pre> <p>Disconnect the backend.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#ensure_collection","title":"ensure<code>_</code>collection","text":"<pre><code>async def ensure_collection(collection_name: str) -&gt; None\n</code></pre> <p>Create collection if not exits.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: name of the collection.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#put","title":"put","text":"<pre><code>async def put(collection_name: str, object_id: str,\nobject_body: JSON_TYPES) -&gt; None\n</code></pre> <p>Put object into collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> <li><code>object_body</code>: python dict, json compatible.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#get","title":"get","text":"<pre><code>async def get(collection_name: str, object_id: str) -&gt; Optional[JSON_TYPES]\n</code></pre> <p>Get object from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> </ul> <p>Returns:</p> <p>dict if object exists in collection otherwise None</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#remove","title":"remove","text":"<pre><code>async def remove(collection_name: str, object_id: str) -&gt; None\n</code></pre> <p>Remove object from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>object_id</code>: str object id</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#find","title":"find","text":"<pre><code>async def find(collection_name: str, field: str,\nequals: EQUALS_TYPE) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>Get objects from the collection by filtering by field value.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> <li><code>field</code>: field name to search: example \"parent.field\"</li> <li><code>equals</code>: value field should be equal to</li> </ul> <p>Returns:</p> <p>list of object ids and body</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/storage/backends/sqlite/#list","title":"list","text":"<pre><code>async def list(collection_name: str) -&gt; List[OBJECT_ID_AND_BODY]\n</code></pre> <p>List all objects with keys from the collection.</p> <p>Arguments:</p> <ul> <li><code>collection_name</code>: str.</li> </ul> <p>Returns:</p> <p>Tuple of objects keys, bodies.</p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/helpers/transaction/base/#aeahelperstransactionbase","title":"aea.helpers.transaction.base","text":"<p>This module contains terms related classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#rawtransaction-objects","title":"RawTransaction Objects","text":"<pre><code>class RawTransaction()\n</code></pre> <p>This class represents an instance of RawTransaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str, body: JSONLike) -&gt; None\n</code></pre> <p>Initialise an instance of RawTransaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body","title":"body","text":"<pre><code>@property\ndef body() -&gt; JSONLike\n</code></pre> <p>Get the body.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(raw_transaction_protobuf_object: Any,\nraw_transaction_object: \"RawTransaction\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument.</p> <p>Arguments:</p> <ul> <li><code>raw_transaction_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>raw_transaction_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, raw_transaction_protobuf_object: Any) -&gt; \"RawTransaction\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>raw_transaction_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#rawmessage-objects","title":"RawMessage Objects","text":"<pre><code>class RawMessage()\n</code></pre> <p>This class represents an instance of RawMessage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str,\nbody: bytes,\nis_deprecated_mode: bool = False) -&gt; None\n</code></pre> <p>Initialise an instance of RawMessage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_1","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body_1","title":"body","text":"<pre><code>@property\ndef body() -&gt; bytes\n</code></pre> <p>Get the body.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_deprecated_mode","title":"is<code>_</code>deprecated<code>_</code>mode","text":"<pre><code>@property\ndef is_deprecated_mode() -&gt; bool\n</code></pre> <p>Get the is_deprecated_mode.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_1","title":"encode","text":"<pre><code>@staticmethod\ndef encode(raw_message_protobuf_object: Any,\nraw_message_object: \"RawMessage\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument.</p> <p>Arguments:</p> <ul> <li><code>raw_message_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>raw_message_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_1","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, raw_message_protobuf_object: Any) -&gt; \"RawMessage\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>raw_message_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___1","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___1","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#signedtransaction-objects","title":"SignedTransaction Objects","text":"<pre><code>class SignedTransaction()\n</code></pre> <p>This class represents an instance of SignedTransaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str, body: JSONLike) -&gt; None\n</code></pre> <p>Initialise an instance of SignedTransaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_2","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body_2","title":"body","text":"<pre><code>@property\ndef body() -&gt; JSONLike\n</code></pre> <p>Get the body.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_2","title":"encode","text":"<pre><code>@staticmethod\ndef encode(signed_transaction_protobuf_object: Any,\nsigned_transaction_object: \"SignedTransaction\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument.</p> <p>Arguments:</p> <ul> <li><code>signed_transaction_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>signed_transaction_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_2","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls,\nsigned_transaction_protobuf_object: Any) -&gt; \"SignedTransaction\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>signed_transaction_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___2","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___2","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#signedmessage-objects","title":"SignedMessage Objects","text":"<pre><code>class SignedMessage()\n</code></pre> <p>This class represents an instance of RawMessage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str,\nbody: str,\nis_deprecated_mode: bool = False) -&gt; None\n</code></pre> <p>Initialise an instance of SignedMessage.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_3","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body_3","title":"body","text":"<pre><code>@property\ndef body() -&gt; str\n</code></pre> <p>Get the body.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_deprecated_mode_1","title":"is<code>_</code>deprecated<code>_</code>mode","text":"<pre><code>@property\ndef is_deprecated_mode() -&gt; bool\n</code></pre> <p>Get the is_deprecated_mode.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_3","title":"encode","text":"<pre><code>@staticmethod\ndef encode(signed_message_protobuf_object: Any,\nsigned_message_object: \"SignedMessage\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument.</p> <p>Arguments:</p> <ul> <li><code>signed_message_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>signed_message_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_3","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, signed_message_protobuf_object: Any) -&gt; \"SignedMessage\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>signed_message_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___3","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___3","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#state-objects","title":"State Objects","text":"<pre><code>class State()\n</code></pre> <p>This class represents an instance of State.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str, body: JSONLike) -&gt; None\n</code></pre> <p>Initialise an instance of State.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_4","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body_4","title":"body","text":"<pre><code>@property\ndef body() -&gt; JSONLike\n</code></pre> <p>Get the body.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_4","title":"encode","text":"<pre><code>@staticmethod\ndef encode(state_protobuf_object: Any, state_object: \"State\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument.</p> <p>Arguments:</p> <ul> <li><code>state_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>state_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_4","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, state_protobuf_object: Any) -&gt; \"State\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>state_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___4","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___4","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#terms-objects","title":"Terms Objects","text":"<pre><code>class Terms()\n</code></pre> <p>Class to represent the terms of a multi-currency &amp; multi-token ledger transaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str,\nsender_address: Address,\ncounterparty_address: Address,\namount_by_currency_id: Dict[str, int],\nquantities_by_good_id: Dict[str, int],\nnonce: str,\nis_sender_payable_tx_fee: bool = True,\nfee_by_currency_id: Optional[Dict[str, int]] = None,\nis_strict: bool = False,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Instantiate terms of a transaction.</p> <p>Arguments:</p> <ul> <li><code>ledger_id</code>: the ledger on which the terms are to be settled.</li> <li><code>sender_address</code>: the sender address of the transaction.</li> <li><code>counterparty_address</code>: the counterparty address of the transaction.</li> <li><code>amount_by_currency_id</code>: the amount by the currency of the transaction.</li> <li><code>quantities_by_good_id</code>: a map from good id to the quantity of that good involved in the transaction.</li> <li><code>nonce</code>: nonce to be included in transaction to discriminate otherwise identical transactions.</li> <li><code>is_sender_payable_tx_fee</code>: whether the sender or counterparty pays the tx fee.</li> <li><code>fee_by_currency_id</code>: the fee associated with the transaction.</li> <li><code>is_strict</code>: whether or not terms must have quantities and amounts of opposite signs.</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#id","title":"id","text":"<pre><code>@property\ndef id() -&gt; str\n</code></pre> <p>Get hash of the terms.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_hash","title":"sender<code>_</code>hash","text":"<pre><code>@property\ndef sender_hash() -&gt; str\n</code></pre> <p>Get the sender hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_hash","title":"counterparty<code>_</code>hash","text":"<pre><code>@property\ndef counterparty_hash() -&gt; str\n</code></pre> <p>Get the sender hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_5","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_address","title":"sender<code>_</code>address","text":"<pre><code>@property\ndef sender_address() -&gt; Address\n</code></pre> <p>Get the sender address.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_address","title":"counterparty<code>_</code>address","text":"<pre><code>@property\ndef counterparty_address() -&gt; Address\n</code></pre> <p>Get the counterparty address.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_address_1","title":"counterparty<code>_</code>address","text":"<pre><code>@counterparty_address.setter\ndef counterparty_address(counterparty_address: Address) -&gt; None\n</code></pre> <p>Set the counterparty address.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#amount_by_currency_id","title":"amount<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef amount_by_currency_id() -&gt; Dict[str, int]\n</code></pre> <p>Get the amount by currency id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_sender_payable_tx_fee","title":"is<code>_</code>sender<code>_</code>payable<code>_</code>tx<code>_</code>fee","text":"<pre><code>@property\ndef is_sender_payable_tx_fee() -&gt; bool\n</code></pre> <p>Bool indicating whether the tx fee is paid by sender or counterparty.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_single_currency","title":"is<code>_</code>single<code>_</code>currency","text":"<pre><code>@property\ndef is_single_currency() -&gt; bool\n</code></pre> <p>Check whether a single currency is used for payment.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_empty_currency","title":"is<code>_</code>empty<code>_</code>currency","text":"<pre><code>@property\ndef is_empty_currency() -&gt; bool\n</code></pre> <p>Check whether a single currency is used for payment.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#currency_id","title":"currency<code>_</code>id","text":"<pre><code>@property\ndef currency_id() -&gt; str\n</code></pre> <p>Get the amount the sender must pay.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_payable_amount","title":"sender<code>_</code>payable<code>_</code>amount","text":"<pre><code>@property\ndef sender_payable_amount() -&gt; int\n</code></pre> <p>Get the amount the sender must pay.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_payable_amount_incl_fee","title":"sender<code>_</code>payable<code>_</code>amount<code>_</code>incl<code>_</code>fee","text":"<pre><code>@property\ndef sender_payable_amount_incl_fee() -&gt; int\n</code></pre> <p>Get the amount the sender must pay inclusive fee.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_payable_amount","title":"counterparty<code>_</code>payable<code>_</code>amount","text":"<pre><code>@property\ndef counterparty_payable_amount() -&gt; int\n</code></pre> <p>Get the amount the counterparty must pay.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_payable_amount_incl_fee","title":"counterparty<code>_</code>payable<code>_</code>amount<code>_</code>incl<code>_</code>fee","text":"<pre><code>@property\ndef counterparty_payable_amount_incl_fee() -&gt; int\n</code></pre> <p>Get the amount the counterparty must pay.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#quantities_by_good_id","title":"quantities<code>_</code>by<code>_</code>good<code>_</code>id","text":"<pre><code>@property\ndef quantities_by_good_id() -&gt; Dict[str, int]\n</code></pre> <p>Get the quantities by good id.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#good_ids","title":"good<code>_</code>ids","text":"<pre><code>@property\ndef good_ids() -&gt; List[str]\n</code></pre> <p>Get the (ordered) good ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_supplied_quantities","title":"sender<code>_</code>supplied<code>_</code>quantities","text":"<pre><code>@property\ndef sender_supplied_quantities() -&gt; List[int]\n</code></pre> <p>Get the (ordered) quantities supplied by the sender.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_supplied_quantities","title":"counterparty<code>_</code>supplied<code>_</code>quantities","text":"<pre><code>@property\ndef counterparty_supplied_quantities() -&gt; List[int]\n</code></pre> <p>Get the (ordered) quantities supplied by the counterparty.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#nonce","title":"nonce","text":"<pre><code>@property\ndef nonce() -&gt; str\n</code></pre> <p>Get the nonce.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#has_fee","title":"has<code>_</code>fee","text":"<pre><code>@property\ndef has_fee() -&gt; bool\n</code></pre> <p>Check if fee is set.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#fee","title":"fee","text":"<pre><code>@property\ndef fee() -&gt; int\n</code></pre> <p>Get the fee.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#sender_fee","title":"sender<code>_</code>fee","text":"<pre><code>@property\ndef sender_fee() -&gt; int\n</code></pre> <p>Get the sender fee.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#counterparty_fee","title":"counterparty<code>_</code>fee","text":"<pre><code>@property\ndef counterparty_fee() -&gt; int\n</code></pre> <p>Get the counterparty fee.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#fee_by_currency_id","title":"fee<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef fee_by_currency_id() -&gt; Dict[str, int]\n</code></pre> <p>Get fee by currency.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#kwargs","title":"kwargs","text":"<pre><code>@property\ndef kwargs() -&gt; JSONLike\n</code></pre> <p>Get the kwargs.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#is_strict","title":"is<code>_</code>strict","text":"<pre><code>@property\ndef is_strict() -&gt; bool\n</code></pre> <p>Get is_strict.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\ndef get_hash(ledger_id: str, sender_address: str, counterparty_address: str,\ngood_ids: List[str], sender_supplied_quantities: List[int],\ncounterparty_supplied_quantities: List[int],\nsender_payable_amount: int, counterparty_payable_amount: int,\nnonce: str) -&gt; str\n</code></pre> <p>Generate a hash from transaction information.</p> <p>Arguments:</p> <ul> <li><code>ledger_id</code>: the ledger id</li> <li><code>sender_address</code>: the sender address</li> <li><code>counterparty_address</code>: the counterparty address</li> <li><code>good_ids</code>: the list of good ids</li> <li><code>sender_supplied_quantities</code>: the quantities supplied by the sender (must all be positive)</li> <li><code>counterparty_supplied_quantities</code>: the quantities supplied by the counterparty (must all be positive)</li> <li><code>sender_payable_amount</code>: the amount payable by the sender</li> <li><code>counterparty_payable_amount</code>: the amount payable by the counterparty</li> <li><code>nonce</code>: the nonce of the transaction</li> </ul> <p>Returns:</p> <p>the hash</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_5","title":"encode","text":"<pre><code>@staticmethod\ndef encode(terms_protobuf_object: Any, terms_object: \"Terms\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the terms_protobuf_object argument must be matched with the instance of this class in the 'terms_object' argument.</p> <p>Arguments:</p> <ul> <li><code>terms_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>terms_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_5","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, terms_protobuf_object: Any) -&gt; \"Terms\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'terms_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>terms_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'terms_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___5","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___5","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#transactiondigest-objects","title":"TransactionDigest Objects","text":"<pre><code>class TransactionDigest()\n</code></pre> <p>This class represents an instance of TransactionDigest.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___6","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str, body: str) -&gt; None\n</code></pre> <p>Initialise an instance of TransactionDigest.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_6","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#body_5","title":"body","text":"<pre><code>@property\ndef body() -&gt; str\n</code></pre> <p>Get the receipt.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_6","title":"encode","text":"<pre><code>@staticmethod\ndef encode(transaction_digest_protobuf_object: Any,\ntransaction_digest_object: \"TransactionDigest\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the transaction_digest_protobuf_object argument must be matched with the instance of this class in the 'transaction_digest_object' argument.</p> <p>Arguments:</p> <ul> <li><code>transaction_digest_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>transaction_digest_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_6","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls,\ntransaction_digest_protobuf_object: Any) -&gt; \"TransactionDigest\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>transaction_digest_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___6","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___6","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#transactionreceipt-objects","title":"TransactionReceipt Objects","text":"<pre><code>class TransactionReceipt()\n</code></pre> <p>This class represents an instance of TransactionReceipt.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__init___7","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(ledger_id: str, receipt: JSONLike, transaction: JSONLike) -&gt; None\n</code></pre> <p>Initialise an instance of TransactionReceipt.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#ledger_id_7","title":"ledger<code>_</code>id","text":"<pre><code>@property\ndef ledger_id() -&gt; str\n</code></pre> <p>Get the id of the ledger on which the terms are to be settled.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#receipt","title":"receipt","text":"<pre><code>@property\ndef receipt() -&gt; JSONLike\n</code></pre> <p>Get the receipt.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#transaction","title":"transaction","text":"<pre><code>@property\ndef transaction() -&gt; JSONLike\n</code></pre> <p>Get the transaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#encode_7","title":"encode","text":"<pre><code>@staticmethod\ndef encode(transaction_receipt_protobuf_object: Any,\ntransaction_receipt_object: \"TransactionReceipt\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the transaction_receipt_protobuf_object argument must be matched with the instance of this class in the 'transaction_receipt_object' argument.</p> <p>Arguments:</p> <ul> <li><code>transaction_receipt_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>transaction_receipt_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#decode_7","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls,\ntransaction_receipt_protobuf_object: Any) -&gt; \"TransactionReceipt\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class must be created that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>transaction_receipt_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__eq___7","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check equality.</p> <p></p>"},{"location":"aea-framework-documentation/api/helpers/transaction/base/#__str___7","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p>"},{"location":"aea-framework-documentation/api/identity/base/","title":"Identity","text":""},{"location":"aea-framework-documentation/api/identity/base/#aeaidentitybase","title":"aea.identity.base","text":"<p>This module contains the identity class.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#identity-objects","title":"Identity Objects","text":"<pre><code>class Identity()\n</code></pre> <p>The identity holds the public elements identifying an agent.</p> <p>It includes:</p> <ul> <li>the agent name</li> <li>the addresses, a map from address identifier to address (can be a single key-value pair)</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(name: SimpleIdOrStr,\naddress: Optional[str] = None,\npublic_key: Optional[str] = None,\naddresses: Optional[Dict[str, Address]] = None,\npublic_keys: Optional[Dict[str, str]] = None,\ndefault_address_key: str = DEFAULT_LEDGER) -&gt; None\n</code></pre> <p>Instantiate the identity.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the agent.</li> <li><code>address</code>: the default address of the agent.</li> <li><code>public_key</code>: the public key of the agent.</li> <li><code>addresses</code>: the addresses of the agent.</li> <li><code>public_keys</code>: the public keys of the agent.</li> <li><code>default_address_key</code>: the key for the default address.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#default_address_key","title":"default<code>_</code>address<code>_</code>key","text":"<pre><code>@property\ndef default_address_key() -&gt; str\n</code></pre> <p>Get the default address key.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#addresses","title":"addresses","text":"<pre><code>@property\ndef addresses() -&gt; Dict[str, Address]\n</code></pre> <p>Get the addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; Address\n</code></pre> <p>Get the default address.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#public_keys","title":"public<code>_</code>keys","text":"<pre><code>@property\ndef public_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get the public keys.</p> <p></p>"},{"location":"aea-framework-documentation/api/identity/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Get the default public key.</p>"},{"location":"aea-framework-documentation/api/mail/base/","title":"Mail","text":""},{"location":"aea-framework-documentation/api/mail/base/#aeamailbase","title":"aea.mail.base","text":"<p>Mail module abstract base classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#uri-objects","title":"URI Objects","text":"<pre><code>class URI()\n</code></pre> <p>URI following RFC3986.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(uri_raw: str) -&gt; None\n</code></pre> <p>Initialize the URI.</p> <p>Must follow: https://tools.ietf.org/html/rfc3986.html</p> <p>Arguments:</p> <ul> <li><code>uri_raw</code>: the raw form uri</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#scheme","title":"scheme","text":"<pre><code>@property\ndef scheme() -&gt; str\n</code></pre> <p>Get the scheme.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#netloc","title":"netloc","text":"<pre><code>@property\ndef netloc() -&gt; str\n</code></pre> <p>Get the netloc.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#path","title":"path","text":"<pre><code>@property\ndef path() -&gt; str\n</code></pre> <p>Get the path.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#params","title":"params","text":"<pre><code>@property\ndef params() -&gt; str\n</code></pre> <p>Get the params.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#query","title":"query","text":"<pre><code>@property\ndef query() -&gt; str\n</code></pre> <p>Get the query.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#fragment","title":"fragment","text":"<pre><code>@property\ndef fragment() -&gt; str\n</code></pre> <p>Get the fragment.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#username","title":"username","text":"<pre><code>@property\ndef username() -&gt; Optional[str]\n</code></pre> <p>Get the username.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#password","title":"password","text":"<pre><code>@property\ndef password() -&gt; Optional[str]\n</code></pre> <p>Get the password.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#host","title":"host","text":"<pre><code>@property\ndef host() -&gt; Optional[str]\n</code></pre> <p>Get the host.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#port","title":"port","text":"<pre><code>@property\ndef port() -&gt; Optional[int]\n</code></pre> <p>Get the port.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#envelopecontext-objects","title":"EnvelopeContext Objects","text":"<pre><code>class EnvelopeContext()\n</code></pre> <p>Contains context information of an envelope.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(connection_id: Optional[PublicId] = None,\nuri: Optional[URI] = None) -&gt; None\n</code></pre> <p>Initialize the envelope context.</p> <p>Arguments:</p> <ul> <li><code>connection_id</code>: the connection id used for routing the outgoing envelope in the multiplexer.</li> <li><code>uri</code>: the URI sent with the envelope.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#uri","title":"uri","text":"<pre><code>@property\ndef uri() -&gt; Optional[URI]\n</code></pre> <p>Get the URI.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#connection_id","title":"connection<code>_</code>id","text":"<pre><code>@property\ndef connection_id() -&gt; Optional[PublicId]\n</code></pre> <p>Get the connection id to route the envelope.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#connection_id_1","title":"connection<code>_</code>id","text":"<pre><code>@connection_id.setter\ndef connection_id(connection_id: PublicId) -&gt; None\n</code></pre> <p>Set the 'via' connection id.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__str___1","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__eq___1","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#aeaconnectionerror-objects","title":"AEAConnectionError Objects","text":"<pre><code>class AEAConnectionError(Exception)\n</code></pre> <p>Exception class for connection errors.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#empty-objects","title":"Empty Objects","text":"<pre><code>class Empty(Exception)\n</code></pre> <p>Exception for when the inbox is empty.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#envelopeserializer-objects","title":"EnvelopeSerializer Objects","text":"<pre><code>class EnvelopeSerializer(ABC)\n</code></pre> <p>Abstract class to specify the serialization layer for the envelope.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#encode","title":"encode","text":"<pre><code>@abstractmethod\ndef encode(envelope: \"Envelope\") -&gt; bytes\n</code></pre> <p>Encode the envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to encode</li> </ul> <p>Returns:</p> <p>the encoded envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#decode","title":"decode","text":"<pre><code>@abstractmethod\ndef decode(envelope_bytes: bytes) -&gt; \"Envelope\"\n</code></pre> <p>Decode the envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope_bytes</code>: the encoded envelope</li> </ul> <p>Returns:</p> <p>the envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#protobufenvelopeserializer-objects","title":"ProtobufEnvelopeSerializer Objects","text":"<pre><code>class ProtobufEnvelopeSerializer(EnvelopeSerializer)\n</code></pre> <p>Envelope serializer using Protobuf.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#encode_1","title":"encode","text":"<pre><code>def encode(envelope: \"Envelope\") -&gt; bytes\n</code></pre> <p>Encode the envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: the envelope to encode</li> </ul> <p>Returns:</p> <p>the encoded envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#decode_1","title":"decode","text":"<pre><code>def decode(envelope_bytes: bytes) -&gt; \"Envelope\"\n</code></pre> <p>Decode the envelope.</p> <p>The default serializer doesn't decode the message field.</p> <p>Arguments:</p> <ul> <li><code>envelope_bytes</code>: the encoded envelope</li> </ul> <p>Returns:</p> <p>the envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#envelope-objects","title":"Envelope Objects","text":"<pre><code>class Envelope()\n</code></pre> <p>The top level message class for agent to agent communication.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(to: Address,\nsender: Address,\nmessage: Union[Message, bytes],\ncontext: Optional[EnvelopeContext] = None,\nprotocol_specification_id: Optional[PublicId] = None) -&gt; None\n</code></pre> <p>Initialize a Message object.</p> <p>Arguments:</p> <ul> <li><code>to</code>: the address of the receiver.</li> <li><code>sender</code>: the address of the sender.</li> <li><code>message</code>: the protocol-specific message.</li> <li><code>context</code>: the optional envelope context.</li> <li><code>protocol_specification_id</code>: the protocol specification id (wire id).</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#to","title":"to","text":"<pre><code>@property\ndef to() -&gt; Address\n</code></pre> <p>Get address of receiver.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#to_1","title":"to","text":"<pre><code>@to.setter\ndef to(to: Address) -&gt; None\n</code></pre> <p>Set address of receiver.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#sender","title":"sender","text":"<pre><code>@property\ndef sender() -&gt; Address\n</code></pre> <p>Get address of sender.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#sender_1","title":"sender","text":"<pre><code>@sender.setter\ndef sender(sender: Address) -&gt; None\n</code></pre> <p>Set address of sender.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#protocol_specification_id","title":"protocol<code>_</code>specification<code>_</code>id","text":"<pre><code>@property\ndef protocol_specification_id() -&gt; PublicId\n</code></pre> <p>Get protocol_specification_id.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#message","title":"message","text":"<pre><code>@property\ndef message() -&gt; Union[Message, bytes]\n</code></pre> <p>Get the protocol-specific message.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#message_1","title":"message","text":"<pre><code>@message.setter\ndef message(message: Union[Message, bytes]) -&gt; None\n</code></pre> <p>Set the protocol-specific message.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#message_bytes","title":"message<code>_</code>bytes","text":"<pre><code>@property\ndef message_bytes() -&gt; bytes\n</code></pre> <p>Get the protocol-specific message.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#context","title":"context","text":"<pre><code>@property\ndef context() -&gt; Optional[EnvelopeContext]\n</code></pre> <p>Get the envelope context.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#to_as_public_id","title":"to<code>_</code>as<code>_</code>public<code>_</code>id","text":"<pre><code>@property\ndef to_as_public_id() -&gt; Optional[PublicId]\n</code></pre> <p>Get to as public id.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#is_sender_public_id","title":"is<code>_</code>sender<code>_</code>public<code>_</code>id","text":"<pre><code>@property\ndef is_sender_public_id() -&gt; bool\n</code></pre> <p>Check if sender is a public id.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#is_to_public_id","title":"is<code>_</code>to<code>_</code>public<code>_</code>id","text":"<pre><code>@property\ndef is_to_public_id() -&gt; bool\n</code></pre> <p>Check if to is a public id.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#is_component_to_component_message","title":"is<code>_</code>component<code>_</code>to<code>_</code>component<code>_</code>message","text":"<pre><code>@property\ndef is_component_to_component_message() -&gt; bool\n</code></pre> <p>Whether or not the message contained is component to component.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__eq___2","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#encode_2","title":"encode","text":"<pre><code>def encode(serializer: Optional[EnvelopeSerializer] = None) -&gt; bytes\n</code></pre> <p>Encode the envelope.</p> <p>Arguments:</p> <ul> <li><code>serializer</code>: the serializer that implements the encoding procedure.</li> </ul> <p>Returns:</p> <p>the encoded envelope.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#decode_2","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls,\nenvelope_bytes: bytes,\nserializer: Optional[EnvelopeSerializer] = None) -&gt; \"Envelope\"\n</code></pre> <p>Decode the envelope.</p> <p>Arguments:</p> <ul> <li><code>envelope_bytes</code>: the bytes to be decoded.</li> <li><code>serializer</code>: the serializer that implements the decoding procedure.</li> </ul> <p>Returns:</p> <p>the decoded envelope.</p> <p></p>"},{"location":"aea-framework-documentation/api/mail/base/#__str___2","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation of an envelope.</p>"},{"location":"aea-framework-documentation/api/manager/manager/","title":"Manager","text":""},{"location":"aea-framework-documentation/api/manager/manager/#aeamanagermanager","title":"aea.manager.manager","text":"<p>This module contains the implementation of AEA agents manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#projectnotfounderror-objects","title":"ProjectNotFoundError Objects","text":"<pre><code>class ProjectNotFoundError(ValueError)\n</code></pre> <p>Project not found exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#projectcheckerror-objects","title":"ProjectCheckError Objects","text":"<pre><code>class ProjectCheckError(ValueError)\n</code></pre> <p>Project check error exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(msg: str, source_exception: Exception)\n</code></pre> <p>Init exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#projectpackageconsistencycheckerror-objects","title":"ProjectPackageConsistencyCheckError Objects","text":"<pre><code>class ProjectPackageConsistencyCheckError(ValueError)\n</code></pre> <p>Check consistency of package versions against already added project.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_project_id: PublicId,\nconflicting_packages: List[Tuple[PackageIdPrefix, str, str,\nSet[PublicId]]])\n</code></pre> <p>Initialize the exception.</p> <p>Arguments:</p> <ul> <li><code>agent_project_id</code>: the agent project id whose addition has failed.</li> <li><code>conflicting_packages</code>: the conflicting packages.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#baseagentruntask-objects","title":"BaseAgentRunTask Objects","text":"<pre><code>class BaseAgentRunTask(ABC)\n</code></pre> <p>Base abstract class for agent run tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start","title":"start","text":"<pre><code>@abstractmethod\ndef start() -&gt; None\n</code></pre> <p>Start task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#wait","title":"wait","text":"<pre><code>@abstractmethod\ndef wait() -&gt; asyncio.Future\n</code></pre> <p>Return future to wait task completed.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop","title":"stop","text":"<pre><code>@abstractmethod\ndef stop() -&gt; None\n</code></pre> <p>Stop task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#is_running","title":"is<code>_</code>running","text":"<pre><code>@property\n@abstractmethod\ndef is_running() -&gt; bool\n</code></pre> <p>Return is task running.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#agentrunasynctask-objects","title":"AgentRunAsyncTask Objects","text":"<pre><code>class AgentRunAsyncTask(BaseAgentRunTask)\n</code></pre> <p>Async task wrapper for agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AEA, loop: asyncio.AbstractEventLoop) -&gt; None\n</code></pre> <p>Init task with agent alias and loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#create_run_loop","title":"create<code>_</code>run<code>_</code>loop","text":"<pre><code>def create_run_loop() -&gt; None\n</code></pre> <p>Create run loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_1","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#wait_1","title":"wait","text":"<pre><code>def wait() -&gt; asyncio.Future\n</code></pre> <p>Return future to wait task completed.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_1","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#run","title":"run","text":"<pre><code>async def run() -&gt; None\n</code></pre> <p>Run task body.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#is_running_1","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Return is task running.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#agentrunthreadtask-objects","title":"AgentRunThreadTask Objects","text":"<pre><code>class AgentRunThreadTask(AgentRunAsyncTask)\n</code></pre> <p>Threaded wrapper to run agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent: AEA, loop: asyncio.AbstractEventLoop) -&gt; None\n</code></pre> <p>Init task with agent alias and loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#create_run_loop_1","title":"create<code>_</code>run<code>_</code>loop","text":"<pre><code>def create_run_loop() -&gt; None\n</code></pre> <p>Create run loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_2","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Run task in a dedicated thread.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_2","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop the task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#agentrunprocesstask-objects","title":"AgentRunProcessTask Objects","text":"<pre><code>class AgentRunProcessTask(BaseAgentRunTask)\n</code></pre> <p>Subprocess wrapper to run agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_alias: AgentAlias, loop: asyncio.AbstractEventLoop) -&gt; None\n</code></pre> <p>Init task with agent alias and loop.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_3","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Run task in a dedicated process.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#wait_2","title":"wait","text":"<pre><code>def wait() -&gt; asyncio.Future\n</code></pre> <p>Return future to wait task completed.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_3","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop the task.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#is_running_2","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Is agent running.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#multiagentmanager-objects","title":"MultiAgentManager Objects","text":"<pre><code>class MultiAgentManager()\n</code></pre> <p>Multi agents manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(working_dir: str,\nmode: str = \"async\",\nregistry_path: str = DEFAULT_REGISTRY_NAME,\nauto_add_remove_project: bool = False,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Initialize manager.</p> <p>Arguments:</p> <ul> <li><code>working_dir</code>: directory to store base agents.</li> <li><code>mode</code>: str. async or threaded</li> <li><code>registry_path</code>: str. path to the local packages registry</li> <li><code>auto_add_remove_project</code>: bool. add/remove project on the first agent add/last agent remove</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#data_dir","title":"data<code>_</code>dir","text":"<pre><code>@property\ndef data_dir() -&gt; str\n</code></pre> <p>Get the certs directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#get_data_dir_of_agent","title":"get<code>_</code>data<code>_</code>dir<code>_</code>of<code>_</code>agent","text":"<pre><code>def get_data_dir_of_agent(agent_name: str) -&gt; str\n</code></pre> <p>Get the data directory of a specific agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#is_running_3","title":"is<code>_</code>running","text":"<pre><code>@property\ndef is_running() -&gt; bool\n</code></pre> <p>Is manager running.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#dict_state","title":"dict<code>_</code>state","text":"<pre><code>@property\ndef dict_state() -&gt; Dict[str, Any]\n</code></pre> <p>Create MultiAgentManager dist state.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#projects","title":"projects","text":"<pre><code>@property\ndef projects() -&gt; Dict[PublicId, Project]\n</code></pre> <p>Get all projects.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#add_error_callback","title":"add<code>_</code>error<code>_</code>callback","text":"<pre><code>def add_error_callback(\nerror_callback: Callable[[str, BaseException],\nNone]) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Add error callback to call on error raised.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_manager","title":"start<code>_</code>manager","text":"<pre><code>def start_manager(local: bool = False,\nremote: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Start manager.</p> <p>If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure).</p> <p>Arguments:</p> <ul> <li><code>local</code>: whether or not to fetch from local registry.</li> <li><code>remote</code>: whether or not to fetch from remote registry.</li> </ul> <p>Returns:</p> <p>the MultiAgentManager instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#last_start_status","title":"last<code>_</code>start<code>_</code>status","text":"<pre><code>@property\ndef last_start_status() -&gt; Tuple[bool, Dict[PublicId, List[Dict]], List[Tuple[\nPublicId, List[Dict], Exception]], ]\n</code></pre> <p>Get status of the last agents start loading state.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_manager","title":"stop<code>_</code>manager","text":"<pre><code>def stop_manager(cleanup: bool = True,\nsave: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Stop manager.</p> <p>Stops all running agents and stop agent.</p> <p>Arguments:</p> <ul> <li><code>cleanup</code>: bool is cleanup on stop.</li> <li><code>save</code>: bool is save state to file on stop.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#add_project","title":"add<code>_</code>project","text":"<pre><code>def add_project(public_id: PublicId,\nlocal: bool = False,\nremote: bool = False,\nrestore: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Fetch agent project and all dependencies to working_dir.</p> <p>If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure).</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public if of the agent project.</li> <li><code>local</code>: whether or not to fetch from local registry.</li> <li><code>remote</code>: whether or not to fetch from remote registry.</li> <li><code>restore</code>: bool flag for restoring already fetched agent.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#remove_project","title":"remove<code>_</code>project","text":"<pre><code>def remove_project(public_id: PublicId,\nkeep_files: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Remove agent project.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#list_projects","title":"list<code>_</code>projects","text":"<pre><code>def list_projects() -&gt; List[PublicId]\n</code></pre> <p>List all agents projects added.</p> <p>Returns:</p> <p>list of public ids of projects</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#add_agent","title":"add<code>_</code>agent","text":"<pre><code>def add_agent(public_id: PublicId,\nagent_name: Optional[str] = None,\nagent_overrides: Optional[dict] = None,\ncomponent_overrides: Optional[List[dict]] = None,\nlocal: bool = False,\nremote: bool = False,\nrestore: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Create new agent configuration based on project with config overrides applied.</p> <p>Alias is stored in memory only!</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: base agent project public id</li> <li><code>agent_name</code>: unique name for the agent</li> <li><code>agent_overrides</code>: overrides for agent config.</li> <li><code>component_overrides</code>: overrides for component section.</li> <li><code>local</code>: whether or not to fetch from local registry.</li> <li><code>remote</code>: whether or not to fetch from remote registry.</li> <li><code>restore</code>: bool flag for restoring already fetched agent.</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#add_agent_with_config","title":"add<code>_</code>agent<code>_</code>with<code>_</code>config","text":"<pre><code>def add_agent_with_config(\npublic_id: PublicId,\nconfig: List[dict],\nagent_name: Optional[str] = None) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Create new agent configuration based on project with config provided.</p> <p>Alias is stored in memory only!</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: base agent project public id</li> <li><code>agent_name</code>: unique name for the agent</li> <li><code>config</code>: agent config (used for agent re-creation).</li> </ul> <p>Returns:</p> <p>manager</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#get_agent_overridables","title":"get<code>_</code>agent<code>_</code>overridables","text":"<pre><code>def get_agent_overridables(agent_name: str) -&gt; Tuple[Dict, List[Dict]]\n</code></pre> <p>Get agent config  overridables.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: str</li> </ul> <p>Returns:</p> <p>Tuple of agent overridables dict and  and list of component overridables dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#set_agent_overrides","title":"set<code>_</code>agent<code>_</code>overrides","text":"<pre><code>def set_agent_overrides(\nagent_name: str, agent_overides: Optional[Dict],\ncomponents_overrides: Optional[List[Dict]]) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Set agent overrides.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: str</li> <li><code>agent_overides</code>: optional dict of agent config overrides</li> <li><code>components_overrides</code>: optional list of dict of components overrides</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#list_agents_info","title":"list<code>_</code>agents<code>_</code>info","text":"<pre><code>def list_agents_info() -&gt; List[Dict[str, Any]]\n</code></pre> <p>List agents detailed info.</p> <p>Returns:</p> <p>list of dicts that represents agent info: public_id, name, is_running.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#list_agents","title":"list<code>_</code>agents","text":"<pre><code>def list_agents(running_only: bool = False) -&gt; List[str]\n</code></pre> <p>List all agents.</p> <p>Arguments:</p> <ul> <li><code>running_only</code>: returns only running if set to True</li> </ul> <p>Returns:</p> <p>list of agents names</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#remove_agent","title":"remove<code>_</code>agent","text":"<pre><code>def remove_agent(\nagent_name: str,\nskip_project_auto_remove: bool = False) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Remove agent alias definition from registry.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: agent name to remove</li> <li><code>skip_project_auto_remove</code>: disable auto project remove on last agent removed.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_agent","title":"start<code>_</code>agent","text":"<pre><code>def start_agent(agent_name: str) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Start selected agent.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: agent name to start</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_all_agents","title":"start<code>_</code>all<code>_</code>agents","text":"<pre><code>def start_all_agents() -&gt; \"MultiAgentManager\"\n</code></pre> <p>Start all not started agents.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_agent","title":"stop<code>_</code>agent","text":"<pre><code>def stop_agent(agent_name: str) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Stop running agent.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: agent name to stop</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_all_agents","title":"stop<code>_</code>all<code>_</code>agents","text":"<pre><code>def stop_all_agents() -&gt; \"MultiAgentManager\"\n</code></pre> <p>Stop all agents running.</p> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#stop_agents","title":"stop<code>_</code>agents","text":"<pre><code>def stop_agents(agent_names: List[str]) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Stop specified agents.</p> <p>Arguments:</p> <ul> <li><code>agent_names</code>: names of agents</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#start_agents","title":"start<code>_</code>agents","text":"<pre><code>def start_agents(agent_names: List[str]) -&gt; \"MultiAgentManager\"\n</code></pre> <p>Stop specified agents.</p> <p>Arguments:</p> <ul> <li><code>agent_names</code>: names of agents</li> </ul> <p>Returns:</p> <p>self</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/manager/#get_agent_alias","title":"get<code>_</code>agent<code>_</code>alias","text":"<pre><code>def get_agent_alias(agent_name: str) -&gt; AgentAlias\n</code></pre> <p>Return details about agent alias definition.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: name of agent</li> </ul> <p>Returns:</p> <p>AgentAlias</p>"},{"location":"aea-framework-documentation/api/manager/project/","title":"Project","text":""},{"location":"aea-framework-documentation/api/manager/project/#aeamanagerproject","title":"aea.manager.project","text":"<p>This module contains the implementation of AEA agents project configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#_base-objects","title":"<code>_</code>Base Objects","text":"<pre><code>class _Base()\n</code></pre> <p>Base class to share some methods.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#builder","title":"builder","text":"<pre><code>@property\ndef builder() -&gt; AEABuilder\n</code></pre> <p>Get AEABuilder instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#install_pypi_dependencies","title":"install<code>_</code>pypi<code>_</code>dependencies","text":"<pre><code>def install_pypi_dependencies() -&gt; None\n</code></pre> <p>Install python dependencies for the project.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#project-objects","title":"Project Objects","text":"<pre><code>class Project(_Base)\n</code></pre> <p>Agent project representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(public_id: PublicId, path: str) -&gt; None\n</code></pre> <p>Init project with public_id and project's path.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#build","title":"build","text":"<pre><code>def build() -&gt; None\n</code></pre> <p>Call all build entry points.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#load","title":"load","text":"<pre><code>@classmethod\ndef load(cls,\nworking_dir: str,\npublic_id: PublicId,\nis_local: bool = False,\nis_remote: bool = False,\nis_restore: bool = False,\ncli_verbosity: str = \"INFO\",\nregistry_path: str = DEFAULT_REGISTRY_NAME,\nskip_consistency_check: bool = False,\nskip_aea_validation: bool = False) -&gt; \"Project\"\n</code></pre> <p>Load project with given public_id to working_dir.</p> <p>If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure).</p> <p>Arguments:</p> <ul> <li><code>working_dir</code>: the working directory</li> <li><code>public_id</code>: the public id</li> <li><code>is_local</code>: whether to fetch from local</li> <li><code>is_remote</code>: whether to fetch from remote</li> <li><code>is_restore</code>: whether to restore or not</li> <li><code>cli_verbosity</code>: the logging verbosity of the CLI</li> <li><code>registry_path</code>: the path to the registry locally</li> <li><code>skip_consistency_check</code>: consistency checks flag</li> <li><code>skip_aea_validation</code>: aea validation flag</li> </ul> <p>Returns:</p> <p>project</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#remove","title":"remove","text":"<pre><code>def remove() -&gt; None\n</code></pre> <p>Remove project, do cleanup.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#agent_config","title":"agent<code>_</code>config","text":"<pre><code>@property\ndef agent_config() -&gt; AgentConfig\n</code></pre> <p>Get the agent configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#builder_1","title":"builder","text":"<pre><code>@property\ndef builder() -&gt; AEABuilder\n</code></pre> <p>Get builder instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#check","title":"check","text":"<pre><code>def check() -&gt; None\n</code></pre> <p>Check we can still construct an AEA from the project with builder.build.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#agentalias-objects","title":"AgentAlias Objects","text":"<pre><code>class AgentAlias(_Base)\n</code></pre> <p>Agent alias representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(project: Project,\nagent_name: str,\ndata_dir: str,\npassword: Optional[str] = None)\n</code></pre> <p>Init agent alias with project, config, name, agent, builder.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#set_agent_config_from_data","title":"set<code>_</code>agent<code>_</code>config<code>_</code>from<code>_</code>data","text":"<pre><code>def set_agent_config_from_data(json_data: List[Dict]) -&gt; None\n</code></pre> <p>Set agent config instance constructed from json data.</p> <p>Arguments:</p> <ul> <li><code>json_data</code>: agent config json data</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#builder_2","title":"builder","text":"<pre><code>@property\ndef builder() -&gt; AEABuilder\n</code></pre> <p>Get builder instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#agent_config_1","title":"agent<code>_</code>config","text":"<pre><code>@property\ndef agent_config() -&gt; AgentConfig\n</code></pre> <p>Get agent config.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#remove_from_project","title":"remove<code>_</code>from<code>_</code>project","text":"<pre><code>def remove_from_project() -&gt; None\n</code></pre> <p>Remove agent alias from project.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#dict","title":"dict","text":"<pre><code>@property\ndef dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert AgentAlias to dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#config_json","title":"config<code>_</code>json","text":"<pre><code>@property\ndef config_json() -&gt; List[Dict]\n</code></pre> <p>Get agent config json data.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#get_aea_instance","title":"get<code>_</code>aea<code>_</code>instance","text":"<pre><code>def get_aea_instance() -&gt; AEA\n</code></pre> <p>Build new aea instance.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#issue_certificates","title":"issue<code>_</code>certificates","text":"<pre><code>def issue_certificates() -&gt; None\n</code></pre> <p>Issue the certificates for this agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#set_overrides","title":"set<code>_</code>overrides","text":"<pre><code>def set_overrides(agent_overrides: Optional[Dict] = None,\ncomponent_overrides: Optional[List[Dict]] = None) -&gt; None\n</code></pre> <p>Set override for this agent alias's config.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#agent_config_manager","title":"agent<code>_</code>config<code>_</code>manager","text":"<pre><code>@property\ndef agent_config_manager() -&gt; AgentConfigManager\n</code></pre> <p>Get agent configuration manager instance for the config.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#get_overridables","title":"get<code>_</code>overridables","text":"<pre><code>def get_overridables() -&gt; Tuple[Dict, List[Dict]]\n</code></pre> <p>Get all overridables for this agent alias's config.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#get_addresses","title":"get<code>_</code>addresses","text":"<pre><code>def get_addresses() -&gt; Dict[str, str]\n</code></pre> <p>Get addresses from private keys.</p> <p>Returns:</p> <p>dict with crypto id str as key and address str as value</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/project/#get_connections_addresses","title":"get<code>_</code>connections<code>_</code>addresses","text":"<pre><code>def get_connections_addresses() -&gt; Dict[str, str]\n</code></pre> <p>Get connections addresses from connections private keys.</p> <p>Returns:</p> <p>dict with crypto id str as key and address str as value</p>"},{"location":"aea-framework-documentation/api/manager/utils/","title":"Utils","text":""},{"location":"aea-framework-documentation/api/manager/utils/#aeamanagerutils","title":"aea.manager.utils","text":"<p>Multiagent manager utils.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#get_lib_path","title":"get<code>_</code>lib<code>_</code>path","text":"<pre><code>def get_lib_path(env_dir: str) -&gt; str\n</code></pre> <p>Get librarty path for env dir.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#make_venv","title":"make<code>_</code>venv","text":"<pre><code>def make_venv(env_dir: str, set_env: bool = False) -&gt; None\n</code></pre> <p>Make venv and update variable to use it.</p> <p>Arguments:</p> <ul> <li><code>env_dir</code>: str, path for new env dir</li> <li><code>set_env</code>: bool. use evn within this python process (update, sys.executable and sys.path)</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#project_install_and_build","title":"project<code>_</code>install<code>_</code>and<code>_</code>build","text":"<pre><code>def project_install_and_build(project: Project) -&gt; None\n</code></pre> <p>Install project dependencies and build required components.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#get_venv_dir_for_project","title":"get<code>_</code>venv<code>_</code>dir<code>_</code>for<code>_</code>project","text":"<pre><code>def get_venv_dir_for_project(project: Project) -&gt; str\n</code></pre> <p>Get virtual env directory for project specified.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#project_check","title":"project<code>_</code>check","text":"<pre><code>def project_check(project: Project) -&gt; None\n</code></pre> <p>Perform project loads well.</p> <p></p>"},{"location":"aea-framework-documentation/api/manager/utils/#run_in_venv","title":"run<code>_</code>in<code>_</code>venv","text":"<pre><code>def run_in_venv(env_dir: str, fn: Callable, timeout: float, *args: Any) -&gt; Any\n</code></pre> <p>Run python function in a dedicated process with virtual env specified.</p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/","title":"API","text":""},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#pluginsaea-cli-ipfsaea_cli_ipfscore","title":"plugins.aea-cli-ipfs.aea<code>_</code>cli<code>_</code>ipfs.core","text":"<p>Core components for <code>ipfs cli command</code>.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#ipfs","title":"ipfs","text":"<pre><code>@click.group()\n@click.pass_context\ndef ipfs(click_context: click.Context) -&gt; None\n</code></pre> <p>IPFS Commands</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#process_result","title":"process<code>_</code>result","text":"<pre><code>@ipfs.result_callback()\n@click.pass_context\ndef process_result(click_context: click.Context, *_: Any) -&gt; None\n</code></pre> <p>Tear down command group.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#add","title":"add","text":"<pre><code>@ipfs.command()\n@click.argument(\n\"dir_path\",\ntype=click.Path(exists=True,\ndir_okay=True,\nfile_okay=False,\nresolve_path=True,\nreadable=True),\nrequired=False,\n)\n@click.option(\"-p\", \"--publish\", is_flag=True)\n@click.option(\"--no-pin\", is_flag=True)\n@click.pass_context\ndef add(click_context: click.Context,\ndir_path: Optional[str],\npublish: bool = False,\nno_pin: bool = False) -&gt; None\n</code></pre> <p>Add directory to ipfs, if not directory specified the current one will be added.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#remove","title":"remove","text":"<pre><code>@ipfs.command()\n@click.argument(\n\"hash_\",\nmetavar=\"hash\",\ntype=str,\nrequired=True,\n)\n@click.pass_context\ndef remove(click_context: click.Context, hash_: str) -&gt; None\n</code></pre> <p>Remove a directory from ipfs by it's hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/core/#download","title":"download","text":"<pre><code>@ipfs.command()\n@click.argument(\n\"hash_\",\nmetavar=\"hash\",\ntype=str,\nrequired=True,\n)\n@click.argument(\n\"target_dir\",\ntype=click.Path(dir_okay=True, file_okay=False, resolve_path=True),\nrequired=False,\n)\n@click.pass_context\ndef download(click_context: click.Context, hash_: str,\ntarget_dir: Optional[str]) -&gt; None\n</code></pre> <p>Download directory by it's hash, if not target directory specified will use current one.</p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/","title":"Utils","text":""},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#pluginsaea-cli-ipfsaea_cli_ipfsipfs_utils","title":"plugins.aea-cli-ipfs.aea<code>_</code>cli<code>_</code>ipfs.ipfs<code>_</code>utils","text":"<p>Ipfs utils for <code>ipfs cli command</code>.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#ipfsdaemon-objects","title":"IPFSDaemon Objects","text":"<pre><code>class IPFSDaemon()\n</code></pre> <p>Set up the IPFS daemon.</p> <p>Raises:</p> <ul> <li><code>Exception</code>: if IPFS is not installed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Initialise IPFS daemon.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#is_started","title":"is<code>_</code>started","text":"<pre><code>def is_started() -&gt; bool\n</code></pre> <p>Check daemon was started.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Run the ipfs daemon.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Terminate the ipfs daemon.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#baseipfstoolexception-objects","title":"BaseIPFSToolException Objects","text":"<pre><code>class BaseIPFSToolException(Exception)\n</code></pre> <p>Base ipfs tool exception.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#removeerror-objects","title":"RemoveError Objects","text":"<pre><code>class RemoveError(BaseIPFSToolException)\n</code></pre> <p>Exception on remove.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#publisherror-objects","title":"PublishError Objects","text":"<pre><code>class PublishError(BaseIPFSToolException)\n</code></pre> <p>Exception on publish.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#nodeerror-objects","title":"NodeError Objects","text":"<pre><code>class NodeError(BaseIPFSToolException)\n</code></pre> <p>Exception for node connection check.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#downloaderror-objects","title":"DownloadError Objects","text":"<pre><code>class DownloadError(BaseIPFSToolException)\n</code></pre> <p>Exception on download failed.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#ipfstool-objects","title":"IPFSTool Objects","text":"<pre><code>class IPFSTool()\n</code></pre> <p>IPFS tool to add, publish, remove, download directories.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(client_options: Optional[Dict] = None)\n</code></pre> <p>Init tool.</p> <p>Arguments:</p> <ul> <li><code>client_options</code>: dict, options for ipfshttpclient instance.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#add","title":"add","text":"<pre><code>def add(dir_path: str, pin: bool = True) -&gt; Tuple[str, str, List]\n</code></pre> <p>Add directory to ipfs.</p> <p>It wraps into directory.</p> <p>Arguments:</p> <ul> <li><code>dir_path</code>: str, path to dir to publish</li> <li><code>pin</code>: bool, pin object or not</li> </ul> <p>Returns:</p> <p>dir name published, hash, list of items processed</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#remove","title":"remove","text":"<pre><code>def remove(hash_id: str) -&gt; Dict\n</code></pre> <p>Remove dir added by it's hash.</p> <p>Arguments:</p> <ul> <li><code>hash_id</code>: str. hash of dir to remove</li> </ul> <p>Returns:</p> <p>dict with unlinked items.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#download","title":"download","text":"<pre><code>def download(hash_id: str, target_dir: str, fix_path: bool = True) -&gt; None\n</code></pre> <p>Download dir by it's hash.</p> <p>Arguments:</p> <ul> <li><code>hash_id</code>: str. hash of file to download</li> <li><code>target_dir</code>: str. directory to place downloaded</li> <li><code>fix_path</code>: bool. default True. on download don't wrap result in to hash_id directory.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#publish","title":"publish","text":"<pre><code>def publish(hash_id: str) -&gt; Dict\n</code></pre> <p>Publish directory by it's hash id.</p> <p>Arguments:</p> <ul> <li><code>hash_id</code>: hash of the directory to publish.</li> </ul> <p>Returns:</p> <p>dict of names it was publish for.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_cli_ipfs/ipfs_utils/#chec_ipfs_node_running","title":"chec<code>_</code>ipfs<code>_</code>node<code>_</code>running","text":"<pre><code>def chec_ipfs_node_running() -&gt; None\n</code></pre> <p>Check ipfs node running.</p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/","title":"API","text":""},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#pluginsaea-ledger-cosmosaea_ledger_cosmoscosmos","title":"plugins.aea-ledger-cosmos.aea<code>_</code>ledger<code>_</code>cosmos.cosmos","text":"<p>Cosmos module wrapping the public and private key cryptography and ledger api.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#dataencrypt-objects","title":"DataEncrypt Objects","text":"<pre><code>class DataEncrypt()\n</code></pre> <p>Class to encrypt/decrypt data strings with password provided.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#encrypt","title":"encrypt","text":"<pre><code>@classmethod\ndef encrypt(cls, data: bytes, password: str) -&gt; bytes\n</code></pre> <p>Encrypt data with password.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#bytes_encode","title":"bytes<code>_</code>encode","text":"<pre><code>@staticmethod\ndef bytes_encode(data: bytes) -&gt; str\n</code></pre> <p>Encode bytes to ascii friendly string.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#bytes_decode","title":"bytes<code>_</code>decode","text":"<pre><code>@staticmethod\ndef bytes_decode(data: str) -&gt; bytes\n</code></pre> <p>Decode ascii friendly string to bytes.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#decrypt","title":"decrypt","text":"<pre><code>@classmethod\ndef decrypt(cls, encrypted_data: bytes, password: str) -&gt; bytes\n</code></pre> <p>Decrypt data with password provided.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#cosmoshelper-objects","title":"CosmosHelper Objects","text":"<pre><code>class CosmosHelper(Helper)\n</code></pre> <p>Helper class usable as Mixin for CosmosApi or as standalone class.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_settled","title":"is<code>_</code>transaction<code>_</code>settled","text":"<pre><code>@staticmethod\ndef is_transaction_settled(tx_receipt: JSONLike) -&gt; bool\n</code></pre> <p>Check whether a transaction is settled or not.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>True if the transaction has been settled, False o/w.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_code_id","title":"get<code>_</code>code<code>_</code>id","text":"<pre><code>@classmethod\ndef get_code_id(cls, tx_receipt: JSONLike) -&gt; Optional[int]\n</code></pre> <p>Retrieve the <code>code_id</code> from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>the code id, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_event_attributes","title":"get<code>_</code>event<code>_</code>attributes","text":"<pre><code>@staticmethod\ndef get_event_attributes(tx_receipt: JSONLike) -&gt; Dict\n</code></pre> <p>Retrieve events attributes from tx receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>dict</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_contract_address","title":"get<code>_</code>contract<code>_</code>address","text":"<pre><code>@classmethod\ndef get_contract_address(cls, tx_receipt: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Retrieve the <code>contract_address</code> from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>the contract address, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_valid","title":"is<code>_</code>transaction<code>_</code>valid","text":"<pre><code>@staticmethod\ndef is_transaction_valid(tx: JSONLike, seller: Address, client: Address,\ntx_nonce: str, amount: int) -&gt; bool\n</code></pre> <p>Check whether a transaction is valid or not.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction.</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> <li><code>tx_nonce</code>: the transaction nonce.</li> <li><code>amount</code>: the amount we expect to get from the transaction.</li> </ul> <p>Returns:</p> <p>True if the random_message is equals to tx['input']</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#generate_tx_nonce","title":"generate<code>_</code>tx<code>_</code>nonce","text":"<pre><code>@staticmethod\ndef generate_tx_nonce(seller: Address, client: Address) -&gt; str\n</code></pre> <p>Generate a unique hash to distinguish transactions with the same terms.</p> <p>Arguments:</p> <ul> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> </ul> <p>Returns:</p> <p>return the hash in hex.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_address_from_public_key","title":"get<code>_</code>address<code>_</code>from<code>_</code>public<code>_</code>key","text":"<pre><code>@classmethod\ndef get_address_from_public_key(cls, public_key: str) -&gt; str\n</code></pre> <p>Get the address from the public key.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key</li> </ul> <p>Returns:</p> <p>str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#recover_message","title":"recover<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_message(cls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[Address, ...]\n</code></pre> <p>Recover the addresses from the hash.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message we expect</li> <li><code>signature</code>: the transaction signature</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered addresses</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#recover_public_keys_from_message","title":"recover<code>_</code>public<code>_</code>keys<code>_</code>from<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_public_keys_from_message(\ncls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[str, ...]\n</code></pre> <p>Get the public key used to produce the <code>signature</code> of the <code>message</code></p> <p>Arguments:</p> <ul> <li><code>message</code>: raw bytes used to produce signature</li> <li><code>signature</code>: signature of the message</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered public keys</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\ndef get_hash(message: bytes) -&gt; str\n</code></pre> <p>Get the hash of a message.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be hashed.</li> </ul> <p>Returns:</p> <p>the hash of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#is_valid_address","title":"is<code>_</code>valid<code>_</code>address","text":"<pre><code>@classmethod\ndef is_valid_address(cls, address: Address) -&gt; bool\n</code></pre> <p>Check if the address is valid.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address to validate</li> </ul> <p>Returns:</p> <p>whether address is valid or not</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#load_contract_interface","title":"load<code>_</code>contract<code>_</code>interface","text":"<pre><code>@classmethod\ndef load_contract_interface(cls, file_path: Path) -&gt; Dict[str, str]\n</code></pre> <p>Load contract interface.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path to the interface</li> </ul> <p>Returns:</p> <p>the interface</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#cosmoscrypto-objects","title":"CosmosCrypto Objects","text":"<pre><code>class CosmosCrypto(Crypto[SigningKey])\n</code></pre> <p>Class wrapping the Account Generation from Ethereum ledger.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(private_key_path: Optional[str] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Instantiate an ethereum crypto object.</p> <p>Arguments:</p> <ul> <li><code>private_key_path</code>: the private key path of the agent</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#private_key","title":"private<code>_</code>key","text":"<pre><code>@property\ndef private_key() -&gt; str\n</code></pre> <p>Return a private key.</p> <p>Returns:</p> <p>a private key string</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Return a public key in hex format.</p> <p>Returns:</p> <p>a public key string in hex format</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; str\n</code></pre> <p>Return the address for the key pair.</p> <p>Returns:</p> <p>a display_address str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#load_private_key_from_path","title":"load<code>_</code>private<code>_</code>key<code>_</code>from<code>_</code>path","text":"<pre><code>@classmethod\ndef load_private_key_from_path(cls,\nfile_name: str,\npassword: Optional[str] = None) -&gt; SigningKey\n</code></pre> <p>Load a private key in hex format from a file.</p> <p>Arguments:</p> <ul> <li><code>file_name</code>: the path to the hex file.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the Entity.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#sign_message","title":"sign<code>_</code>message","text":"<pre><code>def sign_message(message: bytes, is_deprecated_mode: bool = False) -&gt; str\n</code></pre> <p>Sign a message in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be signed</li> <li><code>is_deprecated_mode</code>: if the deprecated signing is used</li> </ul> <p>Returns:</p> <p>signature of the message in string form</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#sign_transaction","title":"sign<code>_</code>transaction","text":"<pre><code>def sign_transaction(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Sign a transaction in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction to be signed</li> </ul> <p>Returns:</p> <p>signed transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#generate_private_key","title":"generate<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef generate_private_key(cls) -&gt; SigningKey\n</code></pre> <p>Generate a key pair for cosmos network.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#encrypt_1","title":"encrypt","text":"<pre><code>def encrypt(password: str) -&gt; str\n</code></pre> <p>Encrypt the private key and return in json.</p> <p>Arguments:</p> <ul> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>json string containing encrypted private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#decrypt_1","title":"decrypt","text":"<pre><code>@classmethod\ndef decrypt(cls, keyfile_json: str, password: str) -&gt; str\n</code></pre> <p>Decrypt the private key and return in raw form.</p> <p>Arguments:</p> <ul> <li><code>keyfile_json</code>: json string containing encrypted private key.</li> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>the raw private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#_cosmosapi-objects","title":"<code>_</code>CosmosApi Objects","text":"<pre><code>class _CosmosApi(LedgerApi)\n</code></pre> <p>Class to interact with the Cosmos SDK via a HTTP APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the Cosmos ledger APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#api","title":"api","text":"<pre><code>@property\ndef api() -&gt; Any\n</code></pre> <p>Get the underlying API object.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_balance","title":"get<code>_</code>balance","text":"<pre><code>def get_balance(address: Address) -&gt; Optional[int]\n</code></pre> <p>Get the balance of a given account.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_state","title":"get<code>_</code>state","text":"<pre><code>def get_state(callable_name: str, *args: Any,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Call a specified function on the ledger API.</p> <p>Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args.</p> <p>Arguments:</p> <ul> <li><code>callable_name</code>: name of the callable</li> <li><code>args</code>: positional arguments</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p>Returns:</p> <p>the transaction dictionary</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_deploy_transaction","title":"get<code>_</code>deploy<code>_</code>transaction","text":"<pre><code>def get_deploy_transaction(contract_interface: Dict[str, str],\ndeployer_address: Address,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction to deploy the smart contract.</p> <p>Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>deployer_address</code>: The address that will deploy the contract.</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p>Returns:</p> <p>the transaction dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_handle_transaction","title":"get<code>_</code>handle<code>_</code>transaction","text":"<pre><code>def get_handle_transaction(\nsender_address: Address,\ncontract_address: Address,\nhandle_msg: Any,\namount: int,\ntx_fee: int,\ndenom: Optional[str] = None,\ngas: int = DEFAULT_GAS_AMOUNT,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\naccount_number: Optional[int] = None,\nsequence: Optional[int] = None,\ntx_fee_denom: Optional[str] = None) -&gt; Optional[JSONLike]\n</code></pre> <p>Create a CosmWasm HandleMsg transaction.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the message initiator.</li> <li><code>contract_address</code>: the address of the smart contract.</li> <li><code>handle_msg</code>: HandleMsg in JSON format.</li> <li><code>amount</code>: Funds amount sent with transaction.</li> <li><code>tx_fee</code>: the tx fee accepted.</li> <li><code>denom</code>: the name of the denomination of the contract funds</li> <li><code>gas</code>: Maximum amount of gas to be used on executing command.</li> <li><code>memo</code>: any string comment.</li> <li><code>chain_id</code>: the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet).</li> <li><code>account_number</code>: Account number</li> <li><code>sequence</code>: Sequence</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> </ul> <p>Returns:</p> <p>the unsigned CosmWasm HandleMsg</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#execute_contract_query","title":"execute<code>_</code>contract<code>_</code>query","text":"<pre><code>def execute_contract_query(contract_address: Address,\nquery_msg: JSONLike) -&gt; Optional[JSONLike]\n</code></pre> <p>Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing.</p> <p>Arguments:</p> <ul> <li><code>contract_address</code>: the address of the smart contract.</li> <li><code>query_msg</code>: QueryMsg in JSON format.</li> </ul> <p>Returns:</p> <p>the message receipt</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_transfer_transaction","title":"get<code>_</code>transfer<code>_</code>transaction","text":"<pre><code>def get_transfer_transaction(sender_address: Address,\ndestination_address: Address,\namount: int,\ntx_fee: int,\ntx_nonce: str,\ndenom: Optional[str] = None,\ngas: int = DEFAULT_GAS_AMOUNT,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\naccount_number: Optional[int] = None,\nsequence: Optional[int] = None,\ntx_fee_denom: Optional[str] = None,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Submit a transfer transaction to the ledger.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the payer.</li> <li><code>destination_address</code>: the destination address of the payee.</li> <li><code>amount</code>: the amount of wealth to be transferred.</li> <li><code>tx_fee</code>: the transaction fee.</li> <li><code>tx_nonce</code>: verifies the authenticity of the tx</li> <li><code>denom</code>: the denomination of tx fee and amount</li> <li><code>gas</code>: the gas used.</li> <li><code>memo</code>: memo to include in tx.</li> <li><code>chain_id</code>: the chain ID of the transaction.</li> <li><code>account_number</code>: Account number</li> <li><code>sequence</code>: Sequence</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p>Returns:</p> <p>the transfer transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_packed_exec_msg","title":"get<code>_</code>packed<code>_</code>exec<code>_</code>msg","text":"<pre><code>def get_packed_exec_msg(sender_address: Address,\ncontract_address: str,\nmsg: JSONLike,\nfunds: int = 0,\ndenom: Optional[str] = None) -&gt; ProtoAny\n</code></pre> <p>Create and pack MsgExecuteContract</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: Address of sender</li> <li><code>contract_address</code>: Address of contract</li> <li><code>msg</code>: Paramaters to be passed to smart contract</li> <li><code>funds</code>: Funds to be sent to smart contract</li> <li><code>denom</code>: the denomination of funds</li> </ul> <p>Returns:</p> <p>Packed MsgExecuteContract</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_packed_send_msg","title":"get<code>_</code>packed<code>_</code>send<code>_</code>msg","text":"<pre><code>def get_packed_send_msg(from_address: Address,\nto_address: Address,\namount: int,\ndenom: Optional[str] = None) -&gt; ProtoAny\n</code></pre> <p>Generate and pack MsgSend</p> <p>Arguments:</p> <ul> <li><code>from_address</code>: Address of sender</li> <li><code>to_address</code>: Address of recipient</li> <li><code>amount</code>: amount of coins to be sent</li> <li><code>denom</code>: the denomination of and amount</li> </ul> <p>Returns:</p> <p>packer ProtoAny type message</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_multi_transaction","title":"get<code>_</code>multi<code>_</code>transaction","text":"<pre><code>def get_multi_transaction(from_addresses: List[str],\npub_keys: Optional[List[bytes]],\nmsgs: List[ProtoAny],\ngas: int,\ntx_fee: int = 0,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\ndenom: Optional[str] = None,\ntx_fee_denom: Optional[str] = None) -&gt; JSONLike\n</code></pre> <p>Generate transaction with multiple messages</p> <p>Arguments:</p> <ul> <li><code>from_addresses</code>: Addresses of signers</li> <li><code>pub_keys</code>: Public keys of signers</li> <li><code>msgs</code>: Messages to be included in transaction</li> <li><code>gas</code>: the gas used.</li> <li><code>tx_fee</code>: the transaction fee.</li> <li><code>memo</code>: memo to include in tx.</li> <li><code>chain_id</code>: the chain ID of the transaction.</li> <li><code>denom</code>: the denomination of tx fee</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: RuntimeError if number of pubkeys is not equal to number of from_addresses</li> </ul> <p>Returns:</p> <p>the transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#send_signed_transaction","title":"send<code>_</code>signed<code>_</code>transaction","text":"<pre><code>def send_signed_transaction(tx_signed: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Send a signed transaction and wait for confirmation.</p> <p>Arguments:</p> <ul> <li><code>tx_signed</code>: the signed transaction</li> </ul> <p>Returns:</p> <p>tx_digest, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_transaction_receipt","title":"get<code>_</code>transaction<code>_</code>receipt","text":"<pre><code>def get_transaction_receipt(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction receipt for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx receipt, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_transaction","title":"get<code>_</code>transaction","text":"<pre><code>def get_transaction(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_contract_instance","title":"get<code>_</code>contract<code>_</code>instance","text":"<pre><code>def get_contract_instance(contract_interface: Dict[str, str],\ncontract_address: Optional[str] = None) -&gt; Any\n</code></pre> <p>Get the instance of a contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>contract_address</code>: the contract address.</li> </ul> <p>Returns:</p> <p>the contract instance</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#update_with_gas_estimate","title":"update<code>_</code>with<code>_</code>gas<code>_</code>estimate","text":"<pre><code>def update_with_gas_estimate(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Attempts to update the transaction with a gas estimate</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: NotImplementedError</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#cosmosapi-objects","title":"CosmosApi Objects","text":"<pre><code>class CosmosApi(_CosmosApi, CosmosHelper)\n</code></pre> <p>Class to interact with the Cosmos SDK via a HTTP APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#cosmosfaucetapi-objects","title":"CosmosFaucetApi Objects","text":"<pre><code>class CosmosFaucetApi(FaucetApi)\n</code></pre> <p>Cosmos testnet faucet API.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(poll_interval: Optional[float] = None,\nfinal_wait_interval: Optional[float] = None)\n</code></pre> <p>Initialize CosmosFaucetApi.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_cosmos/cosmos/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>def get_wealth(address: Address, url: Optional[str] = None) -&gt; None\n</code></pre> <p>Get wealth from the faucet for the provided address.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> <li><code>url</code>: the url</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: RuntimeError of explicit faucet failures</li> </ul>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/","title":"API","text":""},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#pluginsaea-ledger-ethereumaea_ledger_ethereumethereum","title":"plugins.aea-ledger-ethereum.aea<code>_</code>ledger<code>_</code>ethereum.ethereum","text":"<p>Ethereum module wrapping the public and private key cryptography and ledger api.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_gas_price_strategy","title":"get<code>_</code>gas<code>_</code>price<code>_</code>strategy","text":"<pre><code>def get_gas_price_strategy(\ngas_price_strategy: Optional[str] = None,\napi_key: Optional[str] = None) -&gt; Callable[[Web3, TxParams], Wei]\n</code></pre> <p>Get the gas price strategy.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#signedtransactiontranslator-objects","title":"SignedTransactionTranslator Objects","text":"<pre><code>class SignedTransactionTranslator()\n</code></pre> <p>Translator for SignedTransaction.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#to_dict","title":"to<code>_</code>dict","text":"<pre><code>@staticmethod\ndef to_dict(\nsigned_transaction: SignedTransaction) -&gt; Dict[str, Union[str, int]]\n</code></pre> <p>Write SignedTransaction to dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#from_dict","title":"from<code>_</code>dict","text":"<pre><code>@staticmethod\ndef from_dict(signed_transaction_dict: JSONLike) -&gt; SignedTransaction\n</code></pre> <p>Get SignedTransaction from dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#attributedicttranslator-objects","title":"AttributeDictTranslator Objects","text":"<pre><code>class AttributeDictTranslator()\n</code></pre> <p>Translator for AttributeDict.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#to_dict_1","title":"to<code>_</code>dict","text":"<pre><code>@classmethod\ndef to_dict(cls, attr_dict: Union[AttributeDict, TxReceipt,\nTxData]) -&gt; JSONLike\n</code></pre> <p>Simplify to dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#from_dict_1","title":"from<code>_</code>dict","text":"<pre><code>@classmethod\ndef from_dict(cls, di: JSONLike) -&gt; AttributeDict\n</code></pre> <p>Get back attribute dict.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#ethereumcrypto-objects","title":"EthereumCrypto Objects","text":"<pre><code>class EthereumCrypto(Crypto[Account])\n</code></pre> <p>Class wrapping the Account Generation from Ethereum ledger.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(private_key_path: Optional[str] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Instantiate an ethereum crypto object.</p> <p>Arguments:</p> <ul> <li><code>private_key_path</code>: the private key path of the agent</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#private_key","title":"private<code>_</code>key","text":"<pre><code>@property\ndef private_key() -&gt; str\n</code></pre> <p>Return a private key.</p> <p>Returns:</p> <p>a private key string</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Return a public key in hex format.</p> <p>Returns:</p> <p>a public key string in hex format</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; str\n</code></pre> <p>Return the address for the key pair.</p> <p>Returns:</p> <p>a display_address str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#load_private_key_from_path","title":"load<code>_</code>private<code>_</code>key<code>_</code>from<code>_</code>path","text":"<pre><code>@classmethod\ndef load_private_key_from_path(cls,\nfile_name: str,\npassword: Optional[str] = None) -&gt; Account\n</code></pre> <p>Load a private key in hex format from a file.</p> <p>Arguments:</p> <ul> <li><code>file_name</code>: the path to the hex file.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the Entity.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#sign_message","title":"sign<code>_</code>message","text":"<pre><code>def sign_message(message: bytes, is_deprecated_mode: bool = False) -&gt; str\n</code></pre> <p>Sign a message in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be signed</li> <li><code>is_deprecated_mode</code>: if the deprecated signing is used</li> </ul> <p>Returns:</p> <p>signature of the message in string form</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#sign_transaction","title":"sign<code>_</code>transaction","text":"<pre><code>def sign_transaction(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Sign a transaction in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction to be signed</li> </ul> <p>Returns:</p> <p>signed transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#generate_private_key","title":"generate<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef generate_private_key(cls) -&gt; Account\n</code></pre> <p>Generate a key pair for ethereum network.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#encrypt","title":"encrypt","text":"<pre><code>def encrypt(password: str) -&gt; str\n</code></pre> <p>Encrypt the private key and return in json.</p> <p>Arguments:</p> <ul> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>json string containing encrypted private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#decrypt","title":"decrypt","text":"<pre><code>@classmethod\ndef decrypt(cls, keyfile_json: str, password: str) -&gt; str\n</code></pre> <p>Decrypt the private key and return in raw form.</p> <p>Arguments:</p> <ul> <li><code>keyfile_json</code>: json str containing encrypted private key.</li> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>the raw private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#ethereumhelper-objects","title":"EthereumHelper Objects","text":"<pre><code>class EthereumHelper(Helper)\n</code></pre> <p>Helper class usable as Mixin for EthereumApi or as standalone class.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_settled","title":"is<code>_</code>transaction<code>_</code>settled","text":"<pre><code>@staticmethod\ndef is_transaction_settled(tx_receipt: JSONLike) -&gt; bool\n</code></pre> <p>Check whether a transaction is settled or not.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt associated to the transaction.</li> </ul> <p>Returns:</p> <p>True if the transaction has been settled, False o/w.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_contract_address","title":"get<code>_</code>contract<code>_</code>address","text":"<pre><code>@staticmethod\ndef get_contract_address(tx_receipt: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Retrieve the <code>contract_address</code> from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>the contract address, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_valid","title":"is<code>_</code>transaction<code>_</code>valid","text":"<pre><code>@staticmethod\ndef is_transaction_valid(tx: dict, seller: Address, client: Address,\ntx_nonce: str, amount: int) -&gt; bool\n</code></pre> <p>Check whether a transaction is valid or not.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction.</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> <li><code>tx_nonce</code>: the transaction nonce.</li> <li><code>amount</code>: the amount we expect to get from the transaction.</li> </ul> <p>Returns:</p> <p>True if the random_message is equals to tx['input']</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#generate_tx_nonce","title":"generate<code>_</code>tx<code>_</code>nonce","text":"<pre><code>@staticmethod\ndef generate_tx_nonce(seller: Address, client: Address) -&gt; str\n</code></pre> <p>Generate a unique hash to distinguish transactions with the same terms.</p> <p>Arguments:</p> <ul> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> </ul> <p>Returns:</p> <p>return the hash in hex.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_address_from_public_key","title":"get<code>_</code>address<code>_</code>from<code>_</code>public<code>_</code>key","text":"<pre><code>@classmethod\ndef get_address_from_public_key(cls, public_key: str) -&gt; str\n</code></pre> <p>Get the address from the public key.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key</li> </ul> <p>Returns:</p> <p>str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#recover_message","title":"recover<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_message(cls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[Address, ...]\n</code></pre> <p>Recover the addresses from the hash.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message we expect</li> <li><code>signature</code>: the transaction signature</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered addresses</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#recover_public_keys_from_message","title":"recover<code>_</code>public<code>_</code>keys<code>_</code>from<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_public_keys_from_message(\ncls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[str, ...]\n</code></pre> <p>Get the public key used to produce the <code>signature</code> of the <code>message</code></p> <p>Arguments:</p> <ul> <li><code>message</code>: raw bytes used to produce signature</li> <li><code>signature</code>: signature of the message</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered public keys</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\ndef get_hash(message: bytes) -&gt; str\n</code></pre> <p>Get the hash of a message.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be hashed.</li> </ul> <p>Returns:</p> <p>the hash of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#load_contract_interface","title":"load<code>_</code>contract<code>_</code>interface","text":"<pre><code>@classmethod\ndef load_contract_interface(cls, file_path: Path) -&gt; Dict[str, str]\n</code></pre> <p>Load contract interface.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path to the interface</li> </ul> <p>Returns:</p> <p>the interface</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#ethereumapi-objects","title":"EthereumApi Objects","text":"<pre><code>class EthereumApi(LedgerApi, EthereumHelper)\n</code></pre> <p>Class to interact with the Ethereum Web3 APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any)\n</code></pre> <p>Initialize the Ethereum ledger APIs.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#api","title":"api","text":"<pre><code>@property\ndef api() -&gt; Web3\n</code></pre> <p>Get the underlying API object.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_balance","title":"get<code>_</code>balance","text":"<pre><code>def get_balance(address: Address) -&gt; Optional[int]\n</code></pre> <p>Get the balance of a given account.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_state","title":"get<code>_</code>state","text":"<pre><code>def get_state(callable_name: str, *args: Any,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Call a specified function on the ledger API.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_transfer_transaction","title":"get<code>_</code>transfer<code>_</code>transaction","text":"<pre><code>def get_transfer_transaction(sender_address: Address,\ndestination_address: Address,\namount: int,\ntx_fee: int,\ntx_nonce: str,\nchain_id: Optional[int] = None,\ngas_price: Optional[str] = None,\ngas_price_strategy: Optional[str] = None,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Submit a transfer transaction to the ledger.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the payer.</li> <li><code>destination_address</code>: the destination address of the payee.</li> <li><code>amount</code>: the amount of wealth to be transferred (in Wei).</li> <li><code>tx_fee</code>: the transaction fee (gas) to be used (in Wei).</li> <li><code>tx_nonce</code>: verifies the authenticity of the tx.</li> <li><code>chain_id</code>: the Chain ID of the Ethereum transaction.</li> <li><code>gas_price</code>: the gas price (in Wei)</li> <li><code>gas_price_strategy</code>: the gas price strategy to be used.</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p>Returns:</p> <p>the transfer transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#update_with_gas_estimate","title":"update<code>_</code>with<code>_</code>gas<code>_</code>estimate","text":"<pre><code>def update_with_gas_estimate(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Attempts to update the transaction with a gas estimate</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction</li> </ul> <p>Returns:</p> <p>the updated transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#send_signed_transaction","title":"send<code>_</code>signed<code>_</code>transaction","text":"<pre><code>def send_signed_transaction(tx_signed: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Send a signed transaction and wait for confirmation.</p> <p>Arguments:</p> <ul> <li><code>tx_signed</code>: the signed transaction</li> </ul> <p>Returns:</p> <p>tx_digest, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_transaction_receipt","title":"get<code>_</code>transaction<code>_</code>receipt","text":"<pre><code>def get_transaction_receipt(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction receipt for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx receipt, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_transaction","title":"get<code>_</code>transaction","text":"<pre><code>def get_transaction(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_contract_instance","title":"get<code>_</code>contract<code>_</code>instance","text":"<pre><code>def get_contract_instance(contract_interface: Dict[str, str],\ncontract_address: Optional[str] = None) -&gt; Any\n</code></pre> <p>Get the instance of a contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>contract_address</code>: the contract address.</li> </ul> <p>Returns:</p> <p>the contract instance</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_deploy_transaction","title":"get<code>_</code>deploy<code>_</code>transaction","text":"<pre><code>def get_deploy_transaction(contract_interface: Dict[str, str],\ndeployer_address: Address,\nvalue: int = 0,\ngas: int = 0,\ngas_price: Optional[str] = None,\ngas_price_strategy: Optional[str] = None,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction to deploy the smart contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>deployer_address</code>: The address that will deploy the contract.</li> <li><code>value</code>: value to send to contract (in Wei)</li> <li><code>gas</code>: the gas to be used (in Wei)</li> <li><code>gas_price</code>: the gas price (in Wei)</li> <li><code>gas_price_strategy</code>: the gas price strategy to be used.</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p>Returns:</p> <p>the transaction dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#is_valid_address","title":"is<code>_</code>valid<code>_</code>address","text":"<pre><code>@classmethod\ndef is_valid_address(cls, address: Address) -&gt; bool\n</code></pre> <p>Check if the address is valid.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address to validate</li> </ul> <p>Returns:</p> <p>whether the address is valid</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#ethereumfaucetapi-objects","title":"EthereumFaucetApi Objects","text":"<pre><code>class EthereumFaucetApi(FaucetApi)\n</code></pre> <p>Ethereum testnet faucet API.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>def get_wealth(address: Address, url: Optional[str] = None) -&gt; None\n</code></pre> <p>Get wealth from the faucet for the provided address.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> <li><code>url</code>: the url</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#lrulockwrapper-objects","title":"LruLockWrapper Objects","text":"<pre><code>class LruLockWrapper()\n</code></pre> <p>Wrapper for LRU with threading.Lock.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(lru: LRU) -&gt; None\n</code></pre> <p>Init wrapper.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__getitem__","title":"<code>__</code>getitem<code>__</code>","text":"<pre><code>def __getitem__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Get item</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__setitem__","title":"<code>__</code>setitem<code>__</code>","text":"<pre><code>def __setitem__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Set item.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__contains__","title":"<code>__</code>contains<code>__</code>","text":"<pre><code>def __contains__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Contain item.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#__delitem__","title":"<code>__</code>delitem<code>__</code>","text":"<pre><code>def __delitem__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Del item.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_ethereum/ethereum/#set_wrapper_for_web3py_session_cache","title":"set<code>_</code>wrapper<code>_</code>for<code>_</code>web3py<code>_</code>session<code>_</code>cache","text":"<pre><code>def set_wrapper_for_web3py_session_cache() -&gt; None\n</code></pre> <p>Wrap web3py session cache with threading.Lock.</p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/","title":"Helper","text":""},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#pluginsaea-ledger-fetchaiaea_ledger_fetchai_cosmos","title":"plugins.aea-ledger-fetchai.aea<code>_</code>ledger<code>_</code>fetchai.<code>_</code>cosmos","text":"<p>Cosmos module wrapping the public and private key cryptography and ledger api.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#dataencrypt-objects","title":"DataEncrypt Objects","text":"<pre><code>class DataEncrypt()\n</code></pre> <p>Class to encrypt/decrypt data strings with password provided.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#encrypt","title":"encrypt","text":"<pre><code>@classmethod\ndef encrypt(cls, data: bytes, password: str) -&gt; bytes\n</code></pre> <p>Encrypt data with password.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#bytes_encode","title":"bytes<code>_</code>encode","text":"<pre><code>@staticmethod\ndef bytes_encode(data: bytes) -&gt; str\n</code></pre> <p>Encode bytes to ascii friendly string.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#bytes_decode","title":"bytes<code>_</code>decode","text":"<pre><code>@staticmethod\ndef bytes_decode(data: str) -&gt; bytes\n</code></pre> <p>Decode ascii friendly string to bytes.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#decrypt","title":"decrypt","text":"<pre><code>@classmethod\ndef decrypt(cls, encrypted_data: bytes, password: str) -&gt; bytes\n</code></pre> <p>Decrypt data with password provided.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#cosmoshelper-objects","title":"CosmosHelper Objects","text":"<pre><code>class CosmosHelper(Helper)\n</code></pre> <p>Helper class usable as Mixin for CosmosApi or as standalone class.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_settled","title":"is<code>_</code>transaction<code>_</code>settled","text":"<pre><code>@staticmethod\ndef is_transaction_settled(tx_receipt: JSONLike) -&gt; bool\n</code></pre> <p>Check whether a transaction is settled or not.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>True if the transaction has been settled, False o/w.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_code_id","title":"get<code>_</code>code<code>_</code>id","text":"<pre><code>@classmethod\ndef get_code_id(cls, tx_receipt: JSONLike) -&gt; Optional[int]\n</code></pre> <p>Retrieve the <code>code_id</code> from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>the code id, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_event_attributes","title":"get<code>_</code>event<code>_</code>attributes","text":"<pre><code>@staticmethod\ndef get_event_attributes(tx_receipt: JSONLike) -&gt; Dict\n</code></pre> <p>Retrieve events attributes from tx receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>dict</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_contract_address","title":"get<code>_</code>contract<code>_</code>address","text":"<pre><code>@classmethod\ndef get_contract_address(cls, tx_receipt: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Retrieve the <code>contract_address</code> from a transaction receipt.</p> <p>Arguments:</p> <ul> <li><code>tx_receipt</code>: the receipt of the transaction.</li> </ul> <p>Returns:</p> <p>the contract address, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_valid","title":"is<code>_</code>transaction<code>_</code>valid","text":"<pre><code>@staticmethod\ndef is_transaction_valid(tx: JSONLike, seller: Address, client: Address,\ntx_nonce: str, amount: int) -&gt; bool\n</code></pre> <p>Check whether a transaction is valid or not.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction.</li> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> <li><code>tx_nonce</code>: the transaction nonce.</li> <li><code>amount</code>: the amount we expect to get from the transaction.</li> </ul> <p>Returns:</p> <p>True if the random_message is equals to tx['input']</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#generate_tx_nonce","title":"generate<code>_</code>tx<code>_</code>nonce","text":"<pre><code>@staticmethod\ndef generate_tx_nonce(seller: Address, client: Address) -&gt; str\n</code></pre> <p>Generate a unique hash to distinguish transactions with the same terms.</p> <p>Arguments:</p> <ul> <li><code>seller</code>: the address of the seller.</li> <li><code>client</code>: the address of the client.</li> </ul> <p>Returns:</p> <p>return the hash in hex.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_address_from_public_key","title":"get<code>_</code>address<code>_</code>from<code>_</code>public<code>_</code>key","text":"<pre><code>@classmethod\ndef get_address_from_public_key(cls, public_key: str) -&gt; str\n</code></pre> <p>Get the address from the public key.</p> <p>Arguments:</p> <ul> <li><code>public_key</code>: the public key</li> </ul> <p>Returns:</p> <p>str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#recover_message","title":"recover<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_message(cls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[Address, ...]\n</code></pre> <p>Recover the addresses from the hash.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message we expect</li> <li><code>signature</code>: the transaction signature</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered addresses</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#recover_public_keys_from_message","title":"recover<code>_</code>public<code>_</code>keys<code>_</code>from<code>_</code>message","text":"<pre><code>@classmethod\ndef recover_public_keys_from_message(\ncls,\nmessage: bytes,\nsignature: str,\nis_deprecated_mode: bool = False) -&gt; Tuple[str, ...]\n</code></pre> <p>Get the public key used to produce the <code>signature</code> of the <code>message</code></p> <p>Arguments:</p> <ul> <li><code>message</code>: raw bytes used to produce signature</li> <li><code>signature</code>: signature of the message</li> <li><code>is_deprecated_mode</code>: if the deprecated signing was used</li> </ul> <p>Returns:</p> <p>the recovered public keys</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_hash","title":"get<code>_</code>hash","text":"<pre><code>@staticmethod\ndef get_hash(message: bytes) -&gt; str\n</code></pre> <p>Get the hash of a message.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be hashed.</li> </ul> <p>Returns:</p> <p>the hash of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#is_valid_address","title":"is<code>_</code>valid<code>_</code>address","text":"<pre><code>@classmethod\ndef is_valid_address(cls, address: Address) -&gt; bool\n</code></pre> <p>Check if the address is valid.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address to validate</li> </ul> <p>Returns:</p> <p>whether address is valid or not</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#load_contract_interface","title":"load<code>_</code>contract<code>_</code>interface","text":"<pre><code>@classmethod\ndef load_contract_interface(cls, file_path: Path) -&gt; Dict[str, str]\n</code></pre> <p>Load contract interface.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path to the interface</li> </ul> <p>Returns:</p> <p>the interface</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#cosmoscrypto-objects","title":"CosmosCrypto Objects","text":"<pre><code>class CosmosCrypto(Crypto[SigningKey])\n</code></pre> <p>Class wrapping the Account Generation from Ethereum ledger.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(private_key_path: Optional[str] = None,\npassword: Optional[str] = None) -&gt; None\n</code></pre> <p>Instantiate an ethereum crypto object.</p> <p>Arguments:</p> <ul> <li><code>private_key_path</code>: the private key path of the agent</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#private_key","title":"private<code>_</code>key","text":"<pre><code>@property\ndef private_key() -&gt; str\n</code></pre> <p>Return a private key.</p> <p>Returns:</p> <p>a private key string</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Return a public key in hex format.</p> <p>Returns:</p> <p>a public key string in hex format</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#address","title":"address","text":"<pre><code>@property\ndef address() -&gt; str\n</code></pre> <p>Return the address for the key pair.</p> <p>Returns:</p> <p>a display_address str</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#load_private_key_from_path","title":"load<code>_</code>private<code>_</code>key<code>_</code>from<code>_</code>path","text":"<pre><code>@classmethod\ndef load_private_key_from_path(cls,\nfile_name: str,\npassword: Optional[str] = None) -&gt; SigningKey\n</code></pre> <p>Load a private key in hex format from a file.</p> <p>Arguments:</p> <ul> <li><code>file_name</code>: the path to the hex file.</li> <li><code>password</code>: the password to encrypt/decrypt the private key.</li> </ul> <p>Returns:</p> <p>the Entity.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#sign_message","title":"sign<code>_</code>message","text":"<pre><code>def sign_message(message: bytes, is_deprecated_mode: bool = False) -&gt; str\n</code></pre> <p>Sign a message in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message to be signed</li> <li><code>is_deprecated_mode</code>: if the deprecated signing is used</li> </ul> <p>Returns:</p> <p>signature of the message in string form</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#sign_transaction","title":"sign<code>_</code>transaction","text":"<pre><code>def sign_transaction(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Sign a transaction in bytes string form.</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction to be signed</li> </ul> <p>Returns:</p> <p>signed transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#generate_private_key","title":"generate<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef generate_private_key(cls) -&gt; SigningKey\n</code></pre> <p>Generate a key pair for cosmos network.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#encrypt_1","title":"encrypt","text":"<pre><code>def encrypt(password: str) -&gt; str\n</code></pre> <p>Encrypt the private key and return in json.</p> <p>Arguments:</p> <ul> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>json string containing encrypted private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#decrypt_1","title":"decrypt","text":"<pre><code>@classmethod\ndef decrypt(cls, keyfile_json: str, password: str) -&gt; str\n</code></pre> <p>Decrypt the private key and return in raw form.</p> <p>Arguments:</p> <ul> <li><code>keyfile_json</code>: json string containing encrypted private key.</li> <li><code>password</code>: the password to decrypt.</li> </ul> <p>Returns:</p> <p>the raw private key.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#_cosmosapi-objects","title":"<code>_</code>CosmosApi Objects","text":"<pre><code>class _CosmosApi(LedgerApi)\n</code></pre> <p>Class to interact with the Cosmos SDK via a HTTP APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the Cosmos ledger APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#api","title":"api","text":"<pre><code>@property\ndef api() -&gt; Any\n</code></pre> <p>Get the underlying API object.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_balance","title":"get<code>_</code>balance","text":"<pre><code>def get_balance(address: Address) -&gt; Optional[int]\n</code></pre> <p>Get the balance of a given account.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_state","title":"get<code>_</code>state","text":"<pre><code>def get_state(callable_name: str, *args: Any,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Call a specified function on the ledger API.</p> <p>Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args.</p> <p>Arguments:</p> <ul> <li><code>callable_name</code>: name of the callable</li> <li><code>args</code>: positional arguments</li> <li><code>kwargs</code>: keyword arguments</li> </ul> <p>Returns:</p> <p>the transaction dictionary</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_deploy_transaction","title":"get<code>_</code>deploy<code>_</code>transaction","text":"<pre><code>def get_deploy_transaction(contract_interface: Dict[str, str],\ndeployer_address: Address,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction to deploy the smart contract.</p> <p>Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>deployer_address</code>: The address that will deploy the contract.</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p>Returns:</p> <p>the transaction dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_handle_transaction","title":"get<code>_</code>handle<code>_</code>transaction","text":"<pre><code>def get_handle_transaction(\nsender_address: Address,\ncontract_address: Address,\nhandle_msg: Any,\namount: int,\ntx_fee: int,\ndenom: Optional[str] = None,\ngas: int = DEFAULT_GAS_AMOUNT,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\naccount_number: Optional[int] = None,\nsequence: Optional[int] = None,\ntx_fee_denom: Optional[str] = None) -&gt; Optional[JSONLike]\n</code></pre> <p>Create a CosmWasm HandleMsg transaction.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the message initiator.</li> <li><code>contract_address</code>: the address of the smart contract.</li> <li><code>handle_msg</code>: HandleMsg in JSON format.</li> <li><code>amount</code>: Funds amount sent with transaction.</li> <li><code>tx_fee</code>: the tx fee accepted.</li> <li><code>denom</code>: the name of the denomination of the contract funds</li> <li><code>gas</code>: Maximum amount of gas to be used on executing command.</li> <li><code>memo</code>: any string comment.</li> <li><code>chain_id</code>: the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet).</li> <li><code>account_number</code>: Account number</li> <li><code>sequence</code>: Sequence</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> </ul> <p>Returns:</p> <p>the unsigned CosmWasm HandleMsg</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#execute_contract_query","title":"execute<code>_</code>contract<code>_</code>query","text":"<pre><code>def execute_contract_query(contract_address: Address,\nquery_msg: JSONLike) -&gt; Optional[JSONLike]\n</code></pre> <p>Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing.</p> <p>Arguments:</p> <ul> <li><code>contract_address</code>: the address of the smart contract.</li> <li><code>query_msg</code>: QueryMsg in JSON format.</li> </ul> <p>Returns:</p> <p>the message receipt</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_transfer_transaction","title":"get<code>_</code>transfer<code>_</code>transaction","text":"<pre><code>def get_transfer_transaction(sender_address: Address,\ndestination_address: Address,\namount: int,\ntx_fee: int,\ntx_nonce: str,\ndenom: Optional[str] = None,\ngas: int = DEFAULT_GAS_AMOUNT,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\naccount_number: Optional[int] = None,\nsequence: Optional[int] = None,\ntx_fee_denom: Optional[str] = None,\n**kwargs: Any) -&gt; Optional[JSONLike]\n</code></pre> <p>Submit a transfer transaction to the ledger.</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: the sender address of the payer.</li> <li><code>destination_address</code>: the destination address of the payee.</li> <li><code>amount</code>: the amount of wealth to be transferred.</li> <li><code>tx_fee</code>: the transaction fee.</li> <li><code>tx_nonce</code>: verifies the authenticity of the tx</li> <li><code>denom</code>: the denomination of tx fee and amount</li> <li><code>gas</code>: the gas used.</li> <li><code>memo</code>: memo to include in tx.</li> <li><code>chain_id</code>: the chain ID of the transaction.</li> <li><code>account_number</code>: Account number</li> <li><code>sequence</code>: Sequence</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> <li><code>kwargs</code>: keyword arguments.</li> </ul> <p>Returns:</p> <p>the transfer transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_packed_exec_msg","title":"get<code>_</code>packed<code>_</code>exec<code>_</code>msg","text":"<pre><code>def get_packed_exec_msg(sender_address: Address,\ncontract_address: str,\nmsg: JSONLike,\nfunds: int = 0,\ndenom: Optional[str] = None) -&gt; ProtoAny\n</code></pre> <p>Create and pack MsgExecuteContract</p> <p>Arguments:</p> <ul> <li><code>sender_address</code>: Address of sender</li> <li><code>contract_address</code>: Address of contract</li> <li><code>msg</code>: Paramaters to be passed to smart contract</li> <li><code>funds</code>: Funds to be sent to smart contract</li> <li><code>denom</code>: the denomination of funds</li> </ul> <p>Returns:</p> <p>Packed MsgExecuteContract</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_packed_send_msg","title":"get<code>_</code>packed<code>_</code>send<code>_</code>msg","text":"<pre><code>def get_packed_send_msg(from_address: Address,\nto_address: Address,\namount: int,\ndenom: Optional[str] = None) -&gt; ProtoAny\n</code></pre> <p>Generate and pack MsgSend</p> <p>Arguments:</p> <ul> <li><code>from_address</code>: Address of sender</li> <li><code>to_address</code>: Address of recipient</li> <li><code>amount</code>: amount of coins to be sent</li> <li><code>denom</code>: the denomination of and amount</li> </ul> <p>Returns:</p> <p>packer ProtoAny type message</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_multi_transaction","title":"get<code>_</code>multi<code>_</code>transaction","text":"<pre><code>def get_multi_transaction(from_addresses: List[str],\npub_keys: Optional[List[bytes]],\nmsgs: List[ProtoAny],\ngas: int,\ntx_fee: int = 0,\nmemo: str = \"\",\nchain_id: Optional[str] = None,\ndenom: Optional[str] = None,\ntx_fee_denom: Optional[str] = None) -&gt; JSONLike\n</code></pre> <p>Generate transaction with multiple messages</p> <p>Arguments:</p> <ul> <li><code>from_addresses</code>: Addresses of signers</li> <li><code>pub_keys</code>: Public keys of signers</li> <li><code>msgs</code>: Messages to be included in transaction</li> <li><code>gas</code>: the gas used.</li> <li><code>tx_fee</code>: the transaction fee.</li> <li><code>memo</code>: memo to include in tx.</li> <li><code>chain_id</code>: the chain ID of the transaction.</li> <li><code>denom</code>: the denomination of tx fee</li> <li><code>tx_fee_denom</code>: Denomination of tx_fee, identical with denom param when None</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: RuntimeError if number of pubkeys is not equal to number of from_addresses</li> </ul> <p>Returns:</p> <p>the transaction</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#send_signed_transaction","title":"send<code>_</code>signed<code>_</code>transaction","text":"<pre><code>def send_signed_transaction(tx_signed: JSONLike) -&gt; Optional[str]\n</code></pre> <p>Send a signed transaction and wait for confirmation.</p> <p>Arguments:</p> <ul> <li><code>tx_signed</code>: the signed transaction</li> </ul> <p>Returns:</p> <p>tx_digest, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_transaction_receipt","title":"get<code>_</code>transaction<code>_</code>receipt","text":"<pre><code>def get_transaction_receipt(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction receipt for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx receipt, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_transaction","title":"get<code>_</code>transaction","text":"<pre><code>def get_transaction(tx_digest: str) -&gt; Optional[JSONLike]\n</code></pre> <p>Get the transaction for a transaction digest.</p> <p>Arguments:</p> <ul> <li><code>tx_digest</code>: the digest associated to the transaction.</li> </ul> <p>Returns:</p> <p>the tx, if present</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_contract_instance","title":"get<code>_</code>contract<code>_</code>instance","text":"<pre><code>def get_contract_instance(contract_interface: Dict[str, str],\ncontract_address: Optional[str] = None) -&gt; Any\n</code></pre> <p>Get the instance of a contract.</p> <p>Arguments:</p> <ul> <li><code>contract_interface</code>: the contract interface.</li> <li><code>contract_address</code>: the contract address.</li> </ul> <p>Returns:</p> <p>the contract instance</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#update_with_gas_estimate","title":"update<code>_</code>with<code>_</code>gas<code>_</code>estimate","text":"<pre><code>def update_with_gas_estimate(transaction: JSONLike) -&gt; JSONLike\n</code></pre> <p>Attempts to update the transaction with a gas estimate</p> <p>Arguments:</p> <ul> <li><code>transaction</code>: the transaction</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: NotImplementedError</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#cosmosapi-objects","title":"CosmosApi Objects","text":"<pre><code>class CosmosApi(_CosmosApi, CosmosHelper)\n</code></pre> <p>Class to interact with the Cosmos SDK via a HTTP APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#cosmosfaucetapi-objects","title":"CosmosFaucetApi Objects","text":"<pre><code>class CosmosFaucetApi(FaucetApi)\n</code></pre> <p>Cosmos testnet faucet API.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(poll_interval: Optional[float] = None,\nfinal_wait_interval: Optional[float] = None)\n</code></pre> <p>Initialize CosmosFaucetApi.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/_cosmos/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>def get_wealth(address: Address, url: Optional[str] = None) -&gt; None\n</code></pre> <p>Get wealth from the faucet for the provided address.</p> <p>Arguments:</p> <ul> <li><code>address</code>: the address.</li> <li><code>url</code>: the url</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: RuntimeError of explicit faucet failures</li> </ul>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/","title":"API","text":""},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#pluginsaea-ledger-fetchaiaea_ledger_fetchaifetchai","title":"plugins.aea-ledger-fetchai.aea<code>_</code>ledger<code>_</code>fetchai.fetchai","text":"<p>Fetchai module wrapping the public and private key cryptography and ledger api.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#fetchaihelper-objects","title":"FetchAIHelper Objects","text":"<pre><code>class FetchAIHelper(CosmosHelper)\n</code></pre> <p>Helper class usable as Mixin for FetchAIApi or as standalone class.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#fetchaicrypto-objects","title":"FetchAICrypto Objects","text":"<pre><code>class FetchAICrypto(CosmosCrypto)\n</code></pre> <p>Class wrapping the Entity Generation from Fetch.AI ledger.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#fetchaiapi-objects","title":"FetchAIApi Objects","text":"<pre><code>class FetchAIApi(_CosmosApi, FetchAIHelper)\n</code></pre> <p>Class to interact with the Fetch ledger APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the Fetch.ai ledger APIs.</p> <p></p>"},{"location":"aea-framework-documentation/api/plugins/aea_ledger_fetchai/fetchai/#fetchaifaucetapi-objects","title":"FetchAIFaucetApi Objects","text":"<pre><code>class FetchAIFaucetApi(CosmosFaucetApi)\n</code></pre> <p>Fetchai testnet faucet API.</p>"},{"location":"aea-framework-documentation/api/protocols/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/protocols/base/#aeaprotocolsbase","title":"aea.protocols.base","text":"<p>This module contains the base message and serialization definition.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#message-objects","title":"Message Objects","text":"<pre><code>class Message()\n</code></pre> <p>This class implements a message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#performative-objects","title":"Performative Objects","text":"<pre><code>class Performative(Enum)\n</code></pre> <p>Performatives for the base message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(_body: Optional[Dict] = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a Message object.</p> <p>Arguments:</p> <ul> <li><code>_body</code>: the dictionary of values to hold.</li> <li><code>kwargs</code>: any additional value to add to the body. It will overwrite the body values.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#json","title":"json","text":"<pre><code>def json() -&gt; dict\n</code></pre> <p>Get json friendly str representation of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#from_json","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, data: dict) -&gt; \"Message\"\n</code></pre> <p>Construct message instance from json data.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#valid_performatives","title":"valid<code>_</code>performatives","text":"<pre><code>@property\ndef valid_performatives() -&gt; Set[str]\n</code></pre> <p>Get valid performatives.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#has_sender","title":"has<code>_</code>sender","text":"<pre><code>@property\ndef has_sender() -&gt; bool\n</code></pre> <p>Check if it has a sender.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#sender","title":"sender","text":"<pre><code>@property\ndef sender() -&gt; Address\n</code></pre> <p>Get the sender of the message in Address form.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#sender_1","title":"sender","text":"<pre><code>@sender.setter\ndef sender(sender: Address) -&gt; None\n</code></pre> <p>Set the sender of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#has_to","title":"has<code>_</code>to","text":"<pre><code>@property\ndef has_to() -&gt; bool\n</code></pre> <p>Check if it has a sender.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#to","title":"to","text":"<pre><code>@property\ndef to() -&gt; Address\n</code></pre> <p>Get address of receiver.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#to_1","title":"to","text":"<pre><code>@to.setter\ndef to(to: Address) -&gt; None\n</code></pre> <p>Set address of receiver.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#dialogue_reference","title":"dialogue<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_reference() -&gt; Tuple[str, str]\n</code></pre> <p>Get the dialogue_reference of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#message_id","title":"message<code>_</code>id","text":"<pre><code>@property\ndef message_id() -&gt; int\n</code></pre> <p>Get the message_id of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#performative","title":"performative","text":"<pre><code>@property\ndef performative() -&gt; \"Performative\"\n</code></pre> <p>Get the performative of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#target","title":"target","text":"<pre><code>@property\ndef target() -&gt; int\n</code></pre> <p>Get the target of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#set","title":"set","text":"<pre><code>def set(key: str, value: Any) -&gt; None\n</code></pre> <p>Set key and value pair.</p> <p>Arguments:</p> <ul> <li><code>key</code>: the key.</li> <li><code>value</code>: the value.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#get","title":"get","text":"<pre><code>def get(key: str) -&gt; Optional[Any]\n</code></pre> <p>Get value for key.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#is_set","title":"is<code>_</code>set","text":"<pre><code>def is_set(key: str) -&gt; bool\n</code></pre> <p>Check value is set for key.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare with another object.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__repr__","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get the representation of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__str___1","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation of the message. Abbreviated to prevent spamming of logs.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#encode","title":"encode","text":"<pre><code>def encode() -&gt; bytes\n</code></pre> <p>Encode the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#decode","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, data: bytes) -&gt; \"Message\"\n</code></pre> <p>Decode the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#has_dialogue_info","title":"has<code>_</code>dialogue<code>_</code>info","text":"<pre><code>@property\ndef has_dialogue_info() -&gt; bool\n</code></pre> <p>Check whether a message has the dialogue fields populated.</p> <p>More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set.</p> <p>Returns:</p> <p>True if the message has the dialogue fields set, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#encoder-objects","title":"Encoder Objects","text":"<pre><code>class Encoder(ABC)\n</code></pre> <p>Encoder interface.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#encode_1","title":"encode","text":"<pre><code>@staticmethod\n@abstractmethod\ndef encode(msg: Message) -&gt; bytes\n</code></pre> <p>Encode a message.</p> <p>Arguments:</p> <ul> <li><code>msg</code>: the message to be encoded.</li> </ul> <p>Returns:</p> <p>the encoded message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#decoder-objects","title":"Decoder Objects","text":"<pre><code>class Decoder(ABC)\n</code></pre> <p>Decoder interface.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#decode_1","title":"decode","text":"<pre><code>@staticmethod\n@abstractmethod\ndef decode(obj: bytes) -&gt; Message\n</code></pre> <p>Decode a message.</p> <p>Arguments:</p> <ul> <li><code>obj</code>: the sequence of bytes to be decoded.</li> </ul> <p>Returns:</p> <p>the decoded message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#serializer-objects","title":"Serializer Objects","text":"<pre><code>class Serializer(Encoder, Decoder, ABC)\n</code></pre> <p>The implementations of this class defines a serialization layer for a protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#protocol-objects","title":"Protocol Objects","text":"<pre><code>class Protocol(Component)\n</code></pre> <p>This class implements a specifications for a protocol.</p> <p>It includes a serializer to encode/decode a message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: ProtocolConfig, message_class: Type[Message],\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the protocol manager.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the protocol configurations.</li> <li><code>message_class</code>: the message class.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#serializer","title":"serializer","text":"<pre><code>@property\ndef serializer() -&gt; Type[Serializer]\n</code></pre> <p>Get the serializer.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#from_dir","title":"from<code>_</code>dir","text":"<pre><code>@classmethod\ndef from_dir(cls, directory: str, **kwargs: Any) -&gt; \"Protocol\"\n</code></pre> <p>Load the protocol from a directory.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the directory to the skill package.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the protocol object.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#from_config","title":"from<code>_</code>config","text":"<pre><code>@classmethod\ndef from_config(cls, configuration: ProtocolConfig,\n**kwargs: Any) -&gt; \"Protocol\"\n</code></pre> <p>Load the protocol from configuration.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the protocol configuration.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the protocol object.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#protocol_id","title":"protocol<code>_</code>id","text":"<pre><code>@property\ndef protocol_id() -&gt; PublicId\n</code></pre> <p>Get protocol id.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#protocol_specification_id","title":"protocol<code>_</code>specification<code>_</code>id","text":"<pre><code>@property\ndef protocol_specification_id() -&gt; PublicId\n</code></pre> <p>Get protocol specification id.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/base/#__repr___1","title":"<code>__</code>repr<code>__</code>","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Get str representation of the protocol.</p>"},{"location":"aea-framework-documentation/api/protocols/default/custom_types/","title":"Custom Types","text":""},{"location":"aea-framework-documentation/api/protocols/default/custom_types/#packagesfetchaiprotocolsdefaultcustom_types","title":"packages.fetchai.protocols.default.custom<code>_</code>types","text":"<p>This module contains class representations corresponding to every custom type in the protocol specification.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/custom_types/#errorcode-objects","title":"ErrorCode Objects","text":"<pre><code>class ErrorCode(Enum)\n</code></pre> <p>This class represents an instance of ErrorCode.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/custom_types/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(error_code_protobuf_object: Any,\nerror_code_object: \"ErrorCode\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument.</p> <p>Arguments:</p> <ul> <li><code>error_code_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>error_code_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/custom_types/#decode","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, error_code_protobuf_object: Any) -&gt; \"ErrorCode\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>error_code_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.</p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/","title":"Dialogues","text":""},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#packagesfetchaiprotocolsdefaultdialogues","title":"packages.fetchai.protocols.default.dialogues","text":"<p>This module contains the classes required for default dialogue management.</p> <ul> <li>DefaultDialogue: The dialogue class maintains state of a dialogue and manages it.</li> <li>DefaultDialogues: The dialogues class keeps track of all dialogues.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#defaultdialogue-objects","title":"DefaultDialogue Objects","text":"<pre><code>class DefaultDialogue(Dialogue)\n</code></pre> <p>The default dialogue class maintains state of a dialogue and manages it.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#role-objects","title":"Role Objects","text":"<pre><code>class Role(Dialogue.Role)\n</code></pre> <p>This class defines the agent's role in a default dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#endstate-objects","title":"EndState Objects","text":"<pre><code>class EndState(Dialogue.EndState)\n</code></pre> <p>This class defines the end states of a default dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogue_label: DialogueLabel,\nself_address: Address,\nrole: Dialogue.Role,\nmessage_class: Type[DefaultMessage] = DefaultMessage) -&gt; None\n</code></pre> <p>Initialize a dialogue.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: the identifier of the dialogue</li> <li><code>self_address</code>: the address of the entity for whom this dialogue is maintained</li> <li><code>role</code>: the role of the agent this dialogue is maintained for</li> <li><code>message_class</code>: the message class used</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#defaultdialogues-objects","title":"DefaultDialogues Objects","text":"<pre><code>class DefaultDialogues(Dialogues, ABC)\n</code></pre> <p>This class keeps track of all default dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/dialogues/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address,\nrole_from_first_message: Callable[[Message, Address],\nDialogue.Role],\ndialogue_class: Type[DefaultDialogue] = DefaultDialogue) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>dialogue_class</code>: the dialogue class used</li> <li><code>role_from_first_message</code>: the callable determining role from first message</li> </ul>"},{"location":"aea-framework-documentation/api/protocols/default/message/","title":"Message","text":""},{"location":"aea-framework-documentation/api/protocols/default/message/#packagesfetchaiprotocolsdefaultmessage","title":"packages.fetchai.protocols.default.message","text":"<p>This module contains default's message definition.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#defaultmessage-objects","title":"DefaultMessage Objects","text":"<pre><code>class DefaultMessage(Message)\n</code></pre> <p>A protocol for exchanging any bytes message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#performative-objects","title":"Performative Objects","text":"<pre><code>class Performative(Message.Performative)\n</code></pre> <p>Performatives for the default protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(performative: Performative,\ndialogue_reference: Tuple[str, str] = (\"\", \"\"),\nmessage_id: int = 1,\ntarget: int = 0,\n**kwargs: Any)\n</code></pre> <p>Initialise an instance of DefaultMessage.</p> <p>Arguments:</p> <ul> <li><code>message_id</code>: the message id.</li> <li><code>dialogue_reference</code>: the dialogue reference.</li> <li><code>target</code>: the message target.</li> <li><code>performative</code>: the message performative.</li> <li><code>**kwargs</code>: extra options.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#valid_performatives","title":"valid<code>_</code>performatives","text":"<pre><code>@property\ndef valid_performatives() -&gt; Set[str]\n</code></pre> <p>Get valid performatives.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#dialogue_reference","title":"dialogue<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_reference() -&gt; Tuple[str, str]\n</code></pre> <p>Get the dialogue_reference of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#message_id","title":"message<code>_</code>id","text":"<pre><code>@property\ndef message_id() -&gt; int\n</code></pre> <p>Get the message_id of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#performative","title":"performative","text":"<pre><code>@property\ndef performative() -&gt; Performative\n</code></pre> <p>Get the performative of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#target","title":"target","text":"<pre><code>@property\ndef target() -&gt; int\n</code></pre> <p>Get the target of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#content","title":"content","text":"<pre><code>@property\ndef content() -&gt; bytes\n</code></pre> <p>Get the 'content' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#error_code","title":"error<code>_</code>code","text":"<pre><code>@property\ndef error_code() -&gt; CustomErrorCode\n</code></pre> <p>Get the 'error_code' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#error_data","title":"error<code>_</code>data","text":"<pre><code>@property\ndef error_data() -&gt; Dict[str, bytes]\n</code></pre> <p>Get the 'error_data' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/message/#error_msg","title":"error<code>_</code>msg","text":"<pre><code>@property\ndef error_msg() -&gt; str\n</code></pre> <p>Get the 'error_msg' content from the message.</p>"},{"location":"aea-framework-documentation/api/protocols/default/serialization/","title":"Serialization","text":""},{"location":"aea-framework-documentation/api/protocols/default/serialization/#packagesfetchaiprotocolsdefaultserialization","title":"packages.fetchai.protocols.default.serialization","text":"<p>Serialization module for default protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/serialization/#defaultserializer-objects","title":"DefaultSerializer Objects","text":"<pre><code>class DefaultSerializer(Serializer)\n</code></pre> <p>Serialization for the 'default' protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/serialization/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(msg: Message) -&gt; bytes\n</code></pre> <p>Encode a 'Default' message into bytes.</p> <p>Arguments:</p> <ul> <li><code>msg</code>: the message object.</li> </ul> <p>Returns:</p> <p>the bytes.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/default/serialization/#decode","title":"decode","text":"<pre><code>@staticmethod\ndef decode(obj: bytes) -&gt; Message\n</code></pre> <p>Decode bytes into a 'Default' message.</p> <p>Arguments:</p> <ul> <li><code>obj</code>: the bytes object.</li> </ul> <p>Returns:</p> <p>the 'Default' message.</p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#aeaprotocolsdialoguebase","title":"aea.protocols.dialogue.base","text":"<p>This module contains the classes required for dialogue management.</p> <ul> <li>DialogueLabel: The dialogue label class acts as an identifier for dialogues.</li> <li>Dialogue: The dialogue class maintains state of a dialogue and manages it.</li> <li>Dialogues: The dialogues class keeps track of all dialogues.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#invaliddialoguemessage-objects","title":"InvalidDialogueMessage Objects","text":"<pre><code>class InvalidDialogueMessage(Exception)\n</code></pre> <p>Exception for adding invalid message to a dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialoguelabel-objects","title":"DialogueLabel Objects","text":"<pre><code>class DialogueLabel()\n</code></pre> <p>The dialogue label class acts as an identifier for dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogue_reference: Tuple[str,\nstr], dialogue_opponent_addr: Address,\ndialogue_starter_addr: Address) -&gt; None\n</code></pre> <p>Initialize a dialogue label.</p> <p>Arguments:</p> <ul> <li><code>dialogue_reference</code>: the reference of the dialogue.</li> <li><code>dialogue_opponent_addr</code>: the addr of the agent with which the dialogue is kept.</li> <li><code>dialogue_starter_addr</code>: the addr of the agent which started the dialogue.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_reference","title":"dialogue<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_reference() -&gt; Tuple[str, str]\n</code></pre> <p>Get the dialogue reference.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_starter_reference","title":"dialogue<code>_</code>starter<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_starter_reference() -&gt; str\n</code></pre> <p>Get the dialogue starter reference.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_responder_reference","title":"dialogue<code>_</code>responder<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_responder_reference() -&gt; str\n</code></pre> <p>Get the dialogue responder reference.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_opponent_addr","title":"dialogue<code>_</code>opponent<code>_</code>addr","text":"<pre><code>@property\ndef dialogue_opponent_addr() -&gt; str\n</code></pre> <p>Get the address of the dialogue opponent.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_starter_addr","title":"dialogue<code>_</code>starter<code>_</code>addr","text":"<pre><code>@property\ndef dialogue_starter_addr() -&gt; str\n</code></pre> <p>Get the address of the dialogue starter.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__eq__","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Check for equality between two DialogueLabel objects.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__hash__","title":"<code>__</code>hash<code>__</code>","text":"<pre><code>def __hash__() -&gt; int\n</code></pre> <p>Turn object into hash.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#json","title":"json","text":"<pre><code>@property\ndef json() -&gt; Dict\n</code></pre> <p>Return the JSON representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#from_json","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, obj: Dict[str, str]) -&gt; \"DialogueLabel\"\n</code></pre> <p>Get dialogue label from json.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_incomplete_version","title":"get<code>_</code>incomplete<code>_</code>version","text":"<pre><code>def get_incomplete_version() -&gt; \"DialogueLabel\"\n</code></pre> <p>Get the incomplete version of the label.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#from_str","title":"from<code>_</code>str","text":"<pre><code>@classmethod\ndef from_str(cls, obj: str) -&gt; \"DialogueLabel\"\n</code></pre> <p>Get the dialogue label from string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#_dialoguemeta-objects","title":"<code>_</code>DialogueMeta Objects","text":"<pre><code>class _DialogueMeta(type)\n</code></pre> <p>Metaclass for Dialogue.</p> <p>Creates class level Rules instance to share among instances</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__new__","title":"<code>__</code>new<code>__</code>","text":"<pre><code>def __new__(cls, name: str, bases: Tuple[Type], dct: Dict) -&gt; \"_DialogueMeta\"\n</code></pre> <p>Construct a new type.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue-objects","title":"Dialogue Objects","text":"<pre><code>class Dialogue(metaclass=_DialogueMeta)\n</code></pre> <p>The dialogue class maintains state of a dialogue and manages it.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#rules-objects","title":"Rules Objects","text":"<pre><code>class Rules()\n</code></pre> <p>This class defines the rules for the dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\ninitial_performatives: FrozenSet[Message.Performative],\nterminal_performatives: FrozenSet[Message.Performative],\nvalid_replies: Dict[Message.Performative, FrozenSet[Message.Performative]]\n) -&gt; None\n</code></pre> <p>Initialize a dialogue.</p> <p>Arguments:</p> <ul> <li><code>initial_performatives</code>: the set of all initial performatives.</li> <li><code>terminal_performatives</code>: the set of all terminal performatives.</li> <li><code>valid_replies</code>: the reply structure of speech-acts.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#initial_performatives","title":"initial<code>_</code>performatives","text":"<pre><code>@property\ndef initial_performatives() -&gt; FrozenSet[Message.Performative]\n</code></pre> <p>Get the performatives one of which the terminal message in the dialogue must have.</p> <p>Returns:</p> <p>the valid performatives of an terminal message</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#terminal_performatives","title":"terminal<code>_</code>performatives","text":"<pre><code>@property\ndef terminal_performatives() -&gt; FrozenSet[Message.Performative]\n</code></pre> <p>Get the performatives one of which the terminal message in the dialogue must have.</p> <p>Returns:</p> <p>the valid performatives of an terminal message</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#valid_replies","title":"valid<code>_</code>replies","text":"<pre><code>@property\ndef valid_replies(\n) -&gt; Dict[Message.Performative, FrozenSet[Message.Performative]]\n</code></pre> <p>Get all the valid performatives which are a valid replies to performatives.</p> <p>Returns:</p> <p>the full valid reply structure.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_valid_replies","title":"get<code>_</code>valid<code>_</code>replies","text":"<pre><code>def get_valid_replies(\nperformative: Message.Performative) -&gt; FrozenSet[Message.Performative]\n</code></pre> <p>Given a <code>performative</code>, return the list of performatives which are its valid replies in a dialogue.</p> <p>Arguments:</p> <ul> <li><code>performative</code>: the performative in a message</li> </ul> <p>Returns:</p> <p>list of valid performative replies</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#role-objects","title":"Role Objects","text":"<pre><code>class Role(Enum)\n</code></pre> <p>This class defines the agent's role in a dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__str___1","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#endstate-objects","title":"EndState Objects","text":"<pre><code>class EndState(Enum)\n</code></pre> <p>This class defines the end states of a dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__str___2","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogue_label: DialogueLabel, message_class: Type[Message],\nself_address: Address, role: Role) -&gt; None\n</code></pre> <p>Initialize a dialogue.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: the identifier of the dialogue</li> <li><code>message_class</code>: the message class used</li> <li><code>self_address</code>: the address of the entity for whom this dialogue is maintained</li> <li><code>role</code>: the role of the agent this dialogue is maintained for</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#add_terminal_state_callback","title":"add<code>_</code>terminal<code>_</code>state<code>_</code>callback","text":"<pre><code>def add_terminal_state_callback(fn: Callable[[\"Dialogue\"], None]) -&gt; None\n</code></pre> <p>Add callback to be called on dialogue reach terminal state.</p> <p>Arguments:</p> <ul> <li><code>fn</code>: callable to be called with one argument: Dialogue</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__eq___1","title":"<code>__</code>eq<code>__</code>","text":"<pre><code>def __eq__(other: Any) -&gt; bool\n</code></pre> <p>Compare two dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#json_1","title":"json","text":"<pre><code>def json() -&gt; dict\n</code></pre> <p>Get json representation of the dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#from_json_1","title":"from<code>_</code>json","text":"<pre><code>@classmethod\ndef from_json(cls, message_class: Type[Message], data: dict) -&gt; \"Dialogue\"\n</code></pre> <p>Create a dialogue instance with all messages from json data.</p> <p>Arguments:</p> <ul> <li><code>message_class</code>: type of message used with this dialogue</li> <li><code>data</code>: dict with data exported with Dialogue.to_json() method</li> </ul> <p>Returns:</p> <p>Dialogue instance</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_label","title":"dialogue<code>_</code>label","text":"<pre><code>@property\ndef dialogue_label() -&gt; DialogueLabel\n</code></pre> <p>Get the dialogue label.</p> <p>Returns:</p> <p>The dialogue label</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#incomplete_dialogue_label","title":"incomplete<code>_</code>dialogue<code>_</code>label","text":"<pre><code>@property\ndef incomplete_dialogue_label() -&gt; DialogueLabel\n</code></pre> <p>Get the dialogue label.</p> <p>Returns:</p> <p>The incomplete dialogue label</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_labels","title":"dialogue<code>_</code>labels","text":"<pre><code>@property\ndef dialogue_labels() -&gt; Set[DialogueLabel]\n</code></pre> <p>Get the dialogue labels (incomplete and complete, if it exists).</p> <p>Returns:</p> <p>the dialogue labels</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#self_address","title":"self<code>_</code>address","text":"<pre><code>@property\ndef self_address() -&gt; Address\n</code></pre> <p>Get the address of the entity for whom this dialogues is maintained.</p> <p>Returns:</p> <p>the address of this entity</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#role","title":"role","text":"<pre><code>@property\ndef role() -&gt; \"Role\"\n</code></pre> <p>Get the agent's role in the dialogue.</p> <p>Returns:</p> <p>the agent's role</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#rules","title":"rules","text":"<pre><code>@property\ndef rules() -&gt; \"Rules\"\n</code></pre> <p>Get the dialogue rules.</p> <p>Returns:</p> <p>the rules</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#message_class","title":"message<code>_</code>class","text":"<pre><code>@property\ndef message_class() -&gt; Type[Message]\n</code></pre> <p>Get the message class.</p> <p>Returns:</p> <p>the message class</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_self_initiated","title":"is<code>_</code>self<code>_</code>initiated","text":"<pre><code>@property\ndef is_self_initiated() -&gt; bool\n</code></pre> <p>Check whether the agent initiated the dialogue.</p> <p>Returns:</p> <p>True if the agent initiated the dialogue, False otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#last_incoming_message","title":"last<code>_</code>incoming<code>_</code>message","text":"<pre><code>@property\ndef last_incoming_message() -&gt; Optional[Message]\n</code></pre> <p>Get the last incoming message.</p> <p>Returns:</p> <p>the last incoming message if it exists, None otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#last_outgoing_message","title":"last<code>_</code>outgoing<code>_</code>message","text":"<pre><code>@property\ndef last_outgoing_message() -&gt; Optional[Message]\n</code></pre> <p>Get the last outgoing message.</p> <p>Returns:</p> <p>the last outgoing message if it exists, None otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#last_message","title":"last<code>_</code>message","text":"<pre><code>@property\ndef last_message() -&gt; Optional[Message]\n</code></pre> <p>Get the last message.</p> <p>Returns:</p> <p>the last message if it exists, None otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_empty","title":"is<code>_</code>empty","text":"<pre><code>@property\ndef is_empty() -&gt; bool\n</code></pre> <p>Check whether the dialogue is empty.</p> <p>Returns:</p> <p>True if empty, False otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#reply","title":"reply","text":"<pre><code>def reply(performative: Message.Performative,\ntarget_message: Optional[Message] = None,\ntarget: Optional[int] = None,\n**kwargs: Any) -&gt; Message\n</code></pre> <p>Reply to the 'target_message' in this dialogue with a message with 'performative', and contents from kwargs.</p> <p>Note if no target_message is provided, the last message in the dialogue will be replied to.</p> <p>Arguments:</p> <ul> <li><code>target_message</code>: the message to reply to.</li> <li><code>target</code>: the id of the message to reply to.</li> <li><code>performative</code>: the performative of the reply message.</li> <li><code>kwargs</code>: the content of the reply message.</li> </ul> <p>Returns:</p> <p>the reply message if it was successfully added as a reply, None otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_message_by_id","title":"get<code>_</code>message<code>_</code>by<code>_</code>id","text":"<pre><code>def get_message_by_id(message_id: int) -&gt; Optional[Message]\n</code></pre> <p>Get message by id, if not presents return None.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_outgoing_next_message_id","title":"get<code>_</code>outgoing<code>_</code>next<code>_</code>message<code>_</code>id","text":"<pre><code>def get_outgoing_next_message_id() -&gt; int\n</code></pre> <p>Get next outgoing message id.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_incoming_next_message_id","title":"get<code>_</code>incoming<code>_</code>next<code>_</code>message<code>_</code>id","text":"<pre><code>def get_incoming_next_message_id() -&gt; int\n</code></pre> <p>Get next incoming message id.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__str___3","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p>Returns:</p> <p>The string representation of the dialogue</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialoguestats-objects","title":"DialogueStats Objects","text":"<pre><code>class DialogueStats()\n</code></pre> <p>Class to handle statistics on default dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(end_states: FrozenSet[Dialogue.EndState]) -&gt; None\n</code></pre> <p>Initialize a StatsManager.</p> <p>Arguments:</p> <ul> <li><code>end_states</code>: the list of dialogue endstates</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#self_initiated","title":"self<code>_</code>initiated","text":"<pre><code>@property\ndef self_initiated() -&gt; Dict[Dialogue.EndState, int]\n</code></pre> <p>Get the stats dictionary on self initiated dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#other_initiated","title":"other<code>_</code>initiated","text":"<pre><code>@property\ndef other_initiated() -&gt; Dict[Dialogue.EndState, int]\n</code></pre> <p>Get the stats dictionary on other initiated dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#add_dialogue_endstate","title":"add<code>_</code>dialogue<code>_</code>endstate","text":"<pre><code>def add_dialogue_endstate(end_state: Dialogue.EndState,\nis_self_initiated: bool) -&gt; None\n</code></pre> <p>Add dialogue endstate stats.</p> <p>Arguments:</p> <ul> <li><code>end_state</code>: the end state of the dialogue</li> <li><code>is_self_initiated</code>: whether the dialogue is initiated by the agent or the opponent</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#find_caller_object","title":"find<code>_</code>caller<code>_</code>object","text":"<pre><code>def find_caller_object(object_type: Type) -&gt; Any\n</code></pre> <p>Find caller object of certain type in the call stack.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#basicdialoguesstorage-objects","title":"BasicDialoguesStorage Objects","text":"<pre><code>class BasicDialoguesStorage()\n</code></pre> <p>Dialogues state storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogues: \"Dialogues\") -&gt; None\n</code></pre> <p>Init dialogues storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogues_in_terminal_state","title":"dialogues<code>_</code>in<code>_</code>terminal<code>_</code>state","text":"<pre><code>@property\ndef dialogues_in_terminal_state() -&gt; List[\"Dialogue\"]\n</code></pre> <p>Get all dialogues in terminal state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogues_in_active_state","title":"dialogues<code>_</code>in<code>_</code>active<code>_</code>state","text":"<pre><code>@property\ndef dialogues_in_active_state() -&gt; List[\"Dialogue\"]\n</code></pre> <p>Get all dialogues in active state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_terminal_dialogues_kept","title":"is<code>_</code>terminal<code>_</code>dialogues<code>_</code>kept","text":"<pre><code>@property\ndef is_terminal_dialogues_kept() -&gt; bool\n</code></pre> <p>Return True if dialogues should stay after terminal state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_terminal_state_callback","title":"dialogue<code>_</code>terminal<code>_</code>state<code>_</code>callback","text":"<pre><code>def dialogue_terminal_state_callback(dialogue: \"Dialogue\") -&gt; None\n</code></pre> <p>Method to be called on dialogue terminal state reached.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up dialogue storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down dialogue storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#add","title":"add","text":"<pre><code>def add(dialogue: Dialogue) -&gt; None\n</code></pre> <p>Add dialogue to storage.</p> <p>Arguments:</p> <ul> <li><code>dialogue</code>: dialogue to add.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#remove","title":"remove","text":"<pre><code>def remove(dialogue_label: DialogueLabel) -&gt; None\n</code></pre> <p>Remove dialogue from storage by it's label.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: label of the dialogue to remove</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get","title":"get","text":"<pre><code>def get(dialogue_label: DialogueLabel) -&gt; Optional[Dialogue]\n</code></pre> <p>Get dialogue stored by it's label.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: label of the dialogue</li> </ul> <p>Returns:</p> <p>dialogue if presents or None</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_dialogues_with_counterparty","title":"get<code>_</code>dialogues<code>_</code>with<code>_</code>counterparty","text":"<pre><code>def get_dialogues_with_counterparty(counterparty: Address) -&gt; List[Dialogue]\n</code></pre> <p>Get the dialogues by address.</p> <p>Arguments:</p> <ul> <li><code>counterparty</code>: the counterparty</li> </ul> <p>Returns:</p> <p>The dialogues with the counterparty.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_in_incomplete","title":"is<code>_</code>in<code>_</code>incomplete","text":"<pre><code>def is_in_incomplete(dialogue_label: DialogueLabel) -&gt; bool\n</code></pre> <p>Check dialogue label presents in list of incomplete.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#set_incomplete_dialogue","title":"set<code>_</code>incomplete<code>_</code>dialogue","text":"<pre><code>def set_incomplete_dialogue(incomplete_dialogue_label: DialogueLabel,\ncomplete_dialogue_label: DialogueLabel) -&gt; None\n</code></pre> <p>Set incomplete dialogue label.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_dialogue_present","title":"is<code>_</code>dialogue<code>_</code>present","text":"<pre><code>def is_dialogue_present(dialogue_label: DialogueLabel) -&gt; bool\n</code></pre> <p>Check dialogue with label specified presents in storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_latest_label","title":"get<code>_</code>latest<code>_</code>label","text":"<pre><code>def get_latest_label(dialogue_label: DialogueLabel) -&gt; DialogueLabel\n</code></pre> <p>Get latest label for dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#persistdialoguesstorage-objects","title":"PersistDialoguesStorage Objects","text":"<pre><code>class PersistDialoguesStorage(BasicDialoguesStorage)\n</code></pre> <p>Persist dialogues storage.</p> <p>Uses generic storage to load/save dialogues data on setup/teardown.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogues: \"Dialogues\") -&gt; None\n</code></pre> <p>Init dialogues storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_skill_component","title":"get<code>_</code>skill<code>_</code>component","text":"<pre><code>@staticmethod\ndef get_skill_component() -&gt; Optional[SkillComponent]\n</code></pre> <p>Get skill component dialogues storage constructed for.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#setup_1","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up dialogue storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#teardown_1","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down dialogue storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#remove_1","title":"remove","text":"<pre><code>def remove(dialogue_label: DialogueLabel) -&gt; None\n</code></pre> <p>Remove dialogue from memory and persistent storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#persistdialoguesstoragewithoffloading-objects","title":"PersistDialoguesStorageWithOffloading Objects","text":"<pre><code>class PersistDialoguesStorageWithOffloading(PersistDialoguesStorage)\n</code></pre> <p>Dialogue Storage with dialogues offloading.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_terminal_state_callback_1","title":"dialogue<code>_</code>terminal<code>_</code>state<code>_</code>callback","text":"<pre><code>def dialogue_terminal_state_callback(dialogue: \"Dialogue\") -&gt; None\n</code></pre> <p>Call on dialogue reaches terminal state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_1","title":"get","text":"<pre><code>def get(dialogue_label: DialogueLabel) -&gt; Optional[Dialogue]\n</code></pre> <p>Try to get dialogue by label from memory or persists storage.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_dialogues_with_counterparty_1","title":"get<code>_</code>dialogues<code>_</code>with<code>_</code>counterparty","text":"<pre><code>def get_dialogues_with_counterparty(counterparty: Address) -&gt; List[Dialogue]\n</code></pre> <p>Get the dialogues by address.</p> <p>Arguments:</p> <ul> <li><code>counterparty</code>: the counterparty</li> </ul> <p>Returns:</p> <p>The dialogues with the counterparty.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogues_in_terminal_state_1","title":"dialogues<code>_</code>in<code>_</code>terminal<code>_</code>state","text":"<pre><code>@property\ndef dialogues_in_terminal_state() -&gt; List[\"Dialogue\"]\n</code></pre> <p>Get all dialogues in terminal state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogues-objects","title":"Dialogues Objects","text":"<pre><code>class Dialogues()\n</code></pre> <p>The dialogues class keeps track of all dialogues for an agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#__init___6","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address,\nend_states: FrozenSet[Dialogue.EndState],\nmessage_class: Type[Message],\ndialogue_class: Type[Dialogue],\nrole_from_first_message: Callable[[Message, Address],\nDialogue.Role],\nkeep_terminal_state_dialogues: Optional[bool] = None) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>end_states</code>: the list of dialogue endstates</li> <li><code>message_class</code>: the message class used</li> <li><code>dialogue_class</code>: the dialogue class used</li> <li><code>role_from_first_message</code>: the callable determining role from first message</li> <li><code>keep_terminal_state_dialogues</code>: specify do dialogues in terminal state should stay or not</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#is_keep_dialogues_in_terminal_state","title":"is<code>_</code>keep<code>_</code>dialogues<code>_</code>in<code>_</code>terminal<code>_</code>state","text":"<pre><code>@property\ndef is_keep_dialogues_in_terminal_state() -&gt; bool\n</code></pre> <p>Is required to keep dialogues in terminal state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#self_address_1","title":"self<code>_</code>address","text":"<pre><code>@property\ndef self_address() -&gt; Address\n</code></pre> <p>Get the address of the agent for whom dialogues are maintained.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_stats","title":"dialogue<code>_</code>stats","text":"<pre><code>@property\ndef dialogue_stats() -&gt; DialogueStats\n</code></pre> <p>Get the dialogue statistics.</p> <p>Returns:</p> <p>dialogue stats object</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#message_class_1","title":"message<code>_</code>class","text":"<pre><code>@property\ndef message_class() -&gt; Type[Message]\n</code></pre> <p>Get the message class.</p> <p>Returns:</p> <p>the message class</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#dialogue_class","title":"dialogue<code>_</code>class","text":"<pre><code>@property\ndef dialogue_class() -&gt; Type[Dialogue]\n</code></pre> <p>Get the dialogue class.</p> <p>Returns:</p> <p>the dialogue class</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_dialogues_with_counterparty_2","title":"get<code>_</code>dialogues<code>_</code>with<code>_</code>counterparty","text":"<pre><code>def get_dialogues_with_counterparty(counterparty: Address) -&gt; List[Dialogue]\n</code></pre> <p>Get the dialogues by address.</p> <p>Arguments:</p> <ul> <li><code>counterparty</code>: the counterparty</li> </ul> <p>Returns:</p> <p>The dialogues with the counterparty.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#new_self_initiated_dialogue_reference","title":"new<code>_</code>self<code>_</code>initiated<code>_</code>dialogue<code>_</code>reference","text":"<pre><code>@classmethod\ndef new_self_initiated_dialogue_reference(cls) -&gt; Tuple[str, str]\n</code></pre> <p>Return a dialogue label for a new self initiated dialogue.</p> <p>Returns:</p> <p>the next nonce</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#create","title":"create","text":"<pre><code>def create(counterparty: Address, performative: Message.Performative,\n**kwargs: Any) -&gt; Tuple[Message, Dialogue]\n</code></pre> <p>Create a dialogue with 'counterparty', with an initial message whose performative is 'performative' and contents are from 'kwargs'.</p> <p>Arguments:</p> <ul> <li><code>counterparty</code>: the counterparty of the dialogue.</li> <li><code>performative</code>: the performative of the initial message.</li> <li><code>kwargs</code>: the content of the initial message.</li> </ul> <p>Returns:</p> <p>the initial message and the dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#create_with_message","title":"create<code>_</code>with<code>_</code>message","text":"<pre><code>def create_with_message(counterparty: Address,\ninitial_message: Message) -&gt; Dialogue\n</code></pre> <p>Create a dialogue with 'counterparty', with an initial message provided.</p> <p>Arguments:</p> <ul> <li><code>counterparty</code>: the counterparty of the dialogue.</li> <li><code>initial_message</code>: the initial_message.</li> </ul> <p>Returns:</p> <p>the initial message and the dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#update","title":"update","text":"<pre><code>def update(message: Message) -&gt; Optional[Dialogue]\n</code></pre> <p>Update the state of dialogues with a new incoming message.</p> <p>If the message is for a new dialogue, a new dialogue is created with 'message' as its first message, and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None.</p> <p>Arguments:</p> <ul> <li><code>message</code>: a new incoming message</li> </ul> <p>Returns:</p> <p>the new or existing dialogue the message is intended for, or None in case of any errors.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_dialogue","title":"get<code>_</code>dialogue","text":"<pre><code>def get_dialogue(message: Message) -&gt; Optional[Dialogue]\n</code></pre> <p>Retrieve the dialogue 'message' belongs to.</p> <p>Arguments:</p> <ul> <li><code>message</code>: a message</li> </ul> <p>Returns:</p> <p>the dialogue, or None in case such a dialogue does not exist</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#get_dialogue_from_label","title":"get<code>_</code>dialogue<code>_</code>from<code>_</code>label","text":"<pre><code>def get_dialogue_from_label(\ndialogue_label: DialogueLabel) -&gt; Optional[Dialogue]\n</code></pre> <p>Retrieve a dialogue based on its label.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: the dialogue label</li> </ul> <p>Returns:</p> <p>the dialogue if present</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#setup_2","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set  up.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/dialogue/base/#teardown_2","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down.</p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/","title":"Common","text":""},{"location":"aea-framework-documentation/api/protocols/generator/common/#aeaprotocolsgeneratorcommon","title":"aea.protocols.generator.common","text":"<p>This module contains utility code for generator modules.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#is_installed","title":"is<code>_</code>installed","text":"<pre><code>def is_installed(programme: str) -&gt; bool\n</code></pre> <p>Check whether a programme is installed on the system.</p> <p>Arguments:</p> <ul> <li><code>programme</code>: the name of the programme.</li> </ul> <p>Returns:</p> <p>True if installed, False otherwise</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#base_protolint_command","title":"base<code>_</code>protolint<code>_</code>command","text":"<pre><code>def base_protolint_command() -&gt; str\n</code></pre> <p>Return the base protolint command.</p> <p>Returns:</p> <p>The base protolint command</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#check_prerequisites","title":"check<code>_</code>prerequisites","text":"<pre><code>def check_prerequisites() -&gt; None\n</code></pre> <p>Check whether a programme is installed on the system.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#get_protoc_version","title":"get<code>_</code>protoc<code>_</code>version","text":"<pre><code>def get_protoc_version() -&gt; str\n</code></pre> <p>Get the protoc version used.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#load_protocol_specification","title":"load<code>_</code>protocol<code>_</code>specification","text":"<pre><code>def load_protocol_specification(\nspecification_path: str) -&gt; ProtocolSpecification\n</code></pre> <p>Load a protocol specification.</p> <p>Arguments:</p> <ul> <li><code>specification_path</code>: path to the protocol specification yaml file.</li> </ul> <p>Returns:</p> <p>A ProtocolSpecification object</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#try_run_black_formatting","title":"try<code>_</code>run<code>_</code>black<code>_</code>formatting","text":"<pre><code>def try_run_black_formatting(path_to_protocol_package: str) -&gt; None\n</code></pre> <p>Run Black code formatting via subprocess.</p> <p>Arguments:</p> <ul> <li><code>path_to_protocol_package</code>: a path where formatting should be applied.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#try_run_isort_formatting","title":"try<code>_</code>run<code>_</code>isort<code>_</code>formatting","text":"<pre><code>def try_run_isort_formatting(path_to_protocol_package: str) -&gt; None\n</code></pre> <p>Run Isort code formatting via subprocess.</p> <p>Arguments:</p> <ul> <li><code>path_to_protocol_package</code>: a path where formatting should be applied.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#try_run_protoc","title":"try<code>_</code>run<code>_</code>protoc","text":"<pre><code>def try_run_protoc(path_to_generated_protocol_package: str,\nname: str,\nlanguage: str = PROTOCOL_LANGUAGE_PYTHON) -&gt; None\n</code></pre> <p>Run 'protoc' protocol buffer compiler via subprocess.</p> <p>Arguments:</p> <ul> <li><code>path_to_generated_protocol_package</code>: path to the protocol buffer schema file.</li> <li><code>name</code>: name of the protocol buffer schema file.</li> <li><code>language</code>: the target language in which to compile the protobuf schema file</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#try_run_protolint","title":"try<code>_</code>run<code>_</code>protolint","text":"<pre><code>def try_run_protolint(path_to_generated_protocol_package: str,\nname: str) -&gt; None\n</code></pre> <p>Run 'protolint' linter via subprocess.</p> <p>Arguments:</p> <ul> <li><code>path_to_generated_protocol_package</code>: path to the protocol buffer schema file.</li> <li><code>name</code>: name of the protocol buffer schema file.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#check_protobuf_using_protoc","title":"check<code>_</code>protobuf<code>_</code>using<code>_</code>protoc","text":"<pre><code>def check_protobuf_using_protoc(path_to_generated_protocol_package: str,\nname: str) -&gt; Tuple[bool, str]\n</code></pre> <p>Check whether a protocol buffer schema file is valid.</p> <p>Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler.</p> <p>Arguments:</p> <ul> <li><code>path_to_generated_protocol_package</code>: path to the protocol buffer schema file.</li> <li><code>name</code>: name of the protocol buffer schema file.</li> </ul> <p>Returns:</p> <p>Boolean result and an accompanying message</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#compile_protobuf_using_protoc","title":"compile<code>_</code>protobuf<code>_</code>using<code>_</code>protoc","text":"<pre><code>def compile_protobuf_using_protoc(path_to_generated_protocol_package: str,\nname: str,\nlanguage: str) -&gt; Tuple[bool, str]\n</code></pre> <p>Compile a protocol buffer schema file using protoc.</p> <p>If successfully compiled, return True and a success message, otherwise return False and the error thrown by the compiler.</p> <p>Arguments:</p> <ul> <li><code>path_to_generated_protocol_package</code>: path to the protocol buffer schema file.</li> <li><code>name</code>: name of the protocol buffer schema file.</li> <li><code>language</code>: the target language in which to compile the protobuf schema file</li> </ul> <p>Returns:</p> <p>Boolean result and an accompanying message</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/common/#apply_protolint","title":"apply<code>_</code>protolint","text":"<pre><code>def apply_protolint(path_to_proto_file: str, name: str) -&gt; Tuple[bool, str]\n</code></pre> <p>Apply protolint linter to a protocol buffer schema file.</p> <p>If no output, return True and a success message, otherwise return False and the output shown by the linter (minus the indentation suggestions which are automatically fixed by protolint).</p> <p>Arguments:</p> <ul> <li><code>path_to_proto_file</code>: path to the protocol buffer schema file.</li> <li><code>name</code>: name of the protocol buffer schema file.</li> </ul> <p>Returns:</p> <p>Boolean result and an accompanying message</p>"},{"location":"aea-framework-documentation/api/protocols/generator/extract_specification/","title":"Extract Specification","text":""},{"location":"aea-framework-documentation/api/protocols/generator/extract_specification/#aeaprotocolsgeneratorextract_specification","title":"aea.protocols.generator.extract<code>_</code>specification","text":"<p>This module extracts a valid protocol specification into pythonic objects.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/extract_specification/#pythonicprotocolspecification-objects","title":"PythonicProtocolSpecification Objects","text":"<pre><code>class PythonicProtocolSpecification()\n</code></pre> <p>This class represents a protocol specification in python.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/extract_specification/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Instantiate a Pythonic protocol specification.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/extract_specification/#extract","title":"extract","text":"<pre><code>def extract(\nprotocol_specification: ProtocolSpecification\n) -&gt; PythonicProtocolSpecification\n</code></pre> <p>Converts a protocol specification into a Pythonic protocol specification.</p> <p>Arguments:</p> <ul> <li><code>protocol_specification</code>: a protocol specification</li> </ul> <p>Returns:</p> <p>a Pythonic protocol specification</p>"},{"location":"aea-framework-documentation/api/protocols/generator/validate/","title":"Validate","text":""},{"location":"aea-framework-documentation/api/protocols/generator/validate/#aeaprotocolsgeneratorvalidate","title":"aea.protocols.generator.validate","text":"<p>This module validates a protocol specification.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/generator/validate/#validate","title":"validate","text":"<pre><code>def validate(\nprotocol_specification: ProtocolSpecification) -&gt; Tuple[bool, str]\n</code></pre> <p>Evaluate whether a protocol specification is valid.</p> <p>Arguments:</p> <ul> <li><code>protocol_specification</code>: a protocol specification.</li> </ul> <p>Returns:</p> <p>Boolean result, and associated message.</p>"},{"location":"aea-framework-documentation/api/protocols/signing/custom_types/","title":"Custom Types","text":""},{"location":"aea-framework-documentation/api/protocols/signing/custom_types/#packagesfetchaiprotocolssigningcustom_types","title":"packages.fetchai.protocols.signing.custom<code>_</code>types","text":"<p>This module contains class representations corresponding to every custom type in the protocol specification.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/custom_types/#errorcode-objects","title":"ErrorCode Objects","text":"<pre><code>class ErrorCode(Enum)\n</code></pre> <p>This class represents an instance of ErrorCode.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/custom_types/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(error_code_protobuf_object: Any,\nerror_code_object: \"ErrorCode\") -&gt; None\n</code></pre> <p>Encode an instance of this class into the protocol buffer object.</p> <p>The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument.</p> <p>Arguments:</p> <ul> <li><code>error_code_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> <li><code>error_code_object</code>: an instance of this class to be encoded in the protocol buffer object.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/custom_types/#decode","title":"decode","text":"<pre><code>@classmethod\ndef decode(cls, error_code_protobuf_object: Any) -&gt; \"ErrorCode\"\n</code></pre> <p>Decode a protocol buffer object that corresponds with this class into an instance of this class.</p> <p>A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument.</p> <p>Arguments:</p> <ul> <li><code>error_code_protobuf_object</code>: the protocol buffer object whose type corresponds with this class.</li> </ul> <p>Returns:</p> <p>A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.</p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/","title":"Dialogues","text":""},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#packagesfetchaiprotocolssigningdialogues","title":"packages.fetchai.protocols.signing.dialogues","text":"<p>This module contains the classes required for signing dialogue management.</p> <ul> <li>SigningDialogue: The dialogue class maintains state of a dialogue and manages it.</li> <li>SigningDialogues: The dialogues class keeps track of all dialogues.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#signingdialogue-objects","title":"SigningDialogue Objects","text":"<pre><code>class SigningDialogue(Dialogue)\n</code></pre> <p>The signing dialogue class maintains state of a dialogue and manages it.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#role-objects","title":"Role Objects","text":"<pre><code>class Role(Dialogue.Role)\n</code></pre> <p>This class defines the agent's role in a signing dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#endstate-objects","title":"EndState Objects","text":"<pre><code>class EndState(Dialogue.EndState)\n</code></pre> <p>This class defines the end states of a signing dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(dialogue_label: DialogueLabel,\nself_address: Address,\nrole: Dialogue.Role,\nmessage_class: Type[SigningMessage] = SigningMessage) -&gt; None\n</code></pre> <p>Initialize a dialogue.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: the identifier of the dialogue</li> <li><code>self_address</code>: the address of the entity for whom this dialogue is maintained</li> <li><code>role</code>: the role of the agent this dialogue is maintained for</li> <li><code>message_class</code>: the message class used</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#signingdialogues-objects","title":"SigningDialogues Objects","text":"<pre><code>class SigningDialogues(Dialogues, ABC)\n</code></pre> <p>This class keeps track of all signing dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/dialogues/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(self_address: Address,\nrole_from_first_message: Callable[[Message, Address],\nDialogue.Role],\ndialogue_class: Type[SigningDialogue] = SigningDialogue) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>dialogue_class</code>: the dialogue class used</li> <li><code>role_from_first_message</code>: the callable determining role from first message</li> </ul>"},{"location":"aea-framework-documentation/api/protocols/signing/message/","title":"Message","text":""},{"location":"aea-framework-documentation/api/protocols/signing/message/#packagesfetchaiprotocolssigningmessage","title":"packages.fetchai.protocols.signing.message","text":"<p>This module contains signing's message definition.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#signingmessage-objects","title":"SigningMessage Objects","text":"<pre><code>class SigningMessage(Message)\n</code></pre> <p>A protocol for communication between skills and decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#performative-objects","title":"Performative Objects","text":"<pre><code>class Performative(Message.Performative)\n</code></pre> <p>Performatives for the signing protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(performative: Performative,\ndialogue_reference: Tuple[str, str] = (\"\", \"\"),\nmessage_id: int = 1,\ntarget: int = 0,\n**kwargs: Any)\n</code></pre> <p>Initialise an instance of SigningMessage.</p> <p>Arguments:</p> <ul> <li><code>message_id</code>: the message id.</li> <li><code>dialogue_reference</code>: the dialogue reference.</li> <li><code>target</code>: the message target.</li> <li><code>performative</code>: the message performative.</li> <li><code>**kwargs</code>: extra options.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#valid_performatives","title":"valid<code>_</code>performatives","text":"<pre><code>@property\ndef valid_performatives() -&gt; Set[str]\n</code></pre> <p>Get valid performatives.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#dialogue_reference","title":"dialogue<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_reference() -&gt; Tuple[str, str]\n</code></pre> <p>Get the dialogue_reference of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#message_id","title":"message<code>_</code>id","text":"<pre><code>@property\ndef message_id() -&gt; int\n</code></pre> <p>Get the message_id of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#performative","title":"performative","text":"<pre><code>@property\ndef performative() -&gt; Performative\n</code></pre> <p>Get the performative of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#target","title":"target","text":"<pre><code>@property\ndef target() -&gt; int\n</code></pre> <p>Get the target of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#error_code","title":"error<code>_</code>code","text":"<pre><code>@property\ndef error_code() -&gt; CustomErrorCode\n</code></pre> <p>Get the 'error_code' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#raw_message","title":"raw<code>_</code>message","text":"<pre><code>@property\ndef raw_message() -&gt; CustomRawMessage\n</code></pre> <p>Get the 'raw_message' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#raw_transaction","title":"raw<code>_</code>transaction","text":"<pre><code>@property\ndef raw_transaction() -&gt; CustomRawTransaction\n</code></pre> <p>Get the 'raw_transaction' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#signed_message","title":"signed<code>_</code>message","text":"<pre><code>@property\ndef signed_message() -&gt; CustomSignedMessage\n</code></pre> <p>Get the 'signed_message' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#signed_transaction","title":"signed<code>_</code>transaction","text":"<pre><code>@property\ndef signed_transaction() -&gt; CustomSignedTransaction\n</code></pre> <p>Get the 'signed_transaction' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/message/#terms","title":"terms","text":"<pre><code>@property\ndef terms() -&gt; CustomTerms\n</code></pre> <p>Get the 'terms' content from the message.</p>"},{"location":"aea-framework-documentation/api/protocols/signing/serialization/","title":"Serialization","text":""},{"location":"aea-framework-documentation/api/protocols/signing/serialization/#packagesfetchaiprotocolssigningserialization","title":"packages.fetchai.protocols.signing.serialization","text":"<p>Serialization module for signing protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/serialization/#signingserializer-objects","title":"SigningSerializer Objects","text":"<pre><code>class SigningSerializer(Serializer)\n</code></pre> <p>Serialization for the 'signing' protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/serialization/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(msg: Message) -&gt; bytes\n</code></pre> <p>Encode a 'Signing' message into bytes.</p> <p>Arguments:</p> <ul> <li><code>msg</code>: the message object.</li> </ul> <p>Returns:</p> <p>the bytes.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/signing/serialization/#decode","title":"decode","text":"<pre><code>@staticmethod\ndef decode(obj: bytes) -&gt; Message\n</code></pre> <p>Decode bytes into a 'Signing' message.</p> <p>Arguments:</p> <ul> <li><code>obj</code>: the bytes object.</li> </ul> <p>Returns:</p> <p>the 'Signing' message.</p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/","title":"Dialogues","text":""},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#packagesfetchaiprotocolsstate_updatedialogues","title":"packages.fetchai.protocols.state<code>_</code>update.dialogues","text":"<p>This module contains the classes required for state_update dialogue management.</p> <ul> <li>StateUpdateDialogue: The dialogue class maintains state of a dialogue and manages it.</li> <li>StateUpdateDialogues: The dialogues class keeps track of all dialogues.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#stateupdatedialogue-objects","title":"StateUpdateDialogue Objects","text":"<pre><code>class StateUpdateDialogue(Dialogue)\n</code></pre> <p>The state_update dialogue class maintains state of a dialogue and manages it.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#role-objects","title":"Role Objects","text":"<pre><code>class Role(Dialogue.Role)\n</code></pre> <p>This class defines the agent's role in a state_update dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#endstate-objects","title":"EndState Objects","text":"<pre><code>class EndState(Dialogue.EndState)\n</code></pre> <p>This class defines the end states of a state_update dialogue.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\ndialogue_label: DialogueLabel,\nself_address: Address,\nrole: Dialogue.Role,\nmessage_class: Type[StateUpdateMessage] = StateUpdateMessage) -&gt; None\n</code></pre> <p>Initialize a dialogue.</p> <p>Arguments:</p> <ul> <li><code>dialogue_label</code>: the identifier of the dialogue</li> <li><code>self_address</code>: the address of the entity for whom this dialogue is maintained</li> <li><code>role</code>: the role of the agent this dialogue is maintained for</li> <li><code>message_class</code>: the message class used</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#stateupdatedialogues-objects","title":"StateUpdateDialogues Objects","text":"<pre><code>class StateUpdateDialogues(Dialogues, ABC)\n</code></pre> <p>This class keeps track of all state_update dialogues.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/dialogues/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(\nself_address: Address,\nrole_from_first_message: Callable[[Message, Address], Dialogue.Role],\ndialogue_class: Type[StateUpdateDialogue] = StateUpdateDialogue\n) -&gt; None\n</code></pre> <p>Initialize dialogues.</p> <p>Arguments:</p> <ul> <li><code>self_address</code>: the address of the entity for whom dialogues are maintained</li> <li><code>dialogue_class</code>: the dialogue class used</li> <li><code>role_from_first_message</code>: the callable determining role from first message</li> </ul>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/","title":"Message","text":""},{"location":"aea-framework-documentation/api/protocols/state_update/message/#packagesfetchaiprotocolsstate_updatemessage","title":"packages.fetchai.protocols.state<code>_</code>update.message","text":"<p>This module contains state_update's message definition.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#stateupdatemessage-objects","title":"StateUpdateMessage Objects","text":"<pre><code>class StateUpdateMessage(Message)\n</code></pre> <p>A protocol for state updates to the decision maker state.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#performative-objects","title":"Performative Objects","text":"<pre><code>class Performative(Message.Performative)\n</code></pre> <p>Performatives for the state_update protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#__str__","title":"<code>__</code>str<code>__</code>","text":"<pre><code>def __str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(performative: Performative,\ndialogue_reference: Tuple[str, str] = (\"\", \"\"),\nmessage_id: int = 1,\ntarget: int = 0,\n**kwargs: Any)\n</code></pre> <p>Initialise an instance of StateUpdateMessage.</p> <p>Arguments:</p> <ul> <li><code>message_id</code>: the message id.</li> <li><code>dialogue_reference</code>: the dialogue reference.</li> <li><code>target</code>: the message target.</li> <li><code>performative</code>: the message performative.</li> <li><code>**kwargs</code>: extra options.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#valid_performatives","title":"valid<code>_</code>performatives","text":"<pre><code>@property\ndef valid_performatives() -&gt; Set[str]\n</code></pre> <p>Get valid performatives.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#dialogue_reference","title":"dialogue<code>_</code>reference","text":"<pre><code>@property\ndef dialogue_reference() -&gt; Tuple[str, str]\n</code></pre> <p>Get the dialogue_reference of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#message_id","title":"message<code>_</code>id","text":"<pre><code>@property\ndef message_id() -&gt; int\n</code></pre> <p>Get the message_id of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#performative","title":"performative","text":"<pre><code>@property\ndef performative() -&gt; Performative\n</code></pre> <p>Get the performative of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#target","title":"target","text":"<pre><code>@property\ndef target() -&gt; int\n</code></pre> <p>Get the target of the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#amount_by_currency_id","title":"amount<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef amount_by_currency_id() -&gt; Dict[str, int]\n</code></pre> <p>Get the 'amount_by_currency_id' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#exchange_params_by_currency_id","title":"exchange<code>_</code>params<code>_</code>by<code>_</code>currency<code>_</code>id","text":"<pre><code>@property\ndef exchange_params_by_currency_id() -&gt; Dict[str, float]\n</code></pre> <p>Get the 'exchange_params_by_currency_id' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#quantities_by_good_id","title":"quantities<code>_</code>by<code>_</code>good<code>_</code>id","text":"<pre><code>@property\ndef quantities_by_good_id() -&gt; Dict[str, int]\n</code></pre> <p>Get the 'quantities_by_good_id' content from the message.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/message/#utility_params_by_good_id","title":"utility<code>_</code>params<code>_</code>by<code>_</code>good<code>_</code>id","text":"<pre><code>@property\ndef utility_params_by_good_id() -&gt; Dict[str, float]\n</code></pre> <p>Get the 'utility_params_by_good_id' content from the message.</p>"},{"location":"aea-framework-documentation/api/protocols/state_update/serialization/","title":"Serialization","text":""},{"location":"aea-framework-documentation/api/protocols/state_update/serialization/#packagesfetchaiprotocolsstate_updateserialization","title":"packages.fetchai.protocols.state<code>_</code>update.serialization","text":"<p>Serialization module for state_update protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/serialization/#stateupdateserializer-objects","title":"StateUpdateSerializer Objects","text":"<pre><code>class StateUpdateSerializer(Serializer)\n</code></pre> <p>Serialization for the 'state_update' protocol.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/serialization/#encode","title":"encode","text":"<pre><code>@staticmethod\ndef encode(msg: Message) -&gt; bytes\n</code></pre> <p>Encode a 'StateUpdate' message into bytes.</p> <p>Arguments:</p> <ul> <li><code>msg</code>: the message object.</li> </ul> <p>Returns:</p> <p>the bytes.</p> <p></p>"},{"location":"aea-framework-documentation/api/protocols/state_update/serialization/#decode","title":"decode","text":"<pre><code>@staticmethod\ndef decode(obj: bytes) -&gt; Message\n</code></pre> <p>Decode bytes into a 'StateUpdate' message.</p> <p>Arguments:</p> <ul> <li><code>obj</code>: the bytes object.</li> </ul> <p>Returns:</p> <p>the 'StateUpdate' message.</p>"},{"location":"aea-framework-documentation/api/registries/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/registries/base/#aearegistriesbase","title":"aea.registries.base","text":"<p>This module contains registries.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#registry-objects","title":"Registry Objects","text":"<pre><code>class Registry(Generic[ItemId, Item], WithLogger, ABC)\n</code></pre> <p>This class implements an abstract registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_name: str = \"standalone\") -&gt; None\n</code></pre> <p>Initialize the registry.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: the name of the agent</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#register","title":"register","text":"<pre><code>@abstractmethod\ndef register(item_id: ItemId,\nitem: Item,\nis_dynamically_added: bool = False) -&gt; None\n</code></pre> <p>Register an item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the public id of the item.</li> <li><code>item</code>: the item.</li> <li><code>is_dynamically_added</code>: whether or not the item is dynamically added.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if an item is already registered with that item id.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister","title":"unregister","text":"<pre><code>@abstractmethod\ndef unregister(item_id: ItemId) -&gt; Optional[Item]\n</code></pre> <p>Unregister an item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the public id of the item.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if no item registered with that item id.</li> </ul> <p>Returns:</p> <p>the item</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch","title":"fetch","text":"<pre><code>@abstractmethod\ndef fetch(item_id: ItemId) -&gt; Optional[Item]\n</code></pre> <p>Fetch an item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the public id of the item.</li> </ul> <p>Returns:</p> <p>the Item</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_all","title":"fetch<code>_</code>all","text":"<pre><code>@abstractmethod\ndef fetch_all() -&gt; List[Item]\n</code></pre> <p>Fetch all the items.</p> <p>Returns:</p> <p>the list of items.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#ids","title":"ids","text":"<pre><code>@abstractmethod\ndef ids() -&gt; Set[ItemId]\n</code></pre> <p>Return the set of all the used item ids.</p> <p>Returns:</p> <p>the set of item ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#setup","title":"setup","text":"<pre><code>@abstractmethod\ndef setup() -&gt; None\n</code></pre> <p>Set up registry.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#teardown","title":"teardown","text":"<pre><code>@abstractmethod\ndef teardown() -&gt; None\n</code></pre> <p>Teardown the registry.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#publicidregistry-objects","title":"PublicIdRegistry Objects","text":"<pre><code>class PublicIdRegistry(Generic[Item], Registry[PublicId, Item])\n</code></pre> <p>This class implement a registry whose keys are public ids.</p> <p>In particular, it is able to handle the case when the public id points to the 'latest' version of a package.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__() -&gt; None\n</code></pre> <p>Initialize the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#register_1","title":"register","text":"<pre><code>def register(public_id: PublicId,\nitem: Item,\nis_dynamically_added: bool = False) -&gt; None\n</code></pre> <p>Register an item.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_1","title":"unregister","text":"<pre><code>def unregister(public_id: PublicId) -&gt; Item\n</code></pre> <p>Unregister an item.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_1","title":"fetch","text":"<pre><code>def fetch(public_id: PublicId) -&gt; Optional[Item]\n</code></pre> <p>Fetch an item associated with a public id.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: the public id.</li> </ul> <p>Returns:</p> <p>an item, or None if the key is not present.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_all_1","title":"fetch<code>_</code>all","text":"<pre><code>def fetch_all() -&gt; List[Item]\n</code></pre> <p>Fetch all the items.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#ids_1","title":"ids","text":"<pre><code>def ids() -&gt; Set[PublicId]\n</code></pre> <p>Get all the item ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#setup_1","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the items.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#teardown_1","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear down the items.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#agentcomponentregistry-objects","title":"AgentComponentRegistry Objects","text":"<pre><code>class AgentComponentRegistry(Registry[ComponentId, Component])\n</code></pre> <p>This class implements a simple dictionary-based registry for agent components.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Instantiate the registry.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: kwargs</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#register_2","title":"register","text":"<pre><code>def register(component_id: ComponentId,\ncomponent: Component,\nis_dynamically_added: bool = False) -&gt; None\n</code></pre> <p>Register a component.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the id of the component.</li> <li><code>component</code>: the component object.</li> <li><code>is_dynamically_added</code>: whether or not the item is dynamically added.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_2","title":"unregister","text":"<pre><code>def unregister(component_id: ComponentId) -&gt; Optional[Component]\n</code></pre> <p>Unregister a component.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the ComponentId</li> </ul> <p>Returns:</p> <p>the item</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_2","title":"fetch","text":"<pre><code>def fetch(component_id: ComponentId) -&gt; Optional[Component]\n</code></pre> <p>Fetch the component by id.</p> <p>Arguments:</p> <ul> <li><code>component_id</code>: the contract id</li> </ul> <p>Returns:</p> <p>the component or None if the component is not registered</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_all_2","title":"fetch<code>_</code>all","text":"<pre><code>def fetch_all() -&gt; List[Component]\n</code></pre> <p>Fetch all the components.</p> <p>Returns:</p> <p>the list of registered components.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_by_type","title":"fetch<code>_</code>by<code>_</code>type","text":"<pre><code>def fetch_by_type(component_type: ComponentType) -&gt; List[Component]\n</code></pre> <p>Fetch all the components by a given type..</p> <p>Arguments:</p> <ul> <li><code>component_type</code>: a component type</li> </ul> <p>Returns:</p> <p>the list of registered components of a given type.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#ids_2","title":"ids","text":"<pre><code>def ids() -&gt; Set[ComponentId]\n</code></pre> <p>Get the item ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#setup_2","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#teardown_2","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Teardown the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#componentregistry-objects","title":"ComponentRegistry Objects","text":"<pre><code>class ComponentRegistry(Registry[Tuple[PublicId, str], SkillComponentType],\nGeneric[SkillComponentType])\n</code></pre> <p>This class implements a generic registry for skill components.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Instantiate the registry.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: kwargs</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#register_3","title":"register","text":"<pre><code>def register(item_id: Tuple[PublicId, str],\nitem: SkillComponentType,\nis_dynamically_added: bool = False) -&gt; None\n</code></pre> <p>Register a item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: a pair (skill id, item name).</li> <li><code>item</code>: the item to register.</li> <li><code>is_dynamically_added</code>: whether or not the item is dynamically added.</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if an item is already registered with that item id.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_3","title":"unregister","text":"<pre><code>def unregister(item_id: Tuple[PublicId, str]) -&gt; Optional[SkillComponentType]\n</code></pre> <p>Unregister a item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: a pair (skill id, item name).</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if no item registered with that item id.</li> </ul> <p>Returns:</p> <p>skill component</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_3","title":"fetch","text":"<pre><code>def fetch(item_id: Tuple[PublicId, str]) -&gt; Optional[SkillComponentType]\n</code></pre> <p>Fetch an item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the public id of the item.</li> </ul> <p>Returns:</p> <p>the Item</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_by_skill","title":"fetch<code>_</code>by<code>_</code>skill","text":"<pre><code>def fetch_by_skill(skill_id: PublicId) -&gt; List[SkillComponentType]\n</code></pre> <p>Fetch all the items of a given skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_all_3","title":"fetch<code>_</code>all","text":"<pre><code>def fetch_all() -&gt; List[SkillComponentType]\n</code></pre> <p>Fetch all the items.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_by_skill","title":"unregister<code>_</code>by<code>_</code>skill","text":"<pre><code>def unregister_by_skill(skill_id: PublicId) -&gt; None\n</code></pre> <p>Unregister all the components by skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#ids_3","title":"ids","text":"<pre><code>def ids() -&gt; Set[Tuple[PublicId, str]]\n</code></pre> <p>Get the item ids.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#setup_3","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the items in the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#teardown_3","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Teardown the registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#handlerregistry-objects","title":"HandlerRegistry Objects","text":"<pre><code>class HandlerRegistry(ComponentRegistry[Handler])\n</code></pre> <p>This class implements the handlers registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Instantiate the registry.</p> <p>Arguments:</p> <ul> <li><code>kwargs</code>: kwargs</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#register_4","title":"register","text":"<pre><code>def register(item_id: Tuple[PublicId, str],\nitem: Handler,\nis_dynamically_added: bool = False) -&gt; None\n</code></pre> <p>Register a handler.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: the item id.</li> <li><code>item</code>: the handler.</li> <li><code>is_dynamically_added</code>: whether or not the item is dynamically added.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_4","title":"unregister","text":"<pre><code>def unregister(item_id: Tuple[PublicId, str]) -&gt; Handler\n</code></pre> <p>Unregister a item.</p> <p>Arguments:</p> <ul> <li><code>item_id</code>: a pair (skill id, item name).</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: ValueError if no item is registered with that item id.</li> </ul> <p>Returns:</p> <p>the unregistered handler</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#unregister_by_skill_1","title":"unregister<code>_</code>by<code>_</code>skill","text":"<pre><code>def unregister_by_skill(skill_id: PublicId) -&gt; None\n</code></pre> <p>Unregister all the components by skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_by_protocol","title":"fetch<code>_</code>by<code>_</code>protocol","text":"<pre><code>def fetch_by_protocol(protocol_id: PublicId) -&gt; List[Handler]\n</code></pre> <p>Fetch the handler by the pair protocol id and skill id.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id</li> </ul> <p>Returns:</p> <p>the handlers registered for the protocol_id and skill_id</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/base/#fetch_by_protocol_and_skill","title":"fetch<code>_</code>by<code>_</code>protocol<code>_</code>and<code>_</code>skill","text":"<pre><code>def fetch_by_protocol_and_skill(protocol_id: PublicId,\nskill_id: PublicId) -&gt; Optional[Handler]\n</code></pre> <p>Fetch the handler by the pair protocol id and skill id.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id</li> <li><code>skill_id</code>: the skill id.</li> </ul> <p>Returns:</p> <p>the handlers registered for the protocol_id and skill_id</p>"},{"location":"aea-framework-documentation/api/registries/filter/","title":"Filter","text":""},{"location":"aea-framework-documentation/api/registries/filter/#aearegistriesfilter","title":"aea.registries.filter","text":"<p>This module contains registries.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#filter-objects","title":"Filter Objects","text":"<pre><code>class Filter(WithLogger)\n</code></pre> <p>This class implements the filter of an AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(resources: Resources,\ndecision_maker_out_queue: AsyncFriendlyQueue) -&gt; None\n</code></pre> <p>Instantiate the filter.</p> <p>Arguments:</p> <ul> <li><code>resources</code>: the resources</li> <li><code>decision_maker_out_queue</code>: the decision maker queue</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#resources","title":"resources","text":"<pre><code>@property\ndef resources() -&gt; Resources\n</code></pre> <p>Get resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#decision_maker_out_queue","title":"decision<code>_</code>maker<code>_</code>out<code>_</code>queue","text":"<pre><code>@property\ndef decision_maker_out_queue() -&gt; AsyncFriendlyQueue\n</code></pre> <p>Get decision maker (out) queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#get_active_handlers","title":"get<code>_</code>active<code>_</code>handlers","text":"<pre><code>def get_active_handlers(protocol_id: PublicId,\nskill_id: Optional[PublicId] = None) -&gt; List[Handler]\n</code></pre> <p>Get active handlers based on protocol id and optional skill id.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id</li> <li><code>skill_id</code>: the skill id</li> </ul> <p>Returns:</p> <p>the list of handlers currently active</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#get_active_behaviours","title":"get<code>_</code>active<code>_</code>behaviours","text":"<pre><code>def get_active_behaviours() -&gt; List[Behaviour]\n</code></pre> <p>Get the active behaviours.</p> <p>Returns:</p> <p>the list of behaviours currently active</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#handle_new_handlers_and_behaviours","title":"handle<code>_</code>new<code>_</code>handlers<code>_</code>and<code>_</code>behaviours","text":"<pre><code>def handle_new_handlers_and_behaviours() -&gt; None\n</code></pre> <p>Handle the messages from the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#get_internal_message","title":"get<code>_</code>internal<code>_</code>message","text":"<pre><code>async def get_internal_message() -&gt; Optional[Message]\n</code></pre> <p>Get a message from decision_maker_out_queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/filter/#handle_internal_message","title":"handle<code>_</code>internal<code>_</code>message","text":"<pre><code>def handle_internal_message(internal_message: Optional[Message]) -&gt; None\n</code></pre> <p>Handle internal message.</p>"},{"location":"aea-framework-documentation/api/registries/resources/","title":"Resources","text":""},{"location":"aea-framework-documentation/api/registries/resources/#aearegistriesresources","title":"aea.registries.resources","text":"<p>This module contains the resources class.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#resources-objects","title":"Resources Objects","text":"<pre><code>class Resources()\n</code></pre> <p>This class implements the object that holds the resources of an AEA.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_name: str = \"standalone\") -&gt; None\n</code></pre> <p>Instantiate the resources.</p> <p>Arguments:</p> <ul> <li><code>agent_name</code>: the name of the agent</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#agent_name","title":"agent<code>_</code>name","text":"<pre><code>@property\ndef agent_name() -&gt; str\n</code></pre> <p>Get the agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#component_registry","title":"component<code>_</code>registry","text":"<pre><code>@property\ndef component_registry() -&gt; AgentComponentRegistry\n</code></pre> <p>Get the agent component registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#behaviour_registry","title":"behaviour<code>_</code>registry","text":"<pre><code>@property\ndef behaviour_registry() -&gt; ComponentRegistry[Behaviour]\n</code></pre> <p>Get the behaviour registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#handler_registry","title":"handler<code>_</code>registry","text":"<pre><code>@property\ndef handler_registry() -&gt; HandlerRegistry\n</code></pre> <p>Get the handler registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#model_registry","title":"model<code>_</code>registry","text":"<pre><code>@property\ndef model_registry() -&gt; ComponentRegistry[Model]\n</code></pre> <p>Get the model registry.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#add_component","title":"add<code>_</code>component","text":"<pre><code>def add_component(component: Component) -&gt; None\n</code></pre> <p>Add a component to resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#add_protocol","title":"add<code>_</code>protocol","text":"<pre><code>def add_protocol(protocol: Protocol) -&gt; None\n</code></pre> <p>Add a protocol to the set of resources.</p> <p>Arguments:</p> <ul> <li><code>protocol</code>: a protocol</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_protocol","title":"get<code>_</code>protocol","text":"<pre><code>def get_protocol(protocol_id: PublicId) -&gt; Optional[Protocol]\n</code></pre> <p>Get protocol for given protocol id.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id</li> </ul> <p>Returns:</p> <p>a matching protocol, if present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_protocol_by_specification_id","title":"get<code>_</code>protocol<code>_</code>by<code>_</code>specification<code>_</code>id","text":"<pre><code>def get_protocol_by_specification_id(\nprotocol_specification_id: PublicId) -&gt; Optional[Protocol]\n</code></pre> <p>Get protocol for given protocol_specification_id.</p> <p>Arguments:</p> <ul> <li><code>protocol_specification_id</code>: the protocol id</li> </ul> <p>Returns:</p> <p>a matching protocol, if present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_protocols","title":"get<code>_</code>all<code>_</code>protocols","text":"<pre><code>def get_all_protocols() -&gt; List[Protocol]\n</code></pre> <p>Get the list of all the protocols.</p> <p>Returns:</p> <p>the list of protocols.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#remove_protocol","title":"remove<code>_</code>protocol","text":"<pre><code>def remove_protocol(protocol_id: PublicId) -&gt; None\n</code></pre> <p>Remove a protocol from the set of resources.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id for the protocol to be removed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#add_contract","title":"add<code>_</code>contract","text":"<pre><code>def add_contract(contract: Contract) -&gt; None\n</code></pre> <p>Add a contract to the set of resources.</p> <p>Arguments:</p> <ul> <li><code>contract</code>: a contract</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_contract","title":"get<code>_</code>contract","text":"<pre><code>def get_contract(contract_id: PublicId) -&gt; Optional[Contract]\n</code></pre> <p>Get contract for given contract id.</p> <p>Arguments:</p> <ul> <li><code>contract_id</code>: the contract id</li> </ul> <p>Returns:</p> <p>a matching contract, if present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_contracts","title":"get<code>_</code>all<code>_</code>contracts","text":"<pre><code>def get_all_contracts() -&gt; List[Contract]\n</code></pre> <p>Get the list of all the contracts.</p> <p>Returns:</p> <p>the list of contracts.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#remove_contract","title":"remove<code>_</code>contract","text":"<pre><code>def remove_contract(contract_id: PublicId) -&gt; None\n</code></pre> <p>Remove a contract from the set of resources.</p> <p>Arguments:</p> <ul> <li><code>contract_id</code>: the contract id for the contract to be removed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#add_connection","title":"add<code>_</code>connection","text":"<pre><code>def add_connection(connection: Connection) -&gt; None\n</code></pre> <p>Add a connection to the set of resources.</p> <p>Arguments:</p> <ul> <li><code>connection</code>: a connection</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_connection","title":"get<code>_</code>connection","text":"<pre><code>def get_connection(connection_id: PublicId) -&gt; Optional[Connection]\n</code></pre> <p>Get connection for given connection id.</p> <p>Arguments:</p> <ul> <li><code>connection_id</code>: the connection id</li> </ul> <p>Returns:</p> <p>a matching connection, if present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_connections","title":"get<code>_</code>all<code>_</code>connections","text":"<pre><code>def get_all_connections() -&gt; List[Connection]\n</code></pre> <p>Get the list of all the connections.</p> <p>Returns:</p> <p>the list of connections.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#remove_connection","title":"remove<code>_</code>connection","text":"<pre><code>def remove_connection(connection_id: PublicId) -&gt; None\n</code></pre> <p>Remove a connection from the set of resources.</p> <p>Arguments:</p> <ul> <li><code>connection_id</code>: the connection id for the connection to be removed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#add_skill","title":"add<code>_</code>skill","text":"<pre><code>def add_skill(skill: Skill) -&gt; None\n</code></pre> <p>Add a skill to the set of resources.</p> <p>Arguments:</p> <ul> <li><code>skill</code>: a skill</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_skill","title":"get<code>_</code>skill","text":"<pre><code>def get_skill(skill_id: PublicId) -&gt; Optional[Skill]\n</code></pre> <p>Get the skill for a given skill id.</p> <p>Arguments:</p> <ul> <li><code>skill_id</code>: the skill id</li> </ul> <p>Returns:</p> <p>a matching skill, if present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_skills","title":"get<code>_</code>all<code>_</code>skills","text":"<pre><code>def get_all_skills() -&gt; List[Skill]\n</code></pre> <p>Get the list of all the skills.</p> <p>Returns:</p> <p>the list of skills.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#remove_skill","title":"remove<code>_</code>skill","text":"<pre><code>def remove_skill(skill_id: PublicId) -&gt; None\n</code></pre> <p>Remove a skill from the set of resources.</p> <p>Arguments:</p> <ul> <li><code>skill_id</code>: the skill id for the skill to be removed.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_handler","title":"get<code>_</code>handler","text":"<pre><code>def get_handler(protocol_id: PublicId,\nskill_id: PublicId) -&gt; Optional[Handler]\n</code></pre> <p>Get a specific handler.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id the handler is handling</li> <li><code>skill_id</code>: the skill id of the handler's skill</li> </ul> <p>Returns:</p> <p>the handler</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_handlers","title":"get<code>_</code>handlers","text":"<pre><code>def get_handlers(protocol_id: PublicId) -&gt; List[Handler]\n</code></pre> <p>Get all handlers for a given protocol.</p> <p>Arguments:</p> <ul> <li><code>protocol_id</code>: the protocol id the handler is handling</li> </ul> <p>Returns:</p> <p>the list of handlers matching the protocol</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_handlers","title":"get<code>_</code>all<code>_</code>handlers","text":"<pre><code>def get_all_handlers() -&gt; List[Handler]\n</code></pre> <p>Get all handlers from all skills.</p> <p>Returns:</p> <p>the list of handlers</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_behaviour","title":"get<code>_</code>behaviour","text":"<pre><code>def get_behaviour(skill_id: PublicId,\nbehaviour_name: str) -&gt; Optional[Behaviour]\n</code></pre> <p>Get a specific behaviours for a given skill.</p> <p>Arguments:</p> <ul> <li><code>skill_id</code>: the skill id</li> <li><code>behaviour_name</code>: the behaviour name</li> </ul> <p>Returns:</p> <p>the behaviour, if it is present, else None</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_behaviours","title":"get<code>_</code>behaviours","text":"<pre><code>def get_behaviours(skill_id: PublicId) -&gt; List[Behaviour]\n</code></pre> <p>Get all behaviours for a given skill.</p> <p>Arguments:</p> <ul> <li><code>skill_id</code>: the skill id</li> </ul> <p>Returns:</p> <p>the list of behaviours of the skill</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#get_all_behaviours","title":"get<code>_</code>all<code>_</code>behaviours","text":"<pre><code>def get_all_behaviours() -&gt; List[Behaviour]\n</code></pre> <p>Get all behaviours from all skills.</p> <p>Returns:</p> <p>the list of all behaviours</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set up the resources.</p> <p>Calls setup on all resources.</p> <p></p>"},{"location":"aea-framework-documentation/api/registries/resources/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Teardown the resources.</p> <p>Calls teardown on all resources.</p>"},{"location":"aea-framework-documentation/api/skills/base/","title":"Base","text":""},{"location":"aea-framework-documentation/api/skills/base/#aeaskillsbase","title":"aea.skills.base","text":"<p>This module contains the base classes for the skills.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skillcontext-objects","title":"SkillContext Objects","text":"<pre><code>class SkillContext()\n</code></pre> <p>This class implements the context of a skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(agent_context: Optional[AgentContext] = None,\nskill: Optional[\"Skill\"] = None) -&gt; None\n</code></pre> <p>Initialize a skill context.</p> <p>Arguments:</p> <ul> <li><code>agent_context</code>: the agent context.</li> <li><code>skill</code>: the skill.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#logger","title":"logger","text":"<pre><code>@property\ndef logger() -&gt; Logger\n</code></pre> <p>Get the logger.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#logger_1","title":"logger","text":"<pre><code>@logger.setter\ndef logger(logger_: Logger) -&gt; None\n</code></pre> <p>Set the logger.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#set_agent_context","title":"set<code>_</code>agent<code>_</code>context","text":"<pre><code>def set_agent_context(agent_context: AgentContext) -&gt; None\n</code></pre> <p>Set the agent context.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#shared_state","title":"shared<code>_</code>state","text":"<pre><code>@property\ndef shared_state() -&gt; Dict[str, Any]\n</code></pre> <p>Get the shared state dictionary.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#agent_name","title":"agent<code>_</code>name","text":"<pre><code>@property\ndef agent_name() -&gt; str\n</code></pre> <p>Get agent name.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skill_id","title":"skill<code>_</code>id","text":"<pre><code>@property\ndef skill_id() -&gt; PublicId\n</code></pre> <p>Get the skill id of the skill context.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#is_active","title":"is<code>_</code>active","text":"<pre><code>@property\ndef is_active() -&gt; bool\n</code></pre> <p>Get the status of the skill (active/not active).</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#is_active_1","title":"is<code>_</code>active","text":"<pre><code>@is_active.setter\ndef is_active(value: bool) -&gt; None\n</code></pre> <p>Set the status of the skill (active/not active).</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#new_behaviours","title":"new<code>_</code>behaviours","text":"<pre><code>@property\ndef new_behaviours() -&gt; \"Queue[Behaviour]\"\n</code></pre> <p>Queue for the new behaviours.</p> <p>This queue can be used to send messages to the framework to request the registration of a behaviour.</p> <p>Returns:</p> <p>the queue of new behaviours.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#new_handlers","title":"new<code>_</code>handlers","text":"<pre><code>@property\ndef new_handlers() -&gt; \"Queue[Handler]\"\n</code></pre> <p>Queue for the new handlers.</p> <p>This queue can be used to send messages to the framework to request the registration of a handler.</p> <p>Returns:</p> <p>the queue of new handlers.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#agent_addresses","title":"agent<code>_</code>addresses","text":"<pre><code>@property\ndef agent_addresses() -&gt; Dict[str, str]\n</code></pre> <p>Get addresses.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#agent_address","title":"agent<code>_</code>address","text":"<pre><code>@property\ndef agent_address() -&gt; str\n</code></pre> <p>Get address.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#public_key","title":"public<code>_</code>key","text":"<pre><code>@property\ndef public_key() -&gt; str\n</code></pre> <p>Get public key.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#public_keys","title":"public<code>_</code>keys","text":"<pre><code>@property\ndef public_keys() -&gt; Dict[str, str]\n</code></pre> <p>Get public keys.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#connection_status","title":"connection<code>_</code>status","text":"<pre><code>@property\ndef connection_status() -&gt; MultiplexerStatus\n</code></pre> <p>Get connection status.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#outbox","title":"outbox","text":"<pre><code>@property\ndef outbox() -&gt; OutBox\n</code></pre> <p>Get outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#storage","title":"storage","text":"<pre><code>@property\ndef storage() -&gt; Optional[Storage]\n</code></pre> <p>Get optional storage for agent.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#message_in_queue","title":"message<code>_</code>in<code>_</code>queue","text":"<pre><code>@property\ndef message_in_queue() -&gt; Queue\n</code></pre> <p>Get message in queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#decision_maker_message_queue","title":"decision<code>_</code>maker<code>_</code>message<code>_</code>queue","text":"<pre><code>@property\ndef decision_maker_message_queue() -&gt; Queue\n</code></pre> <p>Get message queue of decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#decision_maker_handler_context","title":"decision<code>_</code>maker<code>_</code>handler<code>_</code>context","text":"<pre><code>@property\ndef decision_maker_handler_context() -&gt; SimpleNamespace\n</code></pre> <p>Get decision maker handler context.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#task_manager","title":"task<code>_</code>manager","text":"<pre><code>@property\ndef task_manager() -&gt; TaskManager\n</code></pre> <p>Get behaviours of the skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#default_ledger_id","title":"default<code>_</code>ledger<code>_</code>id","text":"<pre><code>@property\ndef default_ledger_id() -&gt; str\n</code></pre> <p>Get the default ledger id.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#currency_denominations","title":"currency<code>_</code>denominations","text":"<pre><code>@property\ndef currency_denominations() -&gt; Dict[str, str]\n</code></pre> <p>Get a dictionary mapping ledger ids to currency denominations.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#search_service_address","title":"search<code>_</code>service<code>_</code>address","text":"<pre><code>@property\ndef search_service_address() -&gt; Address\n</code></pre> <p>Get the address of the search service.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#decision_maker_address","title":"decision<code>_</code>maker<code>_</code>address","text":"<pre><code>@property\ndef decision_maker_address() -&gt; Address\n</code></pre> <p>Get the address of the decision maker.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#handlers","title":"handlers","text":"<pre><code>@property\ndef handlers() -&gt; SimpleNamespace\n</code></pre> <p>Get handlers of the skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#behaviours","title":"behaviours","text":"<pre><code>@property\ndef behaviours() -&gt; SimpleNamespace\n</code></pre> <p>Get behaviours of the skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#namespace","title":"namespace","text":"<pre><code>@property\ndef namespace() -&gt; SimpleNamespace\n</code></pre> <p>Get the agent context namespace.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__getattr__","title":"<code>__</code>getattr<code>__</code>","text":"<pre><code>def __getattr__(item: Any) -&gt; Any\n</code></pre> <p>Get attribute.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#send_to_skill","title":"send<code>_</code>to<code>_</code>skill","text":"<pre><code>def send_to_skill(message_or_envelope: Union[Message, Envelope],\ncontext: Optional[EnvelopeContext] = None) -&gt; None\n</code></pre> <p>Send message or envelope to another skill.</p> <p>If message passed it will be wrapped into envelope with optional envelope context.</p> <p>Arguments:</p> <ul> <li><code>message_or_envelope</code>: envelope to send to another skill.</li> <li><code>context</code>: the optional envelope context</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skillcomponent-objects","title":"SkillComponent Objects","text":"<pre><code>class SkillComponent(ABC)\n</code></pre> <p>This class defines an abstract interface for skill component classes.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(name: str,\nskill_context: SkillContext,\nconfiguration: Optional[SkillComponentConfiguration] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a skill component.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the component.</li> <li><code>configuration</code>: the configuration for the component.</li> <li><code>skill_context</code>: the skill context.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#name","title":"name","text":"<pre><code>@property\ndef name() -&gt; str\n</code></pre> <p>Get the name of the skill component.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#context","title":"context","text":"<pre><code>@property\ndef context() -&gt; SkillContext\n</code></pre> <p>Get the context of the skill component.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skill_id_1","title":"skill<code>_</code>id","text":"<pre><code>@property\ndef skill_id() -&gt; PublicId\n</code></pre> <p>Get the skill id of the skill component.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#configuration","title":"configuration","text":"<pre><code>@property\ndef configuration() -&gt; SkillComponentConfiguration\n</code></pre> <p>Get the skill component configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#config","title":"config","text":"<pre><code>@property\ndef config() -&gt; Dict[Any, Any]\n</code></pre> <p>Get the config of the skill component.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#setup","title":"setup","text":"<pre><code>@abstractmethod\ndef setup() -&gt; None\n</code></pre> <p>Implement the setup.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#teardown","title":"teardown","text":"<pre><code>@abstractmethod\ndef teardown() -&gt; None\n</code></pre> <p>Implement the teardown.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#parse_module","title":"parse<code>_</code>module","text":"<pre><code>@classmethod\n@abstractmethod\ndef parse_module(cls, path: str, configs: Dict[str,\nSkillComponentConfiguration],\nskill_context: SkillContext) -&gt; dict\n</code></pre> <p>Parse the component module.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#abstractbehaviour-objects","title":"AbstractBehaviour Objects","text":"<pre><code>class AbstractBehaviour(SkillComponent, ABC)\n</code></pre> <p>Abstract behaviour for periodical calls.</p> <p>tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#tick_interval","title":"tick<code>_</code>interval","text":"<pre><code>@property\ndef tick_interval() -&gt; float\n</code></pre> <p>Get the tick_interval in seconds.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#start_at","title":"start<code>_</code>at","text":"<pre><code>@property\ndef start_at() -&gt; Optional[datetime.datetime]\n</code></pre> <p>Get the start time of the behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#behaviour-objects","title":"Behaviour Objects","text":"<pre><code>class Behaviour(AbstractBehaviour, ABC)\n</code></pre> <p>This class implements an abstract behaviour.</p> <p>In a subclass of Behaviour, the flag 'is_programmatically_defined'  can be used by the developer to signal to the framework that the class  is meant to be used programmatically; hence, in case the class is  not declared in the configuration file but it is present in a skill  module, the framework will just ignore this class instead of printing  a warning message.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#act","title":"act","text":"<pre><code>@abstractmethod\ndef act() -&gt; None\n</code></pre> <p>Implement the behaviour.</p> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#is_done","title":"is<code>_</code>done","text":"<pre><code>def is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#act_wrapper","title":"act<code>_</code>wrapper","text":"<pre><code>def act_wrapper() -&gt; None\n</code></pre> <p>Wrap the call of the action. This method must be called only by the framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#parse_module_1","title":"parse<code>_</code>module","text":"<pre><code>@classmethod\ndef parse_module(cls, path: str,\nbehaviour_configs: Dict[str, SkillComponentConfiguration],\nskill_context: SkillContext) -&gt; Dict[str, \"Behaviour\"]\n</code></pre> <p>Parse the behaviours module.</p> <p>Arguments:</p> <ul> <li><code>path</code>: path to the Python module containing the Behaviour classes.</li> <li><code>behaviour_configs</code>: a list of behaviour configurations.</li> <li><code>skill_context</code>: the skill context</li> </ul> <p>Returns:</p> <p>a list of Behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#handler-objects","title":"Handler Objects","text":"<pre><code>class Handler(SkillComponent, ABC)\n</code></pre> <p>This class implements an abstract behaviour.</p> <p>In a subclass of Handler, the flag 'is_programmatically_defined'  can be used by the developer to signal to the framework that the component  is meant to be used programmatically; hence, in case the class is  not declared in the configuration file but it is present in a skill  module, the framework will just ignore this class instead of printing  a warning message.</p> <p>SUPPORTED_PROTOCOL is read by the framework when the handlers are loaded  to register them as 'listeners' to the protocol identified by the specified  public id. Whenever a message of protocol 'SUPPORTED_PROTOCOL' is sent  to the agent, the framework will call the 'handle' method.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#handle","title":"handle","text":"<pre><code>@abstractmethod\ndef handle(message: Message) -&gt; None\n</code></pre> <p>Implement the reaction to a message.</p> <p>Arguments:</p> <ul> <li><code>message</code>: the message</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#handle_wrapper","title":"handle<code>_</code>wrapper","text":"<pre><code>def handle_wrapper(message: Message) -&gt; None\n</code></pre> <p>Wrap the call of the handler. This method must be called only by the framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#parse_module_2","title":"parse<code>_</code>module","text":"<pre><code>@classmethod\ndef parse_module(cls, path: str,\nhandler_configs: Dict[str, SkillComponentConfiguration],\nskill_context: SkillContext) -&gt; Dict[str, \"Handler\"]\n</code></pre> <p>Parse the handler module.</p> <p>Arguments:</p> <ul> <li><code>path</code>: path to the Python module containing the Handler class.</li> <li><code>handler_configs</code>: the list of handler configurations.</li> <li><code>skill_context</code>: the skill context</li> </ul> <p>Returns:</p> <p>an handler, or None if the parsing fails.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#model-objects","title":"Model Objects","text":"<pre><code>class Model(SkillComponent, ABC)\n</code></pre> <p>This class implements an abstract model.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(name: str,\nskill_context: SkillContext,\nconfiguration: Optional[SkillComponentConfiguration] = None,\nkeep_terminal_state_dialogues: Optional[bool] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a model.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the component.</li> <li><code>configuration</code>: the configuration for the component.</li> <li><code>skill_context</code>: the skill context.</li> <li><code>keep_terminal_state_dialogues</code>: specify do dialogues in terminal state should stay or not</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#setup_1","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set the class up.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#teardown_1","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear the class down.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#parse_module_3","title":"parse<code>_</code>module","text":"<pre><code>@classmethod\ndef parse_module(cls, path: str,\nmodel_configs: Dict[str, SkillComponentConfiguration],\nskill_context: SkillContext) -&gt; Dict[str, \"Model\"]\n</code></pre> <p>Parse the model module.</p> <p>Arguments:</p> <ul> <li><code>path</code>: path to the Python skill module.</li> <li><code>model_configs</code>: a list of model configurations.</li> <li><code>skill_context</code>: the skill context</li> </ul> <p>Returns:</p> <p>a list of Model.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skill-objects","title":"Skill Objects","text":"<pre><code>class Skill(Component)\n</code></pre> <p>This class implements a skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: SkillConfig,\nskill_context: Optional[SkillContext] = None,\nhandlers: Optional[Dict[str, Handler]] = None,\nbehaviours: Optional[Dict[str, Behaviour]] = None,\nmodels: Optional[Dict[str, Model]] = None,\n**kwargs: Any)\n</code></pre> <p>Initialize a skill.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: the skill configuration.</li> <li><code>skill_context</code>: the skill context.</li> <li><code>handlers</code>: dictionary of handlers.</li> <li><code>behaviours</code>: dictionary of behaviours.</li> <li><code>models</code>: dictionary of models.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#skill_context","title":"skill<code>_</code>context","text":"<pre><code>@property\ndef skill_context() -&gt; SkillContext\n</code></pre> <p>Get the skill context.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#handlers_1","title":"handlers","text":"<pre><code>@property\ndef handlers() -&gt; Dict[str, Handler]\n</code></pre> <p>Get the handlers.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#behaviours_1","title":"behaviours","text":"<pre><code>@property\ndef behaviours() -&gt; Dict[str, Behaviour]\n</code></pre> <p>Get the handlers.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#models","title":"models","text":"<pre><code>@property\ndef models() -&gt; Dict[str, Model]\n</code></pre> <p>Get the handlers.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#from_dir","title":"from<code>_</code>dir","text":"<pre><code>@classmethod\ndef from_dir(cls, directory: str, agent_context: AgentContext,\n**kwargs: Any) -&gt; \"Skill\"\n</code></pre> <p>Load the skill from a directory.</p> <p>Arguments:</p> <ul> <li><code>directory</code>: the directory to the skill package.</li> <li><code>agent_context</code>: the skill context.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the skill object.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#logger_2","title":"logger","text":"<pre><code>@property\ndef logger() -&gt; Logger\n</code></pre> <p>Get the logger.</p> <p>In the case of a skill, return the logger provided by the skill context.</p> <p>Returns:</p> <p>the logger</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#logger_3","title":"logger","text":"<pre><code>@logger.setter\ndef logger(*args: str) -&gt; None\n</code></pre> <p>Set the logger.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#from_config","title":"from<code>_</code>config","text":"<pre><code>@classmethod\ndef from_config(cls, configuration: SkillConfig, agent_context: AgentContext,\n**kwargs: Any) -&gt; \"Skill\"\n</code></pre> <p>Load the skill from configuration.</p> <p>Arguments:</p> <ul> <li><code>configuration</code>: a skill configuration. Must be associated with a directory.</li> <li><code>agent_context</code>: the agent context.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p>Returns:</p> <p>the skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#_skillcomponentloadingitem-objects","title":"<code>_</code>SkillComponentLoadingItem Objects","text":"<pre><code>class _SkillComponentLoadingItem()\n</code></pre> <p>Class to represent a triple (component name, component configuration, component class).</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(name: str, config: SkillComponentConfiguration,\nclass_: Type[SkillComponent], type_: _SKILL_COMPONENT_TYPES)\n</code></pre> <p>Initialize the item.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#_skillcomponentloader-objects","title":"<code>_</code>SkillComponentLoader Objects","text":"<pre><code>class _SkillComponentLoader()\n</code></pre> <p>This class implements the loading policy for skill components.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(configuration: SkillConfig, skill_context: SkillContext,\n**kwargs: Any)\n</code></pre> <p>Initialize the helper class.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/base/#load_skill","title":"load<code>_</code>skill","text":"<pre><code>def load_skill() -&gt; Skill\n</code></pre> <p>Load the skill.</p>"},{"location":"aea-framework-documentation/api/skills/behaviours/","title":"Behaviors","text":""},{"location":"aea-framework-documentation/api/skills/behaviours/#aeaskillsbehaviours","title":"aea.skills.behaviours","text":"<p>This module contains the classes for specific behaviours.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#simplebehaviour-objects","title":"SimpleBehaviour Objects","text":"<pre><code>class SimpleBehaviour(Behaviour, ABC)\n</code></pre> <p>This class implements a simple behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(act: Optional[Callable[[], None]] = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a simple behaviour.</p> <p>Arguments:</p> <ul> <li><code>act</code>: the act callable.</li> <li><code>kwargs</code>: the keyword arguments to be passed to the parent class.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Set the behaviour up.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act","title":"act","text":"<pre><code>def act() -&gt; None\n</code></pre> <p>Do the action.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Tear the behaviour down.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#compositebehaviour-objects","title":"CompositeBehaviour Objects","text":"<pre><code>class CompositeBehaviour(Behaviour, ABC)\n</code></pre> <p>This class implements a composite behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#cyclicbehaviour-objects","title":"CyclicBehaviour Objects","text":"<pre><code>class CyclicBehaviour(SimpleBehaviour, ABC)\n</code></pre> <p>This behaviour is executed until the agent is stopped.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the cyclic behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#number_of_executions","title":"number<code>_</code>of<code>_</code>executions","text":"<pre><code>@property\ndef number_of_executions() -&gt; int\n</code></pre> <p>Get the number of executions.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act_wrapper","title":"act<code>_</code>wrapper","text":"<pre><code>def act_wrapper() -&gt; None\n</code></pre> <p>Wrap the call of the action. This method must be called only by the framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_done","title":"is<code>_</code>done","text":"<pre><code>def is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p>The user should implement it properly to determine the stopping condition.</p> <p>Returns:</p> <p>bool indicating status</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#oneshotbehaviour-objects","title":"OneShotBehaviour Objects","text":"<pre><code>class OneShotBehaviour(SimpleBehaviour, ABC)\n</code></pre> <p>This behaviour is executed only once.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the cyclic behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_done_1","title":"is<code>_</code>done","text":"<pre><code>def is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act_wrapper_1","title":"act<code>_</code>wrapper","text":"<pre><code>def act_wrapper() -&gt; None\n</code></pre> <p>Wrap the call of the action. This method must be called only by the framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#tickerbehaviour-objects","title":"TickerBehaviour Objects","text":"<pre><code>class TickerBehaviour(SimpleBehaviour, ABC)\n</code></pre> <p>This behaviour is executed periodically with an interval.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(tick_interval: float = 1.0,\nstart_at: Optional[datetime.datetime] = None,\n**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the ticker behaviour.</p> <p>Arguments:</p> <ul> <li><code>tick_interval</code>: interval of the behaviour in seconds.</li> <li><code>start_at</code>: whether to start the behaviour with an offset.</li> <li><code>kwargs</code>: the keyword arguments.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#tick_interval","title":"tick<code>_</code>interval","text":"<pre><code>@property\ndef tick_interval() -&gt; float\n</code></pre> <p>Get the tick_interval in seconds.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#start_at","title":"start<code>_</code>at","text":"<pre><code>@property\ndef start_at() -&gt; datetime.datetime\n</code></pre> <p>Get the start time.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#last_act_time","title":"last<code>_</code>act<code>_</code>time","text":"<pre><code>@property\ndef last_act_time() -&gt; datetime.datetime\n</code></pre> <p>Get the last time the act method has been called.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act_wrapper_2","title":"act<code>_</code>wrapper","text":"<pre><code>def act_wrapper() -&gt; None\n</code></pre> <p>Wrap the call of the action. This method must be called only by the framework.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_time_to_act","title":"is<code>_</code>time<code>_</code>to<code>_</code>act","text":"<pre><code>def is_time_to_act() -&gt; bool\n</code></pre> <p>Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint.</p> <p>Returns:</p> <p>True if it is time to act, false otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#sequencebehaviour-objects","title":"SequenceBehaviour Objects","text":"<pre><code>class SequenceBehaviour(CompositeBehaviour, ABC)\n</code></pre> <p>This behaviour executes sub-behaviour serially.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___4","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(behaviour_sequence: List[Behaviour], **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the sequence behaviour.</p> <p>Arguments:</p> <ul> <li><code>behaviour_sequence</code>: the sequence of behaviour.</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#current_behaviour","title":"current<code>_</code>behaviour","text":"<pre><code>@property\ndef current_behaviour() -&gt; Optional[Behaviour]\n</code></pre> <p>Get the current behaviour.</p> <p>If None, the sequence behaviour can be considered done.</p> <p>Returns:</p> <p>current behaviour or None</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act_1","title":"act","text":"<pre><code>def act() -&gt; None\n</code></pre> <p>Implement the behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_done_2","title":"is<code>_</code>done","text":"<pre><code>def is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#state-objects","title":"State Objects","text":"<pre><code>class State(SimpleBehaviour, ABC)\n</code></pre> <p>A state of a FSMBehaviour.</p> <p>A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___5","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a state of the state machine.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#event","title":"event","text":"<pre><code>@property\ndef event() -&gt; Optional[str]\n</code></pre> <p>Get the event to be triggered at the end of the behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_done_3","title":"is<code>_</code>done","text":"<pre><code>@abstractmethod\ndef is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#reset","title":"reset","text":"<pre><code>def reset() -&gt; None\n</code></pre> <p>Reset initial conditions.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#fsmbehaviour-objects","title":"FSMBehaviour Objects","text":"<pre><code>class FSMBehaviour(CompositeBehaviour, ABC)\n</code></pre> <p>This class implements a finite-state machine behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#__init___6","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the finite-state machine behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_started","title":"is<code>_</code>started","text":"<pre><code>@property\ndef is_started() -&gt; bool\n</code></pre> <p>Check if the behaviour is started.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#register_state","title":"register<code>_</code>state","text":"<pre><code>def register_state(name: str, state: State, initial: bool = False) -&gt; None\n</code></pre> <p>Register a state.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the state.</li> <li><code>state</code>: the behaviour in that state.</li> <li><code>initial</code>: whether the state is an initial state.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if a state with the provided name already exists.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#register_final_state","title":"register<code>_</code>final<code>_</code>state","text":"<pre><code>def register_final_state(name: str, state: State) -&gt; None\n</code></pre> <p>Register a final state.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the name of the state.</li> <li><code>state</code>: the state.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if a state with the provided name already exists.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#unregister_state","title":"unregister<code>_</code>state","text":"<pre><code>def unregister_state(name: str) -&gt; None\n</code></pre> <p>Unregister a state.</p> <p>Arguments:</p> <ul> <li><code>name</code>: the state name to unregister.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the state is not registered.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#states","title":"states","text":"<pre><code>@property\ndef states() -&gt; Set[str]\n</code></pre> <p>Get all the state names.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#initial_state","title":"initial<code>_</code>state","text":"<pre><code>@property\ndef initial_state() -&gt; Optional[str]\n</code></pre> <p>Get the initial state name.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#initial_state_1","title":"initial<code>_</code>state","text":"<pre><code>@initial_state.setter\ndef initial_state(name: str) -&gt; None\n</code></pre> <p>Set the initial state.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#final_states","title":"final<code>_</code>states","text":"<pre><code>@property\ndef final_states() -&gt; Set[str]\n</code></pre> <p>Get the final state names.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#get_state","title":"get<code>_</code>state","text":"<pre><code>def get_state(name: str) -&gt; Optional[State]\n</code></pre> <p>Get a state from its name.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#act_2","title":"act","text":"<pre><code>def act() -&gt; None\n</code></pre> <p>Implement the behaviour.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#is_done_4","title":"is<code>_</code>done","text":"<pre><code>def is_done() -&gt; bool\n</code></pre> <p>Return True if the behaviour is terminated, False otherwise.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#register_transition","title":"register<code>_</code>transition","text":"<pre><code>def register_transition(source: str,\ndestination: str,\nevent: Optional[str] = None) -&gt; None\n</code></pre> <p>Register a transition.</p> <p>No sanity check is done.</p> <p>Arguments:</p> <ul> <li><code>source</code>: the source state name.</li> <li><code>destination</code>: the destination state name.</li> <li><code>event</code>: the event.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if a transition from source with event is already present.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/behaviours/#unregister_transition","title":"unregister<code>_</code>transition","text":"<pre><code>def unregister_transition(source: str,\ndestination: str,\nevent: Optional[str] = None) -&gt; None\n</code></pre> <p>Unregister a transition.</p> <p>Arguments:</p> <ul> <li><code>source</code>: the source state name.</li> <li><code>destination</code>: the destination state name.</li> <li><code>event</code>: the event.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if a transition from source with event is not present.</li> </ul>"},{"location":"aea-framework-documentation/api/skills/tasks/","title":"Task","text":""},{"location":"aea-framework-documentation/api/skills/tasks/#aeaskillstasks","title":"aea.skills.tasks","text":"<p>This module contains the classes for tasks.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#task-objects","title":"Task Objects","text":"<pre><code>class Task(WithLogger)\n</code></pre> <p>This class implements an abstract task.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#__init__","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(**kwargs: Any) -&gt; None\n</code></pre> <p>Initialize a task.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#__call__","title":"<code>__</code>call<code>__</code>","text":"<pre><code>def __call__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Execute the task.</p> <p>Arguments:</p> <ul> <li><code>args</code>: positional arguments forwarded to the 'execute' method.</li> <li><code>kwargs</code>: keyword arguments forwarded to the 'execute' method.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the task has already been executed.</li> </ul> <p>Returns:</p> <p>the task instance</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#is_executed","title":"is<code>_</code>executed","text":"<pre><code>@property\ndef is_executed() -&gt; bool\n</code></pre> <p>Check if the task has already been executed.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#result","title":"result","text":"<pre><code>@property\ndef result() -&gt; Any\n</code></pre> <p>Get the result.</p> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the task has not been executed yet.</li> </ul> <p>Returns:</p> <p>the result from the execute method.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#setup","title":"setup","text":"<pre><code>def setup() -&gt; None\n</code></pre> <p>Implement the task setup.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#execute","title":"execute","text":"<pre><code>@abstractmethod\ndef execute(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Run the task logic.</p> <p>Arguments:</p> <ul> <li><code>args</code>: the positional arguments</li> <li><code>kwargs</code>: the keyword arguments</li> </ul> <p>Returns:</p> <p>any</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#teardown","title":"teardown","text":"<pre><code>def teardown() -&gt; None\n</code></pre> <p>Implement the task teardown.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#init_worker","title":"init<code>_</code>worker","text":"<pre><code>def init_worker() -&gt; None\n</code></pre> <p>Initialize a worker.</p> <p>Disable the SIGINT handler of process pool is using. Related to a well-known bug: https://bugs.python.org/issue8296</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#taskmanager-objects","title":"TaskManager Objects","text":"<pre><code>class TaskManager(WithLogger)\n</code></pre> <p>A Task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#__init___1","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(nb_workers: int = DEFAULT_WORKERS_AMOUNT,\nis_lazy_pool_start: bool = True,\nlogger: Optional[logging.Logger] = None,\npool_mode: str = THREAD_POOL_MODE) -&gt; None\n</code></pre> <p>Initialize the task manager.</p> <p>Arguments:</p> <ul> <li><code>nb_workers</code>: the number of worker processes.</li> <li><code>is_lazy_pool_start</code>: option to postpone pool creation till the first enqueue_task called.</li> <li><code>logger</code>: the logger.</li> <li><code>pool_mode</code>: str. multithread or multiprocess</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#is_started","title":"is<code>_</code>started","text":"<pre><code>@property\ndef is_started() -&gt; bool\n</code></pre> <p>Get started status of TaskManager.</p> <p>Returns:</p> <p>bool</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#nb_workers","title":"nb<code>_</code>workers","text":"<pre><code>@property\ndef nb_workers() -&gt; int\n</code></pre> <p>Get the number of workers.</p> <p>Returns:</p> <p>int</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#enqueue_task","title":"enqueue<code>_</code>task","text":"<pre><code>def enqueue_task(func: Callable,\nargs: Sequence = (),\nkwargs: Optional[Dict[str, Any]] = None) -&gt; int\n</code></pre> <p>Enqueue a task with the executor.</p> <p>Arguments:</p> <ul> <li><code>func</code>: the callable instance to be enqueued</li> <li><code>args</code>: the positional arguments to be passed to the function.</li> <li><code>kwargs</code>: the keyword arguments to be passed to the function.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: if the task manager is not running.</li> </ul> <p>Returns:</p> <p>the task id to get the the result.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#get_task_result","title":"get<code>_</code>task<code>_</code>result","text":"<pre><code>def get_task_result(task_id: int) -&gt; AsyncResult\n</code></pre> <p>Get the result from a task.</p> <p>Arguments:</p> <ul> <li><code>task_id</code>: the task id</li> </ul> <p>Returns:</p> <p>async result for task_id</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>Start the task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>Stop the task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#threadedtaskmanager-objects","title":"ThreadedTaskManager Objects","text":"<pre><code>class ThreadedTaskManager(TaskManager)\n</code></pre> <p>A threaded task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#__init___2","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(nb_workers: int = DEFAULT_WORKERS_AMOUNT,\nis_lazy_pool_start: bool = True,\nlogger: Optional[logging.Logger] = None) -&gt; None\n</code></pre> <p>Initialize the task manager.</p> <p>Arguments:</p> <ul> <li><code>nb_workers</code>: the number of worker processes.</li> <li><code>is_lazy_pool_start</code>: option to postpone pool creation till the first enqueue_task called.</li> <li><code>logger</code>: the logger.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#processtaskmanager-objects","title":"ProcessTaskManager Objects","text":"<pre><code>class ProcessTaskManager(TaskManager)\n</code></pre> <p>A multiprocess task manager.</p> <p></p>"},{"location":"aea-framework-documentation/api/skills/tasks/#__init___3","title":"<code>__</code>init<code>__</code>","text":"<pre><code>def __init__(nb_workers: int = DEFAULT_WORKERS_AMOUNT,\nis_lazy_pool_start: bool = True,\nlogger: Optional[logging.Logger] = None) -&gt; None\n</code></pre> <p>Initialize the task manager.</p> <p>Arguments:</p> <ul> <li><code>nb_workers</code>: the number of worker processes.</li> <li><code>is_lazy_pool_start</code>: option to postpone pool creation till the first enqueue_task called.</li> <li><code>logger</code>: the logger.</li> </ul>"},{"location":"aea-framework-documentation/api/test_tools/constants/","title":"Constants","text":""},{"location":"aea-framework-documentation/api/test_tools/constants/#aeatest_toolsconstants","title":"aea.test<code>_</code>tools.constants","text":"<p>This is a module with constants for test tools.</p>"},{"location":"aea-framework-documentation/api/test_tools/exceptions/","title":"Exceptions","text":""},{"location":"aea-framework-documentation/api/test_tools/exceptions/#aeatest_toolsexceptions","title":"aea.test<code>_</code>tools.exceptions","text":"<p>Module with AEA testing exceptions.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/exceptions/#aeatestingexception-objects","title":"AEATestingException Objects","text":"<pre><code>class AEATestingException(Exception)\n</code></pre> <p>An exception to be raised on incorrect testing tools usage.</p>"},{"location":"aea-framework-documentation/api/test_tools/generic/","title":"Generic","text":""},{"location":"aea-framework-documentation/api/test_tools/generic/#aeatest_toolsgeneric","title":"aea.test<code>_</code>tools.generic","text":"<p>This module contains generic tools for AEA end-to-end testing.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/generic/#write_envelope_to_file","title":"write<code>_</code>envelope<code>_</code>to<code>_</code>file","text":"<pre><code>def write_envelope_to_file(envelope: Envelope, file_path: str) -&gt; None\n</code></pre> <p>Write an envelope to a file.</p> <p>Arguments:</p> <ul> <li><code>envelope</code>: Envelope.</li> <li><code>file_path</code>: the file path</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/generic/#read_envelope_from_file","title":"read<code>_</code>envelope<code>_</code>from<code>_</code>file","text":"<pre><code>def read_envelope_from_file(file_path: str) -&gt; Envelope\n</code></pre> <p>Read an envelope from a file.</p> <p>Arguments:</p> <ul> <li><code>file_path</code>: the file path.</li> </ul> <p>Returns:</p> <p>envelope</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/generic/#nested_set_config","title":"nested<code>_</code>set<code>_</code>config","text":"<pre><code>def nested_set_config(dotted_path: str,\nvalue: Any,\nauthor: str = DEFAULT_AUTHOR) -&gt; None\n</code></pre> <p>Set an AEA config with nested values.</p> <p>Run from agent's directory.</p> <p>Allowed dotted_path:     'agent.an_attribute_name'     'protocols.my_protocol.an_attribute_name'     'connections.my_connection.an_attribute_name'     'contracts.my_contract.an_attribute_name'     'skills.my_skill.an_attribute_name'     'vendor.author.[protocols|connections|skills].package_name.attribute_name</p> <p>Arguments:</p> <ul> <li><code>dotted_path</code>: dotted path to a setting.</li> <li><code>value</code>: a value to assign. Must be of yaml serializable type.</li> <li><code>author</code>: the author name, used to parse the dotted path.</li> </ul>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/","title":"Test Cases","text":""},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatest_toolstest_cases","title":"aea.test<code>_</code>tools.test<code>_</code>cases","text":"<p>This module contains test case classes based on pytest for AEA end-to-end testing.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#baseaeatestcase-objects","title":"BaseAEATestCase Objects","text":"<pre><code>class BaseAEATestCase(ABC)\n</code></pre> <p>Base class for AEA test cases.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#set_agent_context","title":"set<code>_</code>agent<code>_</code>context","text":"<pre><code>@classmethod\ndef set_agent_context(cls, agent_name: str) -&gt; None\n</code></pre> <p>Set the current agent context.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#unset_agent_context","title":"unset<code>_</code>agent<code>_</code>context","text":"<pre><code>@classmethod\ndef unset_agent_context(cls) -&gt; None\n</code></pre> <p>Unset the current agent context.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#set_config","title":"set<code>_</code>config","text":"<pre><code>@classmethod\ndef set_config(cls,\ndotted_path: str,\nvalue: Any,\ntype_: Optional[str] = None) -&gt; Result\n</code></pre> <p>Set a config.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>dotted_path</code>: str dotted path to config param.</li> <li><code>value</code>: a new value to set.</li> <li><code>type_</code>: the type</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#nested_set_config","title":"nested<code>_</code>set<code>_</code>config","text":"<pre><code>@classmethod\ndef nested_set_config(cls, dotted_path: str, value: Any) -&gt; None\n</code></pre> <p>Force set config.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#disable_aea_logging","title":"disable<code>_</code>aea<code>_</code>logging","text":"<pre><code>@classmethod\ndef disable_aea_logging(cls) -&gt; None\n</code></pre> <p>Disable AEA logging of specific agent.</p> <p>Run from agent's directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#run_cli_command","title":"run<code>_</code>cli<code>_</code>command","text":"<pre><code>@classmethod\ndef run_cli_command(cls, *args: str, cwd: str = \".\", **kwargs: str) -&gt; Result\n</code></pre> <p>Run AEA CLI command.</p> <p>Arguments:</p> <ul> <li><code>args</code>: CLI args</li> <li><code>cwd</code>: the working directory from where to run the command.</li> <li><code>kwargs</code>: other keyword arguments to click.CliRunner.invoke.</li> </ul> <p>Raises:</p> <ul> <li><code>AEATestingException</code>: if command fails.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#start_subprocess","title":"start<code>_</code>subprocess","text":"<pre><code>@classmethod\ndef start_subprocess(cls, *args: str, cwd: str = \".\") -&gt; subprocess.Popen\n</code></pre> <p>Run python with args as subprocess.</p> <p>Arguments:</p> <ul> <li><code>args</code>: CLI args</li> <li><code>cwd</code>: the current working directory</li> </ul> <p>Returns:</p> <p>subprocess object.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#start_thread","title":"start<code>_</code>thread","text":"<pre><code>@classmethod\ndef start_thread(cls, target: Callable, **kwargs: subprocess.Popen) -&gt; Thread\n</code></pre> <p>Start python Thread.</p> <p>Arguments:</p> <ul> <li><code>target</code>: target method.</li> <li><code>kwargs</code>: thread keyword arguments</li> </ul> <p>Returns:</p> <p>thread</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#create_agents","title":"create<code>_</code>agents","text":"<pre><code>@classmethod\ndef create_agents(cls,\n*agents_names: str,\nis_local: bool = True,\nis_empty: bool = False) -&gt; None\n</code></pre> <p>Create agents in current working directory.</p> <p>Arguments:</p> <ul> <li><code>agents_names</code>: str agent names.</li> <li><code>is_local</code>: a flag for local folder add True by default.</li> <li><code>is_empty</code>: optional boolean flag for skip adding default dependencies.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#fetch_agent","title":"fetch<code>_</code>agent","text":"<pre><code>@classmethod\ndef fetch_agent(cls,\npublic_id: str,\nagent_name: str,\nis_local: bool = True) -&gt; None\n</code></pre> <p>Create agents in current working directory.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: str public id</li> <li><code>agent_name</code>: str agent name.</li> <li><code>is_local</code>: a flag for local folder add True by default.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#difference_to_fetched_agent","title":"difference<code>_</code>to<code>_</code>fetched<code>_</code>agent","text":"<pre><code>@classmethod\ndef difference_to_fetched_agent(cls, public_id: str,\nagent_name: str) -&gt; List[str]\n</code></pre> <p>Compare agent against the one fetched from public id.</p> <p>Arguments:</p> <ul> <li><code>public_id</code>: str public id</li> <li><code>agent_name</code>: str agent name.</li> </ul> <p>Returns:</p> <p>list of files differing in the projects</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#delete_agents","title":"delete<code>_</code>agents","text":"<pre><code>@classmethod\ndef delete_agents(cls, *agents_names: str) -&gt; None\n</code></pre> <p>Delete agents in current working directory.</p> <p>Arguments:</p> <ul> <li><code>agents_names</code>: str agent names.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#run_agent","title":"run<code>_</code>agent","text":"<pre><code>@classmethod\ndef run_agent(cls, *args: str) -&gt; subprocess.Popen\n</code></pre> <p>Run agent as subprocess.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>args</code>: CLI args</li> </ul> <p>Returns:</p> <p>subprocess object.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#run_interaction","title":"run<code>_</code>interaction","text":"<pre><code>@classmethod\ndef run_interaction(cls) -&gt; subprocess.Popen\n</code></pre> <p>Run interaction as subprocess.</p> <p>Run from agent's directory.</p> <p>Returns:</p> <p>subprocess object.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#terminate_agents","title":"terminate<code>_</code>agents","text":"<pre><code>@classmethod\ndef terminate_agents(cls,\n*subprocesses: subprocess.Popen,\ntimeout: int = 20) -&gt; None\n</code></pre> <p>Terminate agent subprocesses.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>subprocesses</code>: the subprocesses running the agents</li> <li><code>timeout</code>: the timeout for interruption</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#is_successfully_terminated","title":"is<code>_</code>successfully<code>_</code>terminated","text":"<pre><code>@classmethod\ndef is_successfully_terminated(cls, *subprocesses: subprocess.Popen) -&gt; bool\n</code></pre> <p>Check if all subprocesses terminated successfully.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#initialize_aea","title":"initialize<code>_</code>aea","text":"<pre><code>@classmethod\ndef initialize_aea(cls, author: str) -&gt; None\n</code></pre> <p>Initialize AEA locally with author name.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#add_item","title":"add<code>_</code>item","text":"<pre><code>@classmethod\ndef add_item(cls,\nitem_type: str,\npublic_id: str,\nlocal: bool = True) -&gt; Result\n</code></pre> <p>Add an item to the agent.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>item_type</code>: str item type.</li> <li><code>public_id</code>: public id of the item.</li> <li><code>local</code>: a flag for local folder add True by default.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#remove_item","title":"remove<code>_</code>item","text":"<pre><code>@classmethod\ndef remove_item(cls, item_type: str, public_id: str) -&gt; Result\n</code></pre> <p>Remove an item from the agent.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>item_type</code>: str item type.</li> <li><code>public_id</code>: public id of the item.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#scaffold_item","title":"scaffold<code>_</code>item","text":"<pre><code>@classmethod\ndef scaffold_item(cls,\nitem_type: str,\nname: str,\nskip_consistency_check: bool = False) -&gt; Result\n</code></pre> <p>Scaffold an item for the agent.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>item_type</code>: str item type.</li> <li><code>name</code>: name of the item.</li> <li><code>skip_consistency_check</code>: if True, skip consistency check.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#fingerprint_item","title":"fingerprint<code>_</code>item","text":"<pre><code>@classmethod\ndef fingerprint_item(cls, item_type: str, public_id: str) -&gt; Result\n</code></pre> <p>Fingerprint an item for the agent.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>item_type</code>: str item type.</li> <li><code>public_id</code>: public id of the item.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#eject_item","title":"eject<code>_</code>item","text":"<pre><code>@classmethod\ndef eject_item(cls, item_type: str, public_id: str) -&gt; Result\n</code></pre> <p>Eject an item in the agent in quiet mode (i.e. no interaction).</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>item_type</code>: str item type.</li> <li><code>public_id</code>: public id of the item.</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#run_install","title":"run<code>_</code>install","text":"<pre><code>@classmethod\ndef run_install(cls) -&gt; Result\n</code></pre> <p>Execute AEA CLI install command.</p> <p>Run from agent's directory.</p> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#generate_private_key","title":"generate<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef generate_private_key(cls,\nledger_api_id: str = DEFAULT_LEDGER,\nprivate_key_file: Optional[str] = None,\npassword: Optional[str] = None) -&gt; Result\n</code></pre> <p>Generate AEA private key with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>private_key_file</code>: the private key file.</li> <li><code>password</code>: the password.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#add_private_key","title":"add<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef add_private_key(cls,\nledger_api_id: str = DEFAULT_LEDGER,\nprivate_key_filepath: str = DEFAULT_PRIVATE_KEY_FILE,\nconnection: bool = False,\npassword: Optional[str] = None) -&gt; Result\n</code></pre> <p>Add private key with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>private_key_filepath</code>: private key filepath.</li> <li><code>connection</code>: whether or not the private key filepath is for a connection.</li> <li><code>password</code>: the password to encrypt private keys.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#remove_private_key","title":"remove<code>_</code>private<code>_</code>key","text":"<pre><code>@classmethod\ndef remove_private_key(cls,\nledger_api_id: str = DEFAULT_LEDGER,\nconnection: bool = False) -&gt; Result\n</code></pre> <p>Remove private key with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>connection</code>: whether or not the private key filepath is for a connection.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#replace_private_key_in_file","title":"replace<code>_</code>private<code>_</code>key<code>_</code>in<code>_</code>file","text":"<pre><code>@classmethod\ndef replace_private_key_in_file(\ncls,\nprivate_key: str,\nprivate_key_filepath: str = DEFAULT_PRIVATE_KEY_FILE) -&gt; None\n</code></pre> <p>Replace the private key in the provided file with the provided key.</p> <p>Arguments:</p> <ul> <li><code>private_key</code>: the private key</li> <li><code>private_key_filepath</code>: the filepath to the private key file</li> </ul> <p>Raises:</p> <ul> <li><code>None</code>: exception if file does not exist</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#generate_wealth","title":"generate<code>_</code>wealth","text":"<pre><code>@classmethod\ndef generate_wealth(cls,\nledger_api_id: str = DEFAULT_LEDGER,\npassword: Optional[str] = None) -&gt; Result\n</code></pre> <p>Generate wealth with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>password</code>: the password.</li> </ul> <p>Returns:</p> <p>Result</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#get_wealth","title":"get<code>_</code>wealth","text":"<pre><code>@classmethod\ndef get_wealth(cls,\nledger_api_id: str = DEFAULT_LEDGER,\npassword: Optional[str] = None) -&gt; str\n</code></pre> <p>Get wealth with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>password</code>: the password to encrypt/decrypt private keys.</li> </ul> <p>Returns:</p> <p>command line output</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#get_address","title":"get<code>_</code>address","text":"<pre><code>@classmethod\ndef get_address(cls,\nledger_api_id: str = DEFAULT_LEDGER,\npassword: Optional[str] = None) -&gt; str\n</code></pre> <p>Get address with CLI command.</p> <p>Run from agent's directory.</p> <p>Arguments:</p> <ul> <li><code>ledger_api_id</code>: ledger API ID.</li> <li><code>password</code>: the password to encrypt/decrypt private keys.</li> </ul> <p>Returns:</p> <p>command line output</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#replace_file_content","title":"replace<code>_</code>file<code>_</code>content","text":"<pre><code>@classmethod\ndef replace_file_content(cls, src: Path, dest: Path) -&gt; None\n</code></pre> <p>Replace the content of the source file to the destination file.</p> <p>Arguments:</p> <ul> <li><code>src</code>: the source file.</li> <li><code>dest</code>: the destination file.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#change_directory","title":"change<code>_</code>directory","text":"<pre><code>@classmethod\ndef change_directory(cls, path: Path) -&gt; None\n</code></pre> <p>Change current working directory.</p> <p>Arguments:</p> <ul> <li><code>path</code>: path to the new working directory.</li> </ul> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#send_envelope_to_agent","title":"send<code>_</code>envelope<code>_</code>to<code>_</code>agent","text":"<pre><code>@classmethod\ndef send_envelope_to_agent(cls, envelope: Envelope, agent: str) -&gt; None\n</code></pre> <p>Send an envelope to an agent, using the stub connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#read_envelope_from_agent","title":"read<code>_</code>envelope<code>_</code>from<code>_</code>agent","text":"<pre><code>@classmethod\ndef read_envelope_from_agent(cls, agent: str) -&gt; Envelope\n</code></pre> <p>Read an envelope from an agent, using the stub connection.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#missing_from_output","title":"missing<code>_</code>from<code>_</code>output","text":"<pre><code>@classmethod\ndef missing_from_output(cls,\nprocess: subprocess.Popen,\nstrings: Sequence[str],\ntimeout: int = DEFAULT_PROCESS_TIMEOUT,\nperiod: int = 1,\nis_terminating: bool = True) -&gt; List[str]\n</code></pre> <p>Check if strings are present in process output.</p> <p>Read process stdout in thread and terminate when all strings are present or timeout expired.</p> <p>Arguments:</p> <ul> <li><code>process</code>: agent subprocess.</li> <li><code>strings</code>: tuple of strings expected to appear in output.</li> <li><code>timeout</code>: int amount of seconds before stopping check.</li> <li><code>period</code>: int period of checking.</li> <li><code>is_terminating</code>: whether or not the agents are terminated</li> </ul> <p>Returns:</p> <p>list of missed strings.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#is_running","title":"is<code>_</code>running","text":"<pre><code>@classmethod\ndef is_running(cls,\nprocess: subprocess.Popen,\ntimeout: int = DEFAULT_LAUNCH_TIMEOUT) -&gt; bool\n</code></pre> <p>Check if the AEA is launched and running (ready to process messages).</p> <p>Arguments:</p> <ul> <li><code>process</code>: agent subprocess.</li> <li><code>timeout</code>: the timeout to wait for launch to complete</li> </ul> <p>Returns:</p> <p>bool indicating status</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#invoke","title":"invoke","text":"<pre><code>@classmethod\ndef invoke(cls, *args: str) -&gt; Result\n</code></pre> <p>Call the cli command.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#load_agent_config","title":"load<code>_</code>agent<code>_</code>config","text":"<pre><code>@classmethod\ndef load_agent_config(cls, agent_name: str) -&gt; AgentConfig\n</code></pre> <p>Load agent configuration.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatestcaseempty-objects","title":"AEATestCaseEmpty Objects","text":"<pre><code>class AEATestCaseEmpty(BaseAEATestCase)\n</code></pre> <p>Test case for a default AEA project.</p> <p>This test case will create a default AEA project.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class_1","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class_1","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatestcaseemptyflaky-objects","title":"AEATestCaseEmptyFlaky Objects","text":"<pre><code>class AEATestCaseEmptyFlaky(AEATestCaseEmpty)\n</code></pre> <p>Test case for a default AEA project.</p> <p>This test case will create a default AEA project.</p> <p>Use for flaky tests with the flaky decorator.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class_2","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class_2","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatestcasemany-objects","title":"AEATestCaseMany Objects","text":"<pre><code>class AEATestCaseMany(BaseAEATestCase)\n</code></pre> <p>Test case for many AEA projects.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class_3","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class_3","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatestcasemanyflaky-objects","title":"AEATestCaseManyFlaky Objects","text":"<pre><code>class AEATestCaseManyFlaky(AEATestCaseMany)\n</code></pre> <p>Test case for many AEA projects which are flaky.</p> <p>Use for flaky tests with the flaky decorator.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class_4","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class_4","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#aeatestcase-objects","title":"AEATestCase Objects","text":"<pre><code>class AEATestCase(BaseAEATestCase)\n</code></pre> <p>Test case from an existing AEA project.</p> <p>Subclass this class and set <code>path_to_aea</code> properly. By default, it is assumed the project is inside the current working directory.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#setup_class_5","title":"setup<code>_</code>class","text":"<pre><code>@classmethod\ndef setup_class(cls) -&gt; None\n</code></pre> <p>Set up the test class.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_cases/#teardown_class_5","title":"teardown<code>_</code>class","text":"<pre><code>@classmethod\ndef teardown_class(cls) -&gt; None\n</code></pre> <p>Teardown the test class.</p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/","title":"Test Contract","text":""},{"location":"aea-framework-documentation/api/test_tools/test_contract/#aeatest_toolstest_contract","title":"aea.test<code>_</code>tools.test<code>_</code>contract","text":"<p>This module contains test case classes based on pytest for AEA contract testing.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#basecontracttestcase-objects","title":"BaseContractTestCase Objects","text":"<pre><code>class BaseContractTestCase(ABC)\n</code></pre> <p>A class to test a contract.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#contract","title":"contract","text":"<pre><code>@property\ndef contract() -&gt; Contract\n</code></pre> <p>Get the contract.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#setup","title":"setup","text":"<pre><code>@classmethod\ndef setup(cls, **kwargs: Any) -&gt; None\n</code></pre> <p>Set up the contract test case.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#finish_contract_deployment","title":"finish<code>_</code>contract<code>_</code>deployment","text":"<pre><code>@classmethod\n@abstractmethod\ndef finish_contract_deployment(cls) -&gt; str\n</code></pre> <p>Finish deploying contract.</p> <p>Returns:</p> <p>contract address</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#refill_from_faucet","title":"refill<code>_</code>from<code>_</code>faucet","text":"<pre><code>@staticmethod\ndef refill_from_faucet(ledger_api: LedgerApi, faucet_api: FaucetApi,\naddress: str) -&gt; None\n</code></pre> <p>Refill from faucet.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#sign_send_confirm_receipt_multisig_transaction","title":"sign<code>_</code>send<code>_</code>confirm<code>_</code>receipt<code>_</code>multisig<code>_</code>transaction","text":"<pre><code>@staticmethod\ndef sign_send_confirm_receipt_multisig_transaction(\ntx: JSONLike,\nledger_api: LedgerApi,\ncryptos: List[Crypto],\nsleep_time: float = 2.0) -&gt; JSONLike\n</code></pre> <p>Sign, send and confirm settlement of a transaction with multiple signatures.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction</li> <li><code>ledger_api</code>: the ledger api</li> <li><code>cryptos</code>: Cryptos to sign transaction with</li> <li><code>sleep_time</code>: the time to sleep between transaction submission and receipt request</li> </ul> <p>Returns:</p> <p>The transaction receipt</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_contract/#sign_send_confirm_receipt_transaction","title":"sign<code>_</code>send<code>_</code>confirm<code>_</code>receipt<code>_</code>transaction","text":"<pre><code>@classmethod\ndef sign_send_confirm_receipt_transaction(cls,\ntx: JSONLike,\nledger_api: LedgerApi,\ncrypto: Crypto,\nsleep_time: float = 2.0) -&gt; JSONLike\n</code></pre> <p>Sign, send and confirm settlement of a transaction with multiple signatures.</p> <p>Arguments:</p> <ul> <li><code>tx</code>: the transaction</li> <li><code>ledger_api</code>: the ledger api</li> <li><code>crypto</code>: Crypto to sign transaction with</li> <li><code>sleep_time</code>: the time to sleep between transaction submission and receipt request</li> </ul> <p>Returns:</p> <p>The transaction receipt</p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/","title":"Test Skill","text":""},{"location":"aea-framework-documentation/api/test_tools/test_skill/#aeatest_toolstest_skill","title":"aea.test<code>_</code>tools.test<code>_</code>skill","text":"<p>This module contains test case classes based on pytest for AEA skill testing.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#baseskilltestcase-objects","title":"BaseSkillTestCase Objects","text":"<pre><code>class BaseSkillTestCase()\n</code></pre> <p>A class to test a skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#skill","title":"skill","text":"<pre><code>@property\ndef skill() -&gt; Skill\n</code></pre> <p>Get the skill.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#get_quantity_in_outbox","title":"get<code>_</code>quantity<code>_</code>in<code>_</code>outbox","text":"<pre><code>def get_quantity_in_outbox() -&gt; int\n</code></pre> <p>Get the quantity of envelopes in the outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#get_message_from_outbox","title":"get<code>_</code>message<code>_</code>from<code>_</code>outbox","text":"<pre><code>def get_message_from_outbox() -&gt; Optional[Message]\n</code></pre> <p>Get message from outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#drop_messages_from_outbox","title":"drop<code>_</code>messages<code>_</code>from<code>_</code>outbox","text":"<pre><code>def drop_messages_from_outbox(number: int = 1) -&gt; None\n</code></pre> <p>Dismiss the first 'number' number of message from outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#get_quantity_in_decision_maker_inbox","title":"get<code>_</code>quantity<code>_</code>in<code>_</code>decision<code>_</code>maker<code>_</code>inbox","text":"<pre><code>def get_quantity_in_decision_maker_inbox() -&gt; int\n</code></pre> <p>Get the quantity of messages in the decision maker inbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#get_message_from_decision_maker_inbox","title":"get<code>_</code>message<code>_</code>from<code>_</code>decision<code>_</code>maker<code>_</code>inbox","text":"<pre><code>def get_message_from_decision_maker_inbox() -&gt; Optional[Message]\n</code></pre> <p>Get message from decision maker inbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#drop_messages_from_decision_maker_inbox","title":"drop<code>_</code>messages<code>_</code>from<code>_</code>decision<code>_</code>maker<code>_</code>inbox","text":"<pre><code>def drop_messages_from_decision_maker_inbox(number: int = 1) -&gt; None\n</code></pre> <p>Dismiss the first 'number' number of message from decision maker inbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#assert_quantity_in_outbox","title":"assert<code>_</code>quantity<code>_</code>in<code>_</code>outbox","text":"<pre><code>def assert_quantity_in_outbox(expected_quantity: int) -&gt; None\n</code></pre> <p>Assert the quantity of messages in the outbox.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#assert_quantity_in_decision_making_queue","title":"assert<code>_</code>quantity<code>_</code>in<code>_</code>decision<code>_</code>making<code>_</code>queue","text":"<pre><code>def assert_quantity_in_decision_making_queue(expected_quantity: int) -&gt; None\n</code></pre> <p>Assert the quantity of messages in the decision maker queue.</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#message_has_attributes","title":"message<code>_</code>has<code>_</code>attributes","text":"<pre><code>@staticmethod\ndef message_has_attributes(actual_message: Message,\nmessage_type: Type[Message],\n**kwargs: Any) -&gt; Tuple[bool, str]\n</code></pre> <p>Evaluates whether a message's attributes match the expected attributes provided.</p> <p>Arguments:</p> <ul> <li><code>actual_message</code>: the actual message</li> <li><code>message_type</code>: the expected message type</li> <li><code>kwargs</code>: other expected message attributes</li> </ul> <p>Returns:</p> <p>boolean result of the evaluation and accompanied message</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#build_incoming_message","title":"build<code>_</code>incoming<code>_</code>message","text":"<pre><code>def build_incoming_message(message_type: Type[Message],\nperformative: Message.Performative,\ndialogue_reference: Optional[Tuple[str,\nstr]] = None,\nmessage_id: Optional[int] = None,\ntarget: Optional[int] = None,\nto: Optional[Address] = None,\nsender: Optional[Address] = None,\nis_agent_to_agent_messages: Optional[bool] = None,\n**kwargs: Any) -&gt; Message\n</code></pre> <p>Quickly create an incoming message with the provided attributes.</p> <p>For any attribute not provided, the corresponding default value in message is used.</p> <p>Arguments:</p> <ul> <li><code>message_type</code>: the type of the message</li> <li><code>dialogue_reference</code>: the dialogue_reference</li> <li><code>message_id</code>: the message_id</li> <li><code>target</code>: the target</li> <li><code>performative</code>: the performative</li> <li><code>to</code>: the 'to' address</li> <li><code>sender</code>: the 'sender' address</li> <li><code>is_agent_to_agent_messages</code>: whether the dialogue is between agents or components</li> <li><code>kwargs</code>: other attributes</li> </ul> <p>Returns:</p> <p>the created incoming message</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#build_incoming_message_for_skill_dialogue","title":"build<code>_</code>incoming<code>_</code>message<code>_</code>for<code>_</code>skill<code>_</code>dialogue","text":"<pre><code>def build_incoming_message_for_skill_dialogue(\ndialogue: Dialogue,\nperformative: Message.Performative,\nmessage_type: Optional[Type[Message]] = None,\ndialogue_reference: Optional[Tuple[str, str]] = None,\nmessage_id: Optional[int] = None,\ntarget: Optional[int] = None,\nto: Optional[Address] = None,\nsender: Optional[Address] = None,\n**kwargs: Any) -&gt; Message\n</code></pre> <p>Quickly create an incoming message with the provided attributes for a dialogue.</p> <p>For any attribute not provided, a value based on the dialogue is used. These values are shown in parentheses in the list of parameters below.</p> <p>NOTE: This method must be used with care. The dialogue provided is part of the skill which is being tested. Because for any unspecified attribute, a \"correct\" value is used, the test will be, by design, insured to pass on these values.</p> <p>Arguments:</p> <ul> <li><code>dialogue</code>: the dialogue to which the incoming message is intended</li> <li><code>performative</code>: the performative of the message</li> <li><code>message_type</code>: (the message_class of the provided dialogue) the type of the message</li> <li><code>dialogue_reference</code>: (the dialogue_reference of the provided dialogue) the dialogue reference of the message</li> <li><code>message_id</code>: (the id of the last message in the provided dialogue + 1) the id of the message</li> <li><code>target</code>: (the id of the last message in the provided dialogue) the target of the message</li> <li><code>to</code>: (the agent address associated with this skill) the receiver of the message</li> <li><code>sender</code>: (the counterparty in the provided dialogue) the sender of the message</li> <li><code>kwargs</code>: other attributes</li> </ul> <p>Returns:</p> <p>the created incoming message</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#prepare_skill_dialogue","title":"prepare<code>_</code>skill<code>_</code>dialogue","text":"<pre><code>def prepare_skill_dialogue(\ndialogues: Dialogues,\nmessages: Tuple[DialogueMessage, ...],\ncounterparty: Optional[Address] = None,\nis_agent_to_agent_messages: Optional[bool] = None) -&gt; Dialogue\n</code></pre> <p>Quickly create a dialogue.</p> <p>The 'messages' argument is a tuple of DialogueMessages. For every DialogueMessage (performative, contents, is_incoming, target):     - if 'is_incoming' is not provided: for the first message it is assumed False (outgoing),     for any other message, it is the opposite of the one preceding it.     - if 'target' is not provided: for the first message it is assumed 0,     for any other message, it is the index of the message before it in the tuple of messages + 1.</p> <p>Arguments:</p> <ul> <li><code>dialogues</code>: a dialogues class</li> <li><code>counterparty</code>: the message_id</li> <li><code>messages</code>: the dialogue_reference</li> <li><code>is_agent_to_agent_messages</code>: whether the dialogue is between agents or components</li> </ul> <p>Returns:</p> <p>the created incoming message</p> <p></p>"},{"location":"aea-framework-documentation/api/test_tools/test_skill/#setup","title":"setup","text":"<pre><code>@classmethod\ndef setup(cls, **kwargs: Any) -&gt; None\n</code></pre> <p>Set up the skill test case.</p>"},{"location":"archives/redelegate-for-decentralization/","title":"How to Redelegate for Decentralization","text":"<p>Introduction</p> <p>Decentralization is a key problem that we as a community need to tackle in order to provide more security to the network.  </p> <p>As part of this, we have requested that everyone currently staking on the Fetch.ai Mainnet check to see if they are only staking with a single validator or if they are staking within the top 10 validators.</p> <p>You can tell if your validator is in the top 10 validators by going to the Validator Voting Power Distribution List.</p> <p>If this is the case, then we would greatly appreciate it if you followed this guide on the importance of redelegating part of your stake outside the top 10 validators and how to do it.</p> <p>Disclaimer - please note the following:</p> <ol> <li>We are asking you to redelegate your staked $FET, do not undelegate your $FET to transfer from one validator to another, otherwise this process will cause you to lose out on staking rewards for 21 days while you wait for the unbonding period to end.</li> <li>Redelegating, unlike undelegating, is an instant way for you to move part (or all) of your delegated $FET to different validators. Doing this is a very easy process and is what we will be outlining in this article.</li> </ol>"},{"location":"archives/redelegate-for-decentralization/#why-redelegating-is-important-right-now","title":"Why redelegating is important right now","text":"<p>The top 10 validators on the Fetch.ai network currently control roughly 50% of the total voting power on chain through delegations.</p> <p>For the Fetch.ai network to be as secure as possible, we shouldn't have more than 33% of delegated FET staked within the top 10 validators. It should be made clear that lists of validators on block explorers are not the highest to lowest for reputation or benefits, it's simply outlining who has the most FET staked to them.</p> <p>When it comes to reputation or how the validator has performed, it's up to you as a delegator to find that out. Delegating is meant to be an active role between you and a Validator (although commonly perceived incorrectly as \"passive income\").</p> <p>When you select a validator to delegate with, that is essentially your vote to the network saying they are trustworthy, and you are given staking rewards for that.</p> <p>So please ensure that you do your due diligence in ensuring you know as much about a validator as possible.</p>"},{"location":"archives/redelegate-for-decentralization/#to-redelegate-using-the-cosmostation-app","title":"To redelegate using the Cosmostation App","text":"<ol> <li>On the main screen, click Delegate.</li> <li>Select the validator you're staking with that you wish to move your stake from.</li> <li>Select Redelegate.</li> <li>Enter the amount of FET you wish to redelegate and click Next.</li> <li>Choose a validator outside of the top 10 that you wish to redelegate to (see here for the voting power of the validators), and click Next.</li> <li>You'll be prompted to enter an optional memo, but you can leave it blank.    Click Next.</li> <li>Choose the transaction fee for redelegating (low is fine). Click Next.</li> <li>Review the details of your redelegation.    Click Confirm.</li> <li>Click Yes on the popup.    Enter your PIN.</li> </ol>"},{"location":"archives/redelegate-for-decentralization/#to-redelegate-using-keystationcosmostation-web-wallet","title":"To redelegate using Keystation/Cosmostation Web Wallet","text":"<ol> <li>Connect your Fetch.ai wallet to the Cosmostation web wallet.</li> <li>Select Reward from the options on the left side panel.</li> <li>Scroll to My Validators and select Redelegate.</li> <li>Pick the validator outside of the top 10 that you would like to Redelegate to.</li> <li>Enter the amount of FET you'd like to redelegate to them.    Leave the memo blank.</li> <li>Click Generate &amp; Sign Transaction.    On the pop-up select Allow.</li> <li>Enter your PIN.</li> </ol>"},{"location":"archives/redelegate-for-decentralization/#to-redelegate-using-the-fetch-wallet","title":"To redelegate using the Fetch Wallet","text":"<p>First you must ensure that you have the Fetch.ai wallet that you're staking with connected to the Fetch Wallet.</p> <ol> <li>Connect to the Fetch Wallet.</li> <li>In the Fetch.ai Validator Explorer page., click Connect in the top right of the web page.    Once you're connected, click on your wallet address that is now listed in the top right on the web page.</li> <li>From there, scroll down to the Delegations section.    Find the validator you'd like to redelegate from.</li> <li> <p>Click Transfer Stake.    In the pop-up that appears, select a validator below the top 10 that you'd like to redelegate to.</p> <p>Please keep in mind they are not in order on the drop-down, so you will need to have the Validator Voting Power Distribution List open in another tab to see the order.</p> </li> <li> <p>Enter in the amount of FET you wish to redelegate to this new validator.</p> </li> <li> <p>Select Transfer Stake.    You will then be prompted by a transaction request.</p> <p>Choose the gas fee (Low is fine)</p> </li> <li> <p>Click Approve.</p> <p>And then you're done.</p> </li> </ol>"},{"location":"archives/redelegate-for-decentralization/#what-should-you-look-for-in-a-validator","title":"What should you look for in a validator?","text":"<p>People always ask what they should be looking for in a validator. So here is a short list of things you, as a delegator, can look for online or ask validators themselves.</p> <ul> <li>Do they have a website?</li> <li>Do they have social media? (Twitter, Reddit, Instagram)</li> <li>Are they easy to contact? (Discord, Telegram)</li> <li>Do they have FET self-bonded to their node?</li> <li>Are they active in the community?</li> <li>Do they have a good uptime?</li> <li>Do they offer slashing &amp; double sign protection?</li> <li>Do they vote on proposals?</li> <li>Do they have a mission and principles that align with your own?</li> </ul> <p>Some of these questions can be answered through one of the Fetch.ai block explorers, such as our Native Block Explorer or Mintscan. But other things on this list will require you to reach out to validators for answers, which is a good opportunity to see if they are active frequently or not. It should also be noted that not every single one of these questions needs to be answered \"yes\" but if they are, then it's extremely helpful.</p>"},{"location":"basics/staking/how_to_stake/","title":"How to Stake","text":"<p>On this page, you can find instructions on how to stake FET, remove your stake, and claim your staking rewards.</p>"},{"location":"basics/staking/how_to_stake/#to-stake","title":"To Stake","text":"<ol> <li>Ensure you are logged into your Fetch wallet.</li> <li> <p>On the wallet dashboard, select Stake. You should be redirected to the ledger browser. Here you will find a list of every active validator with whom you can stake your FETs. You can also see the amount of FET staked to each validator and their commission rates.</p> <p>Info</p> <p>The validators on this page are ordered according to the number of FETs delegated to them and not their reputation or benefits. See choosing a validator for more details.</p> </li> <li> <p>Connect your wallet, if it is not yet connected, by pressing Connect Wallet at the top right.     </p> </li> <li> <p>Choose a validator to stake your FETs with and hit Stake.</p> <p>Tip</p> <p>To see details of any validator, such as their voting power, self-bonded rate, uptime, active/inactive status at any given time, and contact information, head over to this page. For a visualization of the validators' voting power (more is NOT better) check out this page.</p> </li> <li> <p>In the pop-up, select the amount of FETs you want to delegate to this validator and press Stake.</p> <p>Tip</p> <p>Don't forget to leave some FETs undelegated, as some amount is necessary to pay for transaction fees when submitting any transaction to the main network. The fee is very minimal, but it is still important to make sure you have some FETs to pay for it.</p> </li> <li> <p>Your Fetch Wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</p> </li> </ol>"},{"location":"basics/staking/how_to_stake/#to-claim-your-rewards","title":"To Claim your Rewards","text":""},{"location":"basics/staking/how_to_stake/#using-the-fetch-wallet","title":"Using the Fetch Wallet","text":"<ol> <li>Ensure you are logged into your Fetch wallet.</li> <li> <p>From the wallet dashboard select Claim.</p> <p>Info</p> <p>This will claim the total rewards accrued for your stakes across every validator.</p> </li> <li> <p>The wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</p> </li> </ol> <p>You should now see the rewards added to your Total Balance.</p>"},{"location":"basics/staking/how_to_stake/#using-the-staking-dashboard","title":"Using the Staking Dashboard","text":"<ol> <li>Go to the ledger browser page.</li> <li>Connect your wallet, if it is not yet connected, by pressing Connect Wallet at the top right.   </li> <li>Click on your wallet address at the top right of the page to go to your staking dashboard.</li> <li>In the Rewards section, click Claim Rewards for any validator to withdraw the rewards from your stakes with this particular validator.</li> <li>The wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</li> </ol> <p>You should now see the rewards added to your Total Balance.</p> <p>Info</p> <p>Rewards are paid on a per-block basis and added to the existing pending rewards.</p>"},{"location":"basics/staking/how_to_stake/#to-remove-your-stake","title":"To Remove your Stake","text":"<ol> <li>Go to the ledger browser page.</li> <li>Connect your wallet, if it is not yet connected, by pressing Connect Wallet at the top right.   </li> <li>Click on your wallet address at the top right of the page to go to your staking dashboard.</li> <li>In the Delegations section, click Remove Stake for the validator you wish to remove your stakes from.</li> <li>In the pop-up, enter the amount of FETs you wish to remove from your stakes with this validator and click Remove Stake.</li> <li>The wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</li> </ol> <p>Info</p> <p>When you remove your stake, there is an unbonding (also known as, cooldown) period of 21 days. In your staking dashboard, the Unbonding Delegations section shows you the stakes you have removed which are now in the unbonding period. You can also see the amount of FET unbonded and the number of days remaining from the unbonding period. This is how long you need to wait before being able to withdraw the funds to your wallet.</p>"},{"location":"basics/staking/redelegation/","title":"Re-Delegation","text":"<p>Re-delegation means moving some or all of the stakes you delegated with one validator to another.</p> <p>Note</p> <p>To re-delegate, do not manually remove your stake from one validator and stake with another. This will trigger the unbonding period, causing you to miss out on staking rewards for 21 days while you wait for the unbonding period to end. Re-delegation, unlike manually removing and adding stake, is an instant process for moving some or all of your staked FETs from one validator to another.</p>"},{"location":"basics/staking/redelegation/#why-re-delegate","title":"Why Re-Delegate","text":"<p>There may be different reasons why you might choose to re-delegate and redistribute your stakes. Some examples are:</p> <ul> <li>To increase the decentralization and therefore security of the network: For the Fetch network to be as secure as possible, there should not be a large concentration of stakes (e.g. more than 33% of the delegated FETs) staked within only a small number of (e.g. 10) validators. If you see this is currently the case and that you have also contributed to it by delegating your stakes with one of those validators, you may want to consider redistributing your stakes to some of the other validators.</li> <li>To reduce your staking risks: Remember that when you delegate your tokens with a validator, just as you share the rewards for their contribution to the network's consensus protocol, you also share the punishment they would receive if they misbehave and act against the network's protocol. If this happens, your stake with them will be slashed. To reduce this risk, you may choose to re-delegate parts of your stakes to other validators to have a wider stake distribution.</li> </ul>"},{"location":"basics/staking/redelegation/#to-re-delegate-your-stake","title":"To Re-Delegate your Stake","text":"<ol> <li>Go to the ledger browser page.</li> <li>Connect your wallet, if it is not yet connected, by pressing Connect Wallet at the top right.   </li> <li>Click on your wallet address at the top right of the page to go to your staking dashboard.</li> <li>In the Delegations section, click Transfer Stake for the validator you wish to re-delegate some or all of your stakes from.</li> <li> <p>In the pop-up, select a validator that you'd like to re-delegate your stakes to.</p> <p>Info</p> <p>The validators are not in any order on the drop-down list. To see the validators' details see validator voting power distribution and validator details.</p> </li> <li> <p>Enter the amount of FETs you wish to re-delegate to the new validator and click Transfer Stake.</p> </li> <li>The wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</li> </ol>"},{"location":"basics/staking/redelegation/#choosing-a-validator","title":"Choosing a Validator","text":"<p>Choosing a validator to delegate your stake with is an important decision which ultimately impacts the network's security and performance. When you choose a validator, you are essentially casting a vote in the network indicating their trustworthiness, and that it is beneficial to have them participate in the maintenance of the network's operation.</p> <p>When it comes to choosing a validator, it is up to you as the delegator to do your own research and due diligence to find out about their reputation and how well they have performed so far. Delegation is meant to be an active role between you and a validator.</p> <p>To help you choose a suitable validator, here is a list of criteria to look for:</p> <ul> <li>Do they have a website?</li> <li>Do they have an active presence on social media (e.g. Twitter, Reddit, Instagram, ...)?</li> <li>Are they easy to contact (e.g. on Discord, Telegram, ...)?</li> <li>Do they have FET self-bonded to their node?</li> <li>Are they active in the community?</li> <li>Do they have a high uptime?</li> <li>Do they offer slashing &amp; double sign protection?</li> <li>Do they participate and vote on proposals?</li> <li>Do they have a mission or set of principles that align with yours?</li> </ul> <p>Some of these questions can be answered via our Native Block Explorer or Mintscan. Some of the others on this list will require you to reach out to validators for answers, which is a good opportunity to see if they are active or not.</p>"},{"location":"basics/staking/what_is_staking/","title":"What is Staking?","text":"<p>Staking means locking up some of your tokens in order to participate in a blockchain network's operation, increase its security, and earn some passive rewards.</p> <p>Fetch is a public, decentralized blockchain network which uses proof-of-stake (PoS) as its consensus protocol. The operators of PoS-based networks, known as validators, must lock up some tokens in exchange for the right to earn rewards from their work.</p> <p>There are certain conditions for becoming a validator, such as staking a minimum token amount. Users with lower amounts of tokens could still participate by delegating stake to a particular validator to earn a share of the rewards that they receive. Note that the more tokens locked up, the more decision power a validator has and thus the higher the chances of them earning rewards.</p>"},{"location":"basics/staking/what_is_staking/#why-stake","title":"Why Stake?","text":""},{"location":"basics/staking/what_is_staking/#benefits-to-the-user","title":"Benefits to the User","text":"<ul> <li>Earn Rewards: Validators in the Fetch network participate in the maintenance of network's operation and earn rewards for their work. As someone who staked tokens with validators, you are eligible to earn a share of their rewards. Note that your stake could also be slashed in case a validator misbehaves and acts against the network's protocol. Therefore, you must do your own research when choosing validators to stake your tokens with. It is therefore often a good practice to distribute your tokens and stake with multiple validators.</li> <li>Voting Rights: As a stakeholder, you will be eligible to vote on proposals for the future improvement of the network. The more you stake, the greater your influence and voting power.</li> </ul>"},{"location":"basics/staking/what_is_staking/#benefits-to-the-network","title":"Benefits to the Network","text":"<ul> <li>Decentralization and Security: The level of decentralization in any highly secure blockchain network is dependent on the number of validators involved in the consensus or block production. The larger the number of validators and the more distributed the total stakes, the more decentralized or safe the network is. As a result, it's always a good idea to distribute your stakes across several validators, not only to prevent staking risks but also to keep the network decentralized and secure.</li> <li>Network improvements, DAO and decentralized decision-making: Having a DAO (Decentralized Autonomous Organization) make network enhancement decisions is an important aspect of any decentralized network. As a stakeholder, you have the right to vote on proposals that could be crucial for the network's improvement and use-cases in general. The greater the number of stakeholders, the more individuals vote on network upgrade proposals, resulting in highly decentralized decisions.</li> </ul>"},{"location":"basics/wallet/getting_started/","title":"Getting Started","text":"<p>The Fetch Wallet allows you to interact with the Fetch network via your browser.</p>"},{"location":"basics/wallet/getting_started/#compatibility","title":"Compatibility","text":"<p>The Fetch Wallet works on all Chromium-based web browsers, including Chrome, Brave, Edge and Decentr.</p>"},{"location":"basics/wallet/getting_started/#get-the-wallet","title":"Get the Wallet","text":"<p>Install the Fetch wallet from the Chrome web store.</p> <p>Info</p> <p>At this time, you cannot run the Keplr and Fetch wallets together because they interfere. Please disable the Keplr wallet before using the Fetch wallet.</p>"},{"location":"basics/wallet/getting_started/#set-up","title":"Set up","text":"<p>After opening the wallet for the first time, you will see the option to:</p> <ul> <li>Create a new account</li> <li>Import an existing account</li> <li>Connect your ledger hardware wallet</li> </ul>"},{"location":"basics/wallet/getting_started/#to-create-a-new-account","title":"To Create a New Account","text":"<ul> <li>Select <code>Create new account</code></li> <li> <p>Backup your mnemonic seed securely.</p> <p>Warning</p> <p>KEEP IT SAFE! Anyone with your mnemonic seed can access your wallet and take your assets.</p> <p>Danger</p> <p>DON'T LOSE IT! Lost mnemonic seed cannot be recovered! If you lose your mnemonic seed you will lose access to your wallet.</p> </li> <li> <p>Give your account a name and set a password. This password will be used the next time you want to use the wallet or make important changes to your account.</p> </li> <li>Rearrange the mnemonic phrases by clicking on them in the correct order to confirm your mnemonic seed.</li> </ul>"},{"location":"basics/wallet/getting_started/#to-import-an-existing-account","title":"To Import an Existing Account","text":"<p>If you have an account on the Fetch network, for example having had one already on the Fetch wallet and want to access it again, have an account on another wallet (e.g. Cosmostation, Keplr, ...) and wish to bring it to the Fetch wallet, or having created an address using one of our tools (e.g. the AEA framework), you can import it into the Fetch wallet:</p> <ul> <li>Select <code>Import existing account</code></li> <li> <p>Enter your mnemonic seed (set of words) or private key (hexadecimal)</p> <p>Warning</p> <p>KEEP IT SAFE! Anyone with your mnemonic seed or private key can access your wallet and take your assets.</p> </li> <li> <p>Give your account a name and set a password. This password will be used the next time you want to use the wallet or make important changes to your account.</p> </li> </ul>"},{"location":"basics/wallet/getting_started/#to-use-ledger-hardware-wallet","title":"To Use Ledger Hardware Wallet","text":"<p>If you have a Ledger hardware wallet and wish to keep your key and mnemonics on that device while using the Fetch wallet:</p> <p>Info</p> <p>Currently only ledger hardware wallets are supported.</p> <ul> <li>Select <code>Import ledger</code></li> <li>Give your account a name and set a password. This password will be used the next time you want to use the wallet or make important changes to your account.</li> <li>Follow the instructions on the popup to connect your device.</li> </ul> <p>Warning</p> <p>Please ensure you keep your mnemonic seed somewhere safe where others cannot access it. If you lose it, your wallet will be inaccessible once you log out. The password for your account should also be kept safe but is not necessary for recovery if you have your mnemonic seed.</p> <p>Info</p> <p>If you lose your password, you need to uninstall and re-install the Fetch wallet and select <code>Import existing account</code>. Then use the mnemonic seed for your account and choose a new password.</p>"},{"location":"basics/wallet/how_to_use_wallet/","title":"How to Use the Wallet","text":""},{"location":"basics/wallet/how_to_use_wallet/#deposit-tokens","title":"Deposit Tokens","text":"<p>To transfer funds to your account on the Fetch wallet:</p> <p>In the wallet or application you are using to send the funds, use your account's address as the destination account to which the funds must go.</p>"},{"location":"basics/wallet/how_to_use_wallet/#to-copy-your-accounts-address","title":"To Copy Your Account's Address","text":"<ol> <li>Either click on the account address at the top of the dashboard (under the account name): </li> <li>Or select Deposit and scan the QR code.</li> </ol> <p>Once you send the tokens, the balance should be updated.</p> <p>Failure</p> <p>If your origin wallet says that the address (which should start with \"<code>fetch</code>\") is invalid, it is probably expecting an Ethereum address (beginning with \"<code>0x</code>\") and is most likely trying to send ERC20 FET. In this case, you need to use the token bridge to swap your ERC20 FET for native FET.</p> <p>Warning</p> <p>You should not send ERC20 FET to this wallet. If you do, you will lose your tokens. The Fetch wallet can only hold native FET tokens and not ERC20 FET tokens.</p>"},{"location":"basics/wallet/how_to_use_wallet/#send-tokens","title":"Send Tokens","text":"<p>To send tokens from your account:</p> <ol> <li>Select Send.</li> <li> <p>Fill in the details of your transaction:</p> <ul> <li>Recipient: the address you want to send the tokens to</li> <li>Token: the token denomination or type</li> <li>Amount: the number of tokens you want to send with this transaction (you can see your current balance above the Amount)</li> <li>Memo (Optional): some transactions (e.g. to/from some exchanges) require a specific memo. If not needed, you can leave it blank.</li> <li>Fee: the transaction fee. Choose from Low, Average and High</li> </ul> <p>Tip</p> <p>Usually, the lower the transaction fee, the longer you need to wait for your transaction to be settled on the network.</p> </li> <li> <p>Press Send.</p> </li> <li>In the summary screen, review the details and if everything is correct, select Approve.</li> </ol> <p>Tip</p> <p>You can check the status of your transaction via the explorer.</p>"},{"location":"colearn/","title":"Welcome to the Fetch.ai Collective Learning Library","text":"<p>Colearn is a library that enables privacy-preserving decentralized machine learning tasks on the FET network.</p> <p>This blockchain-mediated collective learning system enables multiple stakeholders to build a shared machine learning model without needing to rely on a central authority, and without revealing their dataset to the other stakeholders. This library is currently in development.</p>"},{"location":"colearn/#how-collective-learning-works","title":"How collective learning works","text":"<p>A group of learners comes together, each of whom have their own datasets and want to collaborate on training a machine learning model over a set number of rounds. We refer to this as an 'experiment'. In each round of collective learning:</p> <ol> <li>One learner is selected to train the model and propose a new set of model weights.</li> <li>The other learners vote on whether the weights are an improvement.</li> <li>If the majority vote that the new weights are better than the old ones then the new weights are accepted by all the learners.     Otherwise the new weights are discarded.</li> <li>The next round begins. For more information on the Collective Learning Protocol see here.</li> </ol>"},{"location":"colearn/#current-version","title":"Current Version","text":"<p>We have released v.0.2.8 of the Colearn Machine Learning Interface, the first version of an interface that allows developers to define their own model architectures that can then be used in collective learning. Together with the interface we provide a simple backend for local experiments. This is a prototype backend with upcoming blockchain ledger based backends to follow. Future releases will use similar interfaces so that learners built with the current system will work on a different backend that integrates a distributed ledger and provides other improvements. The current framework will then be used mainly for model development and debugging. We invite all users to experiment with the framework, develop their own models, and provide feedback!</p>"},{"location":"colearn/#getting-started","title":"Getting Started","text":"<p>To use the latest stable release we recommend installing the package from PyPi</p> <p>To install with support for Keras and Pytorch:</p> <pre><code>pip install colearn[all]\n</code></pre> <p>To install with just support for Keras or Pytorch:</p> <pre><code>pip install colearn[keras]\npip install colearn[pytorch]\n</code></pre> <p>For more installation options or get the latest (development) version see Installation</p> <p>Then run the standalone demo:</p> <pre><code>python -m colearn_examples.ml_interface.run_demo\n</code></pre> <p>For plenty of other examples see the Examples.</p>"},{"location":"colearn/#writing-your-own-models","title":"Writing your own models","text":"<p>We encourage users to try out the system by writing their own models. Models need to implement the collective learning interface, which provides functions for training and voting on updates. More instructions can be found in the Getting Started section.</p>"},{"location":"colearn/about/","title":"How collective learning works","text":"<p>A Colearn experiment begins when a group of entities, referred to as  learners, decide on a model architecture and begin learning. Together they will train a single global model. The goal is to train a model that performs better than any of the learners can produce by training on their private data set.</p>"},{"location":"colearn/about/#how-training-works","title":"How Training Works","text":"<p>Training occurs in rounds; during each round the learners attempt to improve the performance of the global shared model. To do so each round an update of the global model (for example new set of weights in a neural network) is proposed. The learners then validate the update and decide if the new model is better than the current global model. If enough learners approve the update then the global model is updated. After an update is approved or rejected a new round begins.</p> <p>The detailed steps of a round updating a global model M are as follows:</p> <ol> <li>One of the learners is selected and proposes a new updated model M'</li> <li>The rest of the learners validate M'</li> <li>If M' has better performance than M against their private data set then the learner votes to approve</li> <li>If not, the learner votes to reject</li> <li>The total votes are tallied</li> <li>If more than some threshold (typically 50%) of learners approve then M' becomes the new global model. If not,      M continues to be the global model</li> <li>A new round begins.</li> </ol> <p>By using a decentralized ledger (a blockchain) this learning process can be run in a completely decentralized, secure and auditable way. Further security can be provided by using differential privacy to avoid exposing your private data set when generating an update.</p>"},{"location":"colearn/about/#learning-algorithms-that-work-for-collective-learning","title":"Learning algorithms that work for collective learning","text":"<p>Collective learning is not just for neural networks; any learning algorithm that can be trained on subsets of the data and which can use the results of previous training rounds as the basis for subsequent rounds can be used. Neural networks fit both these constraints: training can be done on mini-batches of data and each training step uses the weights of the previous training step as its starting point. More generally, any model that is trained using mini-batch stochastic gradient descent is fine. Other algorithms can be made to work with collective learning as well. For example, a random forest can be trained iteratively by having each learner add new trees (see example in mli_random_forest_iris.py). For more discussion, see here.</p>"},{"location":"colearn/about/#the-driver","title":"The driver","text":"<p>The driver implements the voting protocol, so it handles selecting a learner to train, sending the update out for voting, calculating the vote and accepting or declining the update. Here we have a very minimal driver that doesn't use networking or a blockchain. Eventually the driver will be a smart contract. This is the code that implements one round of voting:</p> <pre><code>def run_one_round(round_index: int, learners: Sequence[MachineLearningInterface],\nvote_threshold=0.5):\nproposer = round_index % len(learners)\nnew_weights = learners[proposer].mli_propose_weights()\nprop_weights_list = [ln.mli_test_weights(new_weights) for ln in learners]\napproves = sum(1 if v.vote else 0 for v in prop_weights_list)\nvote = False\nif approves &gt;= len(learners) * vote_threshold:\nvote = True\nfor j, learner in enumerate(learners):\nlearner.mli_accept_weights(prop_weights_list[j])\nreturn prop_weights_list, vote\n</code></pre> <p>The driver has a list of learners, and each round it selects one learner to be the proposer. The proposer does some training and proposes an updated set of weights. The driver then sends the proposed weights to each of the learners, and they each vote on whether this is an improvement. If the number of approving votes is greater than the vote threshold the proposed weights are accepted, and if not they're rejected.</p>"},{"location":"colearn/about/#the-machine-learning-interface","title":"The Machine Learning Interface","text":"<pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport abc\nfrom enum import Enum\nfrom typing import Any, Optional\nimport onnx\nimport onnxmltools\nimport sklearn\nimport tensorflow as tf\nimport torch\nfrom pydantic import BaseModel\nfrom tensorflow import keras\nmodel_classes_keras = (tf.keras.Model, keras.Model, tf.estimator.Estimator)\nmodel_classes_scipy = (torch.nn.Module)\nmodel_classes_sklearn = (sklearn.base.ClassifierMixin)\ndef convert_model_to_onnx(model: Any):\n\"\"\"\n    Helper function to convert a ML model to onnx format\n    \"\"\"\nif isinstance(model, model_classes_keras):\nreturn onnxmltools.convert_keras(model)\nif isinstance(model, model_classes_sklearn):\nreturn onnxmltools.convert_sklearn(model)\nif 'xgboost' in model.__repr__():\nreturn onnxmltools.convert_sklearn(model)\nif isinstance(model, model_classes_scipy):\nraise Exception(\"Pytorch models not yet supported to onnx\")\nelse:\nraise Exception(\"Attempt to convert unsupported model to onnx: {model}\")\nclass DiffPrivBudget(BaseModel):\ntarget_epsilon: float\ntarget_delta: float\nconsumed_epsilon: float\nconsumed_delta: float\nclass ErrorCodes(Enum):\nDP_BUDGET_EXCEEDED = 1\nclass TrainingSummary(BaseModel):\ndp_budget: Optional[DiffPrivBudget]\nerror_code: Optional[ErrorCodes]\nclass Weights(BaseModel):\nweights: Any\ntraining_summary: Optional[TrainingSummary]\nclass DiffPrivConfig(BaseModel):\ntarget_epsilon: float\ntarget_delta: float\nmax_grad_norm: float\nnoise_multiplier: float\nclass ProposedWeights(BaseModel):\nweights: Weights\nvote_score: float\ntest_score: float\nvote: Optional[bool]\nclass ModelFormat(Enum):\nPICKLE_WEIGHTS_ONLY = 1\nONNX = 2\nclass ColearnModel(BaseModel):\nmodel_format: ModelFormat\nmodel_file: Optional[str]\nmodel: Optional[Any]\ndef deser_model(model: Any) -&gt; onnx.ModelProto:\n\"\"\"\n    Helper function to recover a onnx model from its deserialized form\n    \"\"\"\nreturn onnx.load_model_from_string(model)\nclass MachineLearningInterface(abc.ABC):\n@abc.abstractmethod\ndef mli_propose_weights(self) -&gt; Weights:\n\"\"\"\n        Trains the model. Returns new weights. Does not change the current weights of the model.\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\n\"\"\"\n        Tests the proposed weights and fills in the rest of the fields\n        \"\"\"\n@abc.abstractmethod\ndef mli_accept_weights(self, weights: Weights):\n\"\"\"\n        Updates the model with the proposed set of weights\n        :param weights: The new weights\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_get_current_weights(self) -&gt; Weights:\n\"\"\"\n        Returns the current weights of the model\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_get_current_model(self) -&gt; ColearnModel:\n\"\"\"\n        Returns the current model\n        \"\"\"\npass \n</code></pre> <p>There are four methods that need to be implemented:</p> <ol> <li><code>propose_weights</code> causes the model to do some training and then return a    new set of weights that are proposed to the other learners.    This method shouldn't change the current weights of the model - that    only happens when <code>accept_weights</code> is called.</li> <li><code>test_weights</code> - the models takes some new weights and returns a vote on whether the new weights are an improvement.    As with propose_weights, this shouldn't change the current weights of the model -    that only happens when <code>accept_weights</code> is called.</li> <li><code>accept_weights</code> - the models accepts some weights that have been voted on and approved by the set of learners.     The old weights of the model are discarded and replaced by the new weights.</li> <li><code>current_weights</code> should return the current weights of the model.</li> </ol> <p>For more details about directly implementing the machine learning interface see the tutorial here</p>"},{"location":"colearn/demo/","title":"How to run the demo","text":"<p>You can try collective learning for yourself using the simple demo in run_demo. This demo creates n learners for one of six learning tasks and co-ordinates the collective learning between them.</p> <p>There are six potential models for the demo</p> <ul> <li>KERAS_MNIST is the Tensorflow implementation of a small model for the standard handwritten digits recognition dataset</li> <li>KERAS_MNIST_RESNET is the Tensorflow implementation of a Resnet model for the standard handwritten digits recognition dataset</li> <li>KERAS_CIFAR10 is the Tensorflow implementation of the classical image recognition dataset</li> <li>PYTORCH_XRAY is Pytorch implementation of a binary classification task that requires predicting pneumonia from images of chest X-rays.   The data need to be downloaded from Kaggle</li> <li>PYTORCH_COVID_XRAY is Pytorch implementation of a 3 class classification task that requires predicting no finding, covid or pneumonia from images of chest X-rays.   This dataset is not currently publicly available.</li> <li>FRAUD The fraud dataset consists of information about credit card transactions, and the task is to predict whether   transactions are fraudulent or not.   The data need to be downloaded from Kaggle</li> </ul> <p>Use the -h flag to see the options:</p> <pre><code>python -m colearn_examples.ml_interface.run_demo -h\n</code></pre> <p>Arguments to run the demo:</p> <pre><code>--data_dir:       Directory containing training data, not required for MNIST and CIFAR10\n--test_dir:       Optional directory containing test data. A fraction of the training set will be used as a test set when not specified\n--model:          Model to train, options are KERAS_MNIST KERAS_MNIST_RESNET KERAS_CIFAR10 PYTORCH_XRAY PYTORCH_COVID_XRAY FRAUD\n--n_learners:     Number of individual learners\n--n_rounds:       Number of training rounds\n--vote_threshold: Minimum fraction of positive votes to accept the new model\n--train_ratio:    Fraction of training dataset to be used as test-set when no test-set is specified\n--seed:           Seed for initialising model and shuffling datasets\n--learning_rate:  Learning rate for optimiser\n--batch_size:     Size of training batch\n</code></pre>"},{"location":"colearn/demo/#running-mnist","title":"Running MNIST","text":"<p>The simplest task to run is MNIST because the data are downloaded automatically from <code>tensorflow_datasets</code>. The command below runs the MNIST task with five learners for 15 rounds.</p> <pre><code>python -m colearn_examples.ml_interface.run_demo --model KERAS_MNIST --n_learners 5 --n_rounds 15\n</code></pre> <p>You should see a graph of the vote score and the test score (the score used here is categorical accuracy). The new model is accepted if the fraction of positive votes (green colour) is higher than 0.5. The new model is rejected if the fraction of negative votes (red color) is lower than 0.5.</p> <p></p> <p>As you can see, there are five learners, and initially they perform poorly. In round one, learner 0 is selected to propose a new set of weights.</p>"},{"location":"colearn/demo/#other-datasets","title":"Other datasets","text":"<p>To run the CIFAR10 dataset:</p> <pre><code>python -m colearn_examples.ml_interface.run_demo --model KERAS_CIFAR10 --n_learners 5 --n_rounds 15\n</code></pre> <p>The Fraud and X-ray datasets need to be downloaded from kaggle (this requires a kaggle account). To run the fraud dataset:</p> <pre><code>python -m colearn_examples.ml_interface.run_demo --model FRAUD --n_learners 5 --n_rounds 15 --data_dir ./data/fraud\n</code></pre> <p>To run the X-ray dataset:</p> <pre><code>python -m colearn_examples.ml_interface.run_demo --model PYTORCH_XRAY --n_learners 5 --n_rounds 15 --data_dir ./data/xray\n</code></pre>"},{"location":"colearn/dev_notes/","title":"Developer Notes","text":"<p>These are some notes for developers working on the colearn code repo</p>"},{"location":"colearn/dev_notes/#google-cloud-storage","title":"Google Cloud Storage","text":"<p>To have access to the google cloud storage you need to set up your google authentication and have the $GOOGLE_APPLICATION_CREDENTIALS set up correctly. For more details ask or see the contract-learn documentation</p>"},{"location":"colearn/dev_notes/#build-image","title":"Build image","text":"<p>To build ML server image and push to google cloud use the following command:</p> <pre><code>cd docker\npython3 ./build.py --publish --allow_dirty\n# Check this worked correctly\ndocker images\n</code></pre>"},{"location":"colearn/differential_privacy/","title":"What is differential privacy?","text":"<p>To make a machine learning system that protects privacy we first need to have a definition of what privacy is. Differential privacy (DP) is one such definition. First we need to have three concepts: the database is a collection of data about individuals (for example, their medical records), and we want to make a query about that data (for example \"How much does smoking increase someone's risk of cancer?\"). DP says that privacy is preserved if the result of the query cannot be used to determine if any particular individual is present in the database.</p> <p>So if person A has their medical data in a database, and the query that we want to make on that database is \"How much does smoking increase someone's risk of cancer\" then the result of that query shouldn't disclose whether or not person A's details are in the database.</p> <p>From this comes the idea of sensitivity of a query. The sensitivity of a query determines how much the result of the query depends on an individual's data. For example, the query \"How much does smoking increase the risk of cancer for adults in the UK?\" is less sensitive than the query \"How much does smoking increase the risk of cancer for men aged 50-55 in Cambridge?\" because the second query uses a smaller set of individuals.</p>"},{"location":"colearn/differential_privacy/#epsilon-differential-privacy","title":"Epsilon-differential privacy","text":"<p>EDP is a scheme for preserving differential privacy. In EDP all queries have random noise added to them, so they are no longer deterministic. So if the query was \"What fraction of people in the database are male\", and the true result is 0.5 then the results of calling this query three times might be 0.53, 0.49 and 0.51. This makes it harder to tell if an individual's data is in the database, because the effect of adding a person can't be distinguished from the effect of the random noise. Intuitively this is a bit like blurring an image: adding noise obscures personal information. The amount of personal information that is revealed isn't zero, but it is guaranteed to be below a certain threshold.</p> <p>The level of privacy that is provided is controlled by the parameter epsilon; the greater epsilon is the more noise is added and the more privacy is preserved. Queries that are more sensitive have more noise added, because they reveal more information about individuals. It is important to add as little noise as possible, because adding more noise obscures the patterns that you want to extract from the data.</p>"},{"location":"colearn/differential_privacy/#differential-privacy-when-training-neural-networks","title":"Differential privacy when training neural networks","text":"<p>Each training step for a neural network can be though of as a complicated query on a database of training data. Differential privacy mechanisms tell you how much noise you need to add to guarantee a certain level of privacy. The <code>opacus</code> and <code>tensorflow-privacy</code> libraries implement epsilon-differential privacy for training neural networks for pytorch and keras respectively.</p>"},{"location":"colearn/differential_privacy/#how-to-use-differential-privacy-with-colearn","title":"How to use differential privacy with colearn","text":"<p>By using <code>opacus</code> and <code>tensorflow-privacy</code> we can make collective learning use differential privacy. The learner that is proposing weights does so using a DP-enabled optimiser.</p> <p>To see an example of using this see dp_pytorch and dp_keras.</p>"},{"location":"colearn/examples/","title":"Examples that use Collective Learning","text":"<p>This is a list of examples that we've implemented to show you how to use Collective Learning locally. See and example of the gRPC server for the next step towards decentralized Colearn.</p>"},{"location":"colearn/examples/#mnist","title":"Mnist","text":"<p>Uses the standard Mnist database of handwritten images</p> <ul> <li>mnist_keras.   Uses the <code>KerasLearner</code> helper class.   Discussed in more detail here.</li> <li>mnist_pytorch.   Uses the <code>PytorchLearner</code> helper class.   Discussed in more detail here.</li> </ul>"},{"location":"colearn/examples/#fraud","title":"Fraud","text":"<p>The fraud dataset consists of information about credit card transactions.   The task is to predict whether transactions are fraudulent or not.   The data needs to be downloaded from Kaggle,   and the data directory passed in with the flag <code>--data_dir</code>.</p> <ul> <li>fraud_mli.   Uses the <code>MachineLearningInterface</code> directly and detects fraud in bank transactions.</li> <li>fraud_keras.   Loads data from numpy arrays and uses <code>KerasLearner</code>.</li> </ul>"},{"location":"colearn/examples/#cifar10","title":"Cifar10","text":"<p>Uses the standard Cifar10 database of images</p> <ul> <li>cifar_keras.   Uses the <code>KerasLearner</code> helper class.</li> <li>cifar_pytorch.   Uses the <code>PytorchLearner</code> helper class.</li> </ul>"},{"location":"colearn/examples/#xray","title":"Xray","text":"<p>A binary classification task that requires predicting pneumonia from images of chest X-rays.   The data need to be downloaded from Kaggle,   and the data directory passed in with the flag <code>--data_dir</code></p> <ul> <li>xray_keras.   Uses the <code>KerasLearner</code> helper class.</li> <li>xray_pytorch.   Uses the <code>PytorchLearner</code> helper class.</li> </ul>"},{"location":"colearn/examples/#iris","title":"Iris","text":"<p>Uses the standard Iris dataset. The aim of this task is to classify examples into one of three iris species based on measurements of the flower.</p> <ul> <li>iris_random_forest.   Uses the <code>MachineLearningInterface</code> directly and a random forest for classification.</li> </ul>"},{"location":"colearn/grpc_examples/","title":"Mnist gRPC Example","text":"<p>To run the Keras Mnist gRPC example run:</p> <pre><code>python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\\n--data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4\n</code></pre> <p>Note</p> <p>This requires <code>colearn[keras]</code></p> <p>You can verify that the example is working correctly by running the probe:</p> <pre><code>python -m colearn_grpc.scripts.probe_grpc_server --port 9995\n</code></pre> <p>For more about the gRPC components of Colearn see the gRPC Tutorial</p>"},{"location":"colearn/grpc_tutorial/","title":"gRPC tutorial","text":"<p>This tutorial explains how to set up the gRPC learner server. It assumes that you can already run colearn locally, and that you have already defined your own models and dataloaders (if you're going to do so). If you haven't done this then see the tutorials in the Getting Started section.</p>"},{"location":"colearn/grpc_tutorial/#architecture-of-colearn","title":"Architecture of colearn","text":"<p>There are two main parts to a collective learning system: the learner and the backend. The backend controls the learner, and manages the smart contracts and IPFS, and acts as a control hub for all the associated learners. The learner is the part that executes machine learning code. This consists of proposing, evaluating and accepting new weights as detailed in the Machine Learning Interface. The learner and the backend communicate via gRPC; the learner runs a gRPC server, and the backend runs a gRPC client that makes requests of the learner. This separation means that the learner can run on specialised hardware (e.g. a compute server) and does not need to be co-located with the backend.</p>"},{"location":"colearn/grpc_tutorial/#architecture-of-grpc-server","title":"Architecture of gRPC server","text":"<p>The gRPC interface is defined in colearn_grpc/proto/interface.proto. This defines the functions that the gRPC server exposes and the format for messages between the server and the client.</p> <p>As we covered in the earlier tutorials, the machine learning part of colearn is contained inside the <code>MachineLearningInterface</code> (MLI). To recap: the MLI provides methods for proposing, evaluating and accepting weights. If you want to use your own models with colearn then you need to write an object that implements the MLI (for example, an instance of a python class that inherits from <code>MachineLearningInterface</code>). For more about the MLI see the MLI tutorial.</p> <p>The gRPC server has an MLI factory, and it uses its MLI factory to make objects that implement the <code>MachineLearningInterface</code>. The MLI factory needs to implement the MLI factory interface. You could write your own MLI factory, but it's easier to use the one we provide. Below we will discuss the MLI factory interface and then talk about how to use the example factory.</p>"},{"location":"colearn/grpc_tutorial/#mli-factory-interface","title":"MLI Factory interface","text":"<p>The MLI Factory (as the name suggests) is a factory class for creating objects that implement the machine learning interface:</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport abc\nfrom typing import Dict, Set, Any\nimport os.path\nfrom pkg_resources import get_distribution, DistributionNotFound\nfrom colearn.ml_interface import MachineLearningInterface\nclass MliFactory(abc.ABC):\n\"\"\"\n    Interface a class must implement to be used as a factory by the GRPC Server\n    \"\"\"\n_version = \"0.0.0\"\n# https://stackoverflow.com/questions/17583443\ntry:\n_dist = get_distribution('colearn')\n# Normalize case for Windows systems\ndist_loc = os.path.normcase(_dist.location)\nhere = os.path.normcase(__file__)\nif not here.startswith(os.path.join(dist_loc, 'colearn')):\n# not installed, but there is another version that *is*\nraise DistributionNotFound\nexcept DistributionNotFound:\npass\nelse:\n_version = _dist.version\ndef get_version(self) -&gt; str:\n\"\"\"\n        Returns the version of this library....\n        \"\"\"\nreturn self._version\n@abc.abstractmethod\ndef get_models(self) -&gt; Dict[str, Dict[str, Any]]:\n\"\"\"\n        Returns the models this factory produces.\n        The key is the name of the model and the values are their default parameters\n        \"\"\"\npass\n@abc.abstractmethod\ndef get_dataloaders(self) -&gt; Dict[str, Dict[str, Any]]:\n\"\"\"\n        Returns the dataloaders this factory produces.\n        The key is the name of the dataloader and the values are their default parameters\n        \"\"\"\npass\n@abc.abstractmethod\ndef get_compatibilities(self) -&gt; Dict[str, Set[str]]:\n\"\"\"\n        A model is compatible with a dataloader if they can be used together to\n        construct a MachineLearningInterface with the get_MLI function.\n        Returns a dictionary that defines which model is compatible\n        with which dataloader.\n        \"\"\"\npass\n@abc.abstractmethod\ndef get_mli(self,\nmodel_name: str, model_params: str,\ndataloader_name: str, dataset_params: str) -&gt; MachineLearningInterface:\n\"\"\"\n        @param model_name: name of a model, must be in the set return by get_models\n        @param model_params: user defined parameters for the model\n        @param dataloader_name: name of a dataloader to be used:\n            - must be in the set returned by get_dataloaders\n            - must be compatible with model_name as defined by get_compatibilities\n        @param dataset_params: user defined parameters for the dataset\n        @return: Instance of MachineLearningInterface\n        Constructs an object that implements MachineLearningInterface whose\n        underlying model is model_name and dataset is loaded by dataloader_name.\n        \"\"\"\npass \n</code></pre> <p>The MLI Factory stores the constructors for dataloaders and models and also a list of the dataloaders that are compatible with each model. Each constructor is stored under a specific name. For example, \"KERAS_MNIST_MODEL\" is the model for keras mnist. The gRPC server uses the MLI factory to construct MLI objects. The MLI Factory needs to implement four methods:</p> <ul> <li>get_models - returns the names of the models that are registered with the factory and their parameters.</li> <li>get_dataloaders - returns the names of the dataloaders that are registered with the factory and their parameters.</li> <li>get_compatibilities - returns a list of dataloaders for each model that can be used with that model.</li> <li>get_mli - takes the name and parameters for the model and dataloader and constructs the MLI object.   Returns the MLI object.</li> </ul>"},{"location":"colearn/grpc_tutorial/#using-the-example-mli-factory","title":"Using the example MLI Factory","text":"<p>The example MLI factory is defined in colearn_grpc/example_mli_factory.py. It stores the models and dataloaders that it knows about in factoryRegistry.py To add a new model and dataloader to the factory you need to do the following things:</p> <ol> <li>Define a function that loads the dataset given the location of the dataset.</li> <li>Define a function that takes in the dataset and loads the MLI model.</li> <li>Register both these functions with the factory registry.</li> </ol> <p>Registering a dataloader looks like this:</p> <pre><code>@FactoryRegistry.register_dataloader(dataloader_tag)\ndef prepare_data_loaders(location: str,\ntrain_ratio: float = 0.9,\nbatch_size: int = 32) -&gt; Tuple[PrefetchDataset, PrefetchDataset]:\n</code></pre> <p>Registering a model is similar, but you additionally have to specify the dataloaders that this model is compatible with.</p> <pre><code>@FactoryRegistry.register_model_architecture(model_tag, [dataloader_tag])\ndef prepare_learner(data_loaders: Tuple[PrefetchDataset, PrefetchDataset],\nsteps_per_epoch: int = 100,\nvote_batches: int = 10,\nlearning_rate: float = 0.001\n) -&gt; KerasLearner:\n</code></pre> <p>You can see an example of how to do this in colearn_examples/grpc/mnist_grpc.py. The FactoryRegistry decorators get evaluated when the functions are imported, so ensure that the functions are imported before constructing the gRPC server (more on that later).</p> <p>Constraints on the dataloader function:</p> <ol> <li>The first parameter should be a mandatory parameter called \"location\" which stores the location of the dataset.</li> <li>The subsequent parameters should have default arguments.</li> <li>The return type should be specified with a type annotation, and this should be the same type that is expected by the    model functions that use this dataloader.</li> <li>The arguments that you pass to the dataloader function must be    JSON-encodable.    Native python types are fine (e.g. str, dict, list, float).</li> </ol> <p>Constraints on the model function:</p> <ol> <li>The first parameter should be a mandatory parameter called \"data_loaders\".    This must have the same type as the return type of the compatible dataloaders.</li> <li>The subsequent parameters should have default arguments.</li> <li>The return type of model_function should be <code>MachineLearningInterface</code> or a subclass of it (e.g. <code>KerasLearner</code>).</li> <li>The dataloaders listed as being compatible with the model should already be registered with FactoryRegistry before    the model is registered.</li> <li>The arguments that you pass to the model function must be    JSON-encodable.    Native python types are fine (e.g. str, dict, list, float).</li> </ol>"},{"location":"colearn/grpc_tutorial/#making-it-all-work-together","title":"Making it all work together","text":"<p>It can be challenging to ensure that all the parts talk to each other, so we have provided some examples and helper scripts. It is recommended to first make an all-in-one script following the example of colearn_examples/grpc/mnist_grpc.py. Once this is working you can run colearn_grpc/scripts/run_n_servers.py or colearn_grpc/scripts/run_grpc_server.py to run the server(s). The script colearn_grpc/scripts/probe_grpc_server.py will connect to a gRPC server and print the dataloaders and models that are registered on it (pass in the address as a parameter). The client side of the gRPC communication can then be run using colearn_examples/grpc/run_grpc_demo.py. More details are given below.</p> <p>A note about running tensorflow in multiple processes: on a system with a GPU, tensorflow will try to get all the GPU memory when it starts up. This means that running tensorflow in multiple processes on the same machine will fail. To prevent this happening, tensorflow should be told to use only the CPU by setting the environment variable <code>CUDA_VISIBLE_DEVIES</code> to <code>-1</code>. This can be done in a python script (before importing tensorflow) by using:</p> <pre><code>import os\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n</code></pre>"},{"location":"colearn/grpc_tutorial/#testing-locally-with-an-all-in-one-script","title":"Testing locally with an all-in-one script","text":"<p>You can test this locally by following the example in colearn_examples/grpc/mnist_grpc.py. Define your dataloader and model functions as specified above, and register them with the factory. Then create n_learners gRPC servers:</p> <pre><code>n_learners = 5\nfirst_server_port = 9995\n# make n servers\nfor i in range(n_learners):\nport = first_server_port + i\nserver = GRPCServer(mli_factory=ExampleMliFactory(),\nport=port)\nserver_process = Process(target=server.run)\nserver_process.start()\n</code></pre> <p>And then create n_learners gRPC clients:</p> <pre><code>all_learner_models = []\nfor i in range(n_learners):\nport = first_server_port + i\nml_system = ExampleGRPCLearnerClient(f\"client {i}\", f\"127.0.0.1:{port}\")\nml_system.start()\ndataloader_params = {\"location\": data_folders[i]}\nml_system.setup_ml(dataset_loader_name=dataloader_tag,\ndataset_loader_parameters=json.dumps(dataloader_params),\nmodel_arch_name=model_tag,\nmodel_parameters=json.dumps({}))\nall_learner_models.append(ml_system)\n</code></pre> <p><code>ExampleGRPCLearnerClient</code> inherits from the <code>MachineLearningInterface</code> so you can use it with the training functions as before:</p> <pre><code>for round_index in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round_index)\n)\n</code></pre>"},{"location":"colearn/grpc_tutorial/#testing-remotely","title":"Testing remotely","text":"<p>We expect that the gRPC learner part will often be on a compute cluster and be separate from the gRPC client side. To test the gRPC in a setup like this you can start the servers on the computer side and the client part separately. For one gRPC server:</p> <pre><code>python3 ./colearn_grpc/scripts/run_grpc_server.py --port 9995 --metrics_port 9091\n</code></pre> <p>For multiple gRPC servers:</p> <pre><code>python3 ./colearn_grpc/scrips/run_n_grpc_servers.py --n_learners 5 --port 9995 --metrics_port 9091\n</code></pre> <p>The servers by default will start on port 9995 and use subsequent ports from there, so if three servers are required they will run on ports 9995, 9996 and 9997.</p> <p>If you have written your own dataloaders and models then you need to make sure that those functions are defined or imported before the server is created. These are the imports of the default dataloaders and models in <code>colearn_grpc/scripts/run_grpc_server.py</code>:</p> <pre><code># These are imported so that they are registered in the FactoryRegistry\nimport colearn_keras.keras_mnist\nimport colearn_keras.keras_cifar10\nimport colearn_pytorch.pytorch_xray\nimport colearn_pytorch.pytorch_covid_xray\nimport colearn_other.fraud_dataset\n</code></pre> <p>Once the gRPC server(s) are running, set up whatever networking and port forwarding is required. You can check that the gRPC server is accessible by using the probe script:</p> <pre><code>python3 ./colearn_grpc/scripts/probe_grpc_server.py --port 9995\n</code></pre> <p>If the connection is successful this will print a list of the models and datasets registered on the server. These are the defaults that are registered:</p> <pre><code>info: Attempt number 0 to connect to 127.0.0.1:9995\ninfo: Successfully connected to 127.0.0.1:9995!\n{'compatibilities': {'FRAUD': ['FRAUD'],\n                     'KERAS_CIFAR10': ['KERAS_CIFAR10'],\n                     'KERAS_MNIST': ['KERAS_MNIST'],\n                     'KERAS_MNIST_RESNET': ['KERAS_MNIST'],\n                     'PYTORCH_COVID_XRAY': ['PYTORCH_COVID_XRAY'],\n                     'PYTORCH_XRAY': ['PYTORCH_XRAY']},\n 'data_loaders': {'FRAUD': '{\"train_ratio\": 0.8}',\n                  'KERAS_CIFAR10': '{\"train_ratio\": 0.9, \"batch_size\": 32}',\n                  'KERAS_MNIST': '{\"train_ratio\": 0.9, \"batch_size\": 32}',\n                  'PYTORCH_COVID_XRAY': '{\"train_ratio\": 0.8, \"batch_size\": 8, '\n                                        '\"no_cuda\": false}',\n                  'PYTORCH_XRAY': '{\"test_location\": null, \"train_ratio\": 0.96, '\n                                  '\"batch_size\": 8, \"no_cuda\": false}'},\n 'model_architectures': {'FRAUD': '{}',\n                         'KERAS_CIFAR10': '{\"steps_per_epoch\": 100, '\n                                          '\"vote_batches\": 10, '\n                                          '\"learning_rate\": 0.001}',\n                         'KERAS_MNIST': '{\"steps_per_epoch\": 100, '\n                                        '\"vote_batches\": 10, \"learning_rate\": '\n                                        '0.001}',\n                         'KERAS_MNIST_RESNET': '{\"steps_per_epoch\": 100, '\n                                               '\"vote_batches\": 10, '\n                                               '\"learning_rate\": 0.001}',\n                         'PYTORCH_COVID_XRAY': '{\"learning_rate\": 0.001, '\n                                               '\"steps_per_epoch\": 40, '\n                                               '\"vote_batches\": 10, \"no_cuda\": '\n                                               'false, \"vote_on_accuracy\": '\n                                               'true}',\n                         'PYTORCH_XRAY': '{\"learning_rate\": 0.001, '\n                                         '\"steps_per_epoch\": 40, '\n                                         '\"vote_batches\": 10, \"no_cuda\": '\n                                         'false, \"vote_on_accuracy\": true}'}}\n</code></pre> <p>Then run <code>python -m colearn_examples.grpc.run_grpc_demo</code> on the other side to run the usual demo. The script takes as arguments the model name and dataset name that should be run, along with the number of learners and the data location for each learner.</p> <pre><code>python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\\n--data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4\n</code></pre>"},{"location":"colearn/grpc_tutorial/#using-the-mli-factory-interface","title":"Using the MLI Factory interface","text":"<p>An alternative method of using your own dataloaders and models with the gRPC server is to use the MLI Factory interface. This is defined in <code>colearn_grpc/mli_factory_interface.py</code>. An example is given in <code>colearn_examples/grpc/mlifactory_grpc_mnist.py</code>. The MLI Factory is implemented as shown:</p> <pre><code>dataloader_tag = \"KERAS_MNIST_EXAMPLE_DATALOADER\"\nmodel_tag = \"KERAS_MNIST_EXAMPLE_MODEL\"\nclass SimpleFactory(MliFactory):\ndef get_dataloaders(self) -&gt; Dict[str, Dict[str, Any]]:\nreturn {dataloader_tag: dict(train_ratio=0.9,\nbatch_size=32)}\ndef get_models(self) -&gt; Dict[str, Dict[str, Any]]:\nreturn {model_tag: dict(steps_per_epoch=100,\nvote_batches=10,\nlearning_rate=0.001)}\ndef get_compatibilities(self) -&gt; Dict[str, Set[str]]:\nreturn {model_tag: {dataloader_tag}}\ndef get_mli(self, model_name: str, model_params: str, dataloader_name: str,\ndataset_params: str) -&gt; MachineLearningInterface:\ndataloader_params = json.loads(dataset_params)\ndata_loaders = prepare_data_loaders(**dataloader_params)\nmodel_params = json.loads(model_params)\nmli_model = prepare_learner(data_loaders=data_loaders, **model_params)\nreturn mli_model\n</code></pre> <p>An instance of the <code>SimpleFactory</code> class needs to be passed to the gRPC server on creation:</p> <pre><code>n_learners = 5\nfirst_server_port = 9995\n# make n servers\nserver_processes = []\nfor i in range(n_learners):\nport = first_server_port + i\nserver = GRPCServer(mli_factory=SimpleFactory(),\nport=port)\nserver_process = Process(target=server.run)\nprint(\"starting server\", i)\nserver_process.start()\nserver_processes.append(server_process)\n</code></pre> <p>The rest of the example follows the <code>grpc_mnist.py</code> example.</p>"},{"location":"colearn/installation/","title":"Installation","text":"<p>The core package, <code>colearn</code>, contains only the MachineLearningInterface and a simple driver that implements the Collective Learning Protocol. To install only the core package:</p> <pre><code>pip install colearn\n</code></pre> <p>To make collective learning easier to use we have defined extra packages with helpers for model development in Keras and Pytorch.</p> <p>To install with Keras/Pytorch extras:</p> <pre><code>pip install colearn[keras]\npip install colearn[pytorch]\n</code></pre> <p>To install both the Keras and Pytorch extras use:</p> <pre><code>pip install colearn[all]\n</code></pre> <p>To run stand-alone examples:</p> <pre><code> python -m colearn_examples.ml_interface.run_demo\n</code></pre> <p>For more examples see the Examples Page</p>"},{"location":"colearn/installation/#installing-from-source","title":"Installing From Source","text":"<p>Alternatively, to install the latest code from the repo:</p> <ol> <li>Download the source code from github:</li> </ol> <pre><code>git clone https://github.com/fetchai/colearn.git &amp;&amp; cd colearn\n</code></pre> <ol> <li>Create and launch a clean virtual environment with Python 3.7.    (This library has currently only been tested with Python 3.7).</li> </ol> <pre><code>pipenv --python 3.7 &amp;&amp; pipenv shell\n</code></pre> <ol> <li> <p>Install the package from source:</p> <pre><code>pip install -e .[all]\n</code></pre> </li> <li> <p>Run one of the examples:</p> <pre><code>python colearn_examples/ml_interface/pytorch_mnist.py\n</code></pre> </li> </ol> <p>If you are developing the colearn library then install it in editable mode so that new changes are effective immediately:</p> <pre><code>pip install -e .[all]\n</code></pre>"},{"location":"colearn/installation/#running-the-tests","title":"Running the tests","text":"<p>Tests can be run with:</p> <pre><code>tox\n</code></pre>"},{"location":"colearn/installation/#documentation","title":"Documentation","text":"<p>To run the documentation, first install mkdocs and plugins:</p> <pre><code>pip install .[docs] </code></pre> <p>Then run:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"colearn/intro_tutorial_keras/","title":"Using collective learning with keras","text":"<p>This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally.</p> <p>The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning <code>MachineLearningInterface</code> defined in ml_interface.py. For more details on how to use the <code>MachineLearningInterface</code> see here</p> <p>However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the <code>KerasLearner</code>. First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning.</p> <p>A standard script for machine learning with Keras looks like the one below</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport tensorflow as tf\nimport tensorflow_datasets as tfds\nfrom colearn_keras.utils import normalize_img\nn_rounds = 20\nwidth = 28\nheight = 28\nn_classes = 10\nl_rate = 0.001\nbatch_size = 64\n# Load the data\ntrain_dataset, info = tfds.load('mnist', split='train', as_supervised=True, with_info=True)\nn_train = info.splits['train'].num_examples\ntest_dataset = tfds.load('mnist', split='test', as_supervised=True)\ntrain_dataset = train_dataset.map(normalize_img,\nnum_parallel_calls=tf.data.experimental.AUTOTUNE)\ntrain_dataset = train_dataset.shuffle(n_train)\ntrain_dataset = train_dataset.batch(batch_size)\ntest_dataset = test_dataset.map(normalize_img,\nnum_parallel_calls=tf.data.experimental.AUTOTUNE)\ntest_dataset = test_dataset.batch(batch_size)\n# Define the model\ninput_img = tf.keras.Input(shape=(width, height, 1), name=\"Input\")\nx = tf.keras.layers.Conv2D(64, (3, 3), activation=\"relu\", padding=\"same\", name=\"Conv1_1\")(input_img)\nx = tf.keras.layers.BatchNormalization(name=\"bn1\")(x)\nx = tf.keras.layers.MaxPooling2D((2, 2), name=\"pool1\")(x)\nx = tf.keras.layers.Conv2D(128, (3, 3), activation=\"relu\", padding=\"same\", name=\"Conv2_1\")(x)\nx = tf.keras.layers.BatchNormalization(name=\"bn4\")(x)\nx = tf.keras.layers.MaxPooling2D((2, 2), name=\"pool2\")(x)\nx = tf.keras.layers.Flatten(name=\"flatten\")(x)\nx = tf.keras.layers.Dense(n_classes, activation=\"softmax\", name=\"fc1\")(x)\nmodel = tf.keras.Model(inputs=input_img, outputs=x)\nopt = tf.keras.optimizers.Adam(lr=l_rate)\nmodel.compile(\nloss=\"sparse_categorical_crossentropy\",\nmetrics=[tf.keras.metrics.SparseCategoricalAccuracy()],\noptimizer=opt)\n# Train and evaluate model\nfor round in range(n_rounds):\nmodel.fit(train_dataset, steps_per_epoch=40)\nresult = model.evaluate(x=test_dataset, return_dict=True, steps=10)\nprint(f\"Performance at round {round} is {result}\")\n</code></pre> <p>There are three steps:</p> <ol> <li>Load the data</li> <li>Define the model</li> <li>Train the model</li> </ol> <p>In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this:</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport os\nimport tensorflow as tf\nimport tensorflow_datasets as tfds\nfrom colearn.training import initial_result, collective_learning_round, set_equal_weights\nfrom colearn.utils.plot import ColearnPlot\nfrom colearn.utils.results import Results, print_results\nfrom colearn_keras.keras_learner import KerasLearner\nfrom colearn_keras.utils import normalize_img\n\"\"\"\nMNIST training example using Keras\nUsed dataset:\n- MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes\nWhat script does:\n- Loads MNIST dataset from Keras\n- Sets up a Keras learner\n- Randomly splits dataset between multiple learners\n- Does multiple rounds of learning process and displays plot with results\n\"\"\"\nn_learners = 5\nvote_threshold = 0.5\nvote_batches = 2\ntesting_mode = bool(os.getenv(\"COLEARN_EXAMPLES_TEST\", \"\"))  # for testing\nn_rounds = 20 if not testing_mode else 1\nwidth = 28\nheight = 28\nn_classes = 10\nl_rate = 0.001\nbatch_size = 64\n# Load data for each learner\ntrain_dataset, info = tfds.load('mnist', split='train', as_supervised=True, with_info=True)\nn_datapoints = info.splits['train'].num_examples\ntrain_datasets = [train_dataset.shard(num_shards=n_learners, index=i) for i in range(n_learners)]\ntest_dataset = tfds.load('mnist', split='test', as_supervised=True)\nvote_datasets = [test_dataset.shard(num_shards=2 * n_learners, index=i) for i in range(n_learners)]\ntest_datasets = [test_dataset.shard(num_shards=2 * n_learners, index=i) for i in range(n_learners, 2 * n_learners)]\nfor i in range(n_learners):\ntrain_datasets[i] = train_datasets[i].map(\nnormalize_img, num_parallel_calls=tf.data.experimental.AUTOTUNE)\ntrain_datasets[i] = train_datasets[i].shuffle(n_datapoints // n_learners)\ntrain_datasets[i] = train_datasets[i].batch(batch_size)\nvote_datasets[i] = vote_datasets[i].map(\nnormalize_img, num_parallel_calls=tf.data.experimental.AUTOTUNE)\nvote_datasets[i] = vote_datasets[i].batch(batch_size)\ntest_datasets[i] = test_datasets[i].map(\nnormalize_img, num_parallel_calls=tf.data.experimental.AUTOTUNE)\ntest_datasets[i] = test_datasets[i].batch(batch_size)\n# Define model\ndef get_model():\ninput_img = tf.keras.Input(\nshape=(width, height, 1), name=\"Input\"\n)\nx = tf.keras.layers.Conv2D(\n64, (3, 3), activation=\"relu\", padding=\"same\", name=\"Conv1_1\"\n)(input_img)\nx = tf.keras.layers.BatchNormalization(name=\"bn1\")(x)\nx = tf.keras.layers.MaxPooling2D((2, 2), name=\"pool1\")(x)\nx = tf.keras.layers.Conv2D(\n128, (3, 3), activation=\"relu\", padding=\"same\", name=\"Conv2_1\"\n)(x)\nx = tf.keras.layers.BatchNormalization(name=\"bn4\")(x)\nx = tf.keras.layers.MaxPooling2D((2, 2), name=\"pool2\")(x)\nx = tf.keras.layers.Flatten(name=\"flatten\")(x)\nx = tf.keras.layers.Dense(\nn_classes, activation=\"softmax\", name=\"fc1\"\n)(x)\nmodel = tf.keras.Model(inputs=input_img, outputs=x)\nopt = tf.keras.optimizers.Adam(lr=l_rate)\nmodel.compile(\nloss=\"sparse_categorical_crossentropy\",\nmetrics=[tf.keras.metrics.SparseCategoricalAccuracy()],\noptimizer=opt)\nreturn model\nall_learner_models = []\nfor i in range(n_learners):\nall_learner_models.append(KerasLearner(\nmodel=get_model(),\ntrain_loader=train_datasets[i],\nvote_loader=vote_datasets[i],\ntest_loader=test_datasets[i],\ncriterion=\"sparse_categorical_accuracy\",\nminimise_criterion=False,\nmodel_evaluate_kwargs={\"steps\": vote_batches},\n))\nset_equal_weights(all_learner_models)\n# Train the model using Collective Learning\nresults = Results()\nresults.data.append(initial_result(all_learner_models))\nplot = ColearnPlot(score_name=all_learner_models[0].criterion)\nfor round_index in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round_index)\n)\nprint_results(results)\nplot.plot_results_and_votes(results)\nplot.block()\nprint(\"Colearn Example Finished!\")\n</code></pre> <p>The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with keras:</p> <pre><code>train_datasets = [train_dataset.shard(num_shards=n_learners, index=i) for i in range(n_learners)]\n</code></pre> <p>The model definition is very similar too, except that each learner will need its own copy of the model, so we've moved it into a function.</p> <p>To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the <code>MachineLearningInterface</code> with keras, we've defined <code>KerasLearner</code>. <code>KerasLearner</code> implements standard training and evaluation routines as well as the MachineLearningInterface methods.</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nfrom inspect import signature\nfrom typing import Optional\ntry:\nimport tensorflow as tf\nexcept ImportError:\nraise Exception(\"Tensorflow is not installed. To use the tensorflow/keras \"\n\"add-ons please install colearn with `pip install colearn[keras]`.\")\nfrom tensorflow import keras\nfrom colearn.ml_interface import MachineLearningInterface, Weights, ProposedWeights, ColearnModel, ModelFormat, convert_model_to_onnx\nfrom colearn.ml_interface import DiffPrivBudget, DiffPrivConfig, TrainingSummary, ErrorCodes\nfrom tensorflow_privacy.privacy.analysis.compute_dp_sgd_privacy import compute_dp_sgd_privacy\nfrom tensorflow_privacy.privacy.optimizers.dp_optimizer_keras import make_keras_optimizer_class\nclass KerasLearner(MachineLearningInterface):\n\"\"\"\n    Tensorflow Keras learner implementation of machine learning interface\n    \"\"\"\ndef __init__(self, model: keras.Model,\ntrain_loader: tf.data.Dataset,\nvote_loader: tf.data.Dataset,\ntest_loader: Optional[tf.data.Dataset] = None,\nneed_reset_optimizer: bool = True,\nminimise_criterion: bool = True,\ncriterion: str = 'loss',\nmodel_fit_kwargs: Optional[dict] = None,\nmodel_evaluate_kwargs: Optional[dict] = None,\ndiff_priv_config: Optional[DiffPrivConfig] = None):\n\"\"\"\n        :param model: Keras model used for training\n        :param train_loader: Training dataset\n        :param test_loader: Optional test set. Subset of training set will be used if not specified.\n        :param need_reset_optimizer: True to clear optimizer history before training, False to kepp history.\n        :param minimise_criterion: Boolean - True to minimise value of criterion, False to maximise\n        :param criterion: Function to measure model performance\n        :param model_fit_kwargs: Arguments to be passed on model.fit function call\n        :param model_evaluate_kwargs: Arguments to be passed on model.evaluate function call\n        :param diff_priv_config: Contains differential privacy (dp) budget related configuration\n        \"\"\"\nself.model: keras.Model = model\nself.train_loader: tf.data.Dataset = train_loader\nself.vote_loader: tf.data.Dataset = vote_loader\nself.test_loader: Optional[tf.data.Dataset] = test_loader\nself.need_reset_optimizer = need_reset_optimizer\nself.minimise_criterion: bool = minimise_criterion\nself.criterion = criterion\nself.model_fit_kwargs = model_fit_kwargs or {}\nself.diff_priv_config = diff_priv_config\nself.cumulative_epochs = 0\nif self.diff_priv_config is not None:\nself.diff_priv_budget = DiffPrivBudget(\ntarget_epsilon=self.diff_priv_config.target_epsilon,\ntarget_delta=self.diff_priv_config.target_delta,\nconsumed_epsilon=0.0,\n# we will always use the highest available delta now\nconsumed_delta=self.diff_priv_config.target_delta\n)\nif 'epochs' in self.model_fit_kwargs.keys():\nself.epochs_per_proposal = self.model_fit_kwargs['epochs']\nelse:\nself.epochs_per_proposal = signature(self.model.fit).parameters['epochs'].default\nif model_fit_kwargs:\n# check that these are valid kwargs for model fit\nsig = signature(self.model.fit)\ntry:\nsig.bind_partial(**self.model_fit_kwargs)\nexcept TypeError:\nraise Exception(\"Invalid arguments for model.fit\")\nself.model_evaluate_kwargs = model_evaluate_kwargs or {}\nif model_evaluate_kwargs:\n# check that these are valid kwargs for model evaluate\nsig = signature(self.model.evaluate)\ntry:\nsig.bind_partial(**self.model_evaluate_kwargs)\nexcept TypeError:\nraise Exception(\"Invalid arguments for model.evaluate\")\nself.vote_score: float = self.test(self.vote_loader)\ndef reset_optimizer(self):\n\"\"\"\n        Recompiles the Keras model. This way the optimizer history get erased,\n        which is needed before a new training round, otherwise the outdated history is used.\n        \"\"\"\ncompile_args = self.model._get_compile_args()  # pylint: disable=protected-access\nopt_config = self.model.optimizer.get_config()\nif self.diff_priv_config is not None:\n# tensorflow_privacy optimizers get_config() miss the additional parameters\n# was fixed here: https://github.com/tensorflow/privacy/commit/49db04e3561638fc02795edb5774d322cdd1d7d1\n# but it is not yet in the stable version, thus I need here to do the same.\nopt_config.update({\n'l2_norm_clip': self.model.optimizer._l2_norm_clip,  # pylint: disable=protected-access\n'noise_multiplier': self.model.optimizer._noise_multiplier,  # pylint: disable=protected-access\n'num_microbatches': self.model.optimizer._num_microbatches,  # pylint: disable=protected-access\n})\nnew_opt = make_keras_optimizer_class(\ngetattr(keras.optimizers, opt_config['name'])\n).from_config(opt_config)\ncompile_args['optimizer'] = new_opt\nelse:\ncompile_args['optimizer'] = getattr(keras.optimizers,\nopt_config['name']).from_config(opt_config)\nself.model.compile(**compile_args)\ndef mli_propose_weights(self) -&gt; Weights:\n\"\"\"\n        Trains model on training set and returns new weights after training\n        - Current model is reverted to original state after training\n        :return: Weights after training\n        \"\"\"\ncurrent_weights = self.mli_get_current_weights()\nif self.diff_priv_config is not None:\nepsilon_after_training = self.get_privacy_budget()\nif epsilon_after_training &gt; self.diff_priv_budget.target_epsilon:\nreturn Weights(\nweights=current_weights,\ntraining_summary=TrainingSummary(\ndp_budget=self.diff_priv_budget,\nerror_code=ErrorCodes.DP_BUDGET_EXCEEDED\n)\n)\nself.train()\nnew_weights = self.mli_get_current_weights()\nself.set_weights(current_weights)\nif self.diff_priv_config is not None:\nself.diff_priv_budget.consumed_epsilon = epsilon_after_training\nself.cumulative_epochs += self.epochs_per_proposal\nnew_weights.training_summary = TrainingSummary(dp_budget=self.diff_priv_budget)\nreturn new_weights\ndef mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\n\"\"\"\n        Tests given weights on training and test set and returns weights with score values\n        :param weights: Weights to be tested\n        :return: ProposedWeights - Weights with vote and test score\n        \"\"\"\ncurrent_weights = self.mli_get_current_weights()\nself.set_weights(weights)\nvote_score = self.test(self.vote_loader)\nif self.test_loader:\ntest_score = self.test(self.test_loader)\nelse:\ntest_score = 0\nvote = self.vote(vote_score)\nself.set_weights(current_weights)\nreturn ProposedWeights(weights=weights,\nvote_score=vote_score,\ntest_score=test_score,\nvote=vote,\n)\ndef vote(self, new_score) -&gt; bool:\n\"\"\"\n        Compares current model score with proposed model score and returns vote\n        :param new_score: Proposed score\n        :return: bool positive or negative vote\n        \"\"\"\nif self.minimise_criterion:\nreturn new_score &lt; self.vote_score\nelse:\nreturn new_score &gt; self.vote_score\ndef mli_accept_weights(self, weights: Weights):\n\"\"\"\n        Updates the model with the proposed set of weights\n        :param weights: The new weights\n        \"\"\"\nself.set_weights(weights)\nself.vote_score = self.test(self.vote_loader)\ndef get_train_batch_size(self) -&gt; int:\n\"\"\"\n        Calculates train batch size.\n        \"\"\"\nif hasattr(self.train_loader, '_batch_size'):\nreturn self.train_loader._batch_size  # pylint: disable=protected-access\nelse:\nreturn self.train_loader._input_dataset._batch_size  # pylint: disable=protected-access\ndef get_privacy_budget(self) -&gt; float:\n\"\"\"\n        Calculates, what epsilon will apply after another model training.\n        Need to calculate it in advance to see if another training would result in privacy budget violation.\n        \"\"\"\nbatch_size = self.get_train_batch_size()\niterations_per_epoch = tf.data.experimental.cardinality(self.train_loader).numpy()\nn_samples = batch_size * iterations_per_epoch\nplanned_epochs = self.cumulative_epochs + self.epochs_per_proposal\nepsilon, _ = compute_dp_sgd_privacy(\nn=n_samples,\nbatch_size=batch_size,\nnoise_multiplier=self.diff_priv_config.noise_multiplier,  # type: ignore\nepochs=planned_epochs,\ndelta=self.diff_priv_budget.target_delta\n)\nreturn epsilon\ndef mli_get_current_weights(self) -&gt; Weights:\n\"\"\"\n        :return: The current weights of the model\n        \"\"\"\nreturn Weights(weights=self.model.get_weights())\ndef mli_get_current_model(self) -&gt; ColearnModel:\n\"\"\"\n        :return: The current model and its format\n        \"\"\"\nreturn ColearnModel(\nmodel_format=ModelFormat(ModelFormat.ONNX),\nmodel_file=\"\",\nmodel=convert_model_to_onnx(self.model),\n)\ndef set_weights(self, weights: Weights):\n\"\"\"\n        Rewrites weight of current model\n        :param weights: Weights to be stored\n        \"\"\"\nself.model.set_weights(weights.weights)\ndef train(self):\n\"\"\"\n        Trains the model on the training dataset\n        \"\"\"\nif self.need_reset_optimizer:\n# erase the outdated optimizer memory (momentums mostly)\nself.reset_optimizer()\nself.model.fit(self.train_loader, **self.model_fit_kwargs)\ndef test(self, loader: tf.data.Dataset) -&gt; float:\n\"\"\"\n        Tests performance of the model on specified dataset\n        :param loader: Dataset for testing\n        :return: Value of performance metric\n        \"\"\"\nresult = self.model.evaluate(x=loader, return_dict=True,\n**self.model_evaluate_kwargs)\nreturn result[self.criterion]\n</code></pre> <p>We create a set of KerasLearners by passing in the model and the datasets:</p> <pre><code>all_learner_models = []\nfor i in range(n_learners):\nall_learner_models.append(KerasLearner(\nmodel=get_model(),\ntrain_loader=train_datasets[i],\nvote_loader=vote_datasets[i],\ntest_loader=test_datasets[i],\ncriterion=\"sparse_categorical_accuracy\",\nminimise_criterion=False,\nmodel_evaluate_kwargs={\"steps\": vote_batches},\n))\n</code></pre> <p>Then we give all the models the same weights to start off with:</p> <pre><code>set_equal_weights(all_learner_models)\n</code></pre> <p>And then we can move on to the final stage, which is training with Collective Learning. The function <code>collective_learning_round</code> performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins.</p> <pre><code># Train the model using Collective Learning\nresults = Results()\nresults.data.append(initial_result(all_learner_models))\nfor round in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round)\n)\nplot_results(results, n_learners, block=False,\nscore_name=all_learner_models[0].criterion)\nplot_votes(results, block=False)\nplot_results(results, n_learners, block=False,\nscore_name=all_learner_models[0].criterion)\nplot_votes(results, block=True)\n</code></pre>"},{"location":"colearn/intro_tutorial_mli/","title":"Using collective learning","text":"<p>This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally.</p> <p>The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning <code>MachineLearningInterface</code> defined in ml_interface.py. This tutorial will walk through implementing the <code>MachineLearningInterface</code>. If you're already using keras or pytorch you might find it easier to use the <code>KerasLearner</code> or <code>Pytorchlearner</code> classes. See the other tutorials for details of how to do that.</p>"},{"location":"colearn/intro_tutorial_mli/#the-machinelearninginterface","title":"The MachineLearningInterface","text":"<pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport abc\nfrom enum import Enum\nfrom typing import Any, Optional\nimport onnx\nimport onnxmltools\nimport sklearn\nimport tensorflow as tf\nimport torch\nfrom pydantic import BaseModel\nfrom tensorflow import keras\nmodel_classes_keras = (tf.keras.Model, keras.Model, tf.estimator.Estimator)\nmodel_classes_scipy = (torch.nn.Module)\nmodel_classes_sklearn = (sklearn.base.ClassifierMixin)\ndef convert_model_to_onnx(model: Any):\n\"\"\"\n    Helper function to convert a ML model to onnx format\n    \"\"\"\nif isinstance(model, model_classes_keras):\nreturn onnxmltools.convert_keras(model)\nif isinstance(model, model_classes_sklearn):\nreturn onnxmltools.convert_sklearn(model)\nif 'xgboost' in model.__repr__():\nreturn onnxmltools.convert_sklearn(model)\nif isinstance(model, model_classes_scipy):\nraise Exception(\"Pytorch models not yet supported to onnx\")\nelse:\nraise Exception(\"Attempt to convert unsupported model to onnx: {model}\")\nclass DiffPrivBudget(BaseModel):\ntarget_epsilon: float\ntarget_delta: float\nconsumed_epsilon: float\nconsumed_delta: float\nclass ErrorCodes(Enum):\nDP_BUDGET_EXCEEDED = 1\nclass TrainingSummary(BaseModel):\ndp_budget: Optional[DiffPrivBudget]\nerror_code: Optional[ErrorCodes]\nclass Weights(BaseModel):\nweights: Any\ntraining_summary: Optional[TrainingSummary]\nclass DiffPrivConfig(BaseModel):\ntarget_epsilon: float\ntarget_delta: float\nmax_grad_norm: float\nnoise_multiplier: float\nclass ProposedWeights(BaseModel):\nweights: Weights\nvote_score: float\ntest_score: float\nvote: Optional[bool]\nclass ModelFormat(Enum):\nPICKLE_WEIGHTS_ONLY = 1\nONNX = 2\nclass ColearnModel(BaseModel):\nmodel_format: ModelFormat\nmodel_file: Optional[str]\nmodel: Optional[Any]\ndef deser_model(model: Any) -&gt; onnx.ModelProto:\n\"\"\"\n    Helper function to recover a onnx model from its deserialized form\n    \"\"\"\nreturn onnx.load_model_from_string(model)\nclass MachineLearningInterface(abc.ABC):\n@abc.abstractmethod\ndef mli_propose_weights(self) -&gt; Weights:\n\"\"\"\n        Trains the model. Returns new weights. Does not change the current weights of the model.\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\n\"\"\"\n        Tests the proposed weights and fills in the rest of the fields\n        \"\"\"\n@abc.abstractmethod\ndef mli_accept_weights(self, weights: Weights):\n\"\"\"\n        Updates the model with the proposed set of weights\n        :param weights: The new weights\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_get_current_weights(self) -&gt; Weights:\n\"\"\"\n        Returns the current weights of the model\n        \"\"\"\npass\n@abc.abstractmethod\ndef mli_get_current_model(self) -&gt; ColearnModel:\n\"\"\"\n        Returns the current model\n        \"\"\"\npass \n</code></pre> <p>There are four methods that need to be implemented:</p> <ol> <li><code>propose_weights</code> causes the model to do some training and then return a    new set of weights that are proposed to the other learners.    This method shouldn't charge the current weights of the model - that    only happens when <code>accept_weights</code> is called.</li> <li><code>test_weights</code> - the models takes some new weights and returns a vote on whether the new weights are an improvement.    As in propose_weights, this shouldn't change the current weights of the model -    that only happens when <code>accept_weights</code> is called.</li> <li><code>accept_weights</code> - the model accepts some weights that have been voted on and approved by the set of learners.     The old weighs of the model are discarded and replaced by the new weights.</li> <li><code>current_weights</code> should return the current weights of the model.</li> </ol>"},{"location":"colearn/intro_tutorial_mli/#algorithms-that-work-with-colearn","title":"Algorithms that work with colearn","text":"<p>These conditions need to be fulfilled for algorithms to work with collective learning:</p> <ul> <li>Model fitting must be incremental so that the previous model is used as the starting point for training.   This is easy to achieve for neural networks because neural network training is always iterative, but for other   learning algorithms more care must be taken. Some examples of getting this wrong:</li> </ul> <pre><code>from sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\nmodel.fit(X, y)\n</code></pre> <pre><code>from sklearn.ensemble import RandomForestClassifier\nmodel = RandomForestClassifier(n_estimators=10)  # it would be okay with warm_start=True\nmodel.fit(X, y)\n</code></pre> <pre><code>from xgboost import XGBRegressor\nmodel = XGBRegressor()\nmodel.fit(X, y)\n</code></pre> <p>None of the training methods here use the previous result when fit is called for a second time;   instead they start again from scratch.   Good examples of incremental training can be seen in the examples.   Many sklearn models have a <code>warm_start</code> parameter which can be set to <code>True</code> to use the previous training result.   XGBoost has an <code>xgb_model</code> parameter for passing in the previous training results.</p> <ul> <li>The model mustn't overfit when propose_weights() is called.   You should limit training so that a learner will not overfit their training data in one round.   For example, if a learner overfits their own training data then the other learners will reject the   proposed update because it is not a good fit for their data.   For a neural network a good approach is to restrict the number of batches that are used each round;   for  random forest, restrict the trees that are added each round.</li> </ul>"},{"location":"colearn/intro_tutorial_mli/#implementation-for-fraud-detection-task","title":"Implementation for fraud detection task","text":"<p>Here is the class that implements the <code>MachineLearningInterface</code> for the task of detecting fraud in bank transactions.</p> <pre><code>class FraudSklearnLearner(MachineLearningInterface):\ndef __init__(self, train_data, train_labels, test_data, test_labels,\nbatch_size: int = 10000,\nsteps_per_round: int = 1):\nself.steps_per_round = steps_per_round\nself.batch_size = batch_size\nself.train_data = train_data\nself.train_labels = train_labels\nself.test_data = test_data\nself.test_labels = test_labels\nself.class_labels = np.unique(train_labels)\nself.train_sampler = infinite_batch_sampler(train_data.shape[0], batch_size)\nself.model = SGDClassifier(max_iter=1, verbose=0, loss=\"modified_huber\")\nself.model.partial_fit(self.train_data[0:1], self.train_labels[0:1],\nclasses=self.class_labels)  # this needs to be called before predict\nself.vote_score = self.test(self.train_data, self.train_labels)\ndef mli_propose_weights(self) -&gt; Weights:\ncurrent_weights = self.mli_get_current_weights()\nfor i in range(self.steps_per_round):\nbatch_indices = next(self.train_sampler)\ntrain_data = self.train_data[batch_indices]\ntrain_labels = self.train_labels[batch_indices]\nself.model.partial_fit(train_data, train_labels, classes=self.class_labels)\nnew_weights = self.mli_get_current_weights()\nself.set_weights(current_weights)\nreturn new_weights\ndef mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\ncurrent_weights = self.mli_get_current_weights()\nself.set_weights(weights)\nvote_score = self.test(self.train_data, self.train_labels)\ntest_score = self.test(self.test_data, self.test_labels)\nvote = self.vote_score &lt;= vote_score\nself.set_weights(current_weights)\nreturn ProposedWeights(weights=weights,\nvote_score=vote_score,\ntest_score=test_score,\nvote=vote\n)\ndef mli_accept_weights(self, weights: Weights):\nself.set_weights(weights)\nself.vote_score = self.test(self.train_data, self.train_labels)\ndef mli_get_current_weights(self):\n# return Weights(weights=copy.deepcopy(self.model))\nreturn Weights(weights=dict(coef_=self.model.coef_,\nintercept_=self.model.intercept_))\ndef set_weights(self, weights: Weights):\n# self.model = weights.weights\nself.model.coef_ = weights.weights['coef_']\nself.model.intercept_ = weights.weights['intercept_']\ndef test(self, data, labels):\ntry:\nreturn self.model.score(data, labels)\nexcept sklearn.exceptions.NotFittedError:\nreturn 0\n</code></pre> <p>Let's step through this and see how it works. The propose_weights method saves the current weights of the model. Then it performs some training of the model, and gets the new weights. It returns the new weights, and resets the model weights to be the old weights.</p> <pre><code>    def mli_propose_weights(self) -&gt; Weights:\ncurrent_weights = self.mli_get_current_weights()\nfor i in range(self.steps_per_round):\nbatch_indices = next(self.train_sampler)\ntrain_data = self.train_data[batch_indices]\ntrain_labels = self.train_labels[batch_indices]\nself.model.partial_fit(train_data, train_labels, classes=self.class_labels)\nnew_weights = self.mli_get_current_weights()\nself.set_weights(current_weights)\nreturn new_weights\n</code></pre> <p>The test_weights method takes as a parameter the proposed weights that it needs to vote on. It saves the current weights of the model, and then sets the model weights to be the proposed weights. It tests the model and votes based on whether the score that it is monitoring has improved. The vote score can be any metric that you like. You could use loss, accuracy, mean squared error or any custom metric. If the vote score is the loss then the model would only vote True if the score has decreased. Here we're using accuracy, so the vote is true if the score increases. This method then resets the weights to the old values and returns the vote along with some scores for monitoring purposes.</p> <pre><code>    def mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\ncurrent_weights = self.mli_get_current_weights()\nself.set_weights(weights)\nvote_score = self.test(self.train_data, self.train_labels)\ntest_score = self.test(self.test_data, self.test_labels)\nvote = self.vote_score &lt;= vote_score\nself.set_weights(current_weights)\nreturn ProposedWeights(weights=weights,\nvote_score=vote_score,\ntest_score=test_score,\nvote=vote\n)\n</code></pre> <p>The accept_weights method sets the weights of the model to be the new weights. It also updates the vote score to be the current performance.</p> <p>Note</p> <p>You could implement a cache here. These weights will already have been tested in test_weights, so the vote score could be retrieved from the cache instead of recomputed.</p> <pre><code>    def mli_accept_weights(self, weights: Weights):\nself.set_weights(weights)\nself.vote_score = self.test(self.train_data, self.train_labels)\n</code></pre> <p>The final method is the simplest - get_current_weights just returns the current weights of the model. These weights are wrapped inside a <code>Weights</code> object.</p> <pre><code>    def mli_get_current_weights(self):\nreturn Weights(weights=dict(coef_=self.model.coef_,\nintercept_=self.model.intercept_))\n</code></pre>"},{"location":"colearn/intro_tutorial_mli/#the-rest-of-the-example","title":"The rest of the example","text":"<p>The data is loaded and preprocessed and then split into equal parts for each learner. Then a list of FraudLearner instances is created, each with its own dataset.  </p> <pre><code>    all_learner_models = []\nfor i in range(n_learners):\nall_learner_models.append(\nFraudLearner(\ntrain_data=learner_train_data[i],\ntrain_labels=learner_train_labels[i],\ntest_data=learner_test_data[i],\ntest_labels=learner_test_labels[i]\n))\n</code></pre> <p>Then we give all the models the same weights to start off with:</p> <pre><code>set_equal_weights(all_learner_models)\n</code></pre> <p>And then we can move on to the final stage, which is training with Collective Learning. The function <code>collective_learning_round</code> performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins.</p> <pre><code># Train the model using Collective Learning\nresults = Results()\nresults.data.append(initial_result(all_learner_models))\nfor round in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round)\n)\nplot_results(results, n_learners, block=False,\nscore_name=all_learner_models[0].criterion)\nplot_votes(results, block=False)\nplot_results(results, n_learners, block=False,\nscore_name=all_learner_models[0].criterion)\nplot_votes(results, block=True)\n</code></pre>"},{"location":"colearn/intro_tutorial_pytorch/","title":"Using collective learning with pytorch","text":"<p>This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally.</p> <p>The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning <code>MachineLearningInterface</code> defined in ml_interface.py. For more details on how to use the <code>MachineLearningInterface</code> see here</p> <p>However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the <code>PytorchLearner</code>. First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning.</p> <p>A standard script for machine learning with Pytorch looks like the one below</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nfrom torchsummary import summary\nfrom torchvision import transforms, datasets\nimport torch.utils.data\nimport torch.nn as nn\nimport torch.nn.functional as nn_func\n# define some constants\nbatch_size = 64\nseed = 42\nn_rounds = 20\ntrain_fraction = 0.9\nlearning_rate = 0.001\nheight = 28\nwidth = 28\nn_classes = 10\nnum_test_batches = 10\nno_cuda = False\ncuda = not no_cuda and torch.cuda.is_available()\ndevice = torch.device(\"cuda\" if cuda else \"cpu\")\nkwargs = {'num_workers': 1, 'pin_memory': True} if cuda else {}\n# Load the data\ndata = datasets.MNIST('/tmp/mnist', transform=transforms.ToTensor(), download=True)\nn_train = int(train_fraction * len(data))\nn_test = len(data) - n_train\ntrain_data, test_data = torch.utils.data.random_split(data, [n_train, n_test])\ntrain_dataloader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, shuffle=True, **kwargs)\ntest_dataloader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, shuffle=True, **kwargs)\n# Define the model\nclass Net(nn.Module):\ndef __init__(self):\nsuper(Net, self).__init__()\nself.conv1 = nn.Conv2d(1, 20, 5, 1)\nself.conv2 = nn.Conv2d(20, 50, 5, 1)\nself.fc1 = nn.Linear(4 * 4 * 50, 500)\nself.fc2 = nn.Linear(500, n_classes)\ndef forward(self, x):\nx = nn_func.relu(self.conv1(x.view(-1, 1, height, width)))\nx = nn_func.max_pool2d(x, 2, 2)\nx = nn_func.relu(self.conv2(x))\nx = nn_func.max_pool2d(x, 2, 2)\nx = x.view(-1, 4 * 4 * 50)\nx = nn_func.relu(self.fc1(x))\nx = self.fc2(x)\nreturn nn_func.log_softmax(x, dim=1)\nmodel = Net()\nopt = torch.optim.Adam(model.parameters(), lr=learning_rate)\ncriterion = torch.nn.NLLLoss()\n# Train and evaluate the model\nfor round in range(n_rounds):\n# train model\nmodel.train()\nfor batch_idx, (data, labels) in enumerate(train_dataloader):\nopt.zero_grad()\n# Data needs to be on same device as model\ndata = data.to(device)\nlabels = labels.to(device)\noutput = model(data)\nloss = criterion(output, labels)\nloss.backward()\nopt.step()\n# evaluate model\nmodel.eval()\ntotal_score = 0\nall_labels = []\nall_outputs = []\nwith torch.no_grad():\nfor batch_idx, (data, labels) in enumerate(test_dataloader):\nif batch_idx == num_test_batches:\nbreak\ndata = data.to(device)\nlabels = labels.to(device)\noutput = model(data)\ntotal_score += criterion(output, labels)\navg_loss = float(total_score / (num_test_batches * batch_size))\nprint(f\"Average loss at round {round} is {avg_loss}\")\n</code></pre> <p>There are three steps:</p> <ol> <li>Load the data</li> <li>Define the model</li> <li>Train the model</li> </ol> <p>In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this:</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nimport os\nfrom typing_extensions import TypedDict\nimport torch.nn as nn\nimport torch.nn.functional as nn_func\nimport torch.utils.data\nfrom torchsummary import summary\nfrom torchvision import transforms, datasets\nfrom colearn.training import initial_result, collective_learning_round, set_equal_weights\nfrom colearn.utils.plot import ColearnPlot\nfrom colearn.utils.results import Results, print_results\nfrom colearn_pytorch.utils import categorical_accuracy\nfrom colearn_pytorch.pytorch_learner import PytorchLearner\n\"\"\"\nMNIST training example using PyTorch\nUsed dataset:\n- MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes\nWhat script does:\n- Loads MNIST dataset from torchvision.datasets\n- Randomly splits dataset between multiple learners\n- Does multiple rounds of learning process and displays plot with results\n\"\"\"\n# define some constants\nn_learners = 5\nbatch_size = 64\ntesting_mode = bool(os.getenv(\"COLEARN_EXAMPLES_TEST\", \"\"))  # for testing\nn_rounds = 20 if not testing_mode else 1\nvote_threshold = 0.5\ntrain_fraction = 0.9\nvote_fraction = 0.05\nlearning_rate = 0.001\nheight = 28\nwidth = 28\nn_classes = 10\nvote_batches = 2\nscore_name = \"categorical accuracy\"\nno_cuda = False\ncuda = not no_cuda and torch.cuda.is_available()\ndevice = torch.device(\"cuda\" if cuda else \"cpu\")\nDataloaderKwargs = TypedDict('DataloaderKwargs', {'num_workers': int, 'pin_memory': bool}, total=False)\nkwargs: DataloaderKwargs = {'num_workers': 1, 'pin_memory': True} if cuda else {}\n# Load the data and split for each learner.\nDATA_DIR = os.environ.get('PYTORCH_DATA_DIR',\nos.path.expanduser(os.path.join('~', 'pytorch_datasets')))\ndata = datasets.MNIST(DATA_DIR, transform=transforms.ToTensor(), download=True)\nn_train = int(train_fraction * len(data))\nn_vote = int(vote_fraction * len(data))\nn_test = len(data) - n_train - n_vote\ntrain_data, vote_data, test_data = torch.utils.data.random_split(data, [n_train, n_vote, n_test])\ndata_split = [len(train_data) // n_learners] * n_learners\nlearner_train_data = torch.utils.data.random_split(train_data, data_split)\nlearner_train_dataloaders = [torch.utils.data.DataLoader(\nds,\nbatch_size=batch_size, shuffle=True, **kwargs) for ds in learner_train_data]\ndata_split = [len(vote_data) // n_learners] * n_learners\nlearner_vote_data = torch.utils.data.random_split(vote_data, data_split)\nlearner_vote_dataloaders = [torch.utils.data.DataLoader(\nds,\nbatch_size=batch_size, shuffle=True, **kwargs) for ds in learner_vote_data]\ndata_split = [len(test_data) // n_learners] * n_learners\nlearner_test_data = torch.utils.data.random_split(test_data, data_split)\nlearner_test_dataloaders = [torch.utils.data.DataLoader(\nds,\nbatch_size=batch_size, shuffle=True, **kwargs) for ds in learner_test_data]\n# Define the model\nclass Net(nn.Module):\ndef __init__(self):\nsuper(Net, self).__init__()\nself.conv1 = nn.Conv2d(1, 20, 5, 1)\nself.conv2 = nn.Conv2d(20, 50, 5, 1)\nself.fc1 = nn.Linear(4 * 4 * 50, 500)\nself.fc2 = nn.Linear(500, n_classes)\ndef forward(self, x):\nx = nn_func.relu(self.conv1(x.view(-1, 1, height, width)))\nx = nn_func.max_pool2d(x, 2, 2)\nx = nn_func.relu(self.conv2(x))\nx = nn_func.max_pool2d(x, 2, 2)\nx = x.view(-1, 4 * 4 * 50)\nx = nn_func.relu(self.fc1(x))\nx = self.fc2(x)\nreturn nn_func.log_softmax(x, dim=1)\n# Make n instances of PytorchLearner with model and torch dataloaders\nall_learner_models = []\nfor i in range(n_learners):\nmodel = Net().to(device)\nopt = torch.optim.Adam(model.parameters(), lr=learning_rate)\nlearner = PytorchLearner(\nmodel=model,\ntrain_loader=learner_train_dataloaders[i],\nvote_loader=learner_vote_dataloaders[i],\ntest_loader=learner_test_dataloaders[i],\ndevice=device,\noptimizer=opt,\ncriterion=torch.nn.NLLLoss(),\nnum_test_batches=vote_batches,\nvote_criterion=categorical_accuracy,\nminimise_criterion=False\n)\nall_learner_models.append(learner)\n# Ensure all learners starts with exactly same weights\nset_equal_weights(all_learner_models)\nsummary(all_learner_models[0].model, input_size=(width, height), device=str(device))\n# Train the model using Collective Learning\nresults = Results()\nresults.data.append(initial_result(all_learner_models))\nplot = ColearnPlot(score_name=score_name)\nfor round_index in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round_index)\n)\nprint_results(results)\nplot.plot_results_and_votes(results)\nplot.block()\nprint(\"Colearn Example Finished!\")\n</code></pre> <p>The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with the pytorch random_split utility:</p> <pre><code>data_split = [len(test_data) // n_learners] * n_learners\nlearner_test_data = torch.utils.data.random_split(test_data, data_split)\n</code></pre> <p>The model definition is the same as before. To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the <code>MachineLearningInterface</code> with pytorch, we've defined <code>PytorchLearner</code>. <code>PytorchLearner</code> implements standard training and evaluation routines as well as the MachineLearningInterface methods.</p> <pre><code># ------------------------------------------------------------------------------\n#\n#   Copyright 2021 Fetch.AI Limited\n#\n#   Licensed under the Creative Commons Attribution-NonCommercial International\n#   License, Version 4.0 (the \"License\"); you may not use this file except in\n#   compliance with the License. You may obtain a copy of the License at\n#\n#       http://creativecommons.org/licenses/by-nc/4.0/legalcode\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n# ------------------------------------------------------------------------------\nfrom typing import Optional, Callable\nfrom collections import OrderedDict, defaultdict\ntry:\nimport torch\nexcept ImportError:\nraise Exception(\n\"Pytorch is not installed. To use the pytorch \"\n\"add-ons please install colearn with `pip install colearn[pytorch]`.\"\n)\nimport torch.nn\nimport torch.optim\nimport torch.utils\nimport torch.utils.data\nfrom torch.nn.modules.loss import _Loss\nfrom colearn.ml_interface import (\nMachineLearningInterface,\nWeights,\nProposedWeights,\nColearnModel,\nconvert_model_to_onnx,\nModelFormat,\nDiffPrivBudget,\nDiffPrivConfig,\nTrainingSummary,\nErrorCodes,\n)\nfrom opacus import PrivacyEngine\n_DEFAULT_DEVICE = torch.device(\"cpu\")\nclass PytorchLearner(MachineLearningInterface):\n\"\"\"\n    Pytorch learner implementation of machine learning interface\n    \"\"\"\ndef __init__(\nself,\nmodel: torch.nn.Module,\noptimizer: torch.optim.Optimizer,\ntrain_loader: torch.utils.data.DataLoader,\nvote_loader: torch.utils.data.DataLoader,\ntest_loader: Optional[torch.utils.data.DataLoader] = None,\nneed_reset_optimizer: bool = True,\ndevice=_DEFAULT_DEVICE,\ncriterion: Optional[_Loss] = None,\nminimise_criterion=True,\nvote_criterion: Optional[Callable[[torch.Tensor, torch.Tensor], float]] = None,\nnum_train_batches: Optional[int] = None,\nnum_test_batches: Optional[int] = None,\ndiff_priv_config: Optional[DiffPrivConfig] = None,\n):\n\"\"\"\n        :param model: Pytorch model used for training\n        :param optimizer: Training optimizer\n        :param train_loader: Train dataset\n        :param test_loader: Optional test dataset - subset of training set will be used if not specified\n        :param need_reset_optimizer: True to clear optimizer history before training, False to kepp history.\n        :param device: Pytorch device - CPU or GPU\n        :param criterion: Loss function\n        :param minimise_criterion: True to minimise value of criterion, False to maximise\n        :param vote_criterion: Function to measure model performance for voting\n        :param num_train_batches: Number of training batches\n        :param num_test_batches: Number of testing batches\n        :param diff_priv_config: Contains differential privacy (dp) budget related configuration\n        \"\"\"\n# Model has to be on same device as data\nself.model: torch.nn.Module = model.to(device)\nself.optimizer: torch.optim.Optimizer = optimizer\nself.criterion = criterion\nself.train_loader: torch.utils.data.DataLoader = train_loader\nself.vote_loader: torch.utils.data.DataLoader = vote_loader\nself.test_loader: Optional[torch.utils.data.DataLoader] = test_loader\nself.need_reset_optimizer = need_reset_optimizer\nself.device = device\nself.num_train_batches = num_train_batches or len(train_loader)\nself.num_test_batches = num_test_batches\nself.minimise_criterion = minimise_criterion\nself.vote_criterion = vote_criterion\nself.dp_config = diff_priv_config\nself.dp_privacy_engine = PrivacyEngine()\nif diff_priv_config is not None:\n(\nself.model,\nself.optimizer,\nself.train_loader,\n) = self.dp_privacy_engine.make_private(\nmodule=self.model,\noptimizer=self.optimizer,\ndata_loader=self.train_loader,\nmax_grad_norm=diff_priv_config.max_grad_norm,\nnoise_multiplier=diff_priv_config.noise_multiplier,\n)\nself.vote_score = self.test(self.vote_loader)\ndef mli_get_current_weights(self) -&gt; Weights:\n\"\"\"\n        :return: The current weights of the model\n        \"\"\"\ncurrent_state_dict = OrderedDict()\nfor key in self.model.state_dict():\ncurrent_state_dict[key] = self.model.state_dict()[key].clone()\nw = Weights(\nweights=current_state_dict, training_summary=self.get_training_summary()\n)\nreturn w\ndef mli_get_current_model(self) -&gt; ColearnModel:\n\"\"\"\n        :return: The current model and its format\n        \"\"\"\nreturn ColearnModel(\nmodel_format=ModelFormat(ModelFormat.ONNX),\nmodel_file=\"\",\nmodel=convert_model_to_onnx(self.model),\n)\ndef set_weights(self, weights: Weights):\n\"\"\"\n        Rewrites weight of current model\n        :param weights: Weights to be stored\n        \"\"\"\nself.model.load_state_dict(weights.weights)\ndef reset_optimizer(self):\n\"\"\"\n        Clear optimizer state, such as number of iterations, momentums.\n        This way, the outdated history can be erased.\n        \"\"\"\nself.optimizer.__setstate__({\"state\": defaultdict(dict)})\ndef train(self):\n\"\"\"\n        Trains the model on the training dataset\n        \"\"\"\nif self.need_reset_optimizer:\n# erase the outdated optimizer memory (momentums mostly)\nself.reset_optimizer()\nself.model.train()\nfor batch_idx, (data, labels) in enumerate(self.train_loader):\nif batch_idx == self.num_train_batches:\nbreak\nself.optimizer.zero_grad()\n# Data needs to be on same device as model\ndata = data.to(self.device)\nlabels = labels.to(self.device)\noutput = self.model(data)\nloss = self.criterion(output, labels)\nloss.backward()\nself.optimizer.step()\ndef mli_propose_weights(self) -&gt; Weights:\n\"\"\"\n        Trains model on training set and returns new weights after training\n        - Current model is reverted to original state after training\n        :return: Weights after training\n        \"\"\"\ncurrent_weights = self.mli_get_current_weights()\ntraining_summary = current_weights.training_summary\nif (\ntraining_summary is not None\nand training_summary.error_code is not None\nand training_summary.error_code == ErrorCodes.DP_BUDGET_EXCEEDED\n):\nreturn current_weights\nself.train()\nnew_weights = self.mli_get_current_weights()\nself.set_weights(current_weights)\ntraining_summary = new_weights.training_summary\nif (\ntraining_summary is not None\nand training_summary.error_code is not None\nand training_summary.error_code == ErrorCodes.DP_BUDGET_EXCEEDED\n):\ncurrent_weights.training_summary = training_summary\nreturn current_weights\nreturn new_weights\ndef mli_test_weights(self, weights: Weights) -&gt; ProposedWeights:\n\"\"\"\n        Tests given weights on training and test set and returns weights with score values\n        :param weights: Weights to be tested\n        :return: ProposedWeights - Weights with vote and test score\n        \"\"\"\ncurrent_weights = self.mli_get_current_weights()\nself.set_weights(weights)\nvote_score = self.test(self.vote_loader)\nif self.test_loader:\ntest_score = self.test(self.test_loader)\nelse:\ntest_score = 0\nvote = self.vote(vote_score)\nself.set_weights(current_weights)\nreturn ProposedWeights(\nweights=weights, vote_score=vote_score, test_score=test_score, vote=vote\n)\ndef vote(self, new_score) -&gt; bool:\n\"\"\"\n        Compares current model score with proposed model score and returns vote\n        :param new_score: Proposed score\n        :return: bool positive or negative vote\n        \"\"\"\nif self.minimise_criterion:\nreturn new_score &lt; self.vote_score\nelse:\nreturn new_score &gt; self.vote_score\ndef test(self, loader: torch.utils.data.DataLoader) -&gt; float:\n\"\"\"\n        Tests performance of the model on specified dataset\n        :param loader: Dataset for testing\n        :return: Value of performance metric\n        \"\"\"\nif not self.criterion:\nraise Exception(\"Criterion is unspecified so test method cannot be used\")\nself.model.eval()\ntotal_score = 0\nall_labels = []\nall_outputs = []\nbatch_idx = 0\ntotal_samples = 0\nwith torch.no_grad():\nfor batch_idx, (data, labels) in enumerate(loader):\ntotal_samples += labels.shape[0]\nif self.num_test_batches and batch_idx == self.num_test_batches:\nbreak\ndata = data.to(self.device)\nlabels = labels.to(self.device)\noutput = self.model(data)\nif self.vote_criterion is not None:\nall_labels.append(labels)\nall_outputs.append(output)\nelse:\ntotal_score += self.criterion(output, labels).item()\nif batch_idx == 0:\nraise Exception(\"No batches in loader\")\nif self.vote_criterion is None:\nreturn float(total_score / total_samples)\nelse:\nreturn self.vote_criterion(\ntorch.cat(all_outputs, dim=0), torch.cat(all_labels, dim=0)\n)\ndef mli_accept_weights(self, weights: Weights):\n\"\"\"\n        Updates the model with the proposed set of weights\n        :param weights: The new weights\n        \"\"\"\nself.set_weights(weights)\nself.vote_score = self.test(self.vote_loader)\ndef get_training_summary(self) -&gt; Optional[TrainingSummary]:\n\"\"\"\n        Differential Privacy Budget\n        :return: the target and consumed epsilon so far\n        \"\"\"\nif self.dp_config is None:\nreturn None\ndelta = self.dp_config.target_delta\ntarget_epsilon = self.dp_config.target_epsilon\nconsumed_epsilon = self.dp_privacy_engine.get_epsilon(delta)\nbudget = DiffPrivBudget(\ntarget_epsilon=target_epsilon,\nconsumed_epsilon=consumed_epsilon,\ntarget_delta=delta,\nconsumed_delta=delta,  # delta is constatnt per training\n)\nerr = (\nErrorCodes.DP_BUDGET_EXCEEDED\nif consumed_epsilon &gt;= target_epsilon\nelse None\n)\nreturn TrainingSummary(\ndp_budget=budget,\nerror_code=err,\n)\n</code></pre> <p>We create a set of PytorchLearners by passing in the model and the datasets:</p> <pre><code>all_learner_models = []\nfor i in range(n_learners):\nmodel = Net()\nopt = torch.optim.Adam(model.parameters(), lr=learning_rate)\nlearner = PytorchLearner(\nmodel=model,\ntrain_loader=learner_train_dataloaders[i],\nvote_loader=learner_vote_dataloaders[i],\ntest_loader=learner_test_dataloaders[i],\ndevice=device,\noptimizer=opt,\ncriterion=torch.nn.NLLLoss(),\nnum_test_batches=vote_batches,\nvote_criterion=categorical_accuracy,\nminimise_criterion=False\n)\nall_learner_models.append(learner)\n</code></pre> <p>Then we give all the models the same weights to start off with:</p> <pre><code>set_equal_weights(all_learner_models)\n</code></pre> <p>And then we can move on to the final stage, which is training with Collective Learning. The function <code>collective_learning_round</code> performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins.</p> <pre><code># Train the model using Collective Learning\nresults = Results()\nresults.data.append(initial_result(all_learner_models))\nfor round in range(n_rounds):\nresults.data.append(\ncollective_learning_round(all_learner_models,\nvote_threshold, round)\n)\nplot_results(results, n_learners, score_name=score_name)\nplot_votes(results)\n# Plot the final result with votes\nplot_results(results, n_learners, score_name=score_name)\nplot_votes(results, block=True)\n</code></pre>"},{"location":"colearn/mli_factory/","title":"MLI Factory","text":"<p>The machine learning interface factory are the minimum methods a client needs to implement to work with the GRPC Server (and become a Learner).</p> <p>There are two main types of functions:</p> <ul> <li>Supported Systems (get_models, get_dataloaders, get_compatibilities)</li> <li>Get a MachineLearningInterface (get_mli)</li> </ul> <p>When the GRPC server is connected to the Orchestrator, it will query the supported system functions to know what the MLI Factory can serve.</p> <p>Later when the Orchestrator wants to run something on this Learner it will call get_mli with a model_arch_name, a dataloader_name and more parameters for both. The object returned is then used to run the experiment through the MLI.</p>"},{"location":"colearn/mli_factory/#supported-systems","title":"Supported Systems","text":"<p>The supported systems functions get_models and get_dataloaders should return a set of  which will be stored (not currently implemented) in the api database. The idea being that the user can change these values on the UI while preparing to start/join an experiment."},{"location":"colearn/mli_factory/#examplemlifactory","title":"ExampleMliFactory","text":"<p>An example MLIFactory that will implement all the tasks in run_demo. This is the one used by contract_learn.</p>"},{"location":"colearn/tasks/","title":"1. CIFAR10 dataset","text":""},{"location":"colearn/tasks/#11-information-and-installation","title":"1.1. Information and installation","text":""},{"location":"colearn/tasks/#111-information-about-the-dataset","title":"1.1.1. Information about the dataset","text":"<ul> <li>The CIFAR-10 dataset consists of 60000 32x32x3 colour images in 10 classes, with 6000 images per class.</li> <li>The 10 different classes represent airplanes, cars, birds, cats, deer, dogs, frogs, horses, ships, and trucks</li> <li>Input for NN are raw 32x32 3 channels GRB images</li> <li> <p>NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1</p> </li> <li> <p>Code folder: here</p> </li> <li>Invoke parameter: -t CIFAR10</li> </ul>"},{"location":"colearn/tasks/#112-requirements","title":"1.1.2. Requirements","text":"<ul> <li>Cifar dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required</li> </ul>"},{"location":"colearn/tasks/#12-models","title":"1.2. Models","text":""},{"location":"colearn/tasks/#121-cifar10conv-keras-model","title":"1.2.1. CIFAR10Conv Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                    Output Shape        Param #   \n=================================================================\nInput (InputLayer)              (32, 32, 3)         0             \n_________________________________________________________________\nConv1_1 (Conv2D)                (32, 32, 64)        1792          \nbn1_1 (BatchNormalization)      (32, 32, 64)        256           \nConv1_2 (Conv2D)                (32, 32, 64)        36928         \nbn1_2 (BatchNormalization)      (32, 32, 64)        256           \npool1 (MaxPooling2D)            (16, 16, 64)        0             \n_________________________________________________________________\nConv2_1 (Conv2D)                (16, 16, 128        73856         \nbn2_1 (BatchNormalization)      (16, 16, 128        512           \nConv2_2 (Conv2D)                (16, 16, 128        147584    \nbn2_2 (BatchNormalization)      (16, 16, 128        512           \npool2 (MaxPooling2D)            (8, 8, 128)         0             \n_________________________________________________________________\nConv3_1 (Conv2D)                (8, 8, 256)         295168    \nbn3_1 (BatchNormalization)      (8, 8, 256)         1024          \nConv3_2 (Conv2D)                (8, 8, 256)         590080    \nbn3_2 (BatchNormalization)      (8, 8, 256)         1024          \nConv3_3 (Conv2D)                (8, 8, 256)         590080    \nbn3_3 (BatchNormalization)      (8, 8, 256)         1024          \n_________________________________________________________________\nflatten (Flatten)               (16384)             0             \nfc1 (Dense)                     (100)               1638500   \nfc2 (Dense)                     (10)                1010          \n=================================================================\nTotal params: 3,379,606\nTrainable params: 3,377,302\nNon-trainable params: 2,304\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#122-cifar10conv2-keras-model","title":"1.2.2. CIFAR10Conv2 Keras model","text":"<pre><code>_________________________________________________________\nLayer (type)                Output Shape        Param #   \n=========================================================\nInput (InputLayer)          (32, 32, 3)         0             \n_________________________________________________________\nConv1_1 (Conv2D)            (32, 32, 32)        896           \nConv1_2 (Conv2D)            (32, 32, 32)        9248          \npool1 (MaxPooling2D)        (16, 16, 32)        0             \n_________________________________________________________\nConv2_1 (Conv2D)            (16, 16, 64)        18496         \nConv2_2 (Conv2D)            (16, 16, 64)        36928         \npool2 (MaxPooling2D)        (8, 8, 64)          0             \n_________________________________________________________\nConv3_1 (Conv2D)            (8, 8, 128)         73856         \nConv3_2 (Conv2D)            (8, 8, 128)         147584    \npool3 (MaxPooling2D)        (4, 4, 128)         0             \n_________________________________________________________\nflatten (Flatten)           (2048)              0             \nfc1 (Dense)                 (128)               262272    \nfc2 (Dense)                 (10)                1290          \n=========================================================\nTotal params: 550,570\nTrainable params: 550,570\nNon-trainable params: 0\n_________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#123-cifar10resnet50-keras-model","title":"1.2.3. CIFAR10Resnet50 Keras model","text":"<pre><code>________________________________________________________\nLayer (type)                 Output Shape     Param #   \n========================================================\nInput (InputLayer)           (32, 32, 3)]     0             \n________________________________________________________\nresnet50 (Model)             (1, 1, 2048)     23587712  \n________________________________________________________\nGlobal_average_pooling2d     (2048)           0             \nflatten (Flatten)            (2048)           0             \nfc1 (Dense)                  (10)             20490         \n========================================================\nTotal params: 23,608,202\nTrainable params: 23,555,082\nNon-trainable params: 53,120\n________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#2-covid-x-ray-dataset","title":"2. Covid X-RAY dataset","text":""},{"location":"colearn/tasks/#21-information-and-installation","title":"2.1. Information and installation","text":""},{"location":"colearn/tasks/#211-information-about-the-dataset","title":"2.1.1. Information about the dataset","text":"<ul> <li>The Covid X-Ray dataset consists of grayscale images, there are 478 covid images and 203 normal images.</li> <li>To increase the number of images normal/pneumonia dataset is added</li> <li>Final dataset, which is a combination of two previously mentioned datasets, contains 1434 images, 478 images for each class.</li> <li>Images are cropped and resized to 512x512 pixel and spatial domain (Texture, GLDM, GLCM) and frequency domain (FFT and Wavelet) features are used to create 256 dimensional vector representation of each image. PCA is applied after to reduce dimensionality to 64 values which represents the first 64 highest eigenvalues of the covariance matrix.</li> <li>Input for NN are 64 values for each image</li> <li>NN output is distribution of probabilities for each class i.e. 3 values</li> <li>Code folder: here</li> <li>Invoke parameter: -t COVID</li> </ul>"},{"location":"colearn/tasks/#212-requirements","title":"2.1.2 Requirements","text":"<ul> <li>Download Covid dataset: here</li> <li>Download pneumonia dataset: here</li> </ul>"},{"location":"colearn/tasks/#22-models","title":"2.2. Models","text":""},{"location":"colearn/tasks/#221-covid-xray-keras-model","title":"2.2.1. Covid XRAY Keras model","text":"<pre><code>_________________________________________________________\nLayer (type)              Output Shape        Param #   \n=========================================================\ninput_1 (InputLayer)      (64)                0             \n_________________________________________________________\ndense (Dense)             (128)               8320          \ndropout (Dropout)         (128)               0             \n_________________________________________________________\ndense_1 (Dense)           (16)                2064          \ndropout_1 (Dropout)       (16)                0             \n_________________________________________________________\ndense_2 (Dense)           (3)                 51            \n=========================================================\nTotal params: 10,435\nTrainable params: 10,435\nNon-trainable params: 0\n_________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#3-fraud-dataset","title":"3. FRAUD dataset","text":""},{"location":"colearn/tasks/#31-information-and-installation","title":"3.1. Information and installation","text":""},{"location":"colearn/tasks/#311-information-about-the-dataset","title":"3.1.1. Information about the dataset","text":"<ul> <li>EEE-CIS Fraud Detection, contains multiple files with credit card transactions</li> <li>Raw dataset files are automatically merged and pre-processed and input files for neural network are created</li> <li>X.csv with data - has 431 values for each transaction</li> <li> <p>Y.csv with labels - v has 1 value for each transaction</p> <ul> <li>0 = not a fraud</li> <li>1 = fraud</li> </ul> </li> <li> <p>Code folder: here</p> </li> <li>Invoke parameter: -t FRAUD</li> </ul>"},{"location":"colearn/tasks/#312-requirements","title":"3.1.2. Requirements","text":"<ul> <li>Download dataset: here</li> </ul>"},{"location":"colearn/tasks/#32-models","title":"3.2. Models","text":""},{"location":"colearn/tasks/#321-frauddense1-keras-model","title":"3.2.1. FraudDense1 Keras model","text":"<pre><code>_________________________________________________________\nLayer (type)             Output Shape          Param #   \n=========================================================\nInput (InputLayer)       (431)                 0             \n_________________________________________________________\ndense (Dense)            (512)                 221184    \nBatch_normalization      (512)                 2048          \n_________________________________________________________\ndense_1 (Dense)          (512)                 262656    \nBatch_normalization_1    (512)                 2048          \n_________________________________________________________\ndense_2 (Dense)          (512)                 262656    \nBatch_normalization_2    (512)                 2048          \n_________________________________________________________\nfc1 (Dense)              (1)                   513           \n=========================================================\nTotal params: 753,153\nTrainable params: 750,081\nNon-trainable params: 3,072\n_________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#322-fraudsvm-scikit-learn-model","title":"3.2.2. FraudSVM Scikit-learn model","text":"<ul> <li>Model is defined as SGDClassifier(max_iter=1, verbose=0, loss=\"modified_huber\")</li> <li>Which is support vector machine linear classifier</li> </ul>"},{"location":"colearn/tasks/#4-mnist","title":"4. MNIST","text":""},{"location":"colearn/tasks/#41-information-and-installation","title":"4.1. Information and installation","text":""},{"location":"colearn/tasks/#411-information-about-the-dataset","title":"4.1.1. Information about the dataset","text":"<ul> <li>This is a dataset of 70,000 28x28x1 grayscale images of the 10 digits</li> <li>Input for NN are raw 28x28 1 channel images</li> <li> <p>NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1</p> </li> <li> <p>Code folder: here</p> </li> <li>Invoke parameter: -t MNIST</li> </ul>"},{"location":"colearn/tasks/#412-requirements","title":"4.1.2 Requirements","text":"<ul> <li>MNIST dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required</li> </ul>"},{"location":"colearn/tasks/#42-models","title":"4.2. Models","text":""},{"location":"colearn/tasks/#421-mnistconv-keras-model","title":"4.2.1. MNISTConv Keras model","text":"<pre><code>_________________________________________________________\nLayer (type)                   Output Shape       Param #   \n=========================================================\nInput (InputLayer)             (28, 28, 1)        0             \n_________________________________________________________\nConv1_1 (Conv2D)               (28, 28, 64)       640           \nbn1 (BatchNormalization)       (28, 28, 64)       256           \npool1 (MaxPooling2D)           (14, 14, 64)       0             \n_________________________________________________________\nConv2_1 (Conv2D)               (14, 14, 128)      73856         \nbn4 (BatchNormalization)       (14, 14, 128)      512           \npool2 (MaxPooling2D)           (7, 7, 128)        0             \n_________________________________________________________\nflatten (Flatten)              (6272)             0             \nfc1 (Dense)                    (10)               62730         \n=========================================================\nTotal params: 137,994\nTrainable params: 137,610\nNon-trainable params: 384\n_________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#422-mnist-pytorch-model","title":"4.2.2. MNIST Pytorch model","text":"<pre><code>---------------------------------------------------------\nLayer (type)           Output Shape             Param #\n=========================================================\nInput                  [28,28,1]                0\nConv2d-1               [20, 24, 24]             520\nConv2d-2               [50, 8, 8]               25,050\nLinear-3               [500]                    400,500\nLinear-4               [10]                     5,010\n=========================================================\nTotal params: 431,080\nTrainable params: 431,080\nNon-trainable params: 0\n---------------------------------------------------------\n</code></pre>"},{"location":"colearn/tasks/#423-mnistsupermini-keras-model","title":"4.2.3. MNISTSupermini Keras model","text":"<pre><code>________________________________________________________________________________________\nLayer (type)                Output Shape    Param #      Connected to                         \n========================================================================================\ninput_1 (InputLayer)        (28, 28, 1)     0                                                \n________________________________________________________________________________________\nconv2d (Conv2D)             (26, 26, 8)     80           input_1[0][0]                        \nBatch_normalization         (26, 26, 8)     32           conv2d[0][0]                         \nMax_pooling2d               (13, 13, 8)     0            batch_normalization[0][0]            \ndropout (Dropout)           (13, 13, 8)     0            max_pooling2d[0][0]                  \n________________________________________________________________________________________\nSeparable_conv2d            (11, 11, 26)    306          dropout[0][0]                        \nbatch_normalization_1       (11, 11, 26)    104          separable_conv2d[0][0]               \ndropout_1 (Dropout)         (11, 11, 26)    0            batch_normalization_1[0][0]          \n________________________________________________________________________________________\nSeparable_conv2d_1          (11, 11, 26)    936          dropout_1[0][0]                      \n                                                         dropout_2[0][0]                      \n                                                         dropout_3[0][0]                      \n________________________________________________________________________________________\nBatch_normalization_2        (11, 11, 26)   104          separable_conv2d_1[0][0]             \ndropout_2 (Dropout)          (11, 11, 26)   0            batch_normalization_2[0][0]          \n________________________________________________________________________________________\nBatch_normalization_3        (11, 11, 26)   104          separable_conv2d_1[1][0]             \ndropout_3 (Dropout)          (11, 11, 26)   0            batch_normalization_3[0][0]          \n________________________________________________________________________________________\nBatch_normalization_4        (11, 11, 26)   104          separable_conv2d_1[2][0]             \ndropout_4 (Dropout)          (11, 11, 26)   0            batch_normalization_4[0][0]          \n________________________________________________________________________________________\nGlobal_average_pooling2d     (26)           0            dropout_4[0][0]                      \ndense (Dense)                (16)           432          global_average_pooling2d[0][0]   \nBatch_normalization_5        (16)           64           dense[0][0]                          \ndropout_5 (Dropout)          (16)           0            batch_normalization_5[0][0]          \ndense_1 (Dense)              (10)           170          dropout_5[0][0]                      \n========================================================================================\nTotal params: 2,436\nTrainable params: 2,180\nNon-trainable params: 256\n________________________________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#5-pneumonia-xray","title":"5. Pneumonia XRAY","text":""},{"location":"colearn/tasks/#51-information-and-installation","title":"5.1. Information and installation","text":""},{"location":"colearn/tasks/#511-information-about-the-dataset","title":"5.1.1. Information about the dataset","text":"<ul> <li>The Chest X-Ray Images (Pneumonia) dataset consists of 5856 grayscale images of various sizes in 2 classes (normal/pneumonia).</li> <li>Labels are determined by folder name - NORMAL or PNEUMONIA</li> <li>Input for NN are raw resized 128x128 1 channel images</li> <li> <p>NN output is distribution of probabilities for each class i.e. 2 values</p> </li> <li> <p>Code folder: here</p> </li> <li>Invoke parameter: -t XRAY</li> </ul>"},{"location":"colearn/tasks/#512-requirements","title":"5.1.2 Requirements","text":"<ul> <li>Download dataset: here</li> </ul>"},{"location":"colearn/tasks/#52-models","title":"5.2. Models","text":""},{"location":"colearn/tasks/#521-xraysupermini-keras-model","title":"5.2.1. XraySupermini Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                     Output Shape            Param #   \n=================================================================\nInput (InputLayer)               [(128, 128, 1)]         0             \n_________________________________________________________________\nConv1_1 (Conv2D)                 (128, 128, 32)          320           \n_________________________________________________________________\nbn1 (BatchNormalization)         (128, 128, 32)          128           \n_________________________________________________________________\npool1 (MaxPooling2D)             (32, 32, 32)            0             \n_________________________________________________________________\nConv2_1 (Conv2D)                 (32, 32, 64)            18496         \n_________________________________________________________________\nbn2 (BatchNormalization)         (32, 32, 64)            256           \n_________________________________________________________________\nGlobal_max_pooling2d             (64)                    0             \n_________________________________________________________________\nfc1 (Dense)                      (1)                     65            \n=================================================================\nTotal params: 19,265\nTrainable params: 19,073\nNon-trainable params: 192\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#522-xrayresnet50-keras-model","title":"5.2.2. XrayResnet50 Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                     Output Shape            Param #   \n=================================================================\nInput (InputLayer)               [(128, 128, 1)]         0             \n_________________________________________________________________\nresnet50 (Model)                 (4, 4, 2048)            23581440  \n_________________________________________________________________\nglobal_average_pooling2d         (2048)                  0             \n_________________________________________________________________\nflatten (Flatten)                (2048)                  0             \n_________________________________________________________________\nfc1 (Dense)                      (1)                     2049          \n=================================================================\nTotal params: 23,583,489\nTrainable params: 23,530,369\nNon-trainable params: 53,120\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#523-xraypretrainedresnet50-keras-model","title":"5.2.3. XrayPretrainedResnet50 Keras model","text":"<pre><code>_____________________________________________________________________________________\nLayer (type)                Output Shape    Param #   Connected to                \n=====================================================================================\nInput (InputLayer)          (128, 128, 1)   0                                       \n_____________________________________________________________________________________\nconcatenate (Concatenate)   (128, 128, 3)   0         Input[0][0]                                                                                     Input[0][0]                                                                                    Input[0][0]                 \n_____________________________________________________________________________________\ntf_op_layer_mul             (128, 128, 3)  0          concatenate[0][0]           \ntf_op_layer_strided_slice   (128, 128, 3)  0          tf_op_layer_mul[0][0]       \ntf_op_layer_BiasAdd         (128, 128, 3)  0          tf_op_layer_strided_slice[0][0]  \n_____________________________________________________________________________________\nresnet50 (Model)            (4, 4, 2048)   23587712   tf_op_layer_BiasAdd[0][0]            \n_____________________________________________________________________________________\nglobal_average_pooling2d    (2048)         0          resnet50[1][0]              \nflatten (Flatten)           (2048)         0          global_average_pooling2d[0][0]   \n_____________________________________________________________________________________\nfc1 (Dense)                 (1)            2049       flatten[0][0]              \n=====================================================================================\nTotal params: 23,589,761\nTrainable params: 23,536,641\nNon-trainable params: 53,120\n_____________________________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#524-xraydropout-keras-model","title":"5.2.4. XrayDropout Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                     Output Shape            Param #   \n=================================================================\nInput (InputLayer)               [(128, 128, 1)]         0             \n_________________________________________________________________\nConv1_1 (Conv2D)                 (128, 128, 128)         1280          \nbn1 (BatchNormalization)         (128, 128, 128)         512           \npool1 (MaxPooling2D)             (32, 32, 128)           0             \n_________________________________________________________________\nConv2_1 (Conv2D)                 (32, 32, 256)           295168    \nbn2 (BatchNormalization)         (32, 32, 256)           1024          \npool2 (MaxPooling2D)             (8, 8, 256)             0             \n_________________________________________________________________\nflatten (Flatten)                (16384)                 0             \nfc1 (Dense)                      (128)                   2097280   \nbn3 (BatchNormalization)         (128)                   512           \ndropout (Dropout)                (128)                   0             \n_________________________________________________________________\nfc2 (Dense)                      (64)                    8256          \nbn4 (BatchNormalization)         (64)                    256           \ndropout_1 (Dropout)              (64)                    0             \n_________________________________________________________________\nfc3 (Dense)                      (1)                     65            \n=================================================================\nTotal params: 2,404,353\nTrainable params: 2,403,201\nNon-trainable params: 1,152\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#525-xraydropout2-keras-model","title":"5.2.5. XrayDropout2 Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                     Output Shape            Param #   \n=================================================================\nInput (InputLayer)               (128, 128, 1)           0             \n_________________________________________________________________\nConv1_1 (Conv2D)                 (128, 128, 64)          640           \nbn1 (BatchNormalization)         (128, 128, 64)          256           \npool1 (MaxPooling2D)             (64, 64, 64)            0             \n_________________________________________________________________\nConv2_1 (Conv2D)                 (64, 64, 128)           73856         \nbn2 (BatchNormalization)         (64, 64, 128)           512           \npool2 (MaxPooling2D)             (32, 32, 128)           0             \n_________________________________________________________________\nConv3_1 (Conv2D)                 (32, 32, 256)           295168    \nbn3 (BatchNormalization)         (32, 32, 256)           1024          \npool3 (MaxPooling2D)             (16, 16, 256)           0             \n_________________________________________________________________\nConv4_1 (Conv2D)                 (16, 16, 512)           1180160   \nbn4 (BatchNormalization)         (16, 16, 512)           2048          \npool4 (MaxPooling2D)             (8, 8, 512)             0             \n_________________________________________________________________\nConv5_1 (Conv2D)                 (8, 8, 512)             2359808   \nbn5 (BatchNormalization)         (8, 8, 512)             2048          \npool5 (MaxPooling2D)             (4, 4, 512)             0             \n_________________________________________________________________\nflatten (Flatten)                (8192)                  0             \nfc1 (Dense)                      (256)                   2097408   \nbn6 (BatchNormalization)         (256)                   1024          \ndropout (Dropout)                (256)                   0             \n_________________________________________________________________\nfc2 (Dense)                      (128)                   32896         \nbn7 (BatchNormalization)         (128)                   512           \ndropout_1 (Dropout)              (128)                   0             \n_________________________________________________________________\nfc3 (Dense)                      (64)                    8256          \nbn8 (BatchNormalization)         (64)                    256           \ndropout_2 (Dropout)              (64)                    0             \n_________________________________________________________________\nfc4 (Dense)                      (1)                     65            \n=================================================================\nTotal params: 6,055,937\nTrainable params: 6,052,097\nNon-trainable params: 3,840\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#526-xrayvgg16-keras-model","title":"5.2.6. XrayVGG16 Keras model","text":"<pre><code>_____________________________________________________________________________________\nLayer (type)                 Output Shape     Param #    Connected to                \n=====================================================================================\nInput (InputLayer)           (128, 128, 1)    0                  \n_____________________________________________________________________________________\nconcatenate (Concatenate)    (128, 128, 3)    0          Input[0][0]                 \n                                                         Input[0][0]                 \n                                                         Input[0][0]                 \n_____________________________________________________________________________________\ntf_op_layer_mul               (128, 128, 3)    0         concatenate[0][0]           \nTf_op_layer_strided_slice     (28, 128, 3)     0         tf_op_layer_mul[0][0]       \ntf_op_layer_BiasAdd           (128, 128, 3)    0         tf_op_layer_strided_slice[0][0]  \n_____________________________________________________________________________________\nvgg16 (Model)                 (4, 4, 512)      14714688  tf_op_layer_BiasAdd[0][0]            \n_____________________________________________________________________________________\nflatten (Flatten)             (8192)           0         vgg16[1][0]                  \nfc1 (Dense)                   (1)              8193      flatten[0][0]                \n=====================================================================================\nTotal params: 14,722,881\nTrainable params: 14,722,881\nNon-trainable params: 0\n_____________________________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#527-xraymini-keras-model","title":"5.2.7. XrayMini Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                     Output Shape            Param #   \n=================================================================\nInput (InputLayer)               [(128, 128, 1)]         0             \n_________________________________________________________________\nConv1_1 (Conv2D)                 (128, 128, 128)         1280          \nbn1 (BatchNormalization)         (128, 128, 128)         512           \npool1 (MaxPooling2D)             (32, 32, 128)           0             \n_________________________________________________________________\nConv2_1 (Conv2D)                 (32, 32, 256)           295168    \nbn2 (BatchNormalization)         (32, 32, 256)           1024          \npool2 (MaxPooling2D)             (8, 8, 256)             0             \n_________________________________________________________________\nflatten (Flatten)                (16384)                 0             \nfc1 (Dense)                      (1)                     16385         \n=================================================================\nTotal params: 314,369\nTrainable params: 313,601\nNon-trainable params: 768\n_________________________________________________________________\n</code></pre>"},{"location":"colearn/tasks/#527-xrayonemb-keras-model","title":"5.2.7. XrayOneMB Keras model","text":"<pre><code>_________________________________________________________________\nLayer (type)                   Output Shape            Param #   \n=================================================================\nInput (InputLayer)             (128, 128, 1)           0             \n_________________________________________________________________\nConv1_1 (Conv2D)               (128, 128, 64)          640           \nbn1_1 (BatchNormalization)     (128, 128, 64)          256           \nConv1_2 (Conv2D)               (128, 128, 64)          36928         \nbn1_2 (BatchNormalization)     (128, 128, 64)          256           \npool1 (MaxPooling2D)           (64, 64, 64)            0             \n_________________________________________________________________\nConv2_1 (Conv2D)               (64, 64, 64)            36928         \nbn2_1 (BatchNormalization)     (64, 64, 64)            256           \nConv2_2 (Conv2D)               (64, 64, 64)            36928         \nbn2_2 (BatchNormalization)     (64, 64, 64)            256           \npool2 (MaxPooling2D)           (32, 32, 64)            0             \n_________________________________________________________________\nConv3_1 (Conv2D)               (32, 32, 128)           73856         \nbn3_1 (BatchNormalization)     (32, 32, 128)           512           \nConv3_2 (SeparableConv2D)      (32, 32, 128)           17664         \nbn3_2 (BatchNormalization)     (32, 32, 128)           512           \npool3 (MaxPooling2D)           (16, 16, 128)           0             \n_________________________________________________________________\nConv4_1 (SeparableConv2D)      (16, 16, 128)           17664         \nbn4_1 (BatchNormalization)     (16, 16, 128)           512           \n_________________________________________________________________\nConv4_2 (SeparableConv2D)      (16, 16, 128)           17664         \nbn4_2 (BatchNormalization)     (16, 16, 128)           512           \n_________________________________________________________________\npool4 (AveragePooling2D)       (4, 4, 128)             0             \nflatten (Flatten)              (2048)                  0             \n_________________________________________________________________\nfc1 (Dense)                    (1)                     2049          \n=================================================================\nTotal params: 243,393\nTrainable params: 241,857\nNon-trainable params: 1,536\n_________________________________________________________________\n</code></pre>"},{"location":"create-react-app/example_dapp/","title":"\"Hello Cosmos\"","text":"<p>\"Hello World\" but with friends!</p> <p>Projects generated from the template will include a fully functional example DApp frontend, integrating with the current Fetch test-net directly as well as a cosmwasm contract deployed to the test-net.</p> <p>The \"Hello Cosmos\" example DApp demonstrates the following kinds of interactions:</p> <ul> <li>CosmWasm contract query</li> <li>CosmWasm contract call</li> <li>Native token transfer</li> <li>Fetch / Keplr wallet integration</li> </ul>"},{"location":"create-react-app/example_dapp/#features","title":"Features","text":"<ul> <li>Print greetings submitted by other users</li> <li>Connect with Fetch wallet<ul> <li>Print address</li> <li>Print balance</li> </ul> </li> <li>Submit greeting<ul> <li>(one greeting per address)</li> </ul> </li> <li>Tip other users<ul> <li>(half testnet balance)</li> </ul> </li> </ul>"},{"location":"create-react-app/introduction/","title":"Create React App Template","text":"<p>Create React App is a CLI utility which facilitates generation of react app boilerplate via templates.</p> <p>In order to expedite distributed application (DApp) development, we maintain a create-react-app template: cra-template-cosmjs-keplr. Projects generated from this template include all the necessary dependencies and build configuration needed to:</p> <ul> <li>Interact with the Fetch or Keplr wallet<ul> <li>fetchai/fetch-wallet (github)</li> </ul> </li> <li>Interact with cosmos-based networks<ul> <li>@cosmjs/stargate (npm)</li> <li>@cosmjs/cosmwasm-stargate (npm)</li> </ul> </li> </ul> <p>To generate a new project:</p> <pre><code>npx create-react-app --template cosmjs-keplr\n</code></pre> <p>The generated project also comes with an example DApp, \"Hello Cosmos\", which demonstrates Cosmjs and Keplr API usage in the form of a simple frontend.</p>"},{"location":"fetch-wallet/","title":"Getting Started","text":"<p>The Fetch Wallet, originally forked from the Keplr wallet, is a generic wallet for interacting with the Fetch blockchain network and other ledgers built using the Cosmos-SDK, and supports the Inter-Blockchain Communication (IBC) protocol.</p> <p>Some of its highlights include:</p> <ul> <li>Private keys and mnemonics are encrypted (using scrypt) and are stored locally on device. This means neither Fetch nor the websites visited have access to these sensitive data. </li> <li>Multiple accounts on the Fetch ledger and other Cosmos-based ledgers.</li> <li>Support for Ledger hardware wallets for enhanced security.</li> <li>Native and IBC token transfers.</li> </ul>"},{"location":"fetch-wallet/#compatibility","title":"Compatibility","text":"<p>The Fetch wallet works on all Chromium-based web browsers, including Chrome, Brave, Edge and Decentr.</p>"},{"location":"fetch-wallet/#get-the-wallet","title":"Get the Wallet","text":"<p>Install the Fetch wallet from the Chrome web store.</p> <p>Info</p> <p>At this time, you cannot run the Keplr and Fetch wallets together because they interfere. Please disable the Keplr wallet before using the Fetch wallet.</p>"},{"location":"fetch-wallet/#version","title":"Version","text":""},{"location":"fetch-wallet/#first-time-use","title":"First-time use","text":"<p>The first time you open the wallet, you will see the following options:</p> <ul> <li>Create a new account</li> <li>Import existing account</li> <li>Import ledger</li> <li>Migrate from ETH</li> </ul> <p>After account creation or import is completed, the wallet will be accessible from your browser's extensions.</p>"},{"location":"fetch-wallet/#how-to-contribute","title":"How to contribute","text":"<p>You can contribute to this project by engaging with its repository on GitHub:</p> <p>GitHub repository</p>"},{"location":"fetch-wallet/account_management/","title":"Account Management","text":""},{"location":"fetch-wallet/account_management/#welcome-page","title":"Welcome Page","text":"<p>You can create a new account, import an existing account, connect your hardware wallet, or recover migrated Ethereum accounts from the welcome page. To get there: </p>"},{"location":"fetch-wallet/account_management/#first-time-use","title":"First time Use","text":"<p>The first time you open the wallet, you will be presented with the welcome page. </p>"},{"location":"fetch-wallet/account_management/#not-the-first-time","title":"Not the First Time","text":"<ol> <li>Ensure you are logged into the wallet.</li> <li>Click the account icon  in the top right corner of the dashboard, then + Add Account.</li> </ol> <p>Info</p> <p>In some contexts, the term account refers to an address that has, at some point in time, had a balance (and therefore a state on the ledger). In this context, it is not necessary for an account to have a balance, for example for it to be imported.</p>"},{"location":"fetch-wallet/account_management/#creating-a-new-account","title":"Creating a new account","text":"<p>Using the wallet, you can create a new account and address on the Fetch ledger:</p> <ol> <li>On the welcome page, click Create new account.</li> <li> <p>Choose a 12 or 24 word long mnemonic seed and securely back it up.</p> <p>Warning</p> <p>KEEP IT SAFE! Anyone with your mnemonic seed can access your wallet and take your assets.</p> <p>Danger</p> <p>DON'T LOSE IT! Lost mnemonic seed cannot be recovered! If you lose your mnemonic seed you will lose access to your wallet.</p> </li> <li> <p>Give your account a name and set a password if one is not set (i.e. if it is the first time you open the wallet, or in case you have removed all of your accounts). The password will be used the next time you want to use the wallet or make important changes to your account. Hit Next.</p> </li> <li>Rearrange the mnemonic phrases by clicking on them in the correct order to confirm your mnemonic seed. Then click Register.</li> </ol>"},{"location":"fetch-wallet/account_management/#existing-account","title":"Existing account","text":""},{"location":"fetch-wallet/account_management/#importing-an-existing-account","title":"Importing an existing account","text":"<p>If you have an account on the Fetch network, for example having had one already on the Fetch wallet and want to access it again, have an account on another wallet (e.g. Cosmostation, Keplr, ...) and wish to bring it to the Fetch wallet, or having created an address using one of our tools (e.g. the AEA framework), you can import it into the Fetch wallet:</p> <ol> <li>On the welcome page, click Import existing account.</li> <li> <p>Enter your mnemonic seed (set of words) or private key (hexidecimal).</p> <p>Warning</p> <p>KEEP IT SAFE! Anyone with your mnemonic seed or private key can access your wallet and take your assets.</p> <p>Tip</p> <p>It is more convenient, and preferable, to use the mnemonic over private keys.</p> </li> <li> <p>Give your account a name and set a password if one is not set (i.e. if it is the first time you open the wallet, or in case you have removed all of your accounts). The password will be used the next time you want to use the wallet or make important changes to your account. Hit Next.</p> </li> </ol>"},{"location":"fetch-wallet/account_management/#using-a-hardware-wallet","title":"Using a Hardware Wallet","text":"<p>If you have a Ledger hardware wallet and wish to keep your key and mnemonics on that device while using the Fetch wallet:</p> <p>Info</p> <p>Currently only ledger hardware wallets are supported.</p> <ol> <li>On the welcome page, click Import ledger.</li> <li>Give your account a name and set a password if one is not set (i.e. if it is the first time you open the wallet, or in case you have removed all of your accounts). The password will be used the next time you want to use the wallet or make important changes to your account. Hit Next.</li> <li>Follow the instructions on the popup to connect your device.</li> </ol> <p>Warning</p> <p>Please ensure you keep your mnemonic seed somewhere safe where others cannot access it. If you lose it, your wallet will be inaccessible once you log out. The password for your account should also be kept safe but is not necessary for recovery if you have your mnemonic seed.</p> <p>Info</p> <p>If you lose your password, you need to uninstall and re-install the Fetch wallet and select <code>Import existing account</code>. Then use the mnemonic seed for your account and choose a new password.</p>"},{"location":"fetch-wallet/account_management/#switching-accounts","title":"Switching accounts","text":"<p>If you have multiple accounts set up on the Fetch wallet, to switch between them: </p> <ol> <li>Ensure you are logged into the wallet. </li> <li>Click the account icon  in the top right corner of the dashboard. </li> <li>Select the account you want to switch to.</li> </ol>"},{"location":"fetch-wallet/account_management/#removing-an-account","title":"Removing an Account","text":"<p>To remove an account from your Fetch wallet:</p> <ol> <li>Ensure you are logged into the wallet.</li> <li>Click the account icon  in the top right corner of the dashboard.</li> <li>Hit ... (the three dots icon) for the account you want to remove and choose Delete Account. </li> <li> <p>Enter your wallet password.</p> <p>Warning</p> <p>If you have not yet backed up your mnemonic seed, click on Back-up account and enter you password to view it. Then back it up safely. If you lose your mnemonic seed you will lose access to your account.</p> </li> <li> <p>Click Confirm to remove the account from your wallet.</p> </li> </ol>"},{"location":"fetch-wallet/address_book/","title":"Address Book","text":"<p>The Fetch wallet's Address Book makes it easy to transfer funds to accounts you frequently use. To add an address to the address book:</p> <ol> <li>From the wallet dashboard click the  icon in the top left, then Address Book.</li> <li>Select the network this address belongs to, then + Add New.</li> <li>Fill in the details:<ul> <li>Name: the name you give to this account  </li> <li>Address: the account's address</li> <li>Default memo: the memo used by default when sending funds to this account</li> </ul> </li> <li>Hit Save.</li> </ol> <p>Tip</p> <p>When sending funds, instead of writing the address of the recipient you can hit the icon to the right to select an account from the address book.</p> <p></p>"},{"location":"fetch-wallet/connections/","title":"Connections","text":"<p>Some webpages can connect to your wallet and enable interactions that are otherwise not possible. </p> <p>Example</p> <p>By default, the fetch ledger browser only shows a list of active validators for the Fetch network along with some staking-related details (e.g. the validators' commission rates and number of delegated FETs).  </p> <p>However if you have your wallet set up on the browser, you will see a button for connecting your wallet in the top right of the page, and if you do, you will get the option of staking your FETs with any of the validators on the list and accessing your staking dashboard. To learn more, visit the staking guide.   </p> <p>If you view such webpages using a browser with the Fetch wallet, you will see additional options. If you use a browser with no wallet, those options will not be shown. </p> <p>You can manage these connections on the wallet:</p> <ol> <li>From the wallet dashboard, click the  icon in the top left, then Settings.</li> <li> <p>Click on Manage Connections.</p> <p>Info</p> <p>Here you will see a list of webpages which have been connected to your wallet. Visiting these pages will not ask you for a connection with your wallet again; the page will automatically connect. </p> <p>You have the option of removing and thus revoking these connections. If you do, the next time you visit that page, it will not automatically connect to your wallet.</p> </li> <li> <p>To remove a connection, click the  icon on the connection you wish to remove.</p> </li> </ol>"},{"location":"fetch-wallet/deposit/","title":"Deposit Tokens","text":"<p>To transfer funds to your account on the Fetch wallet:</p> <p>In the wallet or application you are using to send the funds, use your account's address as the destination account to which the funds must go.</p>"},{"location":"fetch-wallet/deposit/#to-copy-your-accounts-address","title":"To copy your account's address","text":"<ol> <li>Ensure you are logged into the wallet.</li> <li>Either click on the account address at the top of the dashboard (under the account name): </li> <li>Or select Deposit and scan the QR code.</li> </ol> <p>Once you send the tokens, the balance should be updated.</p> <p>Failure</p> <p>If your origin wallet says that the address (which should start with \"<code>fetch</code>\") is invalid, it is probably expecting an Ethereum address (beginning with \"<code>0x</code>\") and is most likely trying to send ERC20 FET. In this case, you need to use the token bridge to swap your ERC20 FET for native FET.</p> <p>Warning</p> <p>You should not send ERC20 FET to this wallet. If you do, you will lose your tokens. The Fetch wallet can only hold native FET tokens and not ERC20 FET tokens.</p>"},{"location":"fetch-wallet/migrate_erc20/","title":"Recover Migrated Ethereum Account","text":"<p>Prior to the transition to our native Cosmos SDK-based ledger, ERC20 FETs staked using accounts on Ethereum were migrated to native accounts on the Fetch main network. These accounts correspond to the private key of their associated Ethereum accounts. </p> <p>These native accounts can be accessed by transforming the original Ethereum keypair into a native Fetch keypair and address:</p> <ol> <li>On the welcome page, click Migrate from ETH.</li> <li>In the next page, click Migrate a Metamask Private Key.</li> <li>Enter the address and private key of the Ethereum account which staked ERC20 FETs.</li> <li>Give your account a name and set a password if one is not set (i.e. if it is the first time you open the wallet, or in case you have removed all of your accounts). The password will be used the next time you want to use the wallet or make important changes to your account. Hit Next.</li> </ol>"},{"location":"fetch-wallet/send_tokens/","title":"Send Tokens","text":"<p>On this page, you can find instructions on how to send tokens using native transfers and the Inter-Blockchain Communication (IBC) protocol.</p>"},{"location":"fetch-wallet/send_tokens/#native-network-transfer","title":"Native network transfer","text":"<ol> <li>Ensure you are logged into the wallet.</li> <li>Select Send.</li> <li>Fill in the details of your transaction:<ul> <li>Recipient: the address you want to send the tokens to</li> <li>Token: the token denomination or type</li> <li>Amount: the number of tokens you want to send with this transaction (you can see your current balance above the Amount)</li> <li>Memo (Optional): some transactions (e.g. to/from some exchanges) require a specific memo. If not needed, you can leave it blank.</li> <li>Fee: the transaction fee. Choose from Low, Average and High</li> </ul> <p>Tip</p> <p>Usually, the lower the transaction fee, the longer you need to wait for your transaction to be settled on the network.</p> </li> <li>Press Send.</li> <li>In the summary screen, review the details and if everything is correct, select Approve.</li> </ol> <p>Info</p> <p>You can check the status of your transaction via the explorer.</p>"},{"location":"fetch-wallet/send_tokens/#ibc-transfer","title":"IBC transfer","text":"<ol> <li>Ensure you are logged into the wallet.</li> <li> <p>Make sure IBC transfers are enabled and that your selected network supports it.</p> <p>Tip</p> <p>To enable IBC transfers in the wallet:</p> <p>From dashboard, click the  icon in the top left, then Settings. Toggle the Show Advanced IBC Transfers switch on.</p> <p></p> <p>Note</p> <p>If your selected network does not support IBC transfers, you will not see an IBC Transfer section in the dashboard.</p> </li> <li> <p>Click the Transfer button in the IBC Transfer section.</p> <p></p> </li> <li> <p>Fill in the details of your transaction:</p> <ul> <li> <p>Destination Chain: the destination blockchain.</p> <p>Info</p> <p>If you do not see your desired chain, you need to set up IBC channels first.</p> </li> <li> <p>Recipient: the address you want to send the tokens to</p> </li> <li>Memo (Optional): an optional memo.</li> </ul> </li> <li> <p>Press Next.</p> </li> <li>In the next page, provide the following:<ul> <li>Token: the denomination or type of the tokens being sent</li> <li>Amount: the number of tokens to be sent</li> <li>Fee: the transaction fee. Choose from Low, Average, High.</li> </ul> </li> <li>Hit Submit.</li> <li>The wallet now shows you a summary of the transaction. Review it and if you are happy, hit Approve to complete the transfer.</li> </ol> <p>Warning</p> <p>Do not send tokens via IBC directly to an exchange. In most cases, this will result in the loss of your funds.</p>"},{"location":"fetch-wallet/send_tokens/#first-time-origindestination-transfer","title":"First-time origin/destination transfer","text":"<p>Before being able to make an IBC transfer between any two chains for the first time, an IBC channel must be configured in the wallet:</p> <ol> <li>Follow the instructions for making an IBC transfer, up to Step 4.</li> <li>Click the Select Chain drop-down.</li> <li>Select + New IBC Transfer Channel.</li> <li> <p>Select the Destination Chain and enter the source Channel ID (e.g. <code>channel-100</code>).</p> <p>Tip</p> <p>To find out the IBC channel ID between any two chains:</p> <ol> <li>Head over to this page</li> <li>At the top, select the sending chain, for example Fetch.AI. Then below it, click IBC RELAYERS.</li> <li>Select the destination chain, for example OSMOSIS. </li> <li>You can now see the channels between the two chains. Select an active channel (in green) and note the sending chain's channel ID. For Fetch.AI to Osmosis, the sending chain's (Fetch.AI's) channel ID is <code>channel-10</code>.</li> <li>Enter the channel ID in the Fetch wallet (<code>channel-10</code> in our example).</li> </ol> <p>Info</p> <p>Remember to write the channel ID in lower case (i.e. <code>channel-X</code>)</p> <p>Warning<p>If there are no green channels, the relayers are temporarily inactive. You need to wait until one becomes active again.</p> </p> </li> <li> <p>Click Save.</p> </li> </ol> <p>Failure</p> <p>If you input an incorrect Channel ID, either the wallet will not accept it and shows you an error, or your transaction could get stuck in an inactive channel.</p>"},{"location":"fetch-wallet/stake/","title":"Staking","text":"<p>Clicking the Stake button on the Fetch wallet dashboard opens the Fetch ledger browser. From here, you can connect your wallet and stake your FETs. To learn how, follow the staking guide.</p>"},{"location":"fetch-wallet/stake/#claim-rewards","title":"Claim rewards","text":"<p>If your account has any tokens staked, you can withdraw your rewards from the wallet: </p> <ol> <li>Ensure you are logged into the wallet.</li> <li> <p>From the wallet dashboard, select Claim.</p> <p>Info</p> <p>This will claim the total rewards accrued for your stakes across every validator.</p> </li> <li> <p>The wallet shows you a summary of the transaction. Review it, select a transaction fee, and if you are happy, hit Approve to complete the operation.</p> </li> </ol> <p>You should now see the rewards added to your Total Balance.</p> <p>Info</p> <p>To claim rewards from each validator individually, see the claim rewards using the staking dashboard.</p>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/","title":"Agent-Based and Multi-Agents Systems","text":"<p>An agent is a piece of software that represents an entity (individual, organisation, or object) and acts continuously and autonomously  (with limited or no interference) on their behalf. </p> <p>The most important defining characteristic of an agent is its autonomy, that is the ability to act on its own without external direction from its owner in response to situations it encounters.</p> Note <p>What differentiates agents with other software paradigms (e.g. smart contracts, web apps) is that as well as being reactive, meaning they respond to other agents and changes in their environments, they are also proactive, which means that they take the initiative and perform actions to achieve their goals.</p>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/#key-features-of-agents","title":"Key features of agents","text":"<ol> <li> <p>Representation: Agents are owned by and operate on behalf of an entity, for example an individual, family, company, government, or object, and look after their owner's interests.</p> </li> <li> <p>Autonomy: Agents operate with limited or no interference and do not need to be constantly told what to do. They perform actions continuously according to their internal reasoning system.</p> </li> <li> <p>Self-Interested: Each agent primarily looks after its own interests (which is aligned with those of its owner) and not necessarily the interests of other agents.</p> </li> <li> <p>Proactive:  Agents have goals to achieve allowing them to take the initiative and perform actions that get them closer to achieving their goals. This means an agent typically compares the outcome of different actions relative to its goals and selects the one that takes it closer to them.</p> </li> <li> <p>Reactive: Agents respond to other agents, services, etc., and changes in their environments. A great example of this behaviour is a heating system with a thermostat that constantly monitors its environment and turns the heating on or off when the temperature changes.</p> </li> </ol> Note <p>Agent characteristics and behaviors may vary in their extent and sophistication. An agent may differ from other agents, in the amount of information in its decisions process, its internal models of the external world, its view of the possible reactions of other agents in response to its actions, and the size of the memory of past events the agent retains and uses in making its decisions. Further instances of differentiating factors are the amounts of resources used by agents or accumulated as a result of their interactions.</p>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/#agent-based-modelling","title":"Agent-Based Modelling","text":"<p>In agent-based modelling (ABM), a system is represented as a group of independent decision-making units, i.e. agents. Each agent evaluates its own circumstances and makes decisions based on a set of rules. Agents can act in a variety of ways that are suitable for the system they are representing (e.g. producing, consuming, or selling). An agent-based model, at its most basic form, consists of a system of agents and the connections between them. Even a straightforward agent-based model has the potential to display intricate behavioural patterns and provide important details about the behaviour of the emulated real-world system.</p> <p>Agent-based modelling is used in various application areas, spanning the physical, biological, social, and management sciences. Agent-based models have also been developed in the fields of economics, sociology, anthropology, and cognitive science. Various social phenomena have been investigated using agent-based models that are not easily modeled using other approaches.</p> <p>Example</p> <p>Agent-based models can be used to analyze existing and hypothetical markets, for instance, modelling possible futures for a market directed towards space tourism, to analyze how companies represented by agents would compete and offer products to customers in this hypothetical market.</p>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/#multi-agents-systems","title":"Multi-Agents Systems","text":"<p>A Multi-Agents System (MAS) is a group of agents that interact with each other and the environment to achieve specific goals. In such systems, agents may not have full knowledge of both the environment and the internal state of other agents. </p> Note <p>Interactions between agents is an important feature that enables them to use knowledge of other agents and learn more about the environment in a compressed time period. This type of interaction may be cooperative or competitive. In a cooperative interaction, agents work with each other towards a common goal. The aim of this interaction is to enable agents to distribute and share their knowledge and use the intelligence and capabilities of each other to solve problems. In a competitive interaction, agents may compete to obtain individual resources and achieve individual goals.</p>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/#benefits","title":"Benefits","text":"<ol> <li> <p>Decentralization: multi-agents systems are decentralized. The authority to make management decisions about the system is distributed among the participants. A multi-agents system is run for its participants by its participants.</p> </li> <li> <p>Heterogeneity: agents in multi-agent systems are owned and operated by different entities and so are typically not uniformly designed. For instance, the agents may be composed of different hardware or software components.</p> </li> <li> <p>Scalability: multi-agents systems are easy to scale. You simply add agents to the system to grow the system.</p> </li> <li> <p>Robustness: multi-agents systems are intrinsically very robust as no single failure point takes down the system.</p> </li> <li> <p>Adaptability: multi-agents systems adapt to changing circumstances effectively as each agent autonomously adjusts to changing circumstances.</p> </li> </ol>"},{"location":"learn_the_concepts/agent-based_and_multi-agents_systems/#drawbacks","title":"Drawbacks","text":"<ol> <li> <p>Complexity: multi-agents systems are quite complex to set up, maintain and troubleshoot. You have to use a pre-existing framework or build one, and getting all the agents to communicate effectively together can be a challenge. As these are decentralized systems (i.e. no central authority), managing the system is more complicated than a centralized one, as participants need to be involved in management decisions. The complexity of MASs can increase rapidly with the number of agents, the interactions among them, and the complexity of their behavior. </p> </li> <li> <p>Unpredictability: with every agent acting in their own interest, it might be easy to predict what an individual agent is trying to achieve. However, it is much more difficult to predict the direction the whole system moves towards, as this is the result of the many interactions between every individual agent in the system.</p> </li> </ol> <p>Multi-agent systems have received tremendous attention from scholars in different disciplines, ranging from computer science to civil engineering, in order to solve complex problems by subdividing them into smaller tasks. The individual tasks are allocated to autonomous agents, and each one of them decides on a proper action to solve the task using multiple inputs.</p>"},{"location":"learn_the_concepts/glossary/","title":"Glossary","text":"<ul> <li> <p>ACN (Agent Communication Network): it is a peer-to-peer communication network for autonomous economic agents.</p> </li> <li> <p>Address: an address is a string of alphanumeric characters (that may also be seen as a QR code that can be read by a smartphone) and it is used on a blockchain network to transmit and receive transactions. The address in Ethereum starts with 0x (e.g. ) and is also called public key.</p> </li> <li> <p>AEA (Autonomous Economic Agent): it is an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. AEAs are a special type of agent.</p> </li> <li> <p>AEA Registry: it is a repository of packages for the Autonomous Economic Agent (AEA) framework. Five types of packages are currently supported: entire agents and four agent components, including skills, connections, protocols and contracts. </p> </li> <li> <p>Airdrop: it is a mean of distributing tokens to wallet addresses using digital money or tokens. Airdrops are occasionally used for marketing in return for easy actions like sharing, referring, or downloading an app.</p> </li> <li> <p>Altcoin: any cryptocurrency alternative to Bitcoin. Many alternative cryptocurrencies are modified forks of Bitcoin (e.g. Litecoin). </p> </li> <li> <p>AML (Anti-Money Laundering): this refers to a group of international rules implemented to reduce the likelihood that criminal organizations or individuals would use money laundering. In different countries, these guidelines and legislation are applied to cryptocurrencies with diverse results.</p> </li> <li> <p>Arbitrage: arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from tiny differences in the asset's listed price.</p> </li> <li> <p>API (Application Programming Interface): it is a software bridge that enables communication between two independent programmes. APIs specify how different components will communicate with one another.</p> </li> <li> <p>Automated Market Maker: an automated market maker (AMM) is a system that automatically facilitates buy and sell orders on a decentralized exchange. In contrast to regular market makers, AMMs function by using self-executing computer programs, also known as smart contracts. These smart contracts automatically clear transactions between buyers and sellers.</p> </li> <li> <p>BEP-20: according to Binance Academy, \"BEP-20 is a token standard on Binance Smart Chain that extends ERC-20, the most common Ethereum token standard. You can think of it as a blueprint for tokens that defines how they can be spent, who can spend them, and other rules for their usage. Due to its similarity to Binance Chain\u2019s BEP-2 and Ethereum\u2019s ERC-20, it\u2019s compatible with both.BEP-20 was conceived as a technical specification for Binance Smart Chain, with the goal of providing a flexible format for developers to launch a range of different tokens. These could represent anything from shares in a business to dollars stored in a bank vault\".</p> </li> <li> <p>Bid and Ask Prices: the term bid and ask refers to a two-way price quotation that indicates the best potential price at which a security can be sold and bought at a given point in time. The bid price represents the maximum price that a buyer is willing to pay for a share of stock or other security. The ask price represents the minimum price that a seller is willing to take for that same security. A trade or transaction occurs when a buyer in the market is willing to pay the best offer available, or is willing to sell at the highest bid. The difference between bid and ask prices, or the spread, is a key indicator of the liquidity of the asset. In general, the smaller the spread, the better the liquidity.</p> </li> <li> <p>Block: it is an essential part of every blockchain. Imagine a blockchain as a continuously updated ledger that is synchronized between any number of distinct nodes (in fact, the term \"distributed ledger technology\" is also used to describe it). A block of transactions is cryptographically locked together and formally recorded when a predetermined number of transactions have been added to the ledger and consensus has been obtained among the nodes that the transactions are authentic. This \"block\" serves as the foundation for the following one. As a result, they are all connected in a chain, thus the name blockchain.</p> </li> <li> <p>Block Depth: A block's position index in the blockchain relative to the latest (most recently added) block. For instance, a block that is five blocks before the latest block will have a block depth of 5.</p> </li> <li> <p>Block Explorer: it is a software with a graphical user interface (GUI), that allows users to read and analyze the data contained on a blockchain.</p> </li> <li> <p>Block Height: a block's position index in the blockchain relative to the genesis (zeroeth) block. It represents the number of blocks on a blockchain that are interconnected. For instance, the initial block (i.e. Genesis Block), would have height 0 whereas the 5th block added to a chain would have a block height of 5.</p> </li> <li> <p>Block Reward: the payment made to a miner for successfully hashing a block of transactions. Cryptocurrencies and transaction fees are two possible types of block rewards. Whether or not all of the coins have previously been successfully mined depends on the policy followed by the relevant cryptocurrency.</p> </li> <li> <p>Block Period: the length of time it takes for a block of transactions to be confirmed by the network, either by miners under PoW or by validators under PoS, is referred to as \"block time.\" Also see \"Proof of Work\" and \"Proof of Stake\".</p> </li> <li> <p>Blockchain: the blockchain is a digital ledger of all the transactions ever made in a particular cryptocurrency. It\u2019s composed of individual blocks that are chained to each other through a cryptographic signature. Each time a block\u2019s capacity is reached, a new block is added to the chain. The blockchain is repeatedly copied and saved onto thousands of computers all around the world, and it must always match each copy. As there is no master copy stored in one location, it\u2019s considered decentralized.</p> </li> <li> <p>Bug: mistakes in software or other aspects of a program. These mistakes may produce an error in the form of unexpected results or erratic behavior. In the best case, a bug may only affect software performance. In the worst case, it may make the software crash.</p> </li> <li> <p>Bug Bounty: a reward given for disclosing bugs and vulnerabilities in computer programming.</p> </li> <li> <p>Circulating Supply: this term refers to the number of cryptocurrency coins or tokens that are publicly available and circulating in a specific market. The circulating supply of a cryptocurrency can increase or decrease over time.</p> </li> <li> <p>Cold Wallet: a physical storage device used to store cryptocurrencies offline (e.g. a flash drive, hard disk).</p> </li> <li> <p>Collateral: a collateral is something of value given as a guarantee to obtain something else. For instance, a borrower may offer their car as a collateral to a lender when taking out a loan. The vehicle acts as a safeguard or warranty in case the borrower fails to pay their debts. Usually, collateralized loans present much lower interest rates when compared to non-collateralized ones. Collateral can come in different forms. Some of the most common types include mortgage collaterals, invoice financing and margin trading collaterals.</p> </li> <li> <p>Collateralization Ratio: to borrow tokens from a DeFi protocol, one must put up more collateral than the loan is worth. Each protocol can use different collateralization ratios. However, users must maintain the designated ratio to prevent liquidation (i.e. liquidation ratio).</p> </li> <li> <p>Command Line Interface (CLI): it is a text-based user interface. CLIs can provide more core functionality and access to system resources than a graphical user interface (GUI), but at the cost of usability. Because of this, CLIs are generally directed toward developers over the average user. They can be used to demonstrate the functionality underlying a program without expending development time building a more robust user interface.</p> </li> <li> <p>Confirmation: when the blockchain transaction has been validated by the network, a confirmation occurs. This occurs through a process called mining under a Proof of Work (PoW) consensus mechanism and as validation under a Proof of Stake (PoS) consensus mechanism. Theoretically, a transaction that has been successfully confirmed cannot be changed or double spent. The difficulty of a double spend assault increases with the number of confirmations a transaction has.</p> </li> <li> <p>Consensus: the process through which a number of peers, also known as nodes, on a blockchain network come to an agreement over the legitimacy of transactions presented to the network. Proof of Work (PoW) and Proof of Stake (PoS) are the two main consensus procedures.</p> </li> <li> <p>Cryptocurrency: it is a digital currency which has a mathematical foundation that controls the generation of units of currency and using encryption methods to confirm the transfer of payments. Distributed ledger technology is used to keep track of cryptocurrency transactions, which are carried out without the assistance of a central bank.</p> </li> <li> <p>Cryptography: it is the process of encoding data into unintelligible codes to make it secure and hidden. Only the required key may be used to decode and read the data.</p> </li> <li> <p>Crypto Wallet: these wallets store public and private keys allowing users to send, receive, and store tokens. The tokens reside on the blockchain and the wallet accesses them.</p> </li> <li> <p>DAO: a Decentralized Autonomous Organization (DAO) is a collection of individuals that get together without having any decisions made for them by a centralised authority figure or corporation. These are constructed using smart contracts on a blockchain. Members of DAOs frequently pay their way in by buying a governance token designed just for the DAO, which gives them the right to vote on decisions affecting how the money fund is used and handled. People from all around the world may be a part of these organisations, and they frequently interact on Discord channels.</p> </li> <li> <p>Decentralization: it is the term used to describe the transition of power and control to a decentralized system from a centralized structure, government, or party.</p> </li> <li> <p>Decentralized Application (DApp): a computer program that utilizes a blockchain for data storage, runs autonomously, is not controlled or operated from a single entity, is open source and has its use incentivized by the reward of fees or tokens.</p> </li> <li> <p>Decentralized Exchange (DEX): this is a platform which uses smart contracts to exchange cryptocurrencies. Peer-to-peer trading takes place between liquidity pools. This contrasts with centralised exchanges, which are more comparable to cryptocurrency-focused banks or financial firms. The two have significant, ever-changing technological and regulatory variances from one another.</p> </li> <li> <p>Decentralized Finance (DeFi): DeFi stands for decentralized finance. Traditional finance has always relied on a reputable middleman, and because of this, it has always been centralized. For instance, if you need to send money to a friend or family, you depend on your bank to transfer the funds to their account. DeFi, on the other hand, does not need any middlemen. Direct asset transfers are possible between participants. Theoretically, this speeds up and reduces the cost of transactions.</p> </li> <li> <p>Deflationary Token: tokens are deflationary if a percentage is permanently removed from the marketplace over time. Buybacks and burns are a popular way of destroying tokens. This causes scarcity which hopefully makes the price rise.</p> </li> <li> <p>Digital Asset: a scarce, electronically transferred, intangible digital asset having a market price.</p> </li> <li> <p>Digital Identity: a networked or online identity that a person, business, or technological item adopts.</p> </li> <li> <p>Digital Signature: a public key encryption-generated code that is added to an electronic document transmission to validate the document's contents.</p> </li> <li> <p>Distributed Denial of Service (DDoS) Attack: a cyberattack strategy where the attacker repeatedly floods the system with requests in an effort to block the fulfillment of valid requests.</p> </li> <li> <p>DLT (Distributed Ledger Technology): it is a database of data that is duplicated and shared among a network of computers spread out across many locations. It is a flexible way of information recording as opposed to a centralised ledger. Instead of being updated by a centralised authority, the ledger's or record's data is changed by network participants. The information kept on the ledger can be checked and audited, and it can be accessible to some or all users. Value-containing peer-to-peer transfers may be documented on a DLT. The transferred value could be cash, securities, or even private data.</p> </li> <li> <p>Double Spend Attack: it is a malicious attempt to convince two separate parties that one of two conflicting transactions is valid. In such a situation, both transactions appear individually valid, but their combination is not. Thus, only one is included in the blockchain. Due to the nature of blockchain reorganizations, simply showing that a transaction is included in a block is not enough to verify that it is immutable. Transactions are only immutable once they have reached a depth in the chain where a chain reorganization is unlikely to affect them. Double spend attacks can be mitigated by waiting to ensure that a transaction is confirmed by the network and is acceptably immutable before acting on it.</p> </li> <li> <p>ERC-20: it is the standard to which each Ethereum token complies. This standard defines the way each token behaves so that transactions are predictable. Other cryptocurrencies also use the ERC-20 standard, piggybacking on the Ethereum network in the process.</p> </li> <li> <p>ERC-721: this is an additional standard for Ethereum smart contracts that permits the creation of non-fungible tokens, or NFTs. This token standard is used to symbolize a distinct digital asset that cannot be exchanged.</p> </li> <li> <p>Exchange: service for trading cryptocurrency tokens for other tokens or fiat. Exchanges are highly regulated in the European Union, eastern Asia, and the United States of America; thus, many exchanges are located in countries with less oversight. </p> </li> <li> <p>Fiat: according to Investopedia's definition, \"fiat money is a government-issued currency that is not backed by a physical commodity, such as gold or silver, but rather by the government that issued it. It usually requires fiat exchanged at a CEX or through local means such as Bitcoin ATMs to be able to purchase cryptocurrency with fiat currency\".</p> </li> <li> <p>Fork: a fork establishes a different version of a blockchain and is frequently purposefully carried out to update a network. Hard forks result in a new version of the chain that must be embraced in order to continue participating, whereas soft forks result in two chains that are somewhat compatible. A disputed hard fork may result in the creation of two distinct blockchain networks.</p> </li> <li> <p>Fork (Hard): type of fork that is permanently incompatible with the original network. Hard forks typically change transaction data structures, consensus algorithms, or add/remove blocks that would not have otherwise been included.  For example, Bitcoin Cash is a hard fork of Bitcoin, and Ethereum Classic is a hard fork of Ethereum.</p> </li> <li> <p>Fork (Soft): type of fork that is compatible with the data on the original chain. Blocks created on the original chain after a soft fork would be valid on the forked chain; however the reverse does not have to be true. For instance, when Ethereum upgraded to the Byzantium version, it was affected through a soft fork.</p> </li> <li> <p>Gas fees: gas fees (i.e. transaction fees) are rewards paid to miners to incentivize them to support the network's transactions which become written to the blockchain. On the Ethereum network this gas fee unit amount is expressed in gwei. Operations to or from CEXs, DEXs Liquidity Pools and wallets require gas fees. The cost users incur due to gas fees will vary depending on the current supply and demand: when demand on Ethereum or an ERC-20 network is at its highest, these gas fees are at their highest.</p> </li> <li> <p>Gas Limit: you can only spend a certain amount of gas each transaction on the Ethereum network, according to the gas limit. It may also be seen as a \"rough estimate\" of the amount of computer power your transaction will require.</p> </li> <li> <p>Gas Price: the gas price is the amount paid to the network for the computational labour completed during a particular transaction. It is paid in ETH units known as Gwei. The price of gas may fluctuate dramatically depending on network congestion.</p> </li> <li> <p>Governance Tokens: governance tokens are cryptocurrencies that represent voting power on a blockchain project. Governance tokens are used to vote on system parameters such as choice of autonomous market makers to back with liquidity from the liquidity pool, borrowing rates from the liquidity pool, usage of exchange fees, etc. Governance tokens are minted at an exponentially decreasing rate to incentivise early liquidity providers in the system. Minted tokens are distributed in proportion to the amount of liquidity supplied to the system at each block. Some fraction of the exchange fees and autonomous market maker spreads is used to buy back these tokens and burn them in order to reduce the quantity of tokens circulating and thus increasing their value.</p> </li> <li> <p>Graphical User Interface (GUI): it is way of displaying information to the user through stylized, on-screen elements, such as windows and taskbars.</p> </li> <li> <p>Hash: a programmatic function that accepts an input and produces the \"hash value\" or \"digital fingerprint,\" which is an alphanumeric string. Each block in the blockchain has its own hash value as well as the hash value used to validate the transaction that came before it. Transactions on the blockchain are verified via hashes.</p> </li> <li> <p>Hard Fork: in accordance to Binance Academy, \"Hard forks are backward-incompatible software updates. Typically, these occur when nodes add new rules in a way that conflicts with the rules of old nodes. New nodes can only communicate with others that operate the new version. As a result, the blockchain splits, creating two separate networks: one with the old rules, and one with the new rules\".</p> </li> <li> <p>Hot Wallet: a wallet that is continuously linked to the internet, such as one that is kept on a major exchange. Compared to hardware wallets or cold storage solutions, hot wallets are thought to offer less security.</p> </li> <li> <p>IBC Transfers: the Inter-Blockchain Communication protocol (IBC) is an inter-module communication protocol that bridges different blockchains to facilitate communication and feature exchanges between networks with different infrastructure designs and consensus algorithms. </p> </li> <li> <p>Initial Coin Offering (ICO): it is like an initial public offering (IPO) of stock, an initial coin offering is a way for a tokenized business to generate investment from the public. ICOs are regulated by the Securities and Exchange Commission (SEC), even if the tokens are not specifically securities because the language used in promoting a sale can serve to classify tokens as a security offering.</p> </li> <li> <p>KYC (Know-Your-Customer): KYC guidelines fit into the broader scope of Anti-Money Laundering (AML) policies in traditional finance. There is no KYC or AML in DeFi.</p> </li> <li> <p>Ledger: a book or collection of accounts in which account transactions are recorded. </p> </li> <li> <p>Liquidation: liquidation is applied to borrowers. They can have their collateral liquidated if they do not maintain the set collateralization ratio.</p> </li> <li> <p>Liquidation Ratio: this is the level at which the collateralization ratio dips that can trigger liquidation. </p> </li> <li> <p>Liquidity Pool: a liquidity pool is a crowd sourced pool of cryptocurrencies or tokens locked in a smart contract that is used to facilitate trades between the assets on a decentralized exchange (DEX). Many decentralised finance (DeFi) platforms use automated market makers (AMMs), which enable digital assets to be traded in an automatic and permissionless manner through the use of liquidity pools, in place of traditional markets of buyers and sellers.</p> </li> <li> <p>Liquidity Provider: a liquidity provider (LP) is a user who funds a liquidity pool with own crypto assets so as to facilitate trading on the platform and earn passive income on the liquidity deposited.</p> </li> <li> <p>Mainnet: it represents the main network on which transactions on a certain distributed ledger actually occur. The Ethereum mainnet, for instance, serves as the public blockchain for network verification and transaction processing.</p> </li> <li> <p>MAS (Multi-Agent System): a Multi-Agent System is a group of agents that interact with each other and the environment to achieve specific goals. In such systems, agents may not have full knowledge of both the environment and the internal state of other agents. Interactions between agents may be cooperative or competitive. In a cooperative interaction, agents work with each other towards a common goal. The aim of this interaction is to enable agents to distribute and share their knowledge and use the intelligence and capabilities of each other to solve problems. In a competitive interaction, agents may compete to obtain individual resources and achieve individual goals.</p> </li> <li> <p>Metamask: Metamask is a popular Web 3.0 wallet used in DeFi. Other wallets you may hear about are the Binance Wallet and Torus.</p> </li> <li> <p>Miner: a miner is an actor in a blockchain network that has the ability to create and submit new blocks to the chain. Which miner is allowed to produce a specific block may be predetermined, or miners may simultaneously compete to add the next block to the chain.</p> </li> <li> <p>Mining: mining is the process through which cryptocurrency transactions are gathered, verified and recorded into a digital ledger known as blockchain. The work done by miners is essential for maintaining the integrity of the network and is also responsible for introducing new coins into the system. It is the method used by a Proof of Work (PoW) consensus mechanism to verify blocks or transactions before adding them to a blockchain. A miner must use a computer to solve a cryptographic puzzle in order to validate a block. The block is regarded as having been \"mined\" or validated after the computer has figured out the issue. The first computer to mine or verify the block receives a reward represented by cryptocurrencies (e.g. BTC, ETH).</p> </li> <li> <p>Multi-Signature: multisig stands for multi-signature, which is a specific type of digital signature that makes it possible for two or more users to sign documents as a group. Therefore, a multi-signature is produced through the combination of multiple unique signatures. Basically speaking, the funds stored on a multi-signature address can only be accessed by using 2 or more signatures. Therefore, the use of a multisig wallet enables users to create an additional layer of security to their funds.  </p> </li> <li> <p>Network: it represents a set of actors that are collectively interconnected for a common purpose.</p> </li> <li> <p>Node: a node is any computer that is a part of the blockchain network. A full node is a computer able to completely verify transactions and download all of the data associated with a particular blockchain. A lightweight or light node, in contrast, utilizes a separate validation mechanism and does not download the entire blockchain's data.</p> </li> <li> <p>Nonce: this term has a variety of connotations, and depending on the situation, it is employed in many different ways. On the Ethereum mainnet, it refers to a distinct transaction identification number that rises in value with each subsequent transaction to assure different safety measures. It was originally created from a contraction of a term meaning \"not more than once\" (e.g. preventing a double-spend).</p> </li> <li> <p>NFT: Non-Fungible Tokens are cryptographic assets built on a blockchain with unique identification codes and metadata that distinguish them from each other. These were born as ERC-721 crypto assets representing a unique or rare digital or real world item. They let us tokenize things like art, collectibles, even real estate through a securitisation process that takes place on the blockchain. Unlike cryptocurrencies which are identical to each other and can be used as a medium for commercial transactions, NFTs represent unique and irreplaceable tokens, thereby making it impossible for one non-fungible token to be equal to another (i.e. NFTs are not fungible). This ensures a highly transparent and flexible record of ownership. An NFT can only have one owner at a time. Ownership is managed through the unique ID and metadata that no other token can replicate. NFTs are minted through smart contracts which assign ownership and manage the transferability of the NFT itself. When someone mints an NFT, they execute a code stored in the smart contracts that conform to different standards (i.e. ERC-721). This information is added to the blockchain where the NFT will be managed.</p> </li> <li> <p>Open Source Software: it is a software for which the source code that is available to the public. One of the benefits of open source software is that people from outside the core development team can support it, collaboratively creating new features or fixing bugs. Open source licenses typically include language that prevents anyone from reselling the core code without significant changes.</p> </li> <li> <p>Oracle: within the blockchain context, an oracle is a data source used as a bridge between smart contracts and other external sources. More specifically, an oracle is an agent that not only communicates with external data sources but also verifies and authenticates that the data being provided is accurate. Thus, oracles are responsible for providing vital and reliable information to smart contracts, which in turn perform certain tasks.</p> </li> <li> <p>P2P (Peer-to-Peer): P2P describes interactions that take place between two parties, often two different people. Any number of users can be a part of a P2P network. People may conduct transactions or connect with one another over a blockchain network without depending on a middleman or a single point of failure.</p> </li> <li> <p>Private blockchain: a blockchain or distributed ledger with a closed network whose users are all under the supervision of the same organization. For new members on a private blockchain, there must be a verification procedure. Additionally, a private blockchain may place restrictions on who may take part in the network's consensus.</p> </li> <li> <p>Private Key: this is effectively the encrypted password to someone's cryptocurrency assets, and it is also known as a secret key. It is an impossible-to-guess number that is really lengthy. By signing a transaction with your private key, you approve it. You can access and control your crypto assets using private keys.</p> </li> <li> <p>Proof of Stake (PoS): this is a consensus mechanism in which transactions or blocks are verified by a single validator. Those that validate transactions, stake their cryptocurrencies (e.g. ETH), on those particular transactions. If someone accurately verifies a block (or collection of transactions), they are rewarded. A validator often forfeits the cryptocurrency they staked if they verify an invalid transaction. Comparatively speaking to Proof of Work consensus, PoS takes a tiny amount of computational power.</p> </li> <li> <p>Proof of Work (PoW): this is a consensus mechanism in which a network's nodes or individuals collectively mine each block. Each miner in a PoW network must compete to solve a computational puzzle in order to hash a block.  The complexity of successfully hashing each block is increased by the inclusion of solving for a target. The whole hashing procedure will have required some time and computing effort for each block that was hashed. The miner who successfully hashes the block first earns a reward in the form of cryptocurrency. As a result, a hashed block is regarded as Proof of Work. PoW requires a disproportionately higher amount of energy than other consensus processes.</p> </li> <li> <p>Public Blockchain: a network that is completely open to the public, allowing anybody to take part in transactions, run the consensus protocol to help decide which blocks should be added to the chain, and keep track of the shared ledger.</p> </li> <li> <p>Public Key: the wallet address that is visible to the whole public. You must provide your public key in order to receive funds into your account. It is paired with a private key.</p> </li> <li> <p>Python: it is a high-level, all-purpose programming language.</p> </li> <li> <p>Scalability: a change in scale or size to meet the demands of a network This term is used to describe a blockchain project's capacity in its intended use as well as its capability to manage network traffic and future expansion.</p> </li> <li> <p>SDK: a Software Development Kit (SDK) is a set of tools provided by the manufacturer of (usually) a hardware platform, operating system (OS), or programming language. SDKs help software developers create applications for that specific platform, system, or programming language.</p> </li> <li> <p>Slippage: in accordance to Investopedia's definition, \"slippage refers to the difference between the expected price of a trade and the price at which the trade is executed. Slippage can occur at any time but is most prevalent during periods of higher volatility when market orders are used. It can also occur when a large order is executed but there isn't enough volume at the chosen price to maintain the current bid/ask spread. Slippage occurs in all market venues, including equities, bonds, currencies and futures\".</p> </li> <li> <p>Smart Contracts: these are programs having their terms encoded in computer code. These are not legal documents, even if they sometimes include agreements or agreements between parties that resemble a regular legal contract. On the Ethereum Virtual Machine, smart contracts are the most common type of programming. Smart contracts contains a series of automated operations that may be programmed and executed if a series of criteria are satisfied.</p> </li> <li> <p>Soft Fork: a soft fork is an update that is backward-compatible, allowing upgraded nodes to continue connect with not upgraded ones. A soft fork often involves the insertion of a new rule that does not conflict with the existing ones.</p> </li> <li> <p>Snapshot: in the context of cryptocurrencies, the process of capturing the state of a blockchain at a specific block height is frequently referred to as taking a snapshot. In this instance, the snapshot captures the entirety of the blockchain ledger, including all of the current addresses and the information linked with them (i.e. transactions, fees, balance, metadata, and so on). Prior to each round of an airdrop event, snapshots are frequently employed. Tokens are given during an airdrop based on the balance of each blockchain address. In this instance, snapshots are made to capture each token holder's balance at a certain moment in time (i.e. block height). Snapshots are also important during blockchain hard forks, as they mark the block height in which the main chain will be recorded before giving birth to the new chain.</p> </li> <li> <p>Software Agent: a software agent is a computer program that acts on behalf of an entity (e.g. individual, organisation, business). </p> </li> <li> <p>sOEF (Simple Open Economic Framework): the simple-OEF, or sOEF, is a search and discovery service for autonomous economic agents. For additional information: here.</p> </li> <li> <p>Spread: when an order is made on an exchange or market, the disagreement of the difference in price between potential buy and sell offers of an asset is called the spread. A wide spread in price can lead to higher slippage.</p> </li> <li> <p>Stablecoin: a stablecoin is a type of cryptocurrency that is designed to maintain a stable market price. Recently, this type of digital currency has grown in popularity, and we now have numerous stablecoin projects. Although the exact mechanisms vary from one coin to another, stablecoins are supposed to be somewhat resistant to market volatility, so they should not experience significant price changes.</p> </li> <li> <p>Timing Risk: according to Investopedia's definition, \"timing risk is the speculation that an investor enters into when trying to buy or sell an asset based on future price predictions. Timing risk explains the potential for missing out on beneficial movements in price due to an error in timing\".</p> </li> <li> <p>Testnet: a testing network for a new coin, project, product or for potential improvements to an existing product or offering. Testnets (e.g. Kovan Test Network) are used to test the viability and vulnerability of new ideas, concepts, code, and processes prior to moving on to a production network.</p> </li> <li> <p>Token: a unique form of cryptocurrency. It is a method to specifically refer to a cryptocurrency that utilizes a certain blockchain. There are many types (see also ERC-20 and ERC-721).</p> </li> <li> <p>Tokenization: it represents the concept of translating business strategies, goods, or services into discrete, tradeable units that are recorded on a blockchain or other system. Physical goods can be tokenized by associating their unique identifiers with on-chain references.</p> </li> <li> <p>Trustless: in the context of decentralized technology, everyone has a copy of the ledger of every transaction, so there is no need for a third-party repository of truth where confidence is anchored. This means that everyone can independently verify the transactions. Because the system functions uniformly for everyone, the rules and protections incorporated into the blockchain in some ways serve as the foundation for increased trust amongst members.</p> </li> <li> <p>Validator: it is a computer node in charge of validating blocks on a blockchain. It is a person who owns the ability to verify transactions and earn cryptocurrency on a proof-of-stake blockchain as part a reward for validating such blocks.</p> </li> <li> <p>Volatility: volatility describes how quickly and how much the price of an asset changes. It is usually calculated in terms of standard deviations in the annual return of an asset over a set period of time. Because it is a measure of the rapidity and degree of price changes, volatility is often used as an effective measure of the investment risk associated with an asset.</p> </li> <li> <p>Yield Farming: yield farming is the practice of staking or lending crypto assets in order to generate high returns or rewards in the form of additional cryptocurrency. Yield farming protocols incentivize liquidity providers to stake or lock up their crypto assets in a smart contract-based liquidity pool. These incentives can be a percentage of transaction fees or a governance token. These returns are expressed as an annual percentage yield (APY). As more investors add funds to the related liquidity pool, the value of the issued returns rise in value.</p> </li> <li> <p>Volume: a market's volume, also known as trading volume, is the total number of units exchanged during a specific period of time. It is a calculation of the quantity of separate assets that were traded throughout the course of a specific time period. A buyer and a seller are involved in every transaction. The facilitating exchange records the transaction whenever they come to an agreement at a particular price. The trade volume is then calculated using this data. Any trade asset, such as stocks, bonds, fiat money, or cryptocurrencies, may be used to measure trading volume.</p> </li> <li> <p>Wallet: a safe digital place or storage device for cryptographic assets. Wallets can be offline or online (e.g. hot and cold wallets).</p> </li> <li> <p>Web3: it is a notion for a new version of the World Wide Web (WWW) that integrates ideas like decentralization, blockchain technology, and token-based economics is known as Web3 or Web 3.0. It has been likened to Web 2.0 by some engineers and journalists, who claim that data and information are consolidated in a limited number of businesses frequently referred to as \"Big Tech\". Gavin Wood, a co-founder of Ethereum, first used the phrase Web3 in 2014, and in 2021 venture capital firms, major technological companies, and cryptocurrency enthusiasts began to show interest in the concept.</p> </li> <li> <p>51% Attack: a 51% attack is occurring if one person or one group of individuals control more than half of the network's computing power or mining hash rate. By taking over mining activities, blocking or altering transactions, and double-spending coins, this organisation effectively has complete control over the network and the ability to disrupt a cryptocurrency.</p> </li> </ul>"},{"location":"learn_the_concepts/peer_to_peer_systems/","title":"Peer-to-Peer Applications","text":""},{"location":"learn_the_concepts/peer_to_peer_systems/#what-is-a-peer-to-peer-system","title":"What is a Peer-to-Peer System?","text":"<p>A Peer-to-Peer (i.e. P2P)  system is a network of users who communicate with each other without having to go through a middleman. Peer-to-Peer networks consist of a group of devices that collectively store and share files. Every participant (i.e. node) functions as a distinct peer. Normally, all nodes are equally powerful and carry out the same functions. We can outline three key characteristics featuring a P2P system:</p> <ul> <li> <p>No middlemen needed: One of the key characteristics of peer-to-peer systems is that middlemen are not always required, though they are allowed. </p> <p>Example<p>When booking a hotel room with a travel agent, you are going through a middleman. However, booking a room directly with the hotel itself is direct communication, and an example of peer-to-peer interaction.</p> </p> </li> <li> <p>Direct links: direct communication between both parties can be established only in the presence of direct links between them.</p> </li> <li> <p>Direct interaction: It is not enough just for parties to be able to communicate directly, they have to be able to actually interact. Peer-to-peer systems are characterized by direct interaction. </p> <p>Example<p>In the hotel room booking example, making a booking with the hotel sending back a booking confirmation actually consists of a direct interaction between the two parties.</p> </p> Note <p>P2P networks enable the sharing of files stored on linked devices' hard drives. A user can serve as the source of a file after they have downloaded it. In other words, when a node performs the role of a client, it downloads data from other network nodes. However, while they are acting as a server, they serve as the location for file downloads by other nodes. However, both operations can be carried out concurrently. Therefore, each node has a copy of the data and serves as both a client and a server to other nodes. This removes the need of a central administrator or server. </p> <p>P2P networks differ from more conventional client-server systems in this way, where client devices receive files from a centralized server.  Since every node sends, receives, and saves data, P2P networks often get quicker and more effective as their user bases expand. P2P networks are also particularly resilient to cyberattacks thanks to their distributed architecture, and P2P networks do not have a single point of failure, in contrast to conventional models.</p> </li> </ul> <p>P2P systems can be grouped based on their architecture into the following three primary subtypes:</p>"},{"location":"learn_the_concepts/peer_to_peer_systems/#unstructured-p2p-networks","title":"Unstructured P2P Networks","text":"<p>P2P networks that are unstructured lack a defined node organization. Participants communicate with one another in a random fashion. These systems are thought to be resistant to high churn activity (i.e. several nodes frequently joining and leaving the network). </p> Note <p>Unstructured P2P networks are simpler to set up, but because search requests are sent to as many peers as possible, they may utilize more CPU and memory. This frequently causes the network to get overrun with requests, especially when only a few nodes are providing the needed material.</p>"},{"location":"learn_the_concepts/peer_to_peer_systems/#structured-p2p-networks","title":"Structured P2P Networks","text":"<p>The structured P2P network is organized into an arrangement based on a distributed hash table (i.e. DHT).</p> <p>Info</p> <p>DHT is an advanced form of lookup or search system that allows nodes to access data, such as files, through the use of a key instead of having to make a copy of the data on every node. </p> <p>This contrasts with the idea behind unstructured P2P networks in which whole files may be stored on more than one node. </p> Note <p>Searching for material in a structured network is simpler and uses less power and memory than an unstructured network. The routing of requests and information rely on each peer knowing what is available for download and other criteria of the neighboring node, which must be relearned as peers leave or join the network as the neighbors change.</p>"},{"location":"learn_the_concepts/peer_to_peer_systems/#hybrid-p2p-networks","title":"Hybrid P2P Networks","text":"<p>In hybrid P2P networks some elements of the P2P architecture are combined with the traditional client-server approach. Hybrid models typically display better overall performance when compared to the other two categories. They typically incorporate some key benefits of each strategy, attaining notable levels of efficiency and decentralization at the same time.</p>"},{"location":"learn_the_concepts/peer_to_peer_systems/#benefits-and-drawbacks-of-a-p2p-system","title":"Benefits and Drawbacks of a P2P System","text":""},{"location":"learn_the_concepts/peer_to_peer_systems/#benefits","title":"Benefits","text":"<ul> <li> <p>No need for a Specific Operating System or Software: Individual peers can be on any OS and in most cases do not need specialized software to share files. This is especially useful in remote P2P networks where users might not have the same hardware.</p> </li> <li> <p>Cost: P2P networks do not need a costly server and can be joined together simply through USB or over the internet. Even more permanent connections (using copper wires in smaller offices, for example) is not as costly as creating a server or buying server software.</p> </li> <li> <p>Egalitarian: Each peer has control over what can be accessed by others on the network by changing the sharing settings. This makes it easier to protect the integrity of the network as an issue with one node will not destroy the rest of the peers.</p> </li> <li> <p>Easy to set up: Configuration is straightforward, with no need for the oversight of an administrator. Each node manages access and sharing themselves.</p> </li> <li> <p>Scalable: P2P networks are easy to scale, with more nodes adding performance and giving more power. Adding more peers makes more storage and processing power available to the network and can improve download and upload speeds.</p> </li> <li> <p>Easy Searching: The idea of a peer-to-peer network is that finding the right resources should, in theory, be easy. Even in an unstructured network, if the content you are searching for is not rare, it should be held by several peers and be available to download from multiple sources.</p> </li> <li> <p>Aligns With Decentralized Systems: Peer-to-peer systems align closely with decentralized systems, as both require trust between parties in order to work effectively, and both do not require central authorities to manage the system. Peer-to-peer communication is the basis of how parties in decentralized systems communicate with each other.</p> </li> <li> <p>More Freedom: By not having to go through a middleman, it gives users more freedom. They are not limited by the information for example provided by the hotel booking site but can find out far more by being in direct contact with the hotel and likewise the hotel can ask questions directly to their guests.</p> </li> </ul>"},{"location":"learn_the_concepts/peer_to_peer_systems/#drawbacks","title":"Drawbacks","text":"<ul> <li> <p>Decentralized: this makes it harder to arrange backups and file archiving. The safety and integrity of the content can be at risk if it is not managed, backed up regularly and deleted once it is obsolete. Due to the decentralized nature of such networks, participants may find it hard to provide themselves those useful services normally provided by the middlemen, such as marketing and promoting services, or market balancing services.</p> </li> <li> <p>No Oversight: in most of P2P networks, the decentralized nature makes it hard for a single administrator to monitor contents, and these can be at risk from malware and viruses. Sharing files with an infected node can transmit malware through the network and could cause problems over several affected peers.</p> </li> <li> <p>Slow transmission: simultaneous uploading and downloading of files can lead to a slower rate of transmission. The double function of uploading content while downloading other resources might actually make it slower.</p> </li> <li> <p>Poor Internet Performance: file sharing through P2P networks uses a lot of bandwidth and CPU, which can slow the computer performance for the individual user, especially when it comes to the internet. If multiple files are being shared, there is a risk that productivity in other areas could be reduced.</p> </li> <li> <p>Illegal Content: peer-to-peer networks can be used for downloading pirated music, movies, software and other copyrighted material, even if the sharer is unaware.</p> </li> </ul>"},{"location":"learn_the_concepts/peer_to_peer_systems/#examples-of-peer-to-peer-systems","title":"Examples of Peer-to-Peer Systems","text":"<p>One of the most popular uses of P2P systems is represented by file sharing networks which allow members to directly share files with each other.</p> <p>Example</p> <p>Napster and LimeWire were P2P music sharing networks backed by the idea that peers connected through the internet could find and download any song they wanted, from several other users.</p> <p>There exist also online gaming platforms which adopt a P2P structure for downloading games between users, such as Blizzard Entertainment which distributed Diablo III, StarCraft II, and World of Warcraft using P2P.</p> <p>A more successful use for P2P systems was developed in the crypto world thanks to blockchains and how these relate to P2P networks. Bitcoin, Ether and many other cryptocurrencies were developed following the P2P mechanism. </p> <p>An additional example of P2P architecture is represented by P2P crypto exchanges, on which users can immediately buy or sell cryptos from/to other users directly. The majority of P2P exchanges let you send and receive cryptocurrencies without requesting identity verification, in contrast to centralized exchanges where you must complete KYC in order to fulfill an order. Also, unlike centralized exchanges, P2P-based exchanges do not have a single point of failure. In most cases, a user may sign up for the exchange without having to undergo identification verification. A password and an email address are all that are needed for registration. </p> <p>Example</p> <p>P2P-based crypto exchanges include Paxful and Binance P2P.</p>"},{"location":"learn_the_concepts/blockchains/consensus/","title":"Consensus Mechanisms","text":"<p>Despite the absence of a central authority to confirm and authenticate the transactions, every Blockchain transaction is regarded as being totally safe and validated. Only the presence of the consensus protocol, a fundamental component of every Blockchain network, makes this feasible. </p> <p>Info</p> <p>A consensus algorithm allows every peer in the Blockchain network to agree on the distributed ledger's current state. Consensus algorithms accomplish dependability in the Blockchain network and build confidence amongst unidentified peers in a distributed computing setting in this way.  </p> <p>Hence, the consensus mechanism ensures that every new block added to the Blockchain is the sole version of the truth that has been accepted by every node.</p> <p>When it comes to confirming the legitimacy of distributed blockchain systems, each consensus technique has a unique set of benefits and drawbacks. While PoW and PoS are the most common, new algorithms are always emerging. The following are the most utilized consensus mechanisms nowadays: </p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-work-pow","title":"Proof-of-Work (PoW)","text":"<p>One of the most prominent blockchain technologies is the PoW consensus process, which was initially made popular by Bitcoin. Miners and the power they need to do the computations required to validate transactions are the key elements that distinguish PoW systems. Miners use computer hardware to power network nodes that use processing power to solve algorithmic mathematical computational puzzles, known as proofs of work. The miner who completes the puzzle first validates the blockchain's most recent block of transactions. The successful miner broadcasts the new block to all other nodes, which in turn authenticate its accuracy and add that block to their copies of the blockchain. This verification procedure establishes consensus. A new block cannot be added to the network until this data has been verified. When a miner validates a new block of data this latter one is then added to the PoW blockchain, with the first miner completing the validation process being rewarded with newly created cryptocurrency, known as the block reward.</p> Note <p>PoW networks are constrained in terms of their speed and scalability due to how the high energy-intensive process these imply. Massive quantities of processing hash power must be used to solve the computational challenge, which uses a lot of energy. The more intensive the validation process, the more computational power is adopted to solve the puzzle and this leads to a higher competition among validators, which equals harder proofs of work and more energy consuming operations. Technology advancement in the blockchain sector has put a lot of emphasis on addressing the negative environmental effects of crypto mining, and several alternatives have surfaced.</p> <p>PoW blockchains have typically offered stronger security while preserving significant decentralization, despite their speed and scalability restrictions. Due to the distributed nature of PoW systems, it would be very expensive for a bad actor to seize control of the majority of the network's computing power and take over the blockchain. Typically, it is unable to overcome the high expenses of the hardware, power, and computing.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-stake-pos","title":"Proof-of-Stake (PoS)","text":"<p>PoS blockchains only have validators for transaction validation, not miners. Similar to PoW systems, validators operate network nodes and validate data, but there is no energy-intensive computing procedure required to earn the privilege to validate. </p> <p>Info</p> <p>This consensus mechanism addresses many of the problems of PoW blockchains, including slowness, lack of scalability, wasteful energy use, and high entry barriers. Polkadot, Avalanche, and Cardano are a few instances of contemporary market-dominating PoS blockchains.</p> <p>Validators stake some native tokens of the blockchain to qualify for selection as a validator node rather than working to solve proofs of work. The potential validator will effectively stake blockchain-native crypto tokens to act as collateral. On a PoS blockchain, when it is time to validate the data contained in a transaction block, the system chooses a validator at random to do so. The quantity of tokens a validator has staked is one such factor that might increase the likelihood that they will be picked as a validator. </p> <p>The process starts with a new block after the block is confirmed, and the validator is typically compensated with network transaction fees. By asking validators to stake their tokens, PoS blockchains make the network safe and maintain validators' integrity.  The entrance barrier to PoS blockchains for validators is arguably lower, when compared to PoW blockchains, since they do not need to invest in expensive hardware or incur significant electricity costs. However, you still need to have enough cryptocurrency to stake if you want to become a validator. PoS blockchains have been accused of being plutocratic since validators' control over the network is frequently proportionally correlated with the quantity of their stake. Thus, even though the PoS validation process uses significantly less energy and is quicker and less expensive, it does have some drawbacks, such as the potential for power concentration in the hands of individuals on the network who have amassed a sizable amount of the platform's governance cryptocurrency.</p> Note <p>Through a procedure known as slashing, validators that engage in malevolent or incompetent behaviour lose their stake and network access. By using this incentive system, validators are certain to benefit more from following the law than from breaching it.</p> <p>There can be particular hardware requirements for various platforms adopting a PoS mechanism. While PoS is not nearly as resource-consuming as PoW, certain PoS blockchains' validator nodes may require strong hardware or software specifications because they may be the need of handling a lot of transactions at once.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#delegated-proof-of-stake-dpos","title":"Delegated Proof-of-Stake (DPoS)","text":"<p>It is a well-liked development of the Proof of Stake idea in which network users choose delegates to validate the following block. Delegates may also be referred to as block producers or witnesses. By pooling your tokens into a staking pool and tying them to a specific delegate, you may cast a vote for delegates using DPoS. The argument for DPoS is that it is a more decentralized and equitable method of reaching consensus than just Proof-of-Stake.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-burn-pob","title":"Proof of Burn (PoB)","text":"<p>With PoB, validators burn coins by sending them to an address from which they are irretrievably lost, as opposed to spending money on expensive hardware equipment. Validators obtain the right to mine on the network based on a random selection procedure by sending the coins to an unreachable address. Burning coins here entails a long-term commitment on the part of validators in return for a temporary loss. Miners may burn either the native money of the Blockchain application or the currency of an alternate chain, such as bitcoin, depending on how the PoB is implemented. The more coins they burn, the better are their chances of being selected to mine the next block.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-capacity-poc","title":"Proof of Capacity (PoC)","text":"<p>PoC, often referred to as Proof-of-Space (PoSpace) is a mining technique that is based on the amount of hard disk space that a miner has available. Here, miners generate a list of all the possible hashes beforehand in a process called plotting. Such plots are then stored on hard drives. The more storage capacity a miner has, the more possible solutions available. The more solutions, the higher the chances of possessing the correct combination of hashes and thus the higher the possibility of winning the reward. </p> <p>Info</p> <p>PoC makes it possible for the typical individual to take part in the network because it does not need expensive or specialized equipment. As a result, this is decentralized and less energy-intensive alternative to some of the more widely used consensus mechanisms. However and there are concerns about its susceptibility to malware attacks.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-activity-poa","title":"Proof of Activity (PoA)","text":"<p>It is a consensus approach that combines PoW and PoS. Similar to PoW, the mining process starts here with miners vying to use the most powerful processing power to solve a complex mathematical problem. The system then turns to resemble PoS when the block has been mined, with the successfully created block header being sent to the PoA network. The new block is then randomly validated by a number of validators who sign off on the hash. The more crypto a validator possesses, similar to PoS, the better their chances are of being chosen. The block is introduced to the blockchain network and made available to record transactions once each selected validator has signed it. The miner and validators then split the block rewards.</p>"},{"location":"learn_the_concepts/blockchains/consensus/#proof-of-authority-poa","title":"Proof of Authority (PoA)","text":"<p>This mechanism chooses its validators based on their track record. Validators in PoA do not stake coins. Instead, in order to have the ability to validate blocks, they must risk their reputations. The majority of blockchain systems, in contrast to this, often do not need participants to disclose their identities. This approach is far less resource-intensive than some of its predecessors, especially PoW, as it requires essentially little computational power.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/","title":"Decentralized Applications","text":"<p>Decentralized applications (DApps) are digital applications or programmes that exist and run on a blockchain or peer-to-peer (i.e. P2P) network of computers. DApps, which might resemble ordinary mobile applications on your phone in appearance but have a distinct backend system, as these are not subject to the control of a single authority. DApps function by using smart contracts on a distributed network as opposed to a centralized system. These features make DApps more open, decentralized, and secure as a result. A smart contract functions as a collection of predetermined rules that computer code enforces. The tasks specified in the contract will be carried out by all network nodes when and if specific conditions are satisfied.</p> <p>DApps share the following features:</p> <ul> <li> <p>Open-sourceness: This allows anybody to access, verify, use, copy, and edit their source code. The vast majority of the DApp tokens are not controlled by a single entity. Users are also able to suggest and vote on DApp improvements.</p> </li> <li> <p>Decentralization and Cryptography: To protect data, the DApp stores all of its data on a public, decentralized blockchain that is maintained by a number of users (or nodes).</p> </li> <li> <p>Tokenization: A cryptographic token is required to access DApps. They can use native tokens created using a consensus mechanism like Proof of Work (PoW) or Proof of Stake (PoS), or they can adopt cryptocurrencies like ETH. Additionally, contributors like miners and stakers can be rewarded with this token.</p> </li> </ul> <p>Info</p> <p>DApps are present on the Ethereum network and on other blockchains, such as BNB Smart Chain (BSC), Solana (SOL), Polygon (MATIC), Avalanche (AVAX), EOS.</p> <p>To interact with a DApp, you first need a compatible browser extension wallet like MetaMask, or Trust Wallet.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/#benefits-and-limitations-of-dapps","title":"Benefits and Limitations of DApps","text":"<p>While DApps and conventional apps may have similar-looking user interfaces, DApps have some advantages over their centralized alternatives. Data is kept on centralized servers by web applications. The entire network of the app might be brought down by a single hacked server, rendering it inoperable for a while or ever. Data leaks or theft may occur in centralized systems as well, endangering businesses and consumers.</p> <p>DApps, in contrast, are created via decentralized distributed networks. DApps have no single point of failure, making them less susceptible to assaults and making it exceedingly challenging for bad actors to take over the network. The P2P network can also guarantee that the DApp keeps running with little downtime even if a few machines or a section of the network go wrong. Users may exercise more control over the data they disclose because of DApps' decentralized nature. Users do not need to reveal their real-world identities in order to communicate with a DApp because no corporations are in charge of their personal data. Instead, individuals may connect to DApps using a crypto wallet and have complete control over the data they disclose.</p> <p>Another advantage of DApps is that by utilizing smart contracts, developers may quickly include cryptocurrency into their core functions. </p> <p>Example</p> <p>DApps on Ethereum may accept ETH as payment without integrating external payment services.</p> <p>When it comes to illustrate the limitations of DApps, we first need to highlight the fact that DApps have the potential to play a significant role in a world without censorship. However, decentralized apps are still in their infancy, and the market has yet to find solutions to problems like scalability, code revisions, and a small user base. DApps might overburden the networks they run on since they demand a lot of computational power to function. </p> <p>Another difficult task is modifying a DApp. A DApp does require continual updates to repair problems, update the user interface, and introduce new functions in order to improve user experience and security. </p> <p>Info</p> <p>It is challenging to change the backend code of a DApp once it has been put on the blockchain, though. Any modifications or enhancements would need to be approved by a majority of the network's nodes, which would take a while to put into practise.</p> <p>It is challenging for one DApp to stand out and draw a lot of users when there are so many others available. A DApp has to have a network effect in order to function properly. This is, the more users a DApp has, the more efficient it becomes at offering services. The DApp may be made more secure and shielded from hackers tampering with the open-source code by having more users.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/#use-cases","title":"Use Cases","text":""},{"location":"learn_the_concepts/blockchains/decentralized_applications/#gamefi","title":"GameFi","text":"<p>GameFi DApps are becoming more and more well-liked. The majority of gaming DApps give players complete control over their in-game assets, in contrast to conventional video games. They also provide users the chance to earn money from these things outside the game.</p> Example <p>One of the most successful DApp in this sector is the play-to-earn game Axie Infinity on the Ethereum blockchain. Axie Infinity offers NFT-based game avatars, virtual worlds, and gaming-related merchandise. Players can trade with other players on NFT markets, move them to other Ethereum addresses, or keep them in their digital wallets. Players can compete with one another inside the ecosystem to amass ERC-20 tokens that can be exchanged. Generally speaking, players may earn more in-game incentives the longer they play.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/#dexs-decentralized-exchanges","title":"DEXs - Decentralized Exchanges","text":"<p>The intermediaries in traditional finance are financial institutions. Everyone may access financial services with DApps without the need for a centralized authority and have total control over their assets. Low-income people can also profit from DeFi since it gives them access to a wide range of financial services at a considerable cost savings.</p> <p>The most common financial services offered by decentralized apps are borrowing and lending. Instant transaction settlement, little-to-no credit checks, and the usage of digital assets as collateral are all features of DeFi DApps. Users in DApp lending markets have greater freedom. Another essential example of financial DApps is decentralized exchanges (DEXs). These platforms make peer-to-peer trading easier by getting rid of middlemen like centralized cryptocurrency exchanges. Users are not required to give up control of their funds. With the aid of smart contracts, people trade with another user directly rather than putting their assets into an exchange. Orders are carried out directly between the users' wallets and on the blockchain. In comparison to centralized exchanges, DEXs often charge cheaper trading costs since they require less maintenance. </p> Example <p>SushiSwap, PancakeSwap, and Uniswap are a few of the well-known DEXs.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/#entertainment","title":"Entertainment","text":"<p>DApps enable the transformation of entertainment daily activities into digital experiences that can also produce financial incentives. </p> Example <p>For instance, Audius, a decentralized music streaming network built on blockchain, eliminates the middlemen present in the conventional music industry to connect artists and listeners directly. By creating permanent records of their labor on the blockchain, it enables music curators to better monetise their material. </p> <p>DApps are addressing problems that users of social media platforms encounter. Twitter and Facebook, two centralized social media behemoths, are frequently attacked for editing content and treating user data carelessly. </p> Example <p>An example on decentralized social media platform is given by Steemit. In there, the community can interact freely and express their opinions with fewer limitations and censorship while also having more control over their personal data.</p>"},{"location":"learn_the_concepts/blockchains/decentralized_applications/#governance","title":"Governance","text":"<p>DApps can enable users to participate more actively in the administration of online organizations by establishing a decision-making process that is more focused on the community. Users with governance tokens of a certain blockchain project can make suggestions for the community to vote on and vote on other people's ideas anonymously with the use of smart contracts. </p> Note <p>Decentralized Autonomous Organizations (DAOs) are one of the decentralized governance models. DAOs are completely autonomous DApps that employ smart contracts to decide for themselves without the need for a central authority. There is no hierarchy there. Instead, economic processes bring the organization's interests into line with those of specific DAO members. </p>"},{"location":"learn_the_concepts/blockchains/oracles/","title":"Oracles","text":"<p>Blockchains get their most significant positive features by being purposefully segregated from external systems. However, off-chain data cannot be accessed by blockchains or smart contracts directly, and these need such data to perform any contractual agreement between any party on the blockchain itself.</p> <p>Info</p> <p>This is known as the core of the oracle dilemma. In fact, blockchains are unable to draw data from or push data out to any external systems as part of their built-in functionality. A blockchain's isolation is precisely what makes it so safe and dependable since the network just needs to come to consensus on a very simple set of questions using information that has already been written in the ledger.</p> <p>A blockchain needs an additional piece of infrastructure, an oracle, to connect the blockchain to the off-chain services in a secure manner.  A blockchain oracle is a safe piece of middleware that makes it easier for blockchains to communicate with any off-chain system, such as data providers, online APIs, business backends, cloud providers, IoT devices, e-signatures, payment systems, other blockchains, and more. This is, a blockchain Oracle is the element that links the blockchain to the external system, making it possible for smart contracts to operate on the basis of inputs and outputs from the real world. </p> <p>Note</p> <p>The oracle system must work concurrently on and off the blockchain in order to perform these tasks. The on-chain component is used to connect to the blockchain to listen for requests, broadcast messages, submit proofs, extract blockchain data, and perhaps even carry out computation on the blockchain. The off-chain component is used to execute requests, retrieve and prepare external data, transport blockchain data to other systems, and carry out off-chain computation for improved smart contract scalability, privacy, security, and other features.</p> <p>Blockchain oracles can help to increase the range of possibilities for smart contracts to work, thus, oracles are essential components of the blockchain ecosystem. Smart contracts would not even be particularly useful without blockchain oracles as they would only have access to data from their own networks since the vast majority of smart contract use cases, including DeFi, depend on knowledge of real world data and off-chain occurrences.</p>"},{"location":"learn_the_concepts/blockchains/oracles/#types-of-blockchain-oracles","title":"Types of blockchain oracles","text":"<p>Blockchain oracles may be categorized based on the following characteristics:</p> <ul> <li>Data source: does the data come from hardware or software as its source?</li> <li>Information direction: is the flow of data going inward or outward?</li> <li>Trust: are these oracles decentralized or centralized?</li> </ul> <p>Given this, we can identify the following types of oracles:</p> <ul> <li> <p>Software oracles: these communicate with internet data sources and provide the data to the blockchain. Any internet data source is a possible source for this information (e.g. online databases, servers, websites, ...). Exchange rates, pricing of digital assets, and real-time flight information are just a few of the types of data that software oracles frequently give.</p> </li> <li> <p>Hardware oracle: these oracles are made to gather data from the real world and provide it to smart contracts. Electronic sensors, barcode scanners, and other information gathering tools may transmit this data. In essence, a hardware oracle converts actual occurrences into digital values that smart contracts can comprehend.</p> </li> <li> <p>Inbound and outbound oracles: outbound oracles transfer information from smart contracts to the outside world, whereas inbound oracles give information from external sources to smart contracts.</p> </li> <li> <p>Centralized oracles: a centralized oracle is the only source of data for the smart contract and is managed by a single organization. The primary issue with centralized oracles is that they have a single point of failure, which reduces the contracts' resistance to weaknesses and intrusions. </p> </li> <li> <p>Decentralized oracles: public blockchains and decentralized oracles goal is to reduce counterparty risk. By not depending on a single source of truth, decentralized oracles improve the accuracy of the data supplied to smart contracts.</p> </li> <li> <p>Specialized oracles: these oracles are created so that a single smart contract can use them. This means that a proportionately large number of contract-specific oracles must be created if one plans to implement numerous smart contracts. These oracles are said to be exceedingly time and money consuming. This strategy can prove to be quite unworkable for businesses that need to pull data from a number of sources. On the other hand, developers have a lot of freedom to customize contract-specific oracles to meet unique needs because they may be created from the ground up to service a particular use case.</p> </li> <li> <p>Human oracles: oracles can occasionally be people who have specific expertise in a certain area. They are able to gather information from numerous sources, investigate its veracity, and convert it into smart contracts. Since human oracles may use cryptography to confirm their identity, it is unlikely that a fraudster will pretend to be them while supplying tainted information.</p> </li> <li> <p>Cross-chain oracles: these are another kind of oracle that can read and write data between several blockchains. Using data from one blockchain to start an activity on another or connecting assets across chains, so they may be utilized outside the native blockchain they were issued on, cross-chain oracles provide interoperability for moving both data and assets between blockchains.</p> </li> </ul> <p>Info</p> <p>Given the variety of oracle services, selecting between oracle service providers often comes down to reputation. Reputation frameworks offer transparency into each oracle network's and each oracle node operator's precision and dependability. Then, users may decide for themselves which oracles they wish to use to support their smart contracts.</p>"},{"location":"learn_the_concepts/blockchains/oracles/#blockchain-oracles-use-cases","title":"Blockchain oracles: Use Cases","text":""},{"location":"learn_the_concepts/blockchains/oracles/#decentralized-finance-defi","title":"Decentralized Finance (DeFi)","text":"<p>Oracles are necessary for a significant section of the decentralized finance (i.e. DeFi) ecosystem to access financial information regarding assets and markets. Decentralized money markets, for instance, employ price oracles to assess users' borrowing capacity and evaluate if their holdings are under collateralized and at risk of liquidation. Similarly, Automated Market Makers (AMMs) employ price oracles to assist concentrate liquidity at the current market price to increase capital efficiency. Synthetic asset platforms use price oracles to link the value of tokens to real-world assets.</p>"},{"location":"learn_the_concepts/blockchains/oracles/#dynamic-nfts-and-gaming","title":"Dynamic NFTs and Gaming","text":"<p>Oracles also make it possible for smart contracts to be used in non-financial use cases, such as NFTs and dynamic NFTs. Non-fungible Tokens (i.e. NFTs) that can alter in appearance, value, or distribution based on external factors like the time of day or the weather are examples of dynamic NFTs. Oracles may also produce verified randomness, which projects can utilize to give NFTs randomized characteristics or to choose random winners in high-demand NFT drops. Verifiable randomness is also used in on-chain gaming applications to produce more captivating and surprising gameplay elements, such as the emergence of random treasure boxes or random matchmaking during a tournament.</p>"},{"location":"learn_the_concepts/blockchains/oracles/#businesses","title":"Businesses","text":"<p>Businesses may link their backend systems to any blockchain network using the safe blockchain middleware provided by business cross-chain oracles. Enterprise systems may read from and write to any blockchain in this way, and they can also use complicated logic to decide how to deploy assets and data among chains and with counterparties that are connected to the same oracle network. As a consequence, institutions no longer need to invest time and development resources in integrating with each individual blockchain. Instead, they can immediately join blockchains that are highly desired by their counterparties and quickly provide support for smart contract services that their customers require.</p>"},{"location":"learn_the_concepts/blockchains/oracles/#insurance","title":"Insurance","text":"<p>Insurance smart contracts provide access to physical sensors, online APIs, satellite images, and legal data by using input oracles to confirm the presence of insurable events throughout claims processing. Using other blockchains or conventional payment networks, output oracles can give insurance smart contracts a mechanism to pay out on claims.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/","title":"Smart Contracts","text":""},{"location":"learn_the_concepts/blockchains/smart_contracts/#what-is-a-smart-contract","title":"What is a Smart Contract?","text":"<p>A smart contract (i.e. automated self-enforcing contract) is a piece of computer software that initiates a certain activity when the circumstances are satisfied. In other words, smart contracts are essentially lines of code that run when certain criteria are satisfied, performing a certain purpose.</p> <p>Info</p> <p>Smart contracts enable trustworthy transactions and agreements to be made between dispersed, anonymous participants, without the need for a centralized authority, a legal system, or an external enforcement mechanism. </p> <p>A smart contract may describe the transaction's mechanics and serve as the final arbitrator of the terms. Because of this, smart contracts have evolved into the foundation of a complete ecosystem of decentralized applications (dApps) and are now a key area of focus for blockchain development as a whole.</p> <p>When predefined circumstances have been verified to have been satisfied, a network of computers will carry out the actions. These can entail paying out money to the right people, registering a car, sending out notices, or writing a ticket. When the transaction is finished, the blockchain is then updated.</p> <p>Info</p> <p>As a result, the transaction cannot be modified, and only parties to whom permission has been granted can view the outcome. Smart contacts, therefore, allow intermediaries such as banks and central authorities to be bypassed, as the contract is written onto the blockchain, and once written on the blockchain, these are irreversible. This means they are ideal for automating and decentralizing transactions and deals, and indeed are really the key to making dApps work on the blockchain.</p> <p>Example</p> <p>Smart contracts are adaptable to be used in almost any sector where money, digital assets, or any type of digital information has to be moved between parties. Their application is also being investigated in the healthcare industry and to enforce intellectual property agreements.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#benefits","title":"Benefits","text":"<ol> <li> <p>Speed, Efficiency, and Precision: the contract is promptly carried out if a condition is satisfied. Smart contracts are digital and automated, so there is no paperwork to complete or time wasted fixing mistakes that frequently occur when documents are filled out manually.</p> </li> <li> <p>Transparency and Trust: there is no need to wonder whether information has been changed for one participant's personal gain because there is no third party engaged and participants exchange encrypted records of transactions. Smart contracts are written in a way that does make disputes extremely rare, indeed they are designed to avoid them entirely. </p> </li> <li> <p>Security: because the blockchain transaction records are encrypted, these are incredibly difficult to hack. Additionally, hackers would need to alter the entire chain in order to change a single record on a distributed ledger since each record is linked to the records that came before and after it.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#drawbacks","title":"Drawbacks","text":"<ol> <li> <p>Legal status: smart contracts lack any legal status. This may be largely caused because the technology is so new, and most legal jurisdictions have not yet updated their guidance on smart contracts and legislation if required is usually not yet in place.</p> </li> <li> <p>Difficult to Change: once a record has been written to the blockchain it is impossible to change or delete it. Therefore, if a smart contract has been issued in some way incorrectly, then changing it is almost impossible. You would be able to issue another contract that effectively would reverse the effect of the incorrect contract, but that would not necessarily be easy.</p> </li> <li> <p>Need for Precision: smart contracts do not work unless they are written in an extremely precise way. In fact, there can not be any ambiguity or vagueness in their terms.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#use-cases","title":"Use Cases","text":""},{"location":"learn_the_concepts/blockchains/smart_contracts/#finance","title":"Finance","text":"<p>Thanks to the irreversible, transparent, and trustless properties of blockchain and smart contract technology, DeFi dApps provide whole new sorts of goods and decentralized business models that may be of great use and utility for consumers, in addition to parallel services to the banking and financial services sector like lending, borrowing, trading, and a variety of other financial activities. </p> <p>Note</p> <p>DApps have the ability to lower the barriers to entry into the financial services industry for individuals all over the world because of the improved transparency provided by smart contracts (combined with 24/7 functioning, and cheaper prices). The implications of smart-contract-powered dApps on the financial industry are already apparent, despite the DeFi sector's relative youth given the amount of creative dApps that are currently offering users value and usefulness.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#gaming-and-nfts","title":"Gaming and NFTs","text":"<p>Blockchain and smart contract technologies in gaming can help gamers more effectively realize the value and usefulness of in-game purchases and asset purchases. Non-fungible tokens (NFTs), which are distinctive digital assets that stand in for in-game content, are frequently the engine behind blockchain technology in the gaming industry. Smart contracts are crucial to NFTs. The blockchain networks that support NFTs provide player ownership, proved scarcity, interoperability, and immutability, while these tokens are unique, uncommon, and indivisible. These features of blockchain in gaming might promote widespread adoption and a more equal value model when taken as a whole.</p> <p>Info</p> <p>The worldwide gaming market is a $100 billion ecosystem that is expanding swiftly, yet the way wealth is produced and dispersed within the market may often be unfair. Games are created and released by developers, and users pay to access and participate in such games. As a result, gamers continue to pay money to gain access to in-game resources and gaming options, perpetuating a one-way flow of value. </p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#healthcare","title":"Healthcare","text":"<p>Another sector that has started utilizing blockchain technology for safe, trustless, and transparent data sharing is healthcare. The incorporation of smart contracts and full dApps created to address important healthcare pain points like interoperability, identity, and authentication issues may help strengthen the connection between blockchain technology and healthcare.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#identity-management","title":"Identity Management","text":"<p>To increase security and lower the likelihood of data mismanagement or a breach, Digital Identifier (DIDs) smart contracts built on distributed ledger technologies offer people complete ownership over their data and let them share the content of their data as they see fit. </p> <p>Note</p> <p>For identity management, smart contracts help to ensure and facilitate: identity protection, the information the user wants to share, and KYC verification.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#machine-learning-and-artificial-intelligence","title":"Machine Learning and Artificial Intelligence","text":"<p>The capacity of blockchain technology and related smart contract technology to simplify difficult computing operations like those involved in machine learning and artificial intelligence is one of the most interesting uses of these technologies (AI). There is potential to develop AI-powered smart contracts by fusing the data-intensive processing of AI with the decentralized security and immutability of blockchain technology. Applications for smart contracts will need to develop into increasingly complicated systems as they are used by more and more sectors of the economy.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#real-estate","title":"Real Estate","text":"<p>By fusing blockchain and real estate transactions, smart contracts are increasing fractional ownership of assets and decreasing the entry barrier for investing for many. Particularly, there have been a number of successful attempts to tokenize real estate assets. By adding blockchain into real estate deals, smart contract technology may also remodel the paperwork and transaction procedures. When a piece of property is tokenized, much of the required record-keeping can take place via associated smart contracts, which can save the parties time and money.</p>"},{"location":"learn_the_concepts/blockchains/smart_contracts/#supply-chain-management","title":"Supply Chain Management","text":"<p>A fantastic use case for blockchain smart contracts is supply chain management. The supply chain may be significantly enhanced by the use of smart contracts. </p> <p>Note</p> <p>Smart contracts may be used, for instance, to track things in the supply chain completely transparently. A company may employ supply networks that are enabled by smart contracts to track its inventory more precisely. Additionally, it enhances corporate operations in other areas that are directly related to the supply chain. Additionally, adopting smart contracts leads to less verification work, improved traceability, and fewer frauds and thefts. However, in order for it to be functional, the institutions must upgrade their supply chain with new hardware equipments.</p> <p>Smart contracts and dApps are poised to continue revolutionizing the world of digital agreements. Numerous businesses will benefit greatly from smart contract technology in the future. Researchers and developers are increasingly keen to take use of smart contract technology to meet the demands of the expanding Internet of Things (IoT). While IoT devices are currently given security and transparency by blockchain technology in general, the benefits of smart contracts might make this integration much more seamless.</p>"},{"location":"learn_the_concepts/blockchains/transaction_fees/","title":"Transaction Fees","text":"<p>Any transaction involving the transfer of cryptocurrency will incur fees, whether you are purchasing or withdrawing funds from an exchange or sending or receiving payments in cryptocurrency. Various fee types include:</p> <ul> <li> <p>Transaction or miner fees: these vary depending on how many transactions are awaiting their inclusion in the current block and are intended to motivate miners and validators to validate cryptocurrency transactions.</p> </li> <li> <p>Service or network fees: these are applied by third-party providers that enable transactions (e.g. cryptocurrency exchange). These fees are made in addition to any network-generated fee paid to miners.</p> </li> </ul> <p>Transaction fees serve two crucial functions:</p> <ol> <li> <p>Compensate miners or validators assisting and confirming the transactions.</p> </li> <li> <p>Defend the network against spam assaults: this is because transaction fees lead to a decrease in spam on the network, and large-scale spam assaults become more expensive and more difficult to execute. </p> </li> </ol> <p>Info</p> <p>Transaction fees serve as a basic but efficient spam filter.</p> Note <p>Transaction fees might be modest or substantial. The fees you pay might also be influenced by market forces. It is important to highlight that the amount of fees you pay impacts your transaction's priority for inclusion in the following validated block. In fact, users who wish to execute their transaction more quickly can even increase the transaction cost to enhance the likelihood that their transaction will be added to the following block of transactions on the blockchain. </p> <p>The confirmation procedure moves along more quickly the more money that is spent.</p> <p>Miners are in charge of adding transactions to the blockchain and are required for confirming and securing these transactions on each network. These payments make the effort of miners and validators profitable. Despite the fact that each blockchain is distinct, they all have a limited quantity of transactions that may fit into a single block.</p> Example <p>The Bitcoin network only permits a total of 2,800 transactions per block.</p> <p>Depending on how many transactions are awaiting their inclusion, miner fees may change. During periods of high network traffic, miners prioritize the validation of new transactions based on the fee paid by the user. Hence, the user who wants to complete the transaction more quickly can even increase the transaction fee to boost its chances of being included in the next completed block.</p>"},{"location":"learn_the_concepts/blockchains/transaction_fees/#how-to-reduce-transaction-fees","title":"How to reduce transaction fees","text":"<p>There are several options available for reducing fees. First of all, you may lower these fees by deciding when you want to complete your transaction. Due to the fact that the majority of cryptocurrency users worldwide are concentrated in the U. S., blockchain networks typically see the highest levels of activity during times when people there are awake. Additionally, traffic is lower during the weekends, particularly on Saturdays. Additionally, the fees you pay depend on how quickly you want your transaction to be validated. If you have a high priority transaction and want it to be confirmed faster, you should expect a higher miner fee. If your transaction is not urgent, then a slower verification time means a lower transaction fee. </p> Info <p>On the Ethereum network, transaction fees are referred to as gas. Like other blockchains, the gas costs can go up or down depending on demand. Miners are more likely to give your transaction priority if you pay more for gas. The gas limit specifies the maximum price to be paid for a specific transaction and it should also be taken into account when proceeding with a transaction. </p>"},{"location":"learn_the_concepts/blockchains/transaction_fees/#transaction-fees-on-the-fetchai-network","title":"Transaction fees on the Fetch.ai network","text":"<p>On the Fetch.ai network, the gas mechanism is made simple and gives you an option to pick high, medium, or low fees, in addition to allowing you to manually set the amount you wish to pay. Fetch.ai does operate some validators on the network, which further gives it influence over the gas fee levels. Even though some constraints are set by Fetch.ai on gas fees, the decentralized nature of the network guarantees that transaction fees are not set by any central authority, and the actual level of gas is set by each of the validators on the Fetch network. Fetch.ai has the philosophy that having high gas fees does no good for anyone, and because of this, the Fetch team wants to encourage everyone to use the network, and trade and transact using $FET tokens. </p> <p>Low fees encourages higher network traffic, and this in turn means more transactions and activity and therefore more fees being paid in general. However, $FET that are traded and transferred on other networks are subject to the gas fees that those networks charge and Fetch has no control whatsoever over those fees. The fees gathered on the Fetch network are then distributed among the stakeholders (i.e. validators and community stakeholders). Gas fees on the Fetch network are extremely very low when compared to other networks. As a general comparison, Juno Network, another ecosystem blockchain within the Cosmos ecosystem has fees that on average are $0.05 per transfer, whereas Fetch.ai transfers cost $0.000000000000001. </p> <p>These gas fees are calculated in an extremely fair way, with the fee being directly proportional to the computing power needed to complete the process. </p> <p>Example</p> <p>A simple purchase transaction takes less computing power than activating a smart contract, therefore the associated fee will be lower.</p> <p>There is full transparency too, as it is always clear what the gas fee will be before making a transaction, and so there are no hidden surprises.</p>"},{"location":"learn_the_concepts/blockchains/validators/","title":"Validators","text":"<p>The block validation procedure is one of the essential elements that makes blockchain functioning possible. A network node known as a blockchain validator assists in processing and validating transaction blocks on the platform so that they may be added to the blockchain's permanent ledger.</p> <p>Info</p> <p>On PoS blockchains, these nodes are referred to as validators, whereas, on PoW blockchain networks, these are known as miners. In essence, validator nodes take on the responsibility of validating, voting on, and keeping a record of transactions by taking part in the consensus process.</p> <p>Block validation is a procedure that both of these blockchain variants may use. Staking, the method of block validation utilized on PoS blockchains, would be a more appropriate alternative to mine when referring to blockchain networks.</p> <p>The process starts with a user sending the transaction on the blockchain, which is then queued on the network for further confirmation. The block is then verified by validator nodes by batching individual transactions into it. The amount of transactions that can be included in a block is governed differently by each blockchain. The block is then processed by validators which add it to the blockchain as a permanent record. On some blockchains, validators have the option to select which transactions to group into a block. </p> <p>Info</p> <p>This choice is made depending on the validator's preferences, usually based on the transaction costs involved, and is not necessarily made in chronological sequence. Transactions with extremely little or no fees, however, are more likely to be disregarded by validators and, as a result, can hang around in the unconfirmed state for a very long time. The transaction is often removed from the network if it is not put into a block for validation after a certain time period.</p> <p>The sender of cryptocurrency assets tacks on the fees to every blockchain transaction as a reward for validators. Senders have the option to set their own rates and even transmit transactions completely free of charge.</p>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/","title":"What is a Blockchain?","text":"<p>A  blockchain is a series of data records that functions as a distributed, replicated digital ledger of transactions across a network of computer systems.</p> <p>Info</p> <p>On blockchains, the records of transactions are compiled into blocks which are linked together to form a chain. A blockchain consists of a stable chain of blocks, and in the context of cryptocurrencies, each one of these blocks stores a list of previously confirmed transactions.</p> <p>Transactions take place inside a P2P global network, thus, blockchains are considered borderless and immune to censorship. A blockchain network serves as a decentralized ledger since it is maintained by several computers located all over the world. This implies that each participant, namely node, keeps a copy of the blockchain data and interacts with other participants to make sure that everyone is aware of the same information stored in the block.</p> <p>Note</p> <p>Each block inside the blockchain contains a hash (i.e. a digital fingerprint or unique identifier), timestamped batches of recent valid transactions, and the hash of the previous block. The previous block hash links the blocks together, preventing existing blocks from being altered or new blocks inserted between existing ones. An additional feature of a blockchain is that all previous records are stored within any current record, so, there is always full history of previous transactions.</p>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/#blockchains-use-cases","title":"Blockchains: Use Cases","text":"<p>Currently, the blockchain technology is mostly used to track cryptocurrency transactions. Examples of other uses are:</p> <ol> <li> <p>Monitoring of Supply Chains: businesses may easily identify inefficiencies in their supply chains using blockchain, as well as find products in real time and monitor their quality as they move from producers to retailers.</p> </li> <li> <p>Data sharing: blockchain could act as an intermediary to securely store and move enterprise data among industries.</p> </li> <li> <p>Copyright and royalties protection: blockchain technology has the potential to be utilized to build a decentralized database that guarantees the preservation of music rights and rewards musicians with transparent and real-time royalties.</p> </li> <li> <p>Internet of Things (IoT) network management: blockchain has the potential to regulate IoT networks by identifying connected devices, tracking their behavior, assessing their dependability, and automatically determining the dependability of new devices that are linked to the network, such as smartphones and vehicles.</p> </li> <li> <p>Healthcare: the healthcare industry may benefit greatly from the use of blockchain. Blockchains are being used by healthcare payers and providers to handle clinical trial data and electronic medical records while upholding regulatory compliance.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/#who-can-participate-in-a-blockchain-network","title":"Who can participate in a blockchain network?","text":"<ol> <li> <p>Blockchain users: participants joining the blockchain network and conducting transactions with other network participants.</p> </li> <li> <p>Regulators: users with special permissions to oversee the transactions happening within the network.</p> </li> <li> <p>Blockchain Network Operators: individuals who have special permissions and authority to define, create, manage, and monitor the blockchain network.</p> </li> <li> <p>Certificate Authorities: individuals who issue and manage the different types of certificates required to run a permissioned blockchain.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/#benefits","title":"Benefits","text":"<ol> <li> <p>Security: blockchains are secure, in the sense that the data is cryptographically encrypted, and their structure makes it difficult and immediately noticeable if someone tries to change the data in a blockchain.</p> </li> <li> <p>Resiliency: the same information is stored in many places on the blockchain. This implies high resiliency as, if any part of the network was to fail then the information stored on the blockchain is still available in full.</p> </li> <li> <p>Trust: blockchains are decentralized systems and thus benefit from having no central authority controlling them. Due to their structure, and depending on the mechanism the blockchain's participants use to arrive at a consensus on what the state of the chain is, there is no need for the blockchain's users to trust the other parties. Guarantees are provided by the system itself.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/#drawbacks","title":"Drawbacks","text":"<ol> <li> <p>Complexity: Setting up a blockchain is not a simple task, there are networks of nodes to set up, the participatory framework established, and numerous components to bring together before you can even begin to store any information on the blockchain.</p> </li> <li> <p>Speed: It takes longer to add a record to a block and add a block to the chain than it does to simply add a record into a traditional database table. This is a challenge for blockchain-based payment systems, as blockchains typically handle fewer transactions per second than conventional payment systems.</p> </li> <li> <p>Scaling issues: As blockchains grow, they get more complex leading to issues, such as network congestion.</p> </li> <li> <p>Participation is required: Blockchains are decentralized systems, so they do need the active participation of members, for example they need to vote on governance proposals affecting the chain and be engaged in order for the blockchain to successfully operate.</p> </li> </ol>"},{"location":"learn_the_concepts/blockchains/what_is_a_blockchain/#types-of-blockchain","title":"Types of Blockchain","text":"<p>The architecture of blockchain systems varies greatly, especially in terms of the consensus protocol employed to validate network data. The security, usability, and sustainability of the underlying blockchain are affected differently by their own design. Different blockchain networks operate quite differently from one another. We can identify the following:</p> <ul> <li> <p>Public blockchains are entirely decentralised, permissionless, and open to everybody. All nodes are meant to have equal access and abilities within the blockchain. These are censorship-resistant and offer broad ecosystems for the development of apps and platforms. </p> <p>Example<p>Examples of public blockchains include Bitcoin and Ethereum. The majority of public blockchain networks use processes known as Proof-of-Work (PoW) or Proof-of-Stake (PoS) to provide consensus.</p> </p> </li> <li> <p>Private blockchains are blockchains within which permissions are managed by a single company. It is the central authority which decides who can be a node. The central authority may not always accord each node an equal right to execute certain responsibilities. This makes private blockchains partially decentralised. Private (or permissioned) blockchains can be structured in various ways to prioritize speed, security, and scalability.</p> </li> <li> <p>Consortium blockchains are permissioned blockchains governed by a group of entities, rather than a single one as private blockchains. These blockchains are more decentralised than private blockchains, which increases their security. But creating consortiums may be a difficult process since it calls for collaboration between several groups, which poses logistical problems and a possible antitrust risk. However, these may offer faster transaction processing times and are easier to modify, but are restrictive with limited usage outside the private consortium.</p> </li> <li> <p>Hybrid blockchains are blockchains which are managed by a single entity but at the same time have some supervision provided by the public blockchain, which is necessary to carry out specific transaction validations.</p> </li> </ul> <p>Note</p> <p>Varying consensus techniques have different effects on accessibility, security, and sustainability, and not all blockchains are created equally. In fact, the most suitable type of blockchain design needs to be fitting the actual use case it wants to serve.</p>"},{"location":"ledger-subquery/introduction/","title":"Introduction","text":"<p>The ledger-subquery is a SubQuery-based indexer for the Fetch ledger. This indexer provides a Graphql API for querying tracked entities. For a list of tracked entities, see the schema.graphql file.</p> <p>To learn more about how to run or change this SubQuery Project to get your own custom GraphQL API for your app, visit the SubQuery Academy for documentation. </p>"},{"location":"ledger-subquery/introduction/#endpoints-playground-uis","title":"Endpoints / Playground UIs","text":"<p>The graphql API endpoints also serve a playground UI to browsers for convenience. This UI is useful for rapid experimentation and iteration of queries as well as just getting some results, features include:</p> <ul> <li>real-time query results</li> <li>query editor:</li> <li>auto-complete &amp; validation via schema introspection</li> <li>can store multiple, named queries</li> <li>supports graphql variables</li> <li>local persistence of query editor contents</li> <li>schema reference</li> <li>graphql docs reference</li> </ul> Network API / Playground URL Fetchhub (mainnet) https://subquery.fetch.ai Dorado (testnet) https://subquery-dorado.fetch.ai"},{"location":"ledger-subquery/introduction/#architecture","title":"Architecture","text":""},{"location":"ledger-subquery/introduction/#component-diagram","title":"Component Diagram","text":""},{"location":"ledger-subquery/introduction/#querying","title":"Querying","text":"<p>The graphql API relies heavily on postgraphile (as a library) to resolve graphql requests.</p> <p>Postgraphile plugins also play a critical role; in particular, the connection-filter and pg-aggregates plugins.</p>"},{"location":"ledger-subquery/introduction/#pagination","title":"Pagination","text":"<p>The graphql API implements the connections specification for pagination (see: GraphQL pagination docs for more).</p> <p>Tip</p> <p>It is recommended to prefer using pagination operators by default (e.g. <code>first: &lt;limit&gt;</code>) to avoid unnecessary delays in query responses. </p>"},{"location":"ledger-subquery/introduction/#filtering","title":"Filtering","text":"<p>Filtering is facilitated by postgraphile and its plugins. For specifics on supported operators and how to use them, please refer to their documentation:</p> <ul> <li>connection-filter plugin</li> <li>operators</li> <li>query examples</li> </ul>"},{"location":"ledger-subquery/introduction/#examples","title":"Examples","text":"<p>Filtering <code>NativeTransfer</code>s for a given sender address:</p> <pre><code>query nativeTransfersFromAddress {\n  nativeTransfers(first: 5, filter: {\n    fromAddress: {\n      equalTo: \"fetch1t3qet68dr0qkmrjtq89lrx837qa2t05265qy6s\"\n    }\n  }) {\n    nodes {\n      toAddress\n      amounts\n    }\n  }\n}\n</code></pre> <p>Filtering for <code>Message</code>s from a given sender address:</p> <pre><code>query messagesFromAddress {\n  messages (first: 5, filter:  {\n    transaction: {\n      signerAddress: {\n        equalTo: \"fetch1t3qet68dr0qkmrjtq89lrx837qa2t05265qy6s\"\n      }\n    }\n  }) {\n    nodes {\n      transaction {\n        signerAddress\n      }\n    }\n  }\n}\n</code></pre> <p>Filtering on <code>Events</code>s within a given timeframe and with a given type:</p> <pre><code>query transferEventsDuring {\n  events(first: 5, filter:  {\n    block: {\n      timestamp: {\n        greaterThanOrEqualTo: \"2022-09-15T01:44:13.719\",\n        lessThanOrEqualTo: \"2022-09-19T02:15:28.632\"\n      }\n    },\n    type: {equalTo: \"transfer\"},\n  }) {\n    nodes {\n      attributes {\n        nodes {\n          key\n          value\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"ledger-subquery/introduction/#order-by-sorting","title":"Order by / Sorting","text":"<p>Each entity, by default, can be sorted by any of its respective fields. Additional support for ordering by certain fields on related entities is facilitated by custom ordering plugins generated from <code>makeAddPgTableOrderByPlugin</code> (see: postgraphile-docs).</p>"},{"location":"ledger-subquery/introduction/#block-height","title":"Block height","text":"<p>Any entity which relates to <code>Block</code> can be ordered by a related block's <code>height</code> field: <pre><code>query contractExecByBlockHeight {\n  contractExecutionMessage (orderBy: EXECUTE_CONTRACT_MESSAGES_BY_BLOCK_HEIGHT_ASC) {\n    nodes {\n      id,\n      ...\n      Block {\n        height\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"ledger-subquery/introduction/#contract-code-id","title":"Contract Code ID","text":"<p>The <code>contract</code> entity can be sorted by <code>codeId</code> through the <code>storeMessage</code> and <code>instantiateMessage</code> relations. <pre><code>query contractsByRelatedCodeID {\n  contracts (orderBy: CONTRACTS_BY_STORE_CONTRACT_MESSAGES_CODE_ID_ASC) {\n    #  or CONTRACTS_BY_INSTANTIATE_CONTRACT_MESSAGES_CODE_ID_ASC\n    nodes {\n      id,\n      ...\n      storeMessage {\n        codeId\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"ledger-subquery/introduction/#order-direction","title":"Order direction","text":"<p>Each of these custom orders are implemented in both directions, ascending and descending. These directions are accessed through the ending characters of the order enum, by choosing either <code>_ASC</code> and <code>_DESC</code>.</p>"},{"location":"ledger-subquery/introduction/#aggregation","title":"Aggregation","text":"<p>Aggregation is facilitated by the pg-aggregates plugin. Features include:</p> <ul> <li>calculating aggregates</li> <li>grouped aggregates</li> <li>applying conditions to grouped aggregates</li> <li>ordering by relational aggregates</li> <li>filtering by the results of aggregates on related connections</li> </ul>"},{"location":"ledger-subquery/introduction/#tests-as-examples","title":"Tests as examples","text":"<p>Additional examples of queries and use cases can be found in the end-to-end test suite.</p>"},{"location":"ledger-subquery/introduction/#entities","title":"Entities","text":"<p>Entities tracked by the indexer exist at varying levels of abstraction. \"Lower-level\" entities include the primitives (i.e. blocks, transactions, messages, and events), upon which \"higher-level\" entities are constructed (e.g. LegacyBridgeSwaps).</p> <p>Some entities are derived from objects which do not correspond to any network state change (e.g. failed transactions and their messages). In the case of failed transactions, it is desirable to index the associated data for end-user reference. This notion may also apply to other objects but should be considered carefully to avoid storing invalid or useless data.</p>"},{"location":"ledger-subquery/introduction/#primitive-entities","title":"Primitive entities","text":"<p>(see: schema.graphql)</p> <ul> <li>blocks</li> <li>transactions</li> <li>messages</li> <li>events</li> <li>event attributes</li> </ul>"},{"location":"ledger-subquery/introduction/#entity-relationship-diagrams","title":"Entity relationship diagrams","text":""},{"location":"ledger-subquery/introduction/#versioning","title":"Versioning","text":"<p>The versions of both the GraphQL API and the Indexer itself can be retrieved simply using the following query on the GraphQL playground.</p>"},{"location":"ledger-subquery/introduction/#example","title":"Example:","text":"<pre><code>query ReleaseVersionTest {\n  _metadata {\n    queryNodeVersion\n    indexerNodeVersion\n  }\n}\n</code></pre> <p>Each of these version numbers are stored as the value to the key <code>\"version\"</code> within their relevant module <code>package.json</code> file. These files can be found in the <code>docker/node-cosmos/</code> and <code>subql/packages/query/</code> directories for the Indexer and GraphQL versions, respectively. <pre><code>// The Indexer version number, taken from \"docker/node-cosmos/package.json\"\n{ \"name\": \"@subql/node-cosmos\",\n\"version\": \"1.0.0\",\n...\n}\n</code></pre></p>"},{"location":"ledger-subquery/introduction/#_metadata-entity","title":"<code>\"_metadata\"</code> Entity","text":"<p>The <code>_metadata</code> entity has further utility beyond the scope of the example query given prior. Using any of the relevant fields from the type definition below, internal states and config information can be retrieved with ease. <pre><code>type _Metadata {\n        lastProcessedHeight: Int\n        lastProcessedTimestamp: Date\n        targetHeight: Int\n        chain: String\n        specName: String\n        genesisHash: String\n        indexerHealthy: Boolean\n        indexerNodeVersion: String\n        queryNodeVersion: String\n        rowCountEstimate: [TableEstimate]\n        dynamicDatasources: String\n      }\n</code></pre></p>"},{"location":"ledger-subquery/introduction/#example_1","title":"Example:","text":"<p>If a developer was curious about the <code>chain-id</code> or whether the Indexer has passed any health checks, using <code>indexerHealthy</code>, these values can be returned within the playground or otherwise connected projects. <pre><code>query ReleaseVersionTest {\n  _metadata {\n    chain\n    indexerHealthy\n  }\n}\n</code></pre></p>"},{"location":"ledger_v2/","title":"Mainnet is here","text":"<p>The fetchhub mainnet forms the core of the Fetch.ai ecosystem. In these pages, you will find all information to setup your client and connect on the network and cli-introduction pages.</p> <p>This documentation covers some of the things you need to know in order to prepare for and develop on this network.</p>"},{"location":"ledger_v2/#test-networks","title":"Test Networks","text":"<p>The starting point for most will be our test network, since it can provide you with test tokens with no value, that you can safely experiment with. </p> <p>Head over the Command line client section for guidance on how to install and configure the <code>fetchd</code> client.</p>"},{"location":"ledger_v2/archived-networks/","title":"Mainnet Archive","text":""},{"location":"ledger_v2/archived-networks/#mainnet-archives","title":"Mainnet Archives","text":"<p>Archived data from previous versions of the fetchhub mainnet.</p>"},{"location":"ledger_v2/archived-networks/#fetchhub-3-archive","title":"Fetchhub-3 archive","text":"Parameter Value Chain ID fetchhub-3 Block range 4,504,601 --&gt; 5,300,200 Date range 08/02/2022 --&gt; 05/04/2022 Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.9.1 RPC Endpoint https://rpc-fetchhub3-archive.fetch.ai:443 GRPC Endpoint https://grpc-fetchhub3-archive.fetch.ai:443 REST Endpoint https://rest-fetchhub3-archive.fetch.ai:443 Block Explorer https://explore-fetchhub3-archive.fetch.ai Token Faucet N/A Seed Node(s) N/A Snapshots https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-3-archive.tgz"},{"location":"ledger_v2/archived-networks/#fetchhub-2-archive","title":"Fetchhub-2 archive","text":"Parameter Value Chain ID fetchhub-2 Block range 2,436,701 --&gt; 4,504,600 Date range 15/09/2021 --&gt; 08/02/2022 Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.8.7 RPC Endpoint https://rpc-fetchhub2-archive.fetch.ai:443 GRPC Endpoint https://grpc-fetchhub2-archive.fetch.ai:443 REST Endpoint https://rest-fetchhub2-archive.fetch.ai:443 Block Explorer https://explore-fetchhub2-archive.fetch.ai Token Faucet N/A Seed Node(s) N/A Snapshots https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-2-archive.tgz"},{"location":"ledger_v2/archived-networks/#fetchhub-1-archive","title":"Fetchhub-1 archive","text":"Parameter Value Chain ID fetchhub-1 Block range 1 --&gt; 2,436,700 Date range 31/03/2021 --&gt; 15/09/2021 Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.7.4 RPC Endpoint https://rpc-fetchhub1-archive.fetch.ai:443 GRPC Endpoint N/A REST Endpoint https://rest-fetchhub1-archive.fetch.ai:443 Block Explorer https://explore-fetchhub1-archive.fetch.ai Token Faucet N/A Seed Node(s) N/A Snapshots https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-1-archive.tgz"},{"location":"ledger_v2/block-explorer/","title":"Block Explorer","text":"<p>Each of the networks has a dedicated block explorer web site associated with it. This is a useful tool for monitoring network activity.</p>"},{"location":"ledger_v2/block-explorer/#logging-in-with-the-ledger-nano","title":"Logging in with the Ledger Nano","text":"<p>Return to the block explorer landing page and click on the key button in the top right corner. You'll then be prompted to \"Sign in With Ledger\". You must accept this request on your ledger nano device. After completing this process, the key button will be replaced by a person icon with a link to your personal address page, which keeps track of the activity that you have performed on the test-net.</p>"},{"location":"ledger_v2/block-explorer/#getting-testnet-tokens-from-the-faucet","title":"Getting Testnet Tokens from the Faucet","text":"<p>For networks that support it, you can obtain tokens for your account by copying the address and pasting it into the token faucet. Then, return to the main page, press the \"Get Funds\" button and paste your address in the pop-up. Afterwards you can return to your address page (via the person icon) and should observe that you have been allocated 1 TESTFET.</p>"},{"location":"ledger_v2/block-explorer/#transferring-tokens-to-another-address","title":"Transferring Tokens to another Address","text":"<p>After receiving tokens, you can send these to another address using the purple Transfer button on your address page. This will trigger a pop-up that prompts you to specify the destination address and the amount you wish to transfer. After filling in this information, you will be asked to sign the transaction using your ledger nano. The confirmation that the transaction has been broadcast gives two links that can be used to check that the transaction has been executed on the blockchain using either the transaction hash or your account page.</p> <p>Note:</p> <p>The transaction format includes a memo field that can be used to check the transaction information on the ledger nano display.</p>"},{"location":"ledger_v2/block-explorer/#delegating-stake-to-a-validator","title":"Delegating Stake to a Validator","text":"<p>You can delegate your test-net tokens to a validator who is operating the network by clicking on the Validators tab, and selecting one of the validators that you wish to delegate stake towards. In the Voting Power panel there is an option to <code>DELEGATE</code> tokens. Pressing this button will trigger a pop-up that prompts you to select a delegation amount and then sign the transaction with your Ledger Nano device.  </p> <p>After delegating tokens, buttons labelled with <code>REDELEGATE</code> and <code>UNDELEGATE</code> will appear. The delegation of tokens to a validator provides you with a reward for helping to secure the network. It is also possible to delegate your tokens to a different validator using a <code>REDELEGATE</code> transaction. You can return any bonded tokens to your address by submitting an <code>UNDELEGATE</code> request, which will trigger the tokens to be returned after 21 days have elapsed. The rewards that you receive from delegating tokens to a validator are shown in the account page. These can be sent to your address by sending a <code>WITHDRAW</code> transaction. </p>"},{"location":"ledger_v2/building/","title":"Building the Ledger","text":""},{"location":"ledger_v2/building/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.18+ (installation instructions available here)</li> <li>Packages: <code>make</code>, <code>gcc</code> (on Ubuntu, install them with <code>sudo apt-get update &amp;&amp; sudo apt-get install -y make gcc</code>)</li> </ul>"},{"location":"ledger_v2/building/#building-the-code","title":"Building the code","text":"<p>Download the latest released version from github and build the project using the following commands:</p> <pre><code>git clone https://github.com/fetchai/fetchd.git &amp;&amp; cd fetchd\n</code></pre> <p>Then build the code with the command:</p> <pre><code>make build\n</code></pre> <p>This will generate the <code>./build/fetchd</code> binary.</p> <p>For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command:</p> <pre><code>make install\n</code></pre> <p>This will install the binaries in the directory specified by your <code>$GOBIN</code> environment variable (default to <code>~/go/bin</code>).</p> <pre><code>which fetchd\n</code></pre> <p>This should return a path such as <code>~/go/bin/fetchd</code> (might be different depending on your actual go installation).</p> <p>If you get no output, or an error such as <code>which: no fetchd in ...</code>, possible cause can either be that <code>make install</code> failed with some errors or that your go binary folder (default: ~/go/bin) is not in your <code>PATH</code>.</p> <p>To add the ~/go/bin folder to your PATH, add this line at the end of your ~/.bashrc: <pre><code>export PATH=$PATH:~/go/bin\n</code></pre></p> <p>and reload it with:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>You can also verify that you are running the correct version </p> <pre><code>fetchd version\n</code></pre> <p>This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network).</p>"},{"location":"ledger_v2/building/#faq","title":"FAQ","text":"<ul> <li>Error: failed to parse log level (main:info,state:info,:error): Unknown Level String: 'main:info,state:info,:error', defaulting to NoLevel</li> </ul> <p>This means you had a  pre-stargate version of fetchd (&lt;= v0.7.x), and just installed a stargate version (&gt;= v0.8.x), you'll need to remove the previous configuration files with:</p> <pre><code>rm ~/.fetchd/config/app.toml ~/.fetchd/config/config.toml\n</code></pre>"},{"location":"ledger_v2/cli-bls/","title":"BLS signatures","text":"<p>The BLS algorithm can be selected when creating new keys and signing transactions. BLS supported keys are particularly useful for the increasing the efficiency of multi-signature transactions at the cost of simplicity in verification.</p> <p>It affords the users a shorter and yet still robust grouping of each signature from party members without the sacrifice of security on each multi-signature transaction.</p>"},{"location":"ledger_v2/cli-bls/#creating-bls-keys","title":"Creating BLS keys","text":"<p>Creating BLS keys is straightforward in comparison to normal key instantiation with the addition of one extra parameter to the command. This example will show the additional flag required in comparison to a key with the standard algorithm; with 'bls12381' in place of the default 'secp256k1'.</p>"},{"location":"ledger_v2/cli-bls/#example","title":"Example","text":"<pre><code># Create a normal key\nfetchd keys add Ron\n\n# Create a key capable of BLS signed transactions\nfetchd keys add Tom_BLS --algo bls12381\n\n# 'Ron' can be assumed to define implicitly --algo secp256k1 by default\n</code></pre>"},{"location":"ledger_v2/cli-bls/#bls-transactions-and-signatures","title":"BLS Transactions and signatures","text":"<p>After creating this BLS key, transactions can be carried out between two keys using the different algorithms.</p>"},{"location":"ledger_v2/cli-bls/#example_1","title":"Example","text":"<p>Ensure that the 'Ron' key has some funds before performing this example.</p> <pre><code># Perform a normal transfer of funds from Ron to Tom_BLS\nfetchd tx bank send &lt;address_of_Ron&gt; &lt;address_of_Tom_BLS&gt; 1000test\n\n# This should provide a breakdown of the transaction parameters, including the gas fees\n# Keep note of these fees\n\n# Check that these funds have been transferred to Tom_BLS\nfetchd query bank balaces &lt;address_of_Tom_BLS&gt;\n\n# Perform a BLS signed transaction from Tom_BLS to Ron\nfetchd tx bank send &lt;address_of_Tom_BLS&gt; &lt;address_of_Ron&gt; 1000test\n\n# Compare the difference between information printed from each transaction and observe\n# the difference in gas costs (?)\n\n# Now assure funds were successfully transferred back to Ron through a BLS signed transaction \nfetchd query bank balaces &lt;address_of_Tom_BLS&gt;\nfetchd query bank balaces &lt;address_of_Ron&gt;\n</code></pre>"},{"location":"ledger_v2/cli-governance/","title":"Governance Proposals","text":"<p>In order to change any attribute of a network, a governance proposal must be submitted. This could be a simple poll, a software update or a governing parameter change. </p>"},{"location":"ledger_v2/cli-governance/#parameter-change","title":"Parameter change","text":"<p>This is an example of the process in which network parameters may be changed through the use of a governance proposal.</p> <p>The values within this code can be changed in order to alter the minimum deposited fund threshold for a proposal to enter the voting phase, and the length of the deposit stage in which the minimum deposit threshold must be met. <pre><code># A JSON file containing the following code should be created to instantiate the proposal.\n# The two variables of interest are the \"amount\" which is set from 10000000stake to 1000stake\n# and the \"max_deposit_period\" which is changed from the default value to 7200000000000\n# equal to 2 hours, instead of the standard 2 days (in nanoseconds).\n\n{\n  \"title\": \"Staking Param Change\",\n  \"description\": \"Update max validators\",\n  \"changes\": [\n    {\n      \"subspace\": \"staking\",\n      \"key\": \"MaxValidators\",\n      \"value\": 105\n    }\n  ],\n  \"deposit\": \"1000000000000000000atestfet\"\n}\n</code></pre> <pre><code># Create initial proposal by uploading the JSON file\n# this is signed by a key 'proposer' that provides a portion of the current threshold deposit\nfetchd tx gov submit-proposal --proposal ~/json_path/proposal.json --from proposer\n\n# In order to later refer to this proposal, the proposal_id can be determined\nfetchd query gov proposals\n</code></pre></p>"},{"location":"ledger_v2/cli-governance/#proposal-deposit-phase","title":"Proposal deposit phase","text":"<p>The characteristics of the deposit phase are described by a set of network governance parameters, where the deposit period is two days from the initial proposal deposit until expiration, and a minimum threshold of 10000000denom as default. The minimum threshold must be met during this deposit period in order to proceed to the voting phase. The proposer may provide all of this threshold, or just some. In which case, supporters of the proposal may donate additional funding towards the goal of meeting the threshold.</p> <p>At any point of the deposit stage, the deposit pot can be queried.</p> <pre><code># To get the proposal ID, use the txhash obtained when the proposal was submitted and run the following command:\nfetchd query tx &lt;txhash&gt;\n\n# This command returns a text representation of the current total deposit value of a proposal\nfetchd query gov deposits &lt;proposal_id&gt;\n\n# Other users may contribute to funding the proposal using\nfetchd tx gov deposit &lt;proposal_id&gt; &lt;deposit_amount&gt; --from contributer\n</code></pre> <p>This documentation provides a more detailed explanation of the deposit funding period.</p>"},{"location":"ledger_v2/cli-governance/#proposal-voting-and-querying","title":"Proposal voting and querying","text":"<p>After the deposit period has passed, there are two outcomes: either the current minimum threshold is met, or the value is not met and the funds are returned. In the first case this proposal is submitted and to be voted on, returning a tally at the end of the voting period. </p> <p>In order to submit a vote on a proposal that has passed into the voting phase, all staked users except the proposer may do so using this command. <pre><code># Submit a vote from a key 'voter' with the desired outcome of the voter\nfetchd tx gov vote &lt;proposal_id&gt; &lt;yes|no|no_with_veto|abstain&gt; --from voter\n</code></pre></p> <p>The current voting turnout and tally can be queried, which displays a list of all voters and their choice. <pre><code># The current voting statistics can be printed using\nfetchd query gov votes &lt;proposal_id&gt;\n</code></pre></p>"},{"location":"ledger_v2/cli-governance/#example-output","title":"Example output","text":"<pre><code>votes:\n- option: VOTE_OPTION_YES\n  proposal_id: \"1\"\n  voter: fetch1dmehhhvul8y7slqs3zu2z3fede9kzlnyupd9rr\n- option: VOTE_OPTION_NO\n  proposal_id: \"1\"\n  voter: fetch1064endj5ne5e868asnf0encctwlga4y2jf3h28\n- option: VOTE_OPTION_YES\n  proposal_id: \"1\"\n  voter: fetch1k3ee923osju93jm03fkfmewnal39fjdbakje1x\n</code></pre>"},{"location":"ledger_v2/cli-governance/#voting-outcome","title":"Voting outcome","text":"<p>After the voting period has ended, the results are used to determine the next step of the proposal. The potential outcomes include:</p> <ul> <li>Majority yes vote<ul> <li>The proposal passes through and the users act according to the proposal type - e.g. A Software update proposal passes, and users begin uptake of the new version</li> </ul> </li> <li> <p>Majority no vote</p> <ul> <li>The funds deposited to pass into the voting stage are returned, and there is no governance change</li> </ul> </li> <li> <p>Majority no_with_veto vote</p> <ul> <li>This outcome is indicative of a proposal which may undermine the current governance system, e.g. a proposal to set the deposit threshold or voting period to an absurd value</li> <li>All funds deposited in the proposal are to be burned subject to this outcome, and there is no governance change</li> </ul> </li> </ul>"},{"location":"ledger_v2/cli-introduction/","title":"CLI - Introduction","text":"<p>The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here</p>"},{"location":"ledger_v2/cli-introduction/#connecting-to-a-network","title":"Connecting to a network","text":"<p>While some users will want to connect a node to the network and sync the entire blockchain, for many however, it is quicker and easier to connect directly to existing publically available nodes.</p>"},{"location":"ledger_v2/cli-introduction/#connecting-to-fetchhub-mainnet","title":"Connecting to fetchhub mainnet","text":"<p>To connect to the mainnet run the following configuration steps:</p> <pre><code>fetchd config chain-id fetchhub-4\nfetchd config node https://rpc-fetchhub.fetch.ai:443\n</code></pre>"},{"location":"ledger_v2/cli-introduction/#connecting-to-dorado-network","title":"Connecting to dorado network","text":"<p>To connect to the dorado network run the following configuration steps:</p> <pre><code>fetchd config chain-id dorado-1\nfetchd config node https://rpc-dorado.fetch.ai:443\n</code></pre> <p>Checkout the Network Information page for more detailed information on the available networks.</p>"},{"location":"ledger_v2/cli-keys/","title":"CLI - Managing Keys","text":"<p>Managing your keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys.</p>"},{"location":"ledger_v2/cli-keys/#adding-keys","title":"Adding keys","text":"<p>To create a new local key you need run the following command:</p> <pre><code>fetchd keys add &lt;your_key_name&gt;\n</code></pre> <p>Note</p> <p>These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device</p> <p>After running the command <code>fetchd</code> will print out a summary of the new key. An example of this output is shown below:</p> <pre><code>- name: test\n  type: local\n  address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0\n  pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx\n  mnemonic: \"\"\n  threshold: 0\n  pubkeys: []\n</code></pre> <p>This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account (keep this safe, if ever used to control main-net tokens).</p>"},{"location":"ledger_v2/cli-keys/#looking-up-an-address","title":"Looking up an address","text":"<p>A common operation that you will want to do is to lookup the address for a specified key. This can be done quickly using the following command:</p> <pre><code>fetchd keys show -a &lt;name of key&gt;\n</code></pre> <p>An example of the expected output is shown below:</p> <pre><code>fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0\n</code></pre> <p>A less common operation, but still useful, would be to lookup the public key for a specified key. The can be achieved with the following command:</p> <pre><code>fetchd keys show -p &lt;name of the key&gt;\n</code></pre> <p>An example of the expected output is shown below:</p> <pre><code>fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx\n</code></pre>"},{"location":"ledger_v2/cli-keys/#listing-keys","title":"Listing keys","text":"<p>To lookup more detailed information for all keys on your system use the following command:</p> <pre><code>fetchd keys list\n</code></pre> <p>This will output all of your keys information in a yaml format that is similar to the one generated when you first created the key.</p> <pre><code>- name: test\ntype: local\naddress: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0\n  pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx\n  mnemonic: \"\"\nthreshold: 0\npubkeys: []\n</code></pre>"},{"location":"ledger_v2/cli-keys/#recovering-a-key","title":"Recovering a key","text":"<p>You can import a key from a 24-word mnemonic by running:</p> <p><pre><code>fetchd keys add &lt;name&gt; --recover\n&gt; Enter your bip39 mnemonic\n&lt;type or paste your mnemonic&gt;\n</code></pre> You'll be prompted to enter the mnemonic phrase, and it will then print the matching address and key details as when creating a new key.</p>"},{"location":"ledger_v2/cli-keys/#hardware-wallets","title":"Hardware Wallets","text":""},{"location":"ledger_v2/cli-keys/#setup","title":"Setup","text":"<p>We recommend hardware wallets as a solution for managing private keys. The Fetch ledger is compatible with Ledger Nano hardware wallets. To use your Ledger Nano you will need to complete the following steps:</p> <ol> <li>Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged.</li> <li>Connect your device to your PC and update the firmware to the latest version using the Ledger Live application.</li> <li>Install the Cosmos application using the software manager (Manager &gt; Cosmos &gt; Install).</li> </ol>"},{"location":"ledger_v2/cli-keys/#adding-a-new-key","title":"Adding a new key","text":"<p>In order to use the hardware wallet address with the cli, the user must first add it via <code>fetchd</code>. This process only records the public information about the key.</p> <p>To import the key first plug in the device and enter the device pin. Once you have unlocked the device navigate to the Cosmos app on the device and open it.</p> <p>To add the key use the following command:</p> <pre><code>fetchd keys add &lt;name for the key&gt; --ledger --index 0\n</code></pre> <p>Note</p> <p>The <code>--ledger</code> flag tells the command line tool to talk to the ledger device and the <code>--index</code> flag selects which HD index should be used.</p> <p>When running this command, the Ledger device will prompt you to verify the generated address. Once you have done this you will get an output in the following form:</p> <pre><code>- name: hw1\n  type: ledger\n  address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2\n  pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h\n  mnemonic: \"\"\nthreshold: 0\npubkeys: []\n</code></pre>"},{"location":"ledger_v2/cli-multisig/","title":"Multisig keys","text":"<p>This feature of <code>fetchd</code> allows users to securely control keys in a number of configurations. Using a threshold number K of maximum N keys, a user or group of users can set the minimum number of keys required to sign a transaction. Some examples of these configurations allow some useful features such as the choice of a spare key, where only one key is required to sign (K=1) but there are two keys available to do so. Another more complex example configuration is set out below.</p>"},{"location":"ledger_v2/cli-multisig/#creating-a-multisig-key","title":"Creating a multisig key","text":"<p>The following represents the syntax and argument layout of the <code>fetchd</code> command to create a multisig key.</p> <pre><code># Create a simple multisig key with a threshold of 1 as default\nfetchd keys add &lt;multisig_key_name&gt; --multisig &lt;list_of_key_names&gt;\n\n# Creating a multisig key with a higher threshold, K\nfetchd keys add &lt;multisig_key_name&gt; --multisig &lt;list_of_key_names&gt; --multisig-threshold &lt;threshold integer K&gt;\n</code></pre>"},{"location":"ledger_v2/cli-multisig/#example-instantiation-of-a-multisig-key","title":"Example instantiation of a multisig key","text":"<p>This example represents a shared multisig key that could be used within a business amongst three account holders - where at least two of three (K=2) must sign off on each transaction.</p> <pre><code># Create the three keys owned by the separate account holders\nfetchd keys add fred\nfetchd keys add ted\nfetchd keys add ned\n\n# Create the multisig key from keys above\nfetchd keys add business_key --multisig fred,ted,ned --multisig-threshold 2\n</code></pre> <p>You will need the address of the business_key later in the example. Here just a reminder how to get it:</p> <pre><code>fetchd keys show -a business_key\n</code></pre>"},{"location":"ledger_v2/cli-multisig/#signing-and-broadcasting-multisig-transactions","title":"Signing and broadcasting multisig transactions","text":"<p>Transactions must be signed and broadcast before they are carried out.</p> <p>In order to sign a multisig transaction, the transaction itself must not be immediately broadcast; but instead, the keyholders must each sign until a minimum threshold K signatures are present.</p> <p>For this example we will be performing the transaction on the Dorado network and therefore will be using <code>atestfet</code> as the denomination, and a gas price of 1000000000atestfet (this should be changed depending on the actual currency and network used).</p>"},{"location":"ledger_v2/cli-multisig/#multisig-transaction-example","title":"Multisig transaction example","text":"<pre><code># Create a key to represent a vendor that the business must pay\nfetchd keys add vendor\n\n# Generate a transaction as an output file to be signed by\n# the keyholders, 'ted' and 'fred' in this example\nfetchd tx bank send &lt;business_key address&gt; &lt;vendor address&gt; 1000atestfet --gas 90000 --gas-prices 1000000000atestfet --generate-only &gt; transfer.json\n\n# you'll get \"account &lt;address of business_key&gt; not found\" error for missing funds\n# add funds to &lt;address of business_key&gt; using block explorer or by eg\ncurl -X POST -H 'Content-Type: application/json' -d '{\"address\":\"&lt;address of business_key&gt;\"}' https://faucet-dorado.fetch.ai/api/v3/claims\n\n# This transaction file (transfer.json) is then made available for\n# the first keyholder to sign, 'fred'\nfetchd tx sign transfer.json --chain-id dorado-1 --from fred --multisig &lt;address of business_key&gt; &gt; transfer_fredsigned.json\n\n# This is repeated for 'ted'\nfetchd tx sign transfer.json --chain-id dorado-1 --from ted --multisig &lt;address of business_key&gt; &gt; transfer_tedsigned.json\n\n# These two files are then collated together and used as inputs to the\n# multisign command to create a fully signed transaction\nfetchd tx multisign transfer.json business_key transfer_fredsigned.json transfer_tedsigned.json &gt; signed_transfer.json\n\n# Now that the transaction is fully signed, it may be broadcast\nfetchd tx broadcast signed_transfer.json\n\n# Now display the result of the transaction and confirm that the vendor has\n# received payment\nfetchd query bank balances &lt;address of vendor&gt;\n</code></pre> <p>It is important to note that this method of signing transactions can apply to all types of transaction.</p>"},{"location":"ledger_v2/cli-multisig/#other-multisig-transaction-examples","title":"Other multisig transaction examples","text":"<pre><code># In order to create a staking transaction using a multisig key\n# the same process as above can be used with the output file of this command\nfetchd tx staking delegate &lt;fetchvaloper address&gt; 10000atestfet --from &lt;address of business_key&gt; --gas 200000 --gas-prices 1000000000atestfet --generate-only &gt; stake.json\n\n# The following command can also be used to create a withdrawal transaction for the\n# rewards from staking when using a multisig key - this too must be signed as before\nfetchd tx distribution withdraw-all-rewards --from &lt;address of business_key&gt; --gas 150000 --gas-prices 1000000000atestfet --generate-only &gt; withdrawal.json\n</code></pre>"},{"location":"ledger_v2/cli-tokens/","title":"CLI - Managing Tokens","text":""},{"location":"ledger_v2/cli-tokens/#querying-your-balance","title":"Querying your balance","text":"<p>Once <code>fetchd</code> is configured for the desired network. The user can query their balance using the following command:</p> <pre><code>fetchd query bank balances fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4\n</code></pre> <p>If the address exists on the network then the user will expect to see an output in the following form:</p> <pre><code>balances:\n- amount: \"8000000000000000000\"\n  denom: atestfet\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"ledger_v2/cli-tokens/#sending-funds","title":"Sending funds","text":"<p>Before sending funds, make sure the sender address has tokens available by querying your balance as shown above. Checkout the Token Faucet page for more information on how to add test tokens to your address.</p> <p>To send funds from one address to another address then you would use the <code>tx send</code> subcommand. As shown below:</p> <pre><code>fetchd tx bank send &lt;from address or key name&gt; &lt;target address&gt; &lt;amount&gt;\n</code></pre> <p>In a more concrete example if the user wanted to send <code>100atestfet</code> from <code>main</code> key/address to <code>fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp</code> then the following command would be used.</p> <pre><code>fetchd tx bank send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet\n</code></pre> <p>When you run the command you will get a similar output and prompt. The user can check the details of the transfer and then press 'y' to confirm the transfer.</p> <pre><code>{\"body\":{\"messages\":[{\"@type\":\"/cosmos.bank.v1beta1.MsgSend\",\"from_address\":\"fetch12cjntwl32dry7fxck8qlgxq6na3fk5juwjdyy3\",\"to_address\":\"fetch1hph8kd54gl6qk0hy5rl08qw9gcr4vltmk3w02v\",\"amount\":[{\"denom\":\"atestfet\",\"amount\":\"100\"}]}],\"memo\":\"\",\"timeout_height\":\"0\",\"extension_options\":[],\"non_critical_extension_options\":[]},\"auth_info\":{\"signer_infos\":[],\"fee\":{\"amount\":[],\"gas_limit\":\"200000\",\"payer\":\"\",\"granter\":\"\"}},\"signatures\":[]}\n\nconfirm transaction before signing and broadcasting [y/N]: y\n</code></pre> <p>Once the transfer has been made a summary is presented to the user. An example is shown below:</p> <pre><code>code: 0\ncodespace: \"\"\ndata: \"\"\ngas_used: \"0\"\ngas_wanted: \"0\"\nheight: \"0\"\ninfo: \"\"\nlogs: []\nraw_log: '[]'\ntimestamp: \"\"\ntx: null\ntxhash: 77C7382A0B1B9FE39257A6C16C7E3169A875CB3A87F2CE9D947D7C1335B53E76\n</code></pre> <p>On failure, the response will have a non zero code, as well as some logs under the <code>raw_log</code> key:</p> <pre><code>code: 4\ncodespace: sdk\ndata: \"\"\ngas_used: \"0\"\ngas_wanted: \"0\"\nheight: \"0\"\ninfo: \"\"\nlogs: []\nraw_log: 'signature verification failed; please verify account number (5815) and chain-id\n  (dorado-1): unauthorized'\ntimestamp: \"\"\ntx: null\ntxhash: 23701B052B423D63EB4AC94773B5B8227B03A576692A57999E92F2554F2372D4\n</code></pre>"},{"location":"ledger_v2/delegator-guide-cli/","title":"CLI - Delegator guide","text":""},{"location":"ledger_v2/delegator-guide-cli/#querying-the-state","title":"Querying the state","text":""},{"location":"ledger_v2/delegator-guide-cli/#querying-the-current-staking-holdings-of-the-validators","title":"Querying the current staking holdings of the validators","text":"<p>The following command can be used to retrieve the current staking holdings of all validators:</p> <pre><code>fetchd query staking validators\n</code></pre> <p>On <code>dorado</code> network, this will produce an output similar to the following, describing the status of all the existing validators:</p> <pre><code>- |\n  operatoraddress: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n  conspubkey: fetchvalconspub1zcjduepq3urw6c6u0zvqmde4vr4gmy56nnq57shdhg56jynpu8n3s74hrm0q0mzqrx\n  jailed: false\n  status: 2\n  tokens: \"1000000000000000000000\"\n  delegatorshares: \"1000000000000000000000.000000000000000000\"\n  description:\n    moniker: validator5\n    identity: \"\"\n    website: \"\"\n    security_contact: \"\"\n    details: \"\"\n  unbondingheight: 0\n  unbondingcompletiontime: 1970-01-01T00:00:00Z\n  commission:\n    commission_rates:\n      rate: \"0.050000000000000000\"\n      max_rate: \"0.100000000000000000\"\n      max_change_rate: \"0.010000000000000000\"\n    update_time: 2021-02-12T12:41:25.579730119Z\n  minselfdelegation: \"1000000000000000000000\"\n  producingblocks: true\n- |\n  operatoraddress: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8\n  conspubkey: fetchvalconspub1zcjduepqmxr8gmcs6pwuxpsma264ax59wxtxd3vchrcv2c06deq9986kwt3s0wsk6n\n  jailed: false\n  status: 2\n  tokens: \"1000000000000000000000\"\n  delegatorshares: \"1000000000000000000000.000000000000000000\"\n  description:\n    moniker: validator2\n    identity: \"\"\n    website: \"\"\n    security_contact: \"\"\n    details: \"\"\n  unbondingheight: 0\n  unbondingcompletiontime: 1970-01-01T00:00:00Z\n  commission:\n    commission_rates:\n      rate: \"0.050000000000000000\"\n      max_rate: \"0.100000000000000000\"\n      max_change_rate: \"0.010000000000000000\"\n    update_time: 2021-02-03T13:00:00Z\n  minselfdelegation: \"1000000000000000000000\"\n  producingblocks: true\n...\n</code></pre> <p>To obtain the same information for a single validator, use the following command, providing the <code>operatoraddress</code> of the validator.</p> <pre><code>fetchd query staking validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n</code></pre> <p>A delegator will be particularly interested in the following keys:</p> <ul> <li><code>commission/commission_rates/rate</code>: The commission rate on revenue charged to any delegator by the validator.</li> <li><code>commission/commission_rates/max_change_rate</code>: The maximum daily increase of the validator's commission. This parameter cannot be changed by the validator operator.</li> <li><code>commission/commission_rates/max_rate</code>: The maximum commission rate this validator can charge. This parameter cannot be changed by the validator operator.</li> <li><code>minselfdelegation</code>: Minimum amount of <code>atestfet</code> the validator need to have bonded at all time. If the validator's self-bonded stake falls below this limit, their entire staking pool (i.e. all its delegators) will unbond. This parameter exists as a safeguard for delegators. Indeed, when a validator misbehaves, part of their total stake gets slashed. This includes the validator's self-delegateds stake as well as their delegators' stake. Thus, a validator with a high amount of self-delegated <code>atestfet</code> has more skin-in-the-game than a validator with a low amount. The minimum self-bond amount parameter guarantees to delegators that a validator will never fall below a certain amount of self-bonded stake, thereby ensuring a minimum level of skin-in-the-game. This parameter can only be increased by the validator operator.</li> </ul>"},{"location":"ledger_v2/delegator-guide-cli/#query-the-delegations-made-to-a-validator","title":"Query the delegations made to a validator","text":"<p>From a validator address, we can retrieve the list of delegations it received:</p> <pre><code>fetchd query staking delegations-to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n</code></pre> <p>Here is a sample of delegations <code>validator2</code> received on <code>dorado</code>:</p> <pre><code>- delegation:\n    delegator_address: fetch1z72rph6l5j6ex83n4urputykawcqg6t9zzruef\n    validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n    shares: \"1000000000000000000000.000000000000000000\"\n  balance:\n    denom: atestfet\n    amount: \"1000000000000000000000\"\n- delegation:\n    delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m\n    validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n    shares: \"100000.000000000000000000\"\n  balance:\n    denom: atestfet\n    amount: \"100000\"\n</code></pre>"},{"location":"ledger_v2/delegator-guide-cli/#query-the-redelegations","title":"Query the redelegations","text":"<p>Delegators can choose to redelegate the tokens they already delegated from one validator to another. Redelegation takes effect immediately, without any waiting period. However, the tokens can't be redelegated until the initial redelegation transaction has completed its 21 day completion time (the unlocking time is indicated by the <code>redelegationentry/completion_time</code> field in the outputs below).</p> <p>To obtain the list of redelegations made from a validator, use the following command:</p> <pre><code>fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n</code></pre> <p>This produces an output similar to the following, where delegator <code>fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m</code> issued 2 redelegations from <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> to <code>fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu</code>:</p> <pre><code>fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n- redelegation:\n    delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m\n    validator_src_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n    validator_dst_address: fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu\n    entries: []\n  entries:\n  - redelegationentry:\n      creation_height: 291037\n      completion_time: 2021-03-24T14:24:38.973444629Z\n      initial_balance: \"50000\"\n      shares_dst: \"50000.000000000000000000\"\n    balance: \"50000\"\n  - redelegationentry:\n      creation_height: 291133\n      completion_time: 2021-03-24T14:33:43.425472866Z\n      initial_balance: \"10000\"\n      shares_dst: \"10000.000000000000000000\"\n    balance: \"10000\"\n</code></pre> <p>Similarly, the list of redelegations issued by a delegator can be obtained with the following:</p> <pre><code>fetchd query staking redelegations fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m\n</code></pre>"},{"location":"ledger_v2/delegator-guide-cli/#query-the-user-rewards","title":"Query the user rewards","text":"<p>After having delegated some tokens to a validator, the user is eligible to a share of the rewards the validator collects.</p> <p>To retrieve all the outstanding rewards for an address, issue the following command:</p> <pre><code>fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m\n</code></pre> <p>This address having delegated tokens to 2 validators on <code>dorado</code>, produces the following output:</p> <pre><code>rewards:\n- validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n  reward:\n  - denom: atestfet\n    amount: \"0.000000000000200000\"\n- validator_address: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8\n  reward:\n  - denom: atestfet\n    amount: \"0.000000000001000000\"\ntotal:\n- denom: atestfet\n  amount: \"0.000000000001200000\"\n</code></pre> <p>Rewards can also be filtered for a given validator, like <code>validator5</code> here:</p> <pre><code>fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w\n</code></pre> <p>We now get only the reward from this validator:</p> <pre><code>- denom: atestfet\n  amount: \"0.000000000000200000\"\n</code></pre>"},{"location":"ledger_v2/delegator-guide-cli/#delegator-operations","title":"Delegator operations","text":""},{"location":"ledger_v2/delegator-guide-cli/#delegating-tokens","title":"Delegating tokens","text":"<p>To delegate <code>1000000 atestfet</code> tokens to  the <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> validator from the account <code>myKey</code>, the following command can be used:</p> <pre><code>fetchd tx staking delegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 1000000atestfet --from myKey\n</code></pre> <p>This will prompt for confirmation before issuing a transaction. After the transaction gets processed, it should appear under the delegations of the <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> validator.</p> <p>Note</p> <p>Once delegated, tokens can only be redelegated to another validator, or unbond in order to be returned to their original account. It's important to note that those two operations take 21 days to complete, period in which the involved tokens will be unavailable.</p>"},{"location":"ledger_v2/delegator-guide-cli/#redelegating-tokens","title":"Redelegating tokens","text":"<p>Redelegating tokens allows to transfer already delegated tokens from one validator to another.</p> <p>From the above example where we delegated <code>1000000 atestfet</code> to <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code>, we can now redelegate parts or all of those tokens to another validator. For example, we redelegate <code>400000 atestfet</code> from <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> to <code>fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu</code> with the following command:</p> <pre><code>fetchd tx staking redelegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu 400000atestfet --from myKey\n</code></pre> <p>This will prompt for confirmation and issue a new transaction once accepted. From here, inspecting the delegations from our account, we'll see that our delegated tokens are now:</p> <ul> <li><code>600000atestfet</code> to validator <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> (our initial 1000000 minus the 400000 redelegated)</li> <li><code>400000atestfet</code> to validator <code>fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu</code></li> </ul> <p>Now those <code>400000 atestfet</code> we redelegated can't be redelegated anymore for 21 days (the exact date can be found by querying the redelegation transaction, under the <code>completion_time</code> key). Note that it's still possible to unbond those tokens if needed. </p>"},{"location":"ledger_v2/delegator-guide-cli/#unbonding-tokens","title":"Unbonding tokens","text":"<p>At any time, we can transfer parts or all of our delegated tokens back to our account:</p> <pre><code>fetchd tx staking unbond fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 300000atestfet --from myKey\n</code></pre> <p>Once again, this will prompt for confirmation and issue a transaction, initiating the transfer of <code>300000 atestfet</code> from our stake on <code>fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w</code> validator back to our account. Those tokens will then be available after a 21 day period (the exact date can be found by querying the redelegation transaction, under the <code>completion_time</code> key). </p>"},{"location":"ledger_v2/delegator-guide-cli/#withdrawing-rewards","title":"Withdrawing rewards","text":"<p>In order to transfer rewards to the wallet, the following command can be used:</p> <pre><code>fetchd tx distribution withdraw-rewards fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w --from myKey\n</code></pre> <p>It requires the validator address from where the reward is withdrawn, and the name of the account private key having delegated tokens to the validator.</p> <p>When having delegated tokens to multiple validators, all rewards can be claimed in a single command:</p> <pre><code>fetchd tx distribution withdraw-all-rewards --from myKey\n</code></pre> <p>The rewards then appears on the account as soon as the transaction is processed.</p>"},{"location":"ledger_v2/faucet/","title":"Token Faucet","text":"<p>For our test networks, we have a simple token faucet implemented to allow users of the network to get started quickly. You can send it an account address, and it will transfer some test token on it.</p> <p>Token Faucets are network specific, depending on the network type they may or may not be deployed. Please check the networks page for specific details.</p> <p>The Token Faucet itself is available from the network block explorer (<code>GET FUNDS</code> button on the homepage).</p> <p>Enter your <code>fetch...</code> address in the popup and click Add funds button. Wait a few blocks for the transaction to be processed, and you should see it appear along with some funds on your account.</p>"},{"location":"ledger_v2/faucet/#add-funds-to-wallet-using-faucet-apis","title":"Add funds to Wallet using faucet APIs:","text":"<p>You can also request and get testnet tokens in your wallet using the APIs.</p>"},{"location":"ledger_v2/faucet/#get-some-atestfet","title":"Get some atestfet","text":"<pre><code>curl -X POST -H 'Content-Type: application/json' -d '{\"address\":\"&lt;address&gt;\"}' https://faucet-dorado.fetch.ai/api/v3/claims\n</code></pre>"},{"location":"ledger_v2/faucet/#get-some-nanomobx","title":"Get some nanomobx","text":"<pre><code>curl -X POST -H 'Content-Type: application/json' -d '{\"address\":\"&lt;address&gt;\"}' https://faucet-mobx-dorado.fetch.ai/api/v3/claims\n</code></pre>"},{"location":"ledger_v2/faucet/#get-some-ulrn","title":"Get some ulrn","text":"<pre><code>curl -X POST -H 'Content-Type: application/json' -d '{\"address\":\"&lt;address&gt;\"}' https://faucet-lrn-dorado.fetch.ai/api/v3/claims\n</code></pre>"},{"location":"ledger_v2/faucet/#sample-response-for-fund-request-to-faucet","title":"Sample response for fund request to faucet","text":"<pre><code>{\"status\":\"ok\",\"uuid\":\"&lt;uuid&gt;\",\"target\":\"&lt;address&gt;\"}\n</code></pre>"},{"location":"ledger_v2/faucet/#check-the-wallet-balance","title":"Check the wallet balance","text":"<pre><code>fetchd query bank balances &lt;address&gt;\n</code></pre> <pre><code>balances:\n- amount: \"&lt;balance&gt;\"\n  denom: atestfet\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"ledger_v2/governance/","title":"Governance","text":"<p>In order to be able to take part in the governance you either need to be running a full validator node or you need to have have delegated stake to an existing validator</p>"},{"location":"ledger_v2/governance/#stake-delegation","title":"Stake Delegation","text":"<p>In order to delegate stake to a validator the following command should be used:</p> <pre><code>fetchd tx staking delegate &lt;VALOPER_ADDRESS&gt; &lt;AMOUNT&gt; --from &lt;KEY_NAME&gt;\n</code></pre> <p>Where the <code>&lt;VALOPER_ADDRESS&gt;</code> begins with the prefix <code>fetchvaloper1...</code> and the <code>&lt;AMOUNT&gt;</code> field contains the currency denomination. For example:</p> <pre><code>fetchd tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent\n</code></pre>"},{"location":"ledger_v2/governance/#proposals-overview","title":"Proposals Overview","text":"<p>There are three types of proposal:</p> <ul> <li>Text Proposals: These are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic.</li> <li>Parameter Proposals: These proposals are used to update the value of an existing software parameter of the network.</li> <li>Software Upgrade Proposals: These are used to propose an upgrade of the <code>fetchd</code> software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network.</li> </ul>"},{"location":"ledger_v2/governance/#the-proposal-process","title":"The Proposal Process","text":"<p>Any FET holder can submit a proposal. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called minDeposit. The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit period status. Then, any FET holder can increase the deposit by sending a depositTx transaction to the network.</p> <p>Once the deposit reaches minDeposit, the proposal enters the voting period, which lasts 2 weeks. Any bonded FET holder can then cast a vote on this proposal. The user has the following options for voting:</p> <ul> <li>Yes</li> <li>No</li> <li>NoWithVeto</li> <li>Abstain</li> </ul> <p>At the end of the voting period, the proposal is accepted if there are more than 50% Yes votes (excluding Abstain votes) and less than 33.33% of NoWithVeto votes (excluding Abstain votes).</p>"},{"location":"ledger_v2/governance/#generating-proposals","title":"Generating Proposals","text":"<p>When creating a proposal, the user will create a proposal JSON file with all the relevant information. An example of a text proposal is shown below:</p> <pre><code>{\n\"title\": \"Switch to semantic commit messages for fetchd\",\n\"description\": \"This proposal is advocating a switch to sematic commit messages\\nYou can find the full discussion here: https://github.com/fetchai/fetchd/issues/231\",\n\"type\": \"Text\",\n\"deposit\": \"10000000000000000000atestfet\"\n}\n</code></pre> <p>It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it.</p> <p>Once the user has created the JSON file, to generate the text propsal on chain run the following command:</p> <p><code>fetchd tx gov submit-proposal --proposal proposal.json --from &lt;name of signing key&gt;</code></p>"},{"location":"ledger_v2/governance/#increasing-the-deposit-for-a-proposal","title":"Increasing the deposit for a proposal","text":"<p>If a user wants to increase the deposit of a proposal they would run the following command:</p> <p><code>fetchd tx gov deposit &lt;proposalID&gt; 100atestfet --from &lt;key name&gt;</code></p> <p>For example:</p> <p><code>fetchd tx gov deposit 2 100atestfet --from validator</code></p> <p>To get the proposalID, use the txhash obtained when the proposal was submitted and run the following command:</p> <p><code>fetchd query tx &lt;txhash&gt;</code></p>"},{"location":"ledger_v2/governance/#listing-current-proposals","title":"Listing current proposals","text":"<p>Current proposals are visible from the block explorer and using the CLI.</p> <p>To get the list of current proposals and their corresponding proposal-ids the run the following command:</p> <p><code>fetchd query gov proposals</code></p>"},{"location":"ledger_v2/governance/#voting-on-a-proposal","title":"Voting on a proposal","text":"<p>To vote for a proposal run the following command</p> <p><code>fetchd tx gov vote &lt;proposalID&gt; &lt;option&gt; --from &lt;delegatorKeyName&gt;</code></p> <p>For example:</p> <p><code>fetchd tx gov vote 5 yes --from validator</code></p> <p>Note</p> <p>When using CLI commands make sure that your CLI is pointing at the correct network. See the CLI introduction documentation for more details</p>"},{"location":"ledger_v2/joining-a-testnet/","title":"Joining a testnet","text":"<p>In order to join the test network you will need to have the correct version of the fetchd ledger available on your system. </p>"},{"location":"ledger_v2/joining-a-testnet/#using-a-local-version","title":"Using a local version","text":"<p>Assuming that you have followed the installation guide. You should now have <code>fetchd</code> successfully installed in your path. You can check this with the following command:</p> <pre><code>fetchd version\n</code></pre> <p>This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network).</p>"},{"location":"ledger_v2/joining-a-testnet/#configuring-the-client-fetchd","title":"Configuring the client fetchd","text":"<p>In general to configure the CLI to point at a given network it needs as a minimum the following configuration values</p> <pre><code>fetchd config chain-id &lt;chain-id&gt;\nfetchd config node &lt;rpc url&gt;\n</code></pre>"},{"location":"ledger_v2/joining-a-testnet/#dorado-example","title":"Dorado example","text":"<p>In the case of the Dorado network this would be as follows:</p> <pre><code>fetchd config chain-id dorado-1\nfetchd config node https://rpc-dorado.fetch.ai:443\n</code></pre>"},{"location":"ledger_v2/joining-a-testnet/#configuring-the-server-fetchd","title":"Configuring the server <code>fetchd</code>","text":"<p>Initialize fetchd by running command. This setups a default / empty genesis configuration.</p> <pre><code>fetchd init &lt;moniker-name&gt; --chain-id &lt;chain id&gt;\n</code></pre> <p>This will initialize default configuration files under the <code>FETCHD_HOME</code> folder, which default to <code>~/.fetchd/</code>. </p> <p>Execute the following command to download the latest genesis file:</p> <pre><code>curl &lt;rpc url&gt;/genesis | jq '.result.genesis' &gt; ~/.fetchd/config/genesis.json\n</code></pre> <p>Finally connect fetchd to the network by getting it to connect to a seed node for the given network.</p> <pre><code>fetchd start --p2p.seeds=&lt;network seed peers&gt;\n</code></pre> <p>Dorado Example</p> <p>Less abstractly then, if you wants to connect to the Dorado test net for example, you would need to run the following steps:</p> <pre><code># init\nfetchd init my-first-fetch-node --chain-id dorado-1\n\n# genesis\ncurl https://rpc-dorado.fetch.ai:443 | jq '.result.genesis' &gt; ~/.fetchd/config/genesis.json\n# ...or, if that's too large to download from the rpc interface as a single file...\ncurl https://storage.googleapis.com/fetch-ai-testnet-genesis/genesis-dorado-827201.json --output ~/.fetchd/config/genesis.json\n\n# start\nfetchd start --p2p.seeds=eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai:36556,46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai:36557,066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai:36558\n</code></pre> <p>Your local node will then start to synchronise itself with the network, replaying all blocks and transactions up to the current block. Depending on the age of the network and your hard disk speed, this could take a while.  Consider using chain snapshots to speed up this process.</p> <p>To know when your node as finished syncing, you can query it's status from its RPC API:</p> <pre><code>curl -s 127.0.0.1:26657/status |  jq '.result.sync_info.catching_up'\ntrue # this will print \"false\" once your node is up to date\n</code></pre>"},{"location":"ledger_v2/live-networks/","title":"Networks","text":""},{"location":"ledger_v2/live-networks/#mainnet","title":"Mainnet","text":"<p>The chain identifier of our production network is fetchhub-4.</p> Parameter Value Chain ID fetchhub-4 Block range 5,300,201 --&gt; Date range 05/04/2022 --&gt; Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.10.3 up to block 6295500  v0.10.4 up to block 7305500  v0.10.5 for blocks &gt; 7305500 RPC Endpoint https://rpc-fetchhub.fetch.ai:443 GRPC Endpoint https://grpc-fetchhub.fetch.ai:443 REST Endpoint https://rest-fetchhub.fetch.ai:443 Block Explorer https://explore-fetchhub.fetch.ai Token Faucet N/A Genesis <code>curl https://raw.githubusercontent.com/fetchai/genesis-fetchhub/fetchhub-4/fetchhub-4/data/genesis_migrated_5300200.json --output ~/.fetchd/config/genesis.json</code> Seed Node(s) 17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458 Snapshots https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-full.tgz https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-archive.tgz"},{"location":"ledger_v2/live-networks/#test-nets","title":"Test Nets","text":""},{"location":"ledger_v2/live-networks/#dorado","title":"Dorado","text":"<p>This network is running the same major version of fetchd as our mainnet (<code>fetchhub-4</code>), possibly at a more recent minor version.</p> <p>It is stable for deploying smart contracts and testing IBC.</p> Parameter Value Chain ID dorado-1 Denomination atestfet Decimals 18 (1testfet = 1000000000000000000atestfet) Min Gas Prices 1000000000atestfet Version v0.10.3 up to block 947800  v0.10.4 for blocks &gt; 947800 and &lt; 2198000  v0.10.5 for blocks &gt; 2198000 RPC Endpoint https://rpc-dorado.fetch.ai:443 GRPC Endpoint https://grpc-dorado.fetch.ai:443 REST Endpoint https://rest-dorado.fetch.ai:443 Block Explorer https://explore-dorado.fetch.ai/ Ledger Explorer https://browse-dorado.fetch.ai/ Token Faucet Use block explorer Genesis <code>curl https://storage.googleapis.com/fetch-ai-testnet-genesis/genesis-dorado-827201.json --output ~/.fetchd/config/genesis.json</code> Seed Node(s) eb9b9717975b49a57e62ea93aa4480e091ae0660@connect-dorado.fetch.ai:36556,46d2f86a255ece3daf244e2ca11d5be0f16cb633@connect-dorado.fetch.ai:36557,066fc564979b1f3173615f101b62448ac7e00eb1@connect-dorado.fetch.ai:36558 Snapshots https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-pruned.tgz https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-full.tgz https://storage.googleapis.com/fetch-ai-testnet-snapshots/dorado-archive.tgz"},{"location":"ledger_v2/single-node-network/","title":"Running a Single Node Network","text":"<p>Especially for things like contract development, it can be very useful to be able to run a single node network for testing. This document will outline the steps that are required in order to configure a <code>fetchd</code> network of 1 node.</p>"},{"location":"ledger_v2/single-node-network/#network-setup","title":"Network Setup","text":"<p>These steps only need to be done once in order to setup the local network.</p> <p>Step 1 - Build the ledger from source</p> <p>Follow the build instructions in order to compile the latest version of the ledger.</p> <p>Step 2 - Remove any existing networks</p> <p>Since we are starting a new network we need to remove any local files that we have in our system from a previous network</p> <p><code>rm -Rf ~/.fetchd</code></p> <p>Step 3 - Create an initial genesis</p> <p>Create the initial genesis file (<code>~/.fetchd/config/genesis.json</code>) with the following command:</p> <p><code>fetchd init --chain-id localnet-1 my-local-node-name</code></p> <ul> <li><code>localnet-1</code> is the chain id </li> <li><code>my-local-node-name</code> is the moniker for the node</li> </ul> <p>If you want to make any updates to the genesis, it is a good opportunity to make these updates now.</p> <p>Step 4 - Create your validator key</p> <p>In the following steps we will need to create the public/private keypair for our node. </p> <p>To create a new key called \"validator\" use the following command.</p> <p><code>fetchd keys add validator</code></p> <ul> <li><code>validator</code> is the name of the key in the keyring</li> </ul> <p>For more information checkout the complete documentation on keys.</p> <p>Step 5 - Adding the validator to the network</p> <p>To set the initial state for the network use the following command. This allocates <code>100000000000000000000</code> <code>stake</code> tokens to the validator which can be bonded. </p> <p><code>fetchd add-genesis-account validator 100000000000000000000stake</code></p> <p><code>stake</code> is the default test token denomination in the cosmos ecosystem, but you could use <code>afet</code>, <code>BTC</code> etc.</p> <p>Step 6 - Generating a validator transaction</p> <p>To get your validator to sign the genesis block (and to agree that this is the correct genesis starting point) use the following command.</p> <p><code>fetchd gentx validator 100000000000000000000stake --chain-id localnet-1</code></p> <ul> <li><code>validator</code> here is the name that you have given to the key</li> </ul> <p>Step 7 - Building the complete genesis</p> <p>To build final genesis configuration for the network run the following command</p> <p><code>fetchd collect-gentxs</code></p> <p>After running this command the network is successfully configured and you have computed the final genesis configuration for the network.</p>"},{"location":"ledger_v2/single-node-network/#running-the-local-node","title":"Running the local node","text":"<p>To run the network use the following command.</p> <p><code>fetchd start</code></p>"},{"location":"ledger_v2/single-node-network/#resetting-the-network","title":"Resetting the network","text":"<p>Often you will want to clear out all the data from the network and start again. To do that in a local network simply run the following command:</p> <p><code>fetchd tendermint unsafe-reset-all</code></p> <p>This resets the chain back to genesis, you DO NOT need to perform the network setup steps again. After running this command you can simply run the <code>fetchd start</code> command again.</p>"},{"location":"ledger_v2/snapshots/","title":"Chain State Snapshots","text":"<p>As blockchains get longer, the process of syncing from the genesis block begins to take many hours, or even days to complete. In circumstances where a faster sync is required, various snapshots of the fetchd chain state data are available for download, to more quickly bootstrap a node.</p> <p>Snapshots are available for both mainnet and the most recent testnet.  The URLs can be obtained from the network page. We aim to update snapshots on a daily basis.</p> <p>The example below uses the pruned mainnet snapshot, but can be adapted as required for full or archive nodes.</p>"},{"location":"ledger_v2/snapshots/#using-a-snapshot","title":"Using a snapshot","text":""},{"location":"ledger_v2/snapshots/#stop-your-node","title":"Stop your node","text":"<p>If you are already running fetchd, it is important that you stop it before proceeding.  Instructions for this are highly installation dependent and beyond the scope of this document, but could be as simple as a Ctrl-C. If you have not already initialised your node, follow the instructions for joining a testnet (modifying for mainnet as appropriate), then return to this page before starting fetchd.</p>"},{"location":"ledger_v2/snapshots/#reset-your-node","title":"Reset your node","text":"<p>WARNING: This will irreversibly erase your node's state database.  Ensure you take whatever backups you deem appropriate before proceeding.</p> <p>If using fetchd &lt;= 0.10.3 <code>fetchd unsafe-reset-all</code></p> <p>If using fetchd &gt;= 0.10.4 <code>fetchd tendermint unsafe-reset-all</code></p>"},{"location":"ledger_v2/snapshots/#download-and-install-the-snapshot","title":"Download and install the snapshot","text":"<p>Many options here!  The example below assumes a bash-like environment, uses a single connection for downloading, confirms the md5sum of the downloaded data against that of the original, and does not land the original compressed data to disk.  This is a good starting point, but depending on your local environment you may wish to make adaptations that eg sacrifice disk space and extra md5sum complexity for the benefit of parallel downloads with aria2.  Entirely up to you... let us know how you get on!</p> <pre><code># (optional) show the timestamp of the latest available snapshot\necho \"Latest available snapshot timestamp : $(curl -s -I  https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz | grep last-modified | cut -f3- -d' ')\"\n# download, decompress and extract state database\ncurl -v https://storage.googleapis.com/fetch-ai-mainnet-snapshots/fetchhub-4-pruned.tgz -o- 2&gt;headers.out | tee &gt;(md5sum &gt; md5sum.out) | gunzip -c | tar -xvf - --directory=~/.fetchd\n\n# (optional, but recommended) compare source md5 checksum provided in the headers by google, with the one calculated locally\n[[ $(grep 'x-goog-hash: md5' headers.out | sed -z 's/^.*md5=\\(.*\\)/\\1/g' | tr -d '\\r' | base64 -d | od -An -vtx1 | tr -d ' \\n') == $(awk '{ print $1 }' md5sum.out) ]] &amp;&amp; echo \"OK - md5sum match\" || echo \"ERROR - md5sum MISMATCH\"\n# (optional) show the creation date of the downloaded snapshot\necho \"Downloaded snapshot timestamp: $(grep last-modified headers.out | cut -f3- -d' ')\"\n</code></pre>"},{"location":"ledger_v2/snapshots/#restart-your-node","title":"Restart your node","text":"<p>Again, this entirely depends on your local installation, but a simple example for mainnet might be...</p> <pre><code>fetchd start --p2p.seeds 17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458`.\n</code></pre>"},{"location":"ledger_v2/state-sync/","title":"State-sync","text":"<p>State sync is a feature which allows you to quickly bootstrap a new node by allowing it to pull a state snapshot taken by other nodes.</p> <p>The state sync feature is only available from <code>fetchd  v0.10.6</code> and later. Prior versions needed to either sync from scratch or restore a chain snapshot, which both could take hours before having the node fully synced.</p> <p>With state sync, it now takes only a few minutes before having an operational node.</p>"},{"location":"ledger_v2/state-sync/#configuring-the-new-node","title":"Configuring the new node","text":"<p>In order to instruct the node to sync itself using a state sync snapshot, it need some configuration in the <code>~/.fetchd/config/config.toml</code> file. Open this file in an editor and lookup for the <code>statesync</code> section. By default, it should looks like this:</p> <pre><code>#######################################################\n###         State Sync Configuration Options        ###\n#######################################################\n[statesync]\n# State sync rapidly bootstraps a new node by discovering, fetching, and restoring a state machine\n# snapshot from peers instead of fetching and replaying historical blocks. Requires some peers in\n# the network to take and serve state machine snapshots. State sync is not attempted if the node\n# has any local state (LastBlockHeight &gt; 0). The node will have a truncated block history,\n# starting from the height of the snapshot.\nenable = false\n# RPC servers (comma-separated) for light client verification of the synced state machine and\n# retrieval of state data for node bootstrapping. Also needs a trusted height and corresponding\n# header hash obtained from a trusted source, and a period during which validators can be trusted.\n#\n# For Cosmos SDK-based chains, trust_period should usually be about 2/3 of the unbonding time (~2\n# weeks) during which they can be financially punished (slashed) for misbehavior.\nrpc_servers = \"\"\ntrust_height = 0\ntrust_hash = \"\"\ntrust_period = \"168h0m0s\"\n# Time to spend discovering snapshots before initiating a restore.\ndiscovery_time = \"15s\"\n# Temporary directory for state sync snapshot chunks, defaults to the OS tempdir (typically /tmp).\n# Will create a new, randomly named directory within, and remove it when done.\ntemp_dir = \"\"\n# The timeout duration before re-requesting a chunk, possibly from a different\n# peer (default: 1 minute).\nchunk_request_timeout = \"10s\"\n# The number of concurrent chunk fetchers to run (default: 1).\nchunk_fetchers = \"4\"\n</code></pre> <p>A few changes are needed:</p> <ul> <li>First, set <code>enable = true</code> to activate the state sync engine.</li> <li>Then, at least 2 rpc servers must be provided. A good place to find some is the cosmos chain registry. Servers must be comma separated without space (ie: <code>rpc_servers = \"https://rpc-fetchhub.fetch.ai:443,https://fetch-rpc.polkachu.com:443\"</code>). These servers will be used to verify the snapshots, so make sure you trust them enough for this. </li> <li>a recent <code>trust_height</code> and <code>trust_hash</code> are needed. Recent means it must be contained in the <code>trust_period</code> (168 hours, or ~1 week old by default). These can be obtained from a RPC server you trust to provide you correct data (and the 2nd RPC server from <code>rpc_servers</code> will be charged of confirming that the data are correct). </li> <li>And last, set <code>chunk_request_timeout</code> to <code>60s</code> (the <code>10s</code> default value seems too short and can lead to \"context deadline exceeded\" timeout errors when verifying the hashes)</li> </ul> <p>To retrieve the correct value for a fetch.ai RPC server, and the current network height, use:</p> <pre><code>curl https://rpc-fetchhub.fetch.ai:443/block | jq -r '{\"trusted_hash\": .result.block_id.hash, \"trusted_height\": .result.block.header.height}'\n{\n\"trusted_hash\": \"...some hash...\",\n  \"trusted_height\": \"...some height...\"\n}\n</code></pre> <p>and set the trusted_hash and trusted_height values in the config file.</p> <p>Once this is set, make sure you have the correct genesis by downloading it from the RPC node:</p> <pre><code>curl https://raw.githubusercontent.com/fetchai/genesis-fetchhub/fetchhub-4/fetchhub-4/data/genesis_migrated_5300200.json --output ~/.fetchd/config/genesis.json\n</code></pre> <p>and start the node using the seeds from the chain-registry:</p> <pre><code>fetchd start --p2p.seeds=\"17693da418c15c95d629994a320e2c4f51a8069b@connect-fetchhub.fetch.ai:36456,a575c681c2861fe945f77cb3aba0357da294f1f2@connect-fetchhub.fetch.ai:36457,d7cda986c9f59ab9e05058a803c3d0300d15d8da@connect-fetchhub.fetch.ai:36458\"\n</code></pre> <p>After the node initialized, it will start searching for available snapshots, and it should print log messages similar to:</p> <pre><code>8:22AM INF Discovered new snapshot format=1 hash=\"\ufffd \u076b/\ufffd\ufffd\\r\ufffdF#C(pD\ufffd&lt;\ufffd\ufffd\\x066\ufffd\ufffd\\x1f\ufffd\ufffd\\x1f&lt;i\ufffd\u075d\" height=2000 module=statesync\n8:22AM INF Discovered new snapshot format=1 hash=\"F\ufffd=\\x05\ufffdGh\ufffd{\ufffd|\ufffd\ufffd\ufffd\ufffd\ufffd,\ufffdQ'\ufffd=]\\x1a\ufffd$\ufffdb\ufffd\u05bfQ\" height=1900 module=statesync\n</code></pre> <p>The node will select the one with the <code>height</code> value the closest to the tip of the chain, and it will then start restoring the state, and finish syncing the few blocks remaining. </p> <p>If it fails to verify any blocks or hash when restoring, it will attempt to restore the next available snapshot, and, if no more are available, will fallback in discovery mode until an usable snapshot is available.</p>"},{"location":"ledger_v2/state-sync/#configure-an-existing-node-to-provide-snapshots","title":"Configure an existing node to provide snapshots","text":"<p>In order to provide new nodes snapshots they can start from, existing nodes need to be configured to create these snapshots. This requires changes in the <code>~/.fetchd/config/app.toml</code> file, in the <code>state-sync</code> section.</p> <pre><code>###############################################################################\n###                        State Sync Configuration                         ###\n###############################################################################\n\n# State sync snapshots allow other nodes to rapidly join the network without replaying historical\n# blocks, instead downloading and applying a snapshot of the application state at a given height.\n[state-sync]\n\n# snapshot-interval specifies the block interval at which local state sync snapshots are\n# taken (0 to disable). Must be a multiple of pruning-keep-every.\nsnapshot-interval = 0\n\n# snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).\nsnapshot-keep-recent = 2\n</code></pre> <p>Here <code>snapshot-interval</code> must be set to a number of blocks between each snapshot creation and it must be a multiple of your node prunning settings (default is 100, so valid values are 100, 1000, 700...). The number of snapshots to keep can be set with <code>snapshot-keep-recent</code>.</p>"},{"location":"ledger_v2/versions/","title":"Versions","text":"<p>There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions</p> Version Maturity Description v0.2.x Deprecated This is a stable version of the network to support agent development v0.3.x Deprecated Builds upon our stable release and adds support for the random beacon consensus module v0.4.x Deprecated Builds upon the random beacon consensus and adds support for aggregated signatures v0.5.x Deprecated Extension of v0.4.x v0.6.x Deprecated Extension of v0.5.x v0.7.x Deprecated Pre stargate fetchhub mainnet version v0.8.x Deprecated Mainline version of the network used for Stargate fetchhub mainnet v0.9.x Deprecated Mainline version of the network used for Carpicorn fetchhub mainnet v0.10.x Stable Mainline version of the network used for Dorado fetchhub mainnet"},{"location":"ledger_v2/versions/#upgrade-history","title":"Upgrade history","text":"<p>For node operators, the full upgrade history, documentations and procedures are available at: https://github.com/fetchai/genesis-fetchhub</p>"},{"location":"ledger_v2/validators/overview/","title":"Validators Overview","text":""},{"location":"ledger_v2/validators/overview/#introduction","title":"Introduction","text":"<p>The Fetch.ai Ledger relies on a set of validators that are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each validator's private key.</p> <p>Validator candidates can bond their own FET and have FET delegated, or staked, to them by token holders. The validators are determined by who has the most stake delegated to them. The top N validator candidates with the most stake will become the active validators.</p> <p>Validators and their delegators will earn FET as block provisions and tokens as transaction fees through execution of the consensus protocol. Transaction fees will be paid in FET.</p> <p>If validators double sign, are frequently offline or do not participate in governance, their staked FET (including FET of users that delegated to them) can be slashed. The penalty depends on the severity of the violation.</p>"},{"location":"ledger_v2/validators/overview/#hardware","title":"Hardware","text":"<p>The hardware resources for running a validator node largely depend on the network load. As a recommended configuration we suggest the following requirements</p> <ul> <li>2 x CPU, either Intel or AMD, with the SSE4.1, SSE4.2 and AVX flags (use lscpu to verify)</li> <li>8 GB RAM</li> <li>500 GB SSD</li> <li>100 Mbit/s always-on internet connection</li> <li>Linux OS (Ubuntu 18.04 or 20.04 recommended) / MacOS</li> </ul> <p>Uptime in incredibly important for being a validator. It is expected that validators will have appriopriate redundancies for compute, power, connectivity etc. While the blockchain itself it highly replicated it is also expected that validators will perform local storage backups in order to minimise validator down time.</p>"},{"location":"ledger_v2/validators/overview/#set-up-a-website","title":"Set Up a Website","text":"<p>Set up a dedicated validator's website and signal your intention to become a validator on our Discord server. This is important since delegators will want to have information about the entity they are delegating their FET to.</p> <p>Strictly speaking this is not necessary, however, it is recommended. As a validator on the network you will want to get other community users to delegate stake to your validator. The more combined stake that a validate has then the great share of the block rewards they will take.</p>"},{"location":"ledger_v2/validators/overview/#seek-legal-advice","title":"Seek Legal Advice","text":"<p>Seek legal advice if you intend to run a Validator.</p>"},{"location":"ledger_v2/validators/overview/#community","title":"Community","text":"<p>We highly recommdend to check out the validator community on the discord channel for more information and to see that latest announcements about becoming a validator.</p> <ul> <li>Discord</li> </ul>"},{"location":"ledger_v2/validators/security/","title":"Security","text":""},{"location":"ledger_v2/validators/security/#validator-security","title":"Validator Security","text":"<p>Each validator candidate is encouraged to run its operations independently, as diverse setups increase the resilience of the network. Validator candidates should commence their setup phase now in order to be on time for launch.</p>"},{"location":"ledger_v2/validators/security/#key-management-hsm","title":"Key Management - HSM","text":"<p>It is mission critical that an attacker cannot steal a validator's key. If this is possible, it puts the entire stake delegated to the compromised validator at risk. Hardware security modules are an important strategy for mitigating this risk. HSM modules must support <code>ed25519</code> signatures.</p>"},{"location":"ledger_v2/validators/security/#sentry-nodes-ddos-protection","title":"Sentry Nodes (DDOS Protection)","text":"<p>Validators are responsible for ensuring that the network can sustain denial of service attacks.</p> <p>One recommended way to mitigate these risks is for validators is to carefully structure their network topology in a so-called sentry node architecture.</p> <p>Validator nodes should only connect to full-nodes they trust because they operate them themselves or are run by other validators they know socially. This architecture shifts the burden of denial-of-service from the validator's node directly to its sentry nodes, and may require new sentry nodes be spun up or activated to mitigate attacks on existing ones.</p> <p>Sentry nodes can be quickly spun up or change their IP addresses. Because the links to the sentry nodes are in private IP space, an internet based attacked cannot disturb them directly. This will ensure validator block proposals and votes always make it to the rest of the network.</p> <p>To setup your sentry node architecture you can follow the instructions below:</p> <p>Validators nodes should edit their config.toml:</p> <pre><code># Comma separated list of nodes to keep persistent connections to\n# Do not add private peers to this list if you don't want them advertised\npersistent_peers =[list of sentry nodes]\n# Set true to enable the peer-exchange reactor\npex = false\n</code></pre> <p>Sentry Nodes should edit their config.toml:</p> <pre><code># Comma separated list of peer IDs to keep private (will not be gossiped to other peers)\n# Example ID: 3e16af0cead27979e1fc3dac57d03df3c7a77acc@3.87.179.235:26656\nprivate_peer_ids = \"node_ids_of_private_peers\"\n</code></pre>"},{"location":"ledger_v2/validators/setup/","title":"Setting up a Validator Node","text":"<p>This guide assumes that you have successfuly installed, configured and connected your validator to the desired network.</p>"},{"location":"ledger_v2/validators/setup/#creating-a-validator","title":"Creating a validator","text":"<p>To create a validator on the network you will need to send a transaction to the network bonding / staking your FET tokens. This process registers you as a validator and if you are one of the chosen validators you will start to produce blocks.</p> <pre><code>fetchd tx staking create-validator \\\n--amount=&lt;the amount to bond&gt; \\\n--pubkey=$(fetchd tendermint show-validator) \\\n--moniker=\"choose a moniker\" \\\n--chain-id=&lt;chain_id&gt; \\\n--commission-rate=\"0.10\" \\\n--commission-max-rate=\"0.20\" \\\n--commission-max-change-rate=\"0.01\" \\\n--min-self-delegation=\"&lt;the min self delegation&gt;\" \\\n--gas auto --gas-adjustment 1.5 --gas-prices \"&lt;network gas prices&gt;\" \\\n--from=&lt;key_name&gt;\n</code></pre> <p>Dorado Example</p> <p>Before trying to create a validator you should verify that you have some tokens available beforehand. The easiest way to do this is via the CLI.</p> <p>Here is an sample of a typical command line command that will register the node as running the validator.</p> <pre><code>fetchd tx staking create-validator \\\n--amount=1000000000000000000atestfet \\\n--pubkey=$(fetchd tendermint show-validator) \\\n--moniker=\"my-test-validator\" \\\n--chain-id=dorado-1 \\\n--commission-rate=\"0.10\" \\\n--commission-max-rate=\"0.20\" \\\n--commission-max-change-rate=\"0.01\" \\\n--min-self-delegation=\"1000000000000000000\" \\\n--gas auto --gas-adjustment 1.5 --gas-prices 1000000000atestfet \\\n--from=test-key\n</code></pre>"},{"location":"ledger_v2/validators/setup/#editing-a-validator","title":"Editing a validator","text":"<p>Over time it is possible that validators will want to adjust various settings about their nodes. This can be simple things like the associated website for a validator or more consequential actions like altering the commission rate.</p> <p>In either case, should a validator choose to make this update they would send an \"edit-validator\" transaction to the network. These can be created in a similar way to the \"create-validator\" transactions as shown below:</p> <pre><code>fetchd tx staking edit-validator\n  --moniker=\"choose a moniker\" \\\n--website=\"https://fetch.ai\" \\\n--details=\"To infinity and beyond!\" \\\n--chain-id=&lt;chain_id&gt; \\\n--commission-rate=\"0.10\" \\\n--from=&lt;key_name&gt;\n</code></pre>"},{"location":"ledger_v2/validators/setup/#unbonding-a-validator","title":"Unbonding a validator","text":"<p>When / if a validator wants to stop being a validator for any reason, they can unbond some or all of their staked tokens. This is done with the following command.</p> <pre><code>fetchd tx staking unbond \\\n&lt;validator operator address&gt; \\\n&lt;amount to remove&gt; \\\n--from &lt;key name&gt;\n</code></pre> <p>An example of the command is given in the following example:</p> <pre><code>fetchd tx staking unbond \\\nfetchvaloper1jqqwdch3jmzlmj4tjfn67s3sqm9elkd3wrpspf \\\n1000000000000000000000atestfet \\\n--gas auto --gas-adjustment 1.5 --gas-prices 1000000000atestfet \\\n--from test-key\n</code></pre>"},{"location":"native_and_erc20/how_to_convert_fet/","title":"How to convert","text":"<p>On this page, you can find instructions on how to convert ERC-20 and native FETs to each other.</p>"},{"location":"native_and_erc20/how_to_convert_fet/#native-to-erc-20-fet","title":"Native to ERC-20 FET","text":"<ol> <li> <p>Ensure you have the Fetch wallet installed and that the native FETs you want to convert are in this wallet.</p> </li> <li> <p>Ensure you have the Metamask wallet installed and that your Ethereum account is set up on it. This is where the ERC-20 FETs will go to.</p> </li> <li> <p>Go to the Token Bridge.</p> </li> <li> <p>Unlock the Metamask wallet if instructed to do so.</p> </li> <li> <p>Ensure the Native to ERC-20 tab is selected.</p> </li> <li> <p>Hit Connect Browser Wallet and allow the token bridge to connect to your Fetch wallet.</p> </li> <li> <p>The fields will be automatically populated with the addresses on the two wallets. Ensure these are correct.</p> </li> <li> <p>Under Amount, enter the amount of tokens you wish to convert. </p> </li> <li> <p>Hit Transfer.</p> </li> </ol>"},{"location":"native_and_erc20/how_to_convert_fet/#erc-20-to-native-fet","title":"ERC-20 to Native FET","text":"<ol> <li> <p>Ensure you have the Metamask wallet installed and that the ERC-20 FETs you want to convert are in this wallet.</p> </li> <li> <p>Ensure you have the Fetch wallet installed and that your Fetch.ai account is set up on it. This is where the native FETs will go to.</p> </li> <li> <p>Go to the Token Bridge.</p> </li> <li> <p>Unlock the Metamask wallet if instructed to do so.</p> </li> <li> <p>Ensure the ERC-20 to Native tab is selected.</p> </li> <li> <p>The Ethereum address should be automatically filled in with the address of the active account on your Metamask wallet. Ensure that it is correct.</p> </li> <li> <p>Insert your Fetch wallet address in the Native Address section.</p> </li> <li> <p>Under Amount, enter the amount of tokens you wish to convert. </p> </li> <li> <p>Hit Transfer and allow the Token Bridge to connect with your wallet.</p> </li> </ol>"},{"location":"native_and_erc20/native_and_erc20_fet/","title":"Native and ERC-20 FET","text":"<p>The Fetch.ai token (FET) is a utility token and the key medium of exchange on the Fetch.ai network. FET can be used to pay for services in the Fetch ecosystem and network transaction fees. Users can also choose to stake FET to participate in securing the network via its Proof-of-Stake (PoS) consensus mechanism and earn rewards in return for contributing to validator nodes. </p> <p>The Fetch.ai team initially developed the FET utility token on an ERC-20 contract on the Ethereum network while finishing the work on the Fetch.ai native main network (main-net). This helped developers across the world get their hands on the FET tokens earlier and kickstart the process of developing innovative solutions within the Fetch.ai ecosystem. FET, as an ERC-20 token on the Ethereum contract has never been Fetch.ai's end game because the Ethereum chain does not offer the degree of scalability needed by the kinds of applications the fetch.ai ecosystem aims for.</p> <p>With the launch of the Fetch.ai Main-net, the native FET became available. This meant that users operating on the Fetch.ai network no longer needed to hold any token (e.g. ETH or BTC) associated with any other network. It is only the native FET tokens that fuel the Fetch.ai ecosystem and its applications.</p> <p>ERC-20 FET tokens are still in circulation and currently co-exist with native FET tokens and can be transferred from one to the other easily on the Fetch.ai network. All of the ERC-20 FET tokens will ultimately become native FET tokens, but in the foreseeable future both will live side by side. FET tokens can be purchased from different centralized or decentralized exchanges. However, certain exchanges may buy or sell one type or the other.</p>"},{"location":"native_and_erc20/reconciliation/","title":"Reconciliation service","text":"<p>During the stake migration from ETH to the Fetch Main-net on September 14th, 2021, the staked funds were all migrated from the Ethereum staking contract to the Fetch.ai Main-net. However, some users decided to wait for reconciliation to access their funds after the auto-migration was complete. </p> <p>The reconciliation service has been built to restore access of the migrated funds for these users.</p> <p>Warning</p> <p>The reconciliation service is specifically for those users who opted to not use the guides to gain access to their staked funds during the stake migration. If you are unable to access your funds for any other reason, for example you were hacked, then the reconciliation service is not applicable to you.</p>"},{"location":"native_and_erc20/reconciliation/#instructions","title":"Instructions","text":"<p>First, make sure the following conditions are satisfied:</p> <ul> <li> <p>Your Fetch wallet is set up and you have access to it.</p> <p>Info</p> <p>The address of the account on your Fetch wallet must have recorded at least one transaction on the network. If you have never made a transaction using this address before, the reconciliation tool and the network have no way of knowing your wallet exists and will not allow you to complete the final submission.</p> </li> <li> <p>You have at least 1 Native FET token in your wallet to pay the transaction fee associated with the reconciliation tool. You can buy FET from centralized or decentralized exchanges.</p> </li> <li> <p>You have the Metamask wallet set up and configured with the address you used in the original staking platform.</p> </li> </ul> <p>If the above conditions are satisfied, head over to the reconciliation service and follow the instructions.</p> <p>Info</p> <p>The reconciliation service is activated at certain times so users can register with it. For economic safety, the fund transfers only happen during network upgrades.</p> <p>If the above conditions are satisfied, head over to the reconciliation service and follow the instructions.</p> <p>Once your registered transaction is successful and your reconciliation request is deemed valid, the funds will be automatically released to the main-net address on your Fetch wallet.</p>"},{"location":"soef/simple-oef-usage/","title":"SOEF Connection","text":"<p>You can use the SOEF in the agent framework by using the SOEF connection as a package in your agent project.</p> <p>Note</p> <p>Please consult the relevant guide for details. </p>"},{"location":"soef/simple-oef/","title":"Simple-OEF: Agent Search and Discovery","text":"<p>This documentation has been produced for the Simple-OEF version <code>0.3.4</code>.</p>"},{"location":"soef/simple-oef/#concepts","title":"Concepts","text":"<p>The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents. Agents register with the soef and are then able to conduct searches around them to find other agents that may be able to help. It is a relatively simple implementation focussing on functionality, performance and ease-of-use. As it develops, it will evolve into a full-scale decentralised, multi-dimensional digital world.</p> <p>The work-flow is:</p> <ul> <li>Find relevant agents on the soef,</li> <li>Communicate using the Agent Framework's peer-to-peer network,</li> <li>Negotiate and then transact on the ledger in order to exchange value for tokens</li> </ul> <p>When an agent registers with the soef, it is issued with a unique reference which is quoted in all subsequent transactions. This way, the soef knows who its talking to. The soef is transaction based, so it does not need a permanent connection to be maintained in order to work with it. If it does not hear from an agent for a period of time, that agent will be timed out and automatically unregistered. This period of time is typically about one hour, but you can see the soef's configuration at:</p> <p>https://s-oef.fetch.ai:443\" target=\"_blank\"&gt;https://s-oef.fetch.ai:443</p> <p>Agents identify themselves in a number of ways. These include their address, their given name, their classification and their genus. They can also describe how they \"look\" in other ways, and specify the services that they provide.</p> <p>In order to register, agents must provide a valid address and a given name. The address can be for the Fetch.ai native ledger, the Fetch.ai Cosmos ledger or the Ethereum ledger. It is this that uniquely identifies them, and addresses cannot be duplicated or shared. The given name can be anything and it is not used for search filtering. Typically, it can be thought of as a debugging aid or a context. Names could be Alice, Bob or Jim, as well as they could be a flight number, train identity or reference code. They appear in find results, but are not used to find by.</p>"},{"location":"soef/simple-oef/#describing-an-agent","title":"Describing an Agent","text":"<p>Agents describe themselves in three ways:</p> <ol> <li>Identity: their address and ledger type along with their given name</li> <li>Personality Pieces: how they look</li> <li>Service Keys: what they do, sell or want.</li> </ol> <p>We cover all of these in this next section. It's important to understand the difference between personality pieces and service keys, as agents only have one appearance, but they can provide many services. Search results can be filtered by a number of both, and wildcards are permitted where relevant.</p>"},{"location":"soef/simple-oef/#personality-pieces","title":"Personality Pieces","text":"<p>Agents can have a number of personality pieces. These describe how an agent appears, where it is, and other properties such as heading, supported protocols and types of transactions. All personality pieces are optional, but the more you set, the easier it is for searchers to narrow you down accurately.</p> Piece Description <code>genus</code> Coarse type of agent, includes things such as <code>vehicle</code>, <code>building</code>, <code>iot</code>. See the genus table below. <code>classification</code> An agent's classification, typically in the form <code>mobility.railway.train</code>. See note below on classifications. No fixed classifications are specified. Classifications can contain alphanumeric characters, the period, underscore and colon (<code>_.:</code>). <code>architecture</code> Agent's architecture. See the architecture table below. Introduced in version <code>0.1.20</code>. The vast majority of agents should set this to <code>agentframework</code>. <code>dynamics.moving</code> Boolean, indicates if the agent is moving or not. <code>dynamics.heading</code> Indicates the heading of the agent, in radians, with 0.0 pointing due north. <code>dynamics.altitude</code> Altitude of the agent in metres from MSL <code>dynamics.position</code> Indicates the GPS co-ordinates of the agent as latitude and longitude. <code>action.buyer</code> Boolean, indicates whether the agent wishes to buy information, i.e., is an agent that requires value from another agent. <code>action.seller</code> Boolean, indicates whether the agent sells information, i.e., provides value. Value provided can be zero-cost."},{"location":"soef/simple-oef/#genus-list","title":"Genus List","text":"<p>A genus is a coarse agent class. It is the roughest description of what an agent is, and an easy way of filtering large groups of agents out of searches. The supported genus list is:</p> Name Description <code>test</code> Agent is a test agent, and should be generally ignored. <code>vehicle</code> Moving objects such as trains, planes and automobiles <code>avatar</code> An agent that represents a human being <code>service</code> An agent that provides a service <code>iot</code> An agent that represents an Internet of Things device <code>data</code> An agent that represents data <code>furniture</code> Small fixed location items such as signs, mobile masts <code>building</code> Large fixed location item such as house, railway station, school <code>buyer</code> Indicates the agent is a buyer only and does not have value to deliver <code>viewer</code> The agent is a view in the world, acting as a \"camera\" to view content <code>financial</code> Financial agent: service, exchange, autonomous market maker,  etc. <p>The best way to use genus is to pick the best fit choice. If there isn't one for you, then do not specify it. If you feel that a high-level genus is missing, please make the suggestion in our Developer Discord (see here).</p>"},{"location":"soef/simple-oef/#architectures","title":"Architectures","text":"<p>An architecture is a clue to other agents to describe how the agent is built. The vast majority of agents will be built using the Fetch Agent Framework, but in some cases, such as light-weight IoT devices or test/debugging, agents are built otherwise. Architecture offers a way of describing or filtering, as agents with a similar architecture are more likely to be able to communicate with each other in a meaningful way.</p> Architecture Description <code>custom</code> Custom agent architecture <code>agentframework</code> Built using the Fetch Agent Framework"},{"location":"soef/simple-oef/#a-note-on-classifications","title":"A Note on Classifications","text":"<p>There is currently no fixed set of guidelines as to how classifications are used. It is expected that agent builders will converge on a set of standards, and as those become clearer, they will be documented as \"by convention\" classification uses. Here are some examples of classifications in use:</p> <pre><code>mobility.railway.station\nmobility.railway.train\nmobility.road.taxi\ninfrastructure.road.sign\n</code></pre> <p>When filtering by classifications, the <code>*</code> wildcard can be used to, for example, capture all mobility related agents with a wildcard of <code>mobility.*</code>.</p>"},{"location":"soef/simple-oef/#service-keys","title":"Service Keys","text":"<p>Agents can have a number of service keys. Service keys are simple key/value pairs that describe the list of services that the agent provides. Whilst personality pieces can be thought of as how an agent looks, service keys are what an agent has or does. Service keys are user defined and as with personality pieces, currently have no convention for formatting. They are at the agent builder's discretion. As this changes, the documentation will be updated. However, for buyer agents, three suggested keys are:</p> <pre><code>buying_genus\nbuying_architecture\nbuying_classifications\ndata_type\nsi_unit\n</code></pre> <p>This allows searches to look for potential buyers of classifications, genus or with a compatible architecture.</p>"},{"location":"soef/simple-oef/#finding-agents","title":"Finding Agents","text":"<p>The soef is designed for geographic searches where agents are able to find other agents near to them that are able to provide them with the value that they want, or who might wish to have the value they provide. However, it also allows for positionless searches on a single node. Future versions of the soef will support searches across nodes, and dimensional reduction-based fuzzy searches.</p> <p>Geographic searches are performed using the  <code>find_around_me</code> operation. This allows searches that:</p> <ul> <li>Are within a certain range in KM</li> <li>Optionally must be positioned within an angle of a heading</li> <li>That have a specified set of personality pieces (with wildcards where applicable)</li> <li>That have a specified set of service keys (with wildcards)</li> <li>Where chain identifiers match</li> </ul> <p>Positionless searches are performed using the <code>find_on_this_node</code> operation. This allows searches that:</p> <ul> <li>That have a specified set of personality pieces (with wildcards where applicable)</li> <li>That have a specified set of service keys (with wildcards)</li> <li>Where chain identifiers match</li> </ul> <p>At least one filter must be supplied in positionless searches. Positionless searches are not boundless, they are capped at a specific number. The tighter the filters, the less likely that you will be capped.</p> <p>Some limits apply to the maximum number of filters, range and returned results. This may vary from soef instance to soef instance. You can see (and parse if required) these by getting the soef status at:</p> <p>https://s-oef.fetch.ai:443\" target=\"_blank\"&gt;https://s-oef.fetch.ai:443</p> <p>The soef returns XML that includes information about all found agents. An example of that, unparsed, looks like this:</p> <pre><code>&lt;response&gt;\n&lt;success&gt;1&lt;/success&gt;\n&lt;total&gt;1&lt;/total&gt;\n&lt;capped&gt;0&lt;/capped&gt;\n&lt;results&gt;\n&lt;agent name=\"TrainNumber1234\" genus=\"vehicle\" classification=\"mobility.railway.train\" user_context=\"18:00 to Berlin\"&gt;\n&lt;identities&gt;\n&lt;identity chain_identifier=\"fetchai\"&gt;2h6fi8oCkMz9GCpL7EUYMHjzgdRFGmDP5V4Ls97jZpzjg523yY&lt;/identity&gt;\n&lt;/identities&gt;\n&lt;range_in_km&gt;55.7363&lt;/range_in_km&gt;\n&lt;location accuracy=\"3\"&gt;\n&lt;latitude&gt;52.5&lt;/latitude&gt;\n&lt;longitude&gt;0.2&lt;/longitude&gt;\n&lt;/location&gt;\n&lt;/agent&gt;\n&lt;/results&gt;\n&lt;/response&gt;\n</code></pre> <p>The <code>&lt;location&gt;</code> block is only returned if the agent has set itself to disclose its position in a find. Likewise, the <code>user_context=\"\"</code> is only returned if enabled. Normally, the default is not to, and agents will then only return the <code>&lt;range_in_km&gt;</code> item. This is because agents may deliver their precise location as part of the value that they deliver, and therefore it would need to be negotiated and potentially paid for. However, sometimes, it is desirable for agents to always deliver their position when found but specify the accuracy. Because of this, the soef supports four levels of accuracy:</p> Level Accuracy <code>none</code> Default do not disclose position, range only. <code>low</code> Rounded to nearest 11km <code>medium</code> Rounded to nearest 1.1km <code>high</code> Rounded to nearest 110 metres <code>maximum</code> No rounding: supplied in maximum available detail"},{"location":"soef/simple-oef/#technical-details","title":"Technical Details","text":"<p>For the majority of use cases, the soef will be used from the Agent Framework. As a result, talking to it directly will not be needed. There are some occasions where interacting with the soef directly may be required, and this section documents the API functionality.</p> <p>Until version 1.0 and main-net version 2 (expected in early 2021), some of the security and paid-for-services are not implemented and where they are, they generally not enforced. Digital signatures for the sign-on process and unique identity recovery will be implemented, as will encryption on sensitive data transport, for example. Thus the API is likely to change substantially in the coming months, particularly the initial registration process. It is not recommended that you invest in substantial code that talks to the soef directly until after 1.0, and it is always preferred to go through the Agent Framework.</p>"},{"location":"soef/simple-oef/#registration","title":"Registration","text":"<p>Agents register at the <code>/register</code> page on the soef. They are expected to provide four pieces of information:</p> <ol> <li>An API key</li> <li>A chain identifier, which can be either <code>fetchai_v1</code> for the Fetch native network (testnet or mainnet), <code>fetchai_v2_*</code> for the Fetch version 2 network or <code>ethereum</code> for the Ethereum network. See the \"Chain identifiers\" table below for a complete list of supported chain identifiers.</li> <li>An address, which must be a valid address for the specified chain identifier</li> <li>A \"given name\" (see \"Concepts\", above), which can be anything from Alice to Bob, or a flight number, or any other user-given context. It must not exceed 128 characters.</li> </ol> <p>If registration is successful, the soef will return a result like this:</p> <pre><code>&lt;response&gt;\n&lt;encrypted&gt;0&lt;/encrypted&gt;\n&lt;token&gt;0A709D1ED170A3E96C4AC9D014BCAE30&lt;/token&gt;\n&lt;page_address&gt;\noef_AEC97453A80FFFF5F11E612594585F611D1728FFCD74BBF4FE915BBBB052\n  &lt;/page_address&gt;\n&lt;/response&gt;\n</code></pre> <p>This indicates success and that the agent is now in the Lobby. The lobby is a temporary holding pen where newly registered agents wait until the negotiation is complete. If an agent does not respond and complete its registration within 60 seconds, it is removed from the lobby and registration is cancelled.</p> <p>The <code>&lt;page_address&gt;</code> is the unique URL for the new agent. This must be quoted in all subsequent interactions and is how the soef identifies that specific agent. To complete registration, use the unique URL and specify the parameters:</p> <ul> <li><code>token=</code> with the token that was returned above and</li> <li><code>command=acknowledge</code></li> </ul> <p>If this works, you will receive a success response:</p> <pre><code>&lt;response&gt;\n&lt;success&gt;1&lt;/success&gt;\n&lt;/response&gt;\n</code></pre> <p>At this point, your agent is now fully registered and can then communicate with the soef.</p> <p>Agents that do not contact the soef at least once over a specified interval will be automatically unregistered. The typical setting for this is 60 minutes.</p>"},{"location":"soef/simple-oef/#chain-identifiers","title":"Chain Identifiers","text":"<p>The soef supports a selection of chain identifiers designed to allow agents to distinguish networks in searches, but also to identify the type of address used for verification purposes.</p> Chain identifier Network <code>fetchai_v1</code> Version 1 Fetch.ai network (testnet or mainnet). Versions prior to 0.2 of the soef used <code>fetchai</code> for this, which is retained for compatibility. <code>fetchai_v2_testnet_stable</code> Version 2 Fetch.ai stable testnet, also known as \"Agentland\". Versions prior to 0.2 of the soef used <code>fetchai_cosmos</code> which is retained for compatibility, but deprecated. <code>fetchai_v2_testnet_incentivised</code> Current incentivised testnet. Fetch.ai are running a high-reward sequence of testnets in Q4 2020 and Q1 2021 leading to V2 mainnet. <code>fetchai_v2_misc</code> Miscellaneous v2 network. These are temporary or transient testnets where there is a desire to separate the chain ID from other v2 networks. <code>fetchai_v2_mainnet</code> Fetch.ai v2 mainnet. Not yet active."},{"location":"soef/simple-oef/#commands","title":"Commands","text":"<p>The soef has a number of commands that can be used to set or update personality pieces, manage service keys, unregister, find other agents and other operations. These commands are specified using the agent's unique URL and a <code>command=</code> parameter. There may then be other required and optional parameters for that particular command.</p> Command Details <code>unregister</code> Unregisters the agent from the soef. The unique URL is invalidated and the agent will no longer appear in searches. No parameters. <code>ping</code> Say hello. This is for agents that have been idle for a long period of time and wish to maintain their connection. No parameters. <code>set_personality_piece</code> Sets or updates a personality piece. Specify the <code>piece</code> (see personality piece table above) and the <code>value</code>. For personality pieces with multiple values, such as <code>dynamics.position</code>, separate them with the pipe character <code>|</code>. <code>set_service_key</code> Sets or updates a service key. Specify the <code>key</code> and the <code>value</code> to assign to it. <code>remove_service_key</code> Removes an existing service key. Specify the <code>key</code>. <code>set_find_position_disclosure_accuracy</code> Sets the find disclosure accuracy. See the table in \"Finding Agents\", above, for the accepted values for the parameter <code>accuracy</code>. <code>find_around_me</code> Geographic finding of agents around me. This allows various filters, such as personality pieces and service keys, to be specified. See below, as this is more complex. <code>find_on_this_node</code> Positionless finding of agents on this node. Various filters such as personality pieces and service keys can narrow the search. See below for more information. <code>set_position</code> This is a direct internal mapping to <code>set_personality_piece</code> with a piece of <code>dynamics.position</code>. It existed in the earliest versions of the soef and remains as a short-cut. It expects <code>longitude</code> and <code>latitude</code> as parameters. <code>set_declared_name</code> This allows an agent's declared name to be changed after registration. It takes one parameter, <code>name</code>, to specify the replacement name. Names cannot exceed 128 characters and must not contain illegal characters. <code>set_user_context</code> Sets an optional user-context for an agent to what is specified in the <code>value</code> parameter. This can be optionally disclosed in <code>find_around_me</code> if enabled. See <code>set_disclose_user_context</code>, below. The user context must not contain illegal characters and is limited to 160 maximum. <code>set_disclose_user_context</code> If the <code>disclose</code> parameter is set to <code>true</code>, the optional user context is disclosed if it has been set. Default is <code>false</code>."},{"location":"soef/simple-oef/#find-commands-in-detail","title":"Find Commands in Detail","text":"<p><code>find_around_me</code> and <code>find_on_this_node</code> are the big commands. Ultimately, they will cost a small amount of tokens to use, depending on the size of the request, as it involves the most computing time. This provides an incentive for soef operators to maintain soef nodes that correspond to subject areas, geographic areas or both. The command has a number of parameters specifying the filtering required. For <code>find_around_me</code>, the <code>range_in_km</code> is required, whereas narrowing down agents to be within a certain angle of a direction is optional. This cannot exceed a certain range, typically between 50 and 75km. This, and other configuration items, are available on the soef's configuration page. There are other parameters that are optional, although for <code>find_on_this_node</code> at least one <code>ppfilter</code> or <code>skfilter</code> must be specified. The parameters are:</p> Parameter Use <code>range_in_km</code> Range in kilometres to include agents in results. <code>of_heading</code> Optional: if a pizza-slice type search is required, this is the direction, in degrees, with 0.0 being north. <code>within</code> Optional: if a pizza-slice search, this is the angle in degrees from the <code>of_heading</code> that is allowed. If either <code>of_heading</code> or <code>within</code> are specified, both must be specified. Example: <code>of_heading</code> set to 90.0 and <code>within</code> set to 30 would exclude any agents that are not within 30 degrees of direct east of the me agent. <code>chains_must_match</code> Boolean. Must be <code>true</code> or <code>false</code>. Default is <code>false</code>. If specified, this ensures that any agents returned in the search will have the same chain identifier as you. <code>ppfilter</code> Specify a personality piece filter. Multiple <code>ppfilter</code>s can be specified. Example use is: <code>ppfilter=dynamics.moving,true</code>. Wildcards can be used where relevant, e.g.: <code>ppfilter=classification,mobility*</code> will match all classifications that start with <code>mobility</code>, whereas <code>ppfilter=classification,*mobility*</code> will match all classifications with <code>mobility</code> anywhere in it. <code>skfilter</code> Specify a service key filter. Multiple <code>skfilter</code>s can be specified. Example use is: <code>skfilter=fruit,peach</code> which will require any returned results to have a service key of <code>fruit</code> and a value of <code>peach</code>. Wildcards can be specified, so <code>skfilter=fruit,pea*</code> will match any agent with a service key of <code>fruit</code> that starts <code>pea</code>, so <code>pear</code> and <code>peach</code> would match."},{"location":"soef/simple-oef/#sk-filters-filter-modes","title":"SK Filters: filter modes","text":"<p>The <code>skfilter</code> parameter for <code>find_around_me</code> also supports a mode. Four modes are supported:</p> Mode string Description PS Key must be present, and success is required PF Key must be present, and failure is required OS Only match if present, and success is required OF Only match if present, and failure is required <p>For example:</p> <pre><code>command=find_around_me&amp;range_in_km=50&amp;skfilter=type,fruit,PS&amp;skfilter=size,large,OF\n</code></pre> <p>In this example, the key <code>type</code> must be present, and it must match to <code>fruit</code>. If the <code>size</code> key is present, and it is set to <code>large</code>, then do not match. I.e., return everything that's a fruit within 50km except where the size is large.</p>"},{"location":"soef/simple-oef/#further-information","title":"Further Information","text":"<p>You can find further information, or talk to us, in the #agents channel on our official developer Discord server, which you can access here.</p> <p>We welcome your feedback and strive to deliver the best decentralised search and discovery service for agents that is possible. There are many upcoming features, including the operation incentive mechanisms, additional security and encryption, active searches (where results happen without <code>find_around_me</code> being issued), non-geographic searches across one and many soef nodes and dimensional-reduction based approximate searches.</p> <p>[Docs: issue 15, <code>0.3.4</code>, <code>28-Dec-2020</code>, TWS]</p>"},{"location":"uAgents/","title":"Introduction","text":"<p>The \u03bcAgents (micro-Agents) project is a fast and lightweight framework that makes it easy to build agents for all kinds of decentralised use cases.</p>"},{"location":"uAgents/#why-use-agents","title":"Why use \u03bcAgents?","text":"<p>Here are a few of the reasons to build with \u03bcAgents. They are:</p> <ul> <li>easy to learn: follow our quick start guides to install the Python package and create an agent in just a few minutes.</li> <li>customizable: create any type of agent you can think of and put into code.</li> <li>connected: on startup, each agent automatically joins the fast growing network of \u03bcAgents by registering on the Almanac, a smart contract deployed on the Fetch.ai blockchain.</li> <li>secure: \u03bcAgent messages and wallets are cryptographically secured, so their identities and assets are protected.</li> <li>platform and language independent: though initially launched as a Python library, the exchange protocol is defined in terms of standard data types, and since it is a lightweight framework, expect packages to appear in other languages very soon.</li> </ul>"},{"location":"uAgents/addresses/","title":"Agent addresses","text":"<p>You can print your agent's addresses in the following way:</p> <pre><code>from uagents import Agent\nalice = Agent(name=\"alice\")\nprint(\"uAgent address: \", alice.address)\nprint(\"Fetch network address: \", alice.wallet.address())\n</code></pre> <p>Your agent will have two types of addresses:</p> <ul> <li> <p><code>uAgent address:</code> represents the main \u03bcAgent identifier. Other \u03bcAgents can use this to query the agent's information in the Almanac contract.</p> </li> <li> <p><code>Fetch address:</code> provides the agent with the capabilities for interacting with the Fetch ledger such as registering in the Almanac contract.</p> </li> </ul>"},{"location":"uAgents/agent-protocols/","title":"Agent protocols","text":"<p>The \u03bcAgents framework supports capturing related message types and handlers in protocols. Agents who include the same protocol will be able to communicate with each other.</p> <p>A <code>protocol</code> is built similar to an <code>agent</code>, but it has no identity and cannot be run. It contains only the message types and handlers that define some component of agent functionality.</p> <p>To show how this works, we will use a simple restaurant table booking request as an example. We first need to define the type of messages that the handler will receive and send.  Here we define <code>BookTableRequest</code> which will contain the requested table number and <code>BookTableResponse</code> which will inform the user if that table is available.</p> <pre><code>from uagents import Context, Model, Protocol\nclass BookTableRequest(Model):\ntable_number: int\nclass BookTableResponse(Model):\nsuccess: bool\n</code></pre> <p>Now we define the booking protocol as <code>book_proto</code> and we define the desired logic to determine if the <code>BookTableResponse</code> will be successful or not.</p> <pre><code>book_proto = Protocol()\n@book_proto.on_message(model=BookTableRequest, replies={BookTableResponse})\nasync def handle_book_request(ctx: Context, sender: str, msg: BookTableRequest):\nif ctx.storage.has(str(msg.table_number)):\nsuccess = False\nelse:\nsuccess = True\nctx.storage.set(str(msg.table_number), sender)\n# send the response\nawait ctx.send(sender, BookTableResponse(success=success))\n</code></pre> <p>We will create a folder named <code>protocols</code> and save this file in it as <code>book.py</code>.  We can then import it from the agent script:</p> <pre><code>from protocols.book import book_proto\n</code></pre> <p>Then, if your agent is called <code>restaurant</code> you can include the protocol in this way:</p> <pre><code>restaurant.include(book_proto)\n</code></pre>"},{"location":"uAgents/almanac-endpoint/","title":"Endpoint weighting","text":"<p>When an agent registers in the almanac contract, it must specify the service endpoints that they provide along with a weight parameter for each endpoint. Then, when any agent tries to communicate with your agent, the service endpoint will be chosen using a weighted random selection.</p> <p>You will have two format options when defining your agent's endpoints:</p>"},{"location":"uAgents/almanac-endpoint/#list-format","title":"List format","text":"<p>Define your agent's endpoints as a list of strings, the weights will be automatically assigned a value of 1.</p> <pre><code>agent = Agent(\nname=\"alice\",\nport=8000,\nseed=\"agent secret phrase\",\nendpoint=[\"http://127.0.0.1:8000/submit\",\"http://127.0.0.1:8001/submit\"]\n)\n</code></pre>"},{"location":"uAgents/almanac-endpoint/#dict-format","title":"Dict format","text":"<p>Define your agent's endpoints in a Dict format specifying the weight for each endpoint, if the weight parameter is not specified, it will be assigned a value of 1.</p> <pre><code>agent = Agent(\nname=\"alice\",\nport=8000,\nseed=\"agent recovery seed phrase\",\nendpoint={\n\"http://127.0.0.1:8000/submit\": {\"weight\": 2},\n\"http://127.0.0.1:8001/submit\": {}, # weight value = 1\n},\n)\n</code></pre>"},{"location":"uAgents/almanac-overview/","title":"Almanac Contract","text":"<p>Agents of the system will be registered in the Almanac contract. Users can query a particular agent's information directly from the contract to communicate.</p> <p>A central part of the system is that registrations are strictly time (in blocks) limited. This primarily helps with the liveness problem when dealing with a large ecosystem of agents. In order to keep the registration information up to date, the agent will need to intermittently re-register their information with the Almanac contract.</p> <p>When an agent\u2019s information times out, queries for that agent will no longer return the registered information. </p> <p>With each registration, the agent will need to prove ownership of  the agent address by signing a sequence number with their \u03bcAgent private key and submitting the  signature for verification on the contract. This sequence number should increment with each successful registration and should also be queryable. This will be performed automatically.</p>"},{"location":"uAgents/almanac-registration/","title":"Registration","text":"<p>Agent registration in the almanac-contract is a key part for remote agents communication.</p> <p>To be found by other \u03bcAgents, each \u03bcAgent needs to register (paying a small fee) in the almanac contract using their agent address. Therefore, your agents need to have funds available in their Fetch address. When using the testnet, you can use the function <code>fund_agent_if_low</code> to fund your agent:</p> <p><pre><code>from uagents.setup import fund_agent_if_low\nfrom uagents import Agent\nagent = Agent(name=\"alice\", seed=\"agent1 secret phrase\")\nfund_agent_if_low(agent.wallet.address())\n</code></pre> This function will check if you have enough tokens to register in the <code>almanac-contract</code>. If not it will add tokens to your Fetch address. Make sure to add a <code>seed</code> to your agent so you don't have to fund different addresses each time you run your agent.</p> <p>\u03bcAgents can communicate by querying the <code>almanac-contract</code> and retrieving an HTTP endpoint from the recipient \u03bcAgent. Therefore, we need to specify the service endpoints when defining an agent:</p> <pre><code>agent = Agent(\nname=\"alice\",\nport=8000,\nseed=\"agent1 secret phrase\",\nendpoint=[\"http://127.0.0.1:8000/submit\"],\n)\n</code></pre> <p>Here we defined a local http address, but you could also define a remote address to allow agent communication over different machines through the internet.</p>"},{"location":"uAgents/booking-demo/","title":"Restaurant Booking Demo","text":"<p>To showcase how easy it is to create \u03bcAgents for a particular application, here is an example of how to create a custom message type using the <code>Model</code> class.</p> <pre><code>from uagents import Model\nclass TableStatus(Model):\nseats: int\ntime_start: int\ntime_end: int\n</code></pre> <p>For this example, we will create a restaurant booking service with two agents: a <code>restaurant</code> with tables available and a <code>user</code> requesting table availability.</p>"},{"location":"uAgents/booking-demo/#restaurant-setup","title":"Restaurant Setup","text":"<p>We can create a restaurant agent with its corresponding http endpoint. We will also make sure that the agent is funded so it is able to register in the Almanac contract.</p> <p><pre><code>from uagents import Agent\nfrom uagents.setup import fund_agent_if_low\nrestaurant = Agent(\nname=\"restaurant\",\nport=8001,\nseed=\"restaurant secret phrase\",\nendpoint=[\"http://127.0.0.1:8001/submit\"],\n)\nfund_agent_if_low(restaurant.wallet.address())\n</code></pre> The protocols <code>query_proto</code> and <code>book_proto</code> are built from message handlers in the same way as agents. See query protocol and book protocol for the details and logic behind these protocols, but for now we will simply import them. You will need to add these files inside a <code>protocols</code> folder in the same directory you are running your agent. See agent protocols for more information. Next we build the restaurant agent from these protocols and set the table availability information.</p> <pre><code>from protocols.book import book_proto\nfrom protocols.query import query_proto, TableStatus\n# build the restaurant agent from stock protocols\nrestaurant.include(query_proto)\nrestaurant.include(book_proto)\nTABLES = {\n1: TableStatus(seats=2, time_start=16, time_end=22),\n2: TableStatus(seats=4, time_start=19, time_end=21),\n3: TableStatus(seats=4, time_start=17, time_end=19),\n}\n</code></pre>"},{"location":"uAgents/booking-demo/#storage","title":"Storage","text":"<p>We will now store the <code>TABLES</code> information in the restaurant agent and run it.</p> <p><pre><code># set the table availability information in the restaurant protocols\nfor (number, status) in TABLES.items():\nrestaurant._storage.set(number, status.dict())\nif __name__ == \"__main__\":\nrestaurant.run()\n</code></pre> The restaurant agent is now online and listing for messages.</p>"},{"location":"uAgents/booking-demo/#user-setup","title":"User Setup","text":"<p>We will first import the needed objects and protocols. We will also need the restaurant agent's address to be able to communicate with it.</p> <pre><code>from protocols.book import BookTableRequest, BookTableResponse\nfrom protocols.query import (\nQueryTableRequest,\nQueryTableResponse,\n)\nfrom uagents import Agent, Context\nfrom uagents.setup import fund_agent_if_low\nRESTAURANT_ADDRESS = \"agent1qw50wcs4nd723ya9j8mwxglnhs2kzzhh0et0yl34vr75hualsyqvqdzl990\"\nuser = Agent(\nname=\"user\",\nport=8000,\nseed=\"user secret phrase\",\nendpoint=[\"http://127.0.0.1:8000/submit\"],\n)\nfund_agent_if_low(user.wallet.address())\n</code></pre> <p>Now we create the table query to generate the <code>QueryTableRequest</code> using the restaurant address. If the request has not been completed before, we send the request to the restaurant agent.</p> <pre><code>table_query = QueryTableRequest(\nguests=3,\ntime_start=19,\nduration=2,\n)\n# This on_interval agent function performs a request on a defined period\n@user.on_interval(period=3.0, messages=QueryTableRequest)\nasync def interval(ctx: Context):\ncompleted = ctx.storage.get(\"completed\")\nif not completed:\nawait ctx.send(RESTAURANT_ADDRESS, table_query)\n</code></pre> <p>The function below activates when a message is received back from the restaurant agent. <code>handle_query_response</code> will evaluate if there is a table available, and if so, respond with a <code>BookTableRequest</code> to complete the reservation.</p> <pre><code>@user.on_message(QueryTableResponse, replies={BookTableRequest})\nasync def handle_query_response(ctx: Context, sender: str, msg: QueryTableResponse):\nif len(msg.tables) &gt; 0:\nctx.logger.info(\"There is a free table, attempting to book one now\")\ntable_number = msg.tables[0]\nrequest = BookTableRequest(\ntable_number=table_number,\ntime_start=table_query.time_start,\nduration=table_query.duration,\n)\nawait ctx.send(sender, request)\nelse:\nctx.logger.info(\"No free tables - nothing more to do\")\nctx.storage.set(\"completed\", True)\n</code></pre> <p>Then, <code>handle_book_response</code> will handle messages from the restaurant agent on whether the reservation was successful or unsuccessful.</p> <pre><code>@user.on_message(BookTableResponse, replies=set())\nasync def handle_book_response(ctx: Context, _sender: str, msg: BookTableResponse):\nif msg.success:\nctx.logger.info(\"Table reservation was successful\")\nelse:\nctx.logger.info(\"Table reservation was UNSUCCESSFUL\")\nctx.storage.set(\"completed\", True)\nif __name__ == \"__main__\":\nuser.run()\n</code></pre> <p>Finally, run the restaurant agent and then the user agent from different terminals.</p> <p>Run restaurant agent from one terminal</p> <pre><code>python restaurant.py\n</code></pre> <p>Run user agent from a second terminal</p> <pre><code>python user.py\n</code></pre> <p>You should see this printed on the user terminal:</p> INFO:root:Adding funds to agent...complete INFO:root:Registering Agent user... INFO:root:Registering Agent user...complete. Wallet address: fetchnfu3hd87323mw484ma3v3nz2v0q6uhds7d There is a free table, attempting to book one now Table reservation was successful <p>See the full example scripts at restaurant and  user.</p>"},{"location":"uAgents/installation/","title":"Installation","text":""},{"location":"uAgents/installation/#system-requirements","title":"System requirements","text":"<p>The system requirements for the Python \u03bcAgents package are as follows, but libraries for more platforms and languages will be released soon.</p> <p>System requirements</p> <p>The Python \u03bcAgents pacakge runs on <code>Ubuntu/Debian</code>, <code>MacOS</code>, and <code>Windows</code>.</p> <p>You need Python 3.8, 3.9 or 3.10 on your system.</p>"},{"location":"uAgents/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>We recommend first creating a clean Python virtual environment, for example using poetry or pipenv.</p> poetrypipenv <p>Create and enter a new <code>poetry</code> virtual environment: <pre><code>poetry init -n &amp;&amp; poetry shell\n</code></pre></p> <p>Create and enter a new <code>pipenv</code> environment: <pre><code>pipenv --python 3.10 &amp;&amp; pipenv shell\n</code></pre></p> <p>Now install \u03bcAgents from the PyPI package registry: <pre><code>pip install uagents\n</code></pre></p> Alternatively, install from source code: <p>Download the latest released version from Github and navigate to the uAgents directory</p> <pre><code>git clone https://github.com/fetchai/uAgents.git\ncd uAgents\n</code></pre> <p>Install the required dependencies</p> <pre><code>poetry install\n</code></pre> <p>Open the virtual environment</p> <pre><code>poetry shell\n</code></pre>"},{"location":"uAgents/interval-tasks/","title":"Interval tasks","text":"<p>\u03bcAgents can use interval tasks to periodically perform actions with some time interval.</p> <p>We can use the <code>on_interval</code> decorator to repeat a task in a specified period. We also need to import <code>Context</code> to have access to the information that the agent needs to function. In this case, we will just define a <code>say_hello</code> function that will print out the agent name every 2 seconds.</p> <pre><code>from uagents import Agent, Context\nalice = Agent(name=\"alice\")\n@alice.on_interval(period=2.0)\nasync def say_hello(ctx: Context):\nctx.logger.info(f'hello, my name is {ctx.name}')\nif __name__ == \"__main__\":\nalice.run()\n</code></pre> <p>Run your agent</p> <pre><code>python agent.py\n</code></pre> <p>You should see the message printed out in the terminal every 2 seconds. </p> Hello my name is alice. Hello my name is alice. Hello my name is alice. Hello my name is alice. <p>For another interval task example see agent communication.</p>"},{"location":"uAgents/protocol/","title":"Exchange protocol","text":""},{"location":"uAgents/protocol/#overview","title":"Overview","text":"<p>The \u03bcAgents Exchange Protocol defines a simple standard by which the agents communicate.</p> <p>In this protocol, agents can send messages enclosed in envelopes, which are then encoded and sent via HTTP to the endpoints of other agents.</p> <p>We break down each of these concepts in more detail below.</p>"},{"location":"uAgents/protocol/#messages","title":"Messages","text":"<p>Messages consist of key-value pairs following the standard JSON format.</p> <p>Here are a few examples: <pre><code>{\"message\": \"hello\"}\n</code></pre> <pre><code>{\"name\": \"alice\", \"age\": 26, \"languages\": [\"English\", \"Japanese\", \"Arabic\"]}\n</code></pre> <pre><code>{\"item\": \"pretzel\", \"bid\": {\"amount\": 120, \"denomination\": \"GBP\"}}\n</code></pre></p> <p>Once created, messages are then enclosed in envelopes containing some important metadata.</p>"},{"location":"uAgents/protocol/#envelopes","title":"Envelopes","text":"<p>Envelopes have the following form and are quite similar to blockchain transactions:</p> <pre><code>@dataclass\nclass Envelope:\nsender: str:    # bech32-encoded public address\ntarget: str:    # bech32-encoded public address\nsession: str    # UUID\nprotocol: str   # protocol digest\npayload: bytes  # JSON type: base64 str\nexpires: int    # Unix timestamp in seconds\nsignature: str  # bech32-encoded signature\n</code></pre>"},{"location":"uAgents/protocol/#semantics","title":"Semantics","text":"<p>The sender field exposes the address of the sender of the message.</p> <p>The target field exposes the address of the recipient of the message.</p> <p>The protocol contains the unique schema digest string for the message.</p> <p>The payload field exposes the payload of the protocol. Its JSON representation should be a base64 encoded string.</p> <p>The expires field contains the Unix timestamp in seconds at which the message is no longer valid.</p> <p>The signature field contains the signature that is used to authenticate that the message has been sent from the sender agent.</p> <p>Envelopes are then JSON encoded and sent to endpoints of other agents or services.</p>"},{"location":"uAgents/protocol/#endpoints","title":"Endpoints","text":"<p>The protocol supports only one standardised endpoint:</p> <p><code>HTTP 1.1 POST /submit</code></p> <p>and expects data which is broadly JSON compatible. The protocol currently supports MIME content type <code>application/json</code>.</p>"},{"location":"uAgents/remote-agents/","title":"Remote agents","text":"<p>\u03bcAgents can also interact remotely from different locations across the internet. All you need to know is the recipient agent's address to query it's information in the Almanac contract. See Addresses for more information about \u03bcAgent addresses.</p> <p>In this example, we will simulate remote communication between agents by running two agents on different ports and terminals on the same device.</p>"},{"location":"uAgents/remote-agents/#alice","title":"Alice","text":"<p>We will start by defining agent <code>alice</code> and the recipient address (<code>bob</code>'s address in this example). Then we will include  a send function and a handler as we have learned in agent interactions:</p> <pre><code>from uagents.setup import fund_agent_if_low\nfrom uagents import Agent, Context, Model\nclass Message(Model):\nmessage: str\nRECIPIENT_ADDRESS = \"agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50\"\nalice = Agent(\nname=\"alice\",\nport=8000,\nseed=\"alice secret phrase\",\nendpoint=[\"http://127.0.0.1:8000/submit\"],\n)\nfund_agent_if_low(alice.wallet.address())\n@alice.on_interval(period=2.0)\nasync def send_message(ctx: Context):\nawait ctx.send(RECIPIENT_ADDRESS, Message(message=\"hello there bob\"))\n@alice.on_message(model=Message)\nasync def message_handler(ctx: Context, sender: str, msg: Message):\nctx.logger.info(f\"Received message from {sender}: {msg.message}\")\nif __name__ == \"__main__\":\nalice.run()\n</code></pre>"},{"location":"uAgents/remote-agents/#bob","title":"Bob","text":"<p>In a different script, we will define agent <code>bob</code> with just a message handler to print out <code>alice</code>'s messages and respond to her afterward.</p> <pre><code>from uagents.setup import fund_agent_if_low\nfrom uagents import Agent, Context, Model\nclass Message(Model):\nmessage: str\nbob = Agent(\nname=\"bob\",\nport=8001,\nseed=\"bob secret phrase\",\nendpoint=[\"http://127.0.0.1:8001/submit\"],\n)\nfund_agent_if_low(bob.wallet.address())\n@bob.on_message(model=Message)\nasync def message_handler(ctx: Context, sender: str, msg: Message):\nctx.logger.info(f\"Received message from {sender}: {msg.message}\")\n# send the response\nawait ctx.send(sender, Message(message=\"hello there alice\"))\nif __name__ == \"__main__\":\nbob.run()\n</code></pre> <p>Now, we first run <code>bob</code> and then <code>alice</code> from different terminals. They will register automatically in the Almanac contract using their funds. The received messages will print out in each terminal.</p> <p>Run Bob and Alice</p> <pre><code>python bob.py\npython alice.py\n</code></pre> <p>In bob's terminal:</p> INFO:root:Adding funds to agent...complete INFO:root:Registering Agent bob... INFO:root:Registering Agent bob...complete. Wallet address: fetch1cr9ghmxrf943dmw484ma3v3nz2v0q6u9pynqdk [bob] From: agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a hello there bob [bob] From: agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a hello there bob [bob] From: agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a hello there bob <p>In alice's terminal:</p> INFO:root:Adding funds to agent...complete INFO:root:Registering Agent alice... INFO:root:Registering Agent alice...complete. Wallet address: fetchnfu3hd87323mw484ma3v3nz2v0q6uhds7d [alice] From: agent5kdyfj2ev86k3h5acaa93kdnch8shv4mjxn05pa2kwesspstzj023jdus93j hello there alice [alice] From: agent5kdyfj2ev86k3h5acaa93kdnch8shv4mjxn05pa2kwesspstzj023jdus93j hello there alice [alice] From: agent5kdyfj2ev86k3h5acaa93kdnch8shv4mjxn05pa2kwesspstzj023jdus93j hello there alice <p>For a more complex example visit restaurant booking demo.</p>"},{"location":"uAgents/remote-agents/#the-agentverse-explorer","title":"The Agentverse Explorer","text":"<p>\u03bcAgents can also interact remotely using a mailbox server. For example, you can use The Agentverse Explorer to find other agents and register your own.</p> <p>To register agents in the Agentverse mailbox, you need to sign in at The Agentverse Explorer. Then, in the upper right corner click on your profile and select <code>API Keys</code>, select <code>Create new key</code> and name it. This will generate your own <code>API Key</code> that will allow you to use the mailbox server.</p> <p>Then, navigate to the <code>Mailroom</code> tab and select <code>+ Mailbox</code> to register an agent, you need to select a name for it and provide the agent's address. Finally, you need to define the \u03bcAgent specifying the mailbox server and the <code>API Key</code></p> <pre><code># First generate a secure seed phrase (e.g. https://pypi.org/project/mnemonic/)\nSEED_PHRASE = \"put_your_seed_phrase_here\"\n# Copy the address shown below\nprint(f\"Your agent's address is: {Agent(seed=SEED_PHRASE).address}\")\n# Then sign up at https://agentverse.ai to get an API key and register your agent\nAPI_KEY = \"put_your_API_key_here\"\n# Now your agent is ready to join the agentverse!\nagent = Agent(\nname=\"alice\",\nseed=SEED_PHRASE,\nmailbox=f\"{API_KEY}@wss://agentverse.ai\",\n)\n</code></pre> <p>Now, you can recreate the example we showed at the begining of this section by also registering agent <code>bob</code> in The Agentverse Explorer.</p>"},{"location":"uAgents/run-agent/","title":"Running an agent","text":""},{"location":"uAgents/run-agent/#create-the-agent","title":"Create the agent","text":"<p>You can create your first \u03bcAgent by building a Python script with the following steps:</p> <pre><code>from uagents import Agent, Context\nalice = Agent(name=\"alice\", seed=\"alice recovery phrase\")\n</code></pre> <p>It is optional but useful to include a <code>seed</code> parameter when creating an agent to set fixed addresses. Otherwise, random addresses will be generated every time you run the agent.</p>"},{"location":"uAgents/run-agent/#give-the-agent-something-to-do","title":"Give the agent something to do","text":"<p>Let's start with a simple task of saying hello every 2 seconds: <pre><code>@alice.on_interval(period=2.0)\nasync def say_hello(ctx: Context):\nctx.logger.info(f'hello, my name is {ctx.name}')\n</code></pre> The <code>Context</code> object is a collection of data and functions related to the agent. In this case, we just use the agent's name.</p>"},{"location":"uAgents/run-agent/#run-the-agent","title":"Run the agent","text":"<p>You can now run your first \u03bcAgent!</p> <pre><code>from uagents import Agent, Context\nalice = Agent(name=\"alice\", seed=\"alice recovery phrase\")\n@alice.on_interval(period=2.0)\nasync def say_hello(ctx: Context):\nctx.logger.info(f'hello, my name is {ctx.name}')\nif __name__ == \"__main__\":\nalice.run()\n</code></pre> <p>Run your agent</p> <pre><code>python agent.py\n</code></pre> <p>After a few lines in the agent's logs, you should see the following text printed on your terminal:</p> hello, my name is alice. hello, my name is alice. hello, my name is alice. ..."},{"location":"uAgents/simple-interaction/","title":"Agent interactions","text":""},{"location":"uAgents/simple-interaction/#add-a-second-agent","title":"Add a second agent","text":"<p>To show \u03bcAgents interacting, we'll need to create a second agent. Importing the <code>Bureau</code> class will allow us to create a collection of agents and run them together in the same script. Then we can simply add agents <code>alice</code> and <code>bob</code> to the <code>Bureau</code> and run it.</p> <pre><code>from uagents import Agent, Context, Bureau\nalice = Agent(name=\"alice\", seed=\"alice recovery phrase\")\nbob = Agent(name=\"bob\", seed=\"bob recovery phrase\")\n@alice.on_interval(period=2.0)\nasync def say_hello(ctx: Context):\nctx.logger.info(f'Hello, my name is {ctx.name}')\n@bob.on_interval(period=2.0)\nasync def say_hello(ctx: Context):\nctx.logger.info(f'Hello, my name is {ctx.name}')\nbureau = Bureau()\nbureau.add(alice)\nbureau.add(bob)\nif __name__ == \"__main__\":\nbureau.run()\n</code></pre> <p>Yoy should observe alice and bob printing out their name in the terminal.</p> <p>Run your agents</p> <pre><code>python simple-agents.py\n</code></pre> <p>You will see the message printed out every 2 seconds. You might see a message indicating insufficient funds to register, check out agent registration for more information.</p> Hello, my name is alice Hello, my name is bob Hello, my name is alice Hello, my name is bob"},{"location":"uAgents/simple-interaction/#agent-communication","title":"Agent communication","text":"<p>To allow our agents to communicate with each other we will need a message structure, and for that, we need to import <code>Model</code> to define a generic message.</p> <pre><code>from uagents import Model\nclass Message(Model):\ntext: str\n</code></pre> <p>We can use the <code>send</code> function from the <code>Context</code> class to send a message from alice to bob on an interval.</p> <pre><code>@alice.on_interval(period=2.0)\nasync def send_message(ctx: Context):\nmsg = f'hello there {bob.name} my name is {alice.name}'\nawait ctx.send(bob.address, Message(text=msg))\n</code></pre> <p>We also need to introduce a message handler for bob. We will do this inside the <code>on_message</code> decorator that will activate the <code>message_handler</code> once bob receives the message.</p> <pre><code>@bob.on_message(Message)\nasync def message_handler(ctx: Context, sender: str, msg: Message):\nctx.logger.info(f\"Received message from {sender}: {msg.text}\")\nctx.logger.info(msg)\n</code></pre> <p>Finally, we need to add both agents to the <code>Bureau</code> in order to run them from the same script.</p> <pre><code>from uagents import Agent, Context, Bureau, Model\nclass Message(Model):\ntext: str\nalice = Agent(name=\"alice\", seed=\"alice recovery phrase\")\nbob = Agent(name=\"bob\", seed=\"bob recovery phrase\")\n@alice.on_interval(period=2.0)\nasync def send_message(ctx: Context):\nmsg = f'hello there {bob.name} my name is {alice.name}'\nawait ctx.send(bob.address, Message(text=msg))\n@bob.on_message(model=Message)\nasync def message_handler(ctx: Context, sender: str, msg: Message):\nctx.logger.info(f\"Received message from {sender}: {msg.text}\")\nbureau = Bureau()\nbureau.add(alice)\nbureau.add(bob)\nif __name__ == \"__main__\":\nbureau.run()\n</code></pre> <p>When running the script above, you should see alice's message printed on the terminal:</p> <p>Run your agents</p> <pre><code>python agent-communication.py\n</code></pre> [bob]: message received from agent1qww3ju3h6kfcuqf54gkghvt2pqe8qp97a7nzm2vp8plfxflc0epzcjsv79t: hello there bob my name is alice [bob]: message received from agent1qww3ju3h6kfcuqf54gkghvt2pqe8qp97a7nzm2vp8plfxflc0epzcjsv79t: hello there bob my name is alice <p>You could also try to add a response from bob to alice, for that you would need to add a <code>send</code> message from bob after alice's  message is received and a new message handler for alice to be able to manage and print out bob's message. For a slightly more complex  example check out the next section remote agents.</p>"},{"location":"uAgents/storage/","title":"Storage","text":"<p>You can store information using the agent's local storage by simply running: <pre><code>ctx.storage.set(\"key\", \"value\")\n</code></pre> within a handler, where <code>ctx</code> is the agent's <code>Context</code> object.</p> <p>This will save the information in a JSON file, you can retreive it a any time using:</p> <pre><code> ctx.storage.get(\"key\")\n</code></pre> <p>See the restaurant booking demo for an example that makes use of the agent's storage to store table information.</p>"}]}