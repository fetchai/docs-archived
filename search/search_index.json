{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fetch.ai developer resources. Let's get started. Developing agents Speed up the development of Autonomous Economic Agents using our framework Using the ledger Learn how to make transfers, deploy smart contracts, etc Deploying a node Run your own local node What is Fetch.ai There are billions of devices, processes and pipelines around the world that are desperate for automation and communication. Most blockchains aren't built to handle such a large number of transactions, and none enable their clients to learn from the data generated and exchanged. Fetch.ai is a platform built to bring value to data, by connecting devices and facilitating the creation of new markets based on what they learn from each other. It is the platform where truly autonomous decisions can be made. Some of the technical features that will enable this autonomous world are: Blockchain sharding to increase concurrency and scalability Smart contract language with ML and AI capabilities Framework for rapid development of Autonomous Economic Agents (AEAs) that can be deployed in any device Support for fixed-point arithmetics to guarantee precision and determinism across all operations and transactions Fetch.ai glossary Collective learning: The act by which autonomous agents, with competitive or complementary interests, increase their understanding of the state and behavior of the decentralized ecosystem they are connected to. Ideally, this will allow them to improve their solutions to a problem. Etch: Our native language in which smart contracts can be written, with support for ML and AI. FET: The cryptocurrency that powers the Fetch.ai ecosystem. Its first version is an ERC-20 token in the Ethereum blockchain, but following versions are native to the Fetch.ai ledger. Synergetic contracts: Type of smart contract that allows anyone to register a problem on the ledger, with miners then using their computational power to solve it and earn a reward. What can you do *now* with Fetch.ai All the components of the Fetch.ai stack and the interfaces to interact with them are open source. Take a look at our SDKs (Python Ledger API, JavaScript Ledger API, Agent Framework and Etch language) so you can start building smart contracts, new agents connected to Fetch.ai, or new ways of interacting with the ledger. And if you want to go even further, you can fork and build any components from the Fetch.ai stack! Versions and release notes As with any software and its documentation, things do change and evolve. We at Fetch.ai try to support backwards compatibility as much as possible, but deprecations will occur. Keep an eye our release notes, as these list all major changes. If you want to view older versions of the documentation, you can select them using the drop down at the bottom of the left hand menu. Updates! November 29th, 2019 Documentation updated for Fetch.ai ledger v0.10.x. See summary details here .","title":"Home"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Fixed32 , Fixed64 , Fixed128 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Fixed32 , Fixed64 , Fixed128 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"summary/","text":"November 29th, 2019 Documentation has been updated for Fetch.ai ledger v0.10.x New style, and new section on Machine Learning on Fetch.ai. We will be continuously updating these docs. Please see github.com/fetchai/docs for latest updates. There have been a number of other minor corrections and updates.","title":"Summary"},{"location":"aea/","text":"The AEA framework provides the tools for creating Autonomous Economic Agents (AEA). What are AEAs? We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. In short, \"software that works for you\". AEAs act independently of constant user input and autonomously execute actions to achieve their goal. Their goal is to create economic value for you, their owner. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs have an express purpose to generate economic value. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic. What is the AEA Framework? The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. This framework attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. To get started developing your own AEA, check out the quick start . To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . AEAs achieve their goals with the help of the OEF - a search and discovery platform for agents by Fetch.ai - and using Fetch.ai's blockchain as a financial settlement layer. Third-party blockchains, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"Introduction"},{"location":"aea/#what-are-aeas","text":"We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. In short, \"software that works for you\". AEAs act independently of constant user input and autonomously execute actions to achieve their goal. Their goal is to create economic value for you, their owner. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs have an express purpose to generate economic value. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic.","title":"What are AEAs?"},{"location":"aea/#what-is-the-aea-framework","text":"The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. This framework attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. To get started developing your own AEA, check out the quick start . To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . AEAs achieve their goals with the help of the OEF - a search and discovery platform for agents by Fetch.ai - and using Fetch.ai's blockchain as a financial settlement layer. Third-party blockchains, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"What is the AEA Framework?"},{"location":"aea/aea-vs-mvc/","text":"The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails. Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the html templates Controller: deals with the request-response handling The AEA framework is based on asynchronous messaging. Hence, there is not a direct 1-1 relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make progress in the AEA framework in particular, the development of Skills , quickly: Handler : receive the messages for the protocol they are registered against and are supposed to handle these messages. They are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. Behaviour : a behaviour encapsulates pro-active components of the agent. Since web apps do not have any goals or intentions they do not pro-actively pursue an objective. Therefore, there is no equivalent concept in MVC. Task : are meant to deal with long running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : implement business logic and data representation, as such they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views, represent information to the client, messages represent information sent to other agents.","title":"AEA and web frameworks"},{"location":"aea/agent-oriented-development/","text":"Agent-oriented development In this section, we highlight some of the most fundamental characteristics of the agent-oriented approach to solution development, which might be different from some of the existing paradigms and methodologies you may be used to. We hope that with this, we can guide you towards having the right mindset when you are designing your own agent-based solutions to real world problems. Decentralisation Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is, an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on third-parties to facilitate this. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. For example systems based on the client-server architecture, in which clients interact with one another, regarding a specific service (e.g. communication, trade), only through the server. Note, this is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the 'commanding reliance on middlemen' that MAS disagrees with. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of peers that creates the infrastructure. As such, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. People who are getting into cryptocurrencies are often reminded that, due to the lack of a central trusted entity (e.g. a bank), most security precautions related to the handling of digital assets and the execution of transactions fall on individuals themselves. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do tend to also be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google's infrastructure is an example of this, where all of the components are distributed across the globe, yet designed to work together highly efficiently and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences, which may not necessarily be aligned with one another or that of the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of a central point of authority between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for. Conflicting Environment As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worst yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise. Asynchronisation The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks. Complex, Incomplete, Inconsistent and Uncertain The forth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#agent-oriented-development","text":"In this section, we highlight some of the most fundamental characteristics of the agent-oriented approach to solution development, which might be different from some of the existing paradigms and methodologies you may be used to. We hope that with this, we can guide you towards having the right mindset when you are designing your own agent-based solutions to real world problems.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#decentralisation","text":"Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is, an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on third-parties to facilitate this. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. For example systems based on the client-server architecture, in which clients interact with one another, regarding a specific service (e.g. communication, trade), only through the server. Note, this is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the 'commanding reliance on middlemen' that MAS disagrees with. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of peers that creates the infrastructure. As such, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. People who are getting into cryptocurrencies are often reminded that, due to the lack of a central trusted entity (e.g. a bank), most security precautions related to the handling of digital assets and the execution of transactions fall on individuals themselves. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do tend to also be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google's infrastructure is an example of this, where all of the components are distributed across the globe, yet designed to work together highly efficiently and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences, which may not necessarily be aligned with one another or that of the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of a central point of authority between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.","title":"Decentralisation"},{"location":"aea/agent-oriented-development/#conflicting-environment","text":"As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worst yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise.","title":"Conflicting Environment"},{"location":"aea/agent-oriented-development/#asynchronisation","text":"The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks.","title":"Asynchronisation"},{"location":"aea/agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","text":"The forth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Complex, Incomplete, Inconsistent and Uncertain"},{"location":"aea/agent-vs-aea/","text":"AEAs are more than just agents. In this guide we show some of the differences in terms of code. The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the Agent class programmatically as well. First, import the python and application specific libraries. import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope Unlike an AEA , an Agent does not require a Wallet , LedgerApis or Resources module. However, we need to implement 5 abstract methods: - setup() - act() - react() - update() - teardown() When we run an agent, start() calls setup() and then the main agent loop. The main agent loop calls act() , react() and update() on each tick. When the agent is stopped via stop() then teardown() is called. Such a lightweight agent can be used to implement simple logic. Code an Agent We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass Instantiate an Agent # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) Start the agent We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) Shutdown Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join () Your turn Now it is your turn to develop a simple agent with the Agent class. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"AEAs vs Agents"},{"location":"aea/agent-vs-aea/#code-an-agent","text":"We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass","title":"Code an Agent"},{"location":"aea/agent-vs-aea/#instantiate-an-agent","text":"# Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ])","title":"Instantiate an Agent"},{"location":"aea/agent-vs-aea/#start-the-agent","text":"We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the agent"},{"location":"aea/agent-vs-aea/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/agent-vs-aea/#shutdown","text":"Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join ()","title":"Shutdown"},{"location":"aea/agent-vs-aea/#your-turn","text":"Now it is your turn to develop a simple agent with the Agent class.","title":"Your turn"},{"location":"aea/agent-vs-aea/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/app-areas/","text":"An AEA is an intelligent agent whose goal is generating economic value for its owner. It can represent machines, humans, or data. There are five general application areas for AEAs: Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. An example can be found here . Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. An example can be found here . Representative : an agent which represents an individual's activities on the Fetch.ai network. An example can be found here . Likely short-term applications In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well defined processes in supply chain, transport and finance. Micro transactions: AEAs make it economically viable to execute trades which reference only small values. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify the interactions with blockchains for end users. Multi-agent system versus agent-based modelling The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Application areas"},{"location":"aea/app-areas/#likely-short-term-applications","text":"In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well defined processes in supply chain, transport and finance. Micro transactions: AEAs make it economically viable to execute trades which reference only small values. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify the interactions with blockchains for end users.","title":"Likely short-term applications"},{"location":"aea/app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Multi-agent system versus agent-based modelling"},{"location":"aea/aries-cloud-agent-demo/","text":"Note This demo is incomplete and will soon be updated. Demonstrating an entire decentralised identity scenario involving AEAs and instances of Aries Cloud Agents (ACAs). Discussion This demo corresponds with the one here from aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows identity faea->>faca: Request status? faca->>faea: status faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its identity in the terminal and waits for an invitation detail from Faber_AEA . Faber_AEA : starts Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the oef communication network accessed via the oef connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo, at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential. Preparation Instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent Terminals Open four terminals. Each terminal will be used to run one of the four agents in this demo. Alice and Faber ACAs To learn about the command for starting an ACA and its various options: aca-py start --help Faber_ACA In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications. Alice_ACA In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032 Alice and Faber AEAs Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively. There are two methods for creating each AEA, constructing it piece by piece, or fetching the whole agent project. Alice_AEA -- Method 1: Construct the Agent In the third terminal, create Alice_AEA and move into its project folder: aea create aries_alice cd aries_alice Add and Configure the Skill Add the aries_alice skill: aea add skill fetchai/aries_alice:0.1.0 You now need to configure this skill to ensure admin_host and admin_port values in the skill's configuration file alice/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_port 8031 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_port 8031 Add and Configure the Connections Add http_client , oef and webhook connections: aea add connection fetchai/http_client:0.2.0 aea add connection fetchai/webhook:0.1.0 aea add connection fetchai/oef:0.3.0 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file alice/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure Alice_AEA: Now you must ensure Alice_AEA 's default connection is oef . aea config set agent.default_connection fetchai/oef:0.3.0 Alice_AEA -- Method 2: Fetch the Agent Alternatively, in the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.2.0 cd aries_alice Configure the skill and connections: You need to configure the aries_alice skill of the AEA to ensure admin_host and admin_port values in the skill's configuration file alice/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_port 8031 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_port 8031 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file alice/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Install the Dependencies and Run Alice_AEA: After creating Alice_AEA using either of the methods above, you must install all the dependencies: aea install Finally run Alice_AEA : aea run You should see Alice_AEA running and showing its identity on the terminal. For example: My address is: YrP7H2qdCb3VyPwpQa53o39cWCDHhVcjwCtJLes6HKWM8FpVK Take note of this value. We will refer to this as Alice_AEA's address . Faber_AEA -- Method 1: Construct the Agent In the fourth terminal, create Faber_AEA and move into its project folder: aea create aries_faber cd aries_faber Add and Configure the Skill: Add the aries_faber skill: aea add skill fetchai/aries_faber:0.1.0 You now need to configure this skill to ensure admin_host and admin_port values in the skill's configuration file faber/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_port 8021 aea config set --type int vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_port 8021 Additionally, make sure that the value of alice_id matches Alice_AEA's address as displayed in the third terminal. aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.alice_id <Alice_AEA ' s address> Add and Configure the Connections: Add http_client , oef and webhook connections: aea add connection fetchai/http_client:0.2.0 aea add connection fetchai/webhook:0.1.0 aea add connection fetchai/oef:0.3.0 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file faber/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure Faber_AEA: Now you must ensure Faber_AEA 's default connection is http_client . aea config set agent.default_connection fetchai/http_client:0.2.0 Alice_AEA -- Method 2: Fetch the Agent Alternatively, in the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.2.0 cd aries_faber Configure the skill and connections: You need to configure the aries_faber skill of the AEA to ensure admin_host and admin_port values in the skill's configuration file faber/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_port 8021 aea config set --type int vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_port 8021 Additionally, make sure that the value of alice_id matches Alice_AEA's address as displayed in the third terminal. aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.alice_id <Alice_AEA ' s address> You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file faber/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Install the Dependencies and Run Faber_AEA: After creating Faber_AEA using either of the methods above, you must install all the dependencies: aea install Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved. Terminate and Delete the Agents You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice Further developments In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, config, creds) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Aries Cloud Agents Demo"},{"location":"aea/aries-cloud-agent-demo/#discussion","text":"This demo corresponds with the one here from aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows identity faea->>faca: Request status? faca->>faea: status faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its identity in the terminal and waits for an invitation detail from Faber_AEA . Faber_AEA : starts Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the oef communication network accessed via the oef connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo, at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential.","title":"Discussion"},{"location":"aea/aries-cloud-agent-demo/#preparation-instructions","text":"","title":"Preparation Instructions"},{"location":"aea/aries-cloud-agent-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent","title":"Dependencies"},{"location":"aea/aries-cloud-agent-demo/#terminals","text":"Open four terminals. Each terminal will be used to run one of the four agents in this demo.","title":"Terminals"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-acas","text":"To learn about the command for starting an ACA and its various options: aca-py start --help","title":"Alice and Faber ACAs"},{"location":"aea/aries-cloud-agent-demo/#faber_aca","text":"In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications.","title":"Faber_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice_aca","text":"In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032","title":"Alice_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-aeas","text":"Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively. There are two methods for creating each AEA, constructing it piece by piece, or fetching the whole agent project.","title":"Alice and Faber AEAs"},{"location":"aea/aries-cloud-agent-demo/#alice_aea-method-1-construct-the-agent","text":"In the third terminal, create Alice_AEA and move into its project folder: aea create aries_alice cd aries_alice","title":"Alice_AEA -- Method 1: Construct the Agent"},{"location":"aea/aries-cloud-agent-demo/#add-and-configure-the-skill","text":"Add the aries_alice skill: aea add skill fetchai/aries_alice:0.1.0 You now need to configure this skill to ensure admin_host and admin_port values in the skill's configuration file alice/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_port 8031 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_port 8031","title":"Add and Configure the Skill"},{"location":"aea/aries-cloud-agent-demo/#add-and-configure-the-connections","text":"Add http_client , oef and webhook connections: aea add connection fetchai/http_client:0.2.0 aea add connection fetchai/webhook:0.1.0 aea add connection fetchai/oef:0.3.0 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file alice/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Add and Configure the Connections"},{"location":"aea/aries-cloud-agent-demo/#configure-alice_aea","text":"Now you must ensure Alice_AEA 's default connection is oef . aea config set agent.default_connection fetchai/oef:0.3.0","title":"Configure Alice_AEA:"},{"location":"aea/aries-cloud-agent-demo/#alice_aea-method-2-fetch-the-agent","text":"Alternatively, in the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.2.0 cd aries_alice","title":"Alice_AEA -- Method 2: Fetch the Agent"},{"location":"aea/aries-cloud-agent-demo/#configure-the-skill-and-connections","text":"You need to configure the aries_alice skill of the AEA to ensure admin_host and admin_port values in the skill's configuration file alice/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_default.args.admin_port 8031 aea config set --type int vendor.fetchai.skills.aries_alice.handlers.aries_demo_http.args.admin_port 8031 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file alice/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the skill and connections:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-alice_aea","text":"After creating Alice_AEA using either of the methods above, you must install all the dependencies: aea install Finally run Alice_AEA : aea run You should see Alice_AEA running and showing its identity on the terminal. For example: My address is: YrP7H2qdCb3VyPwpQa53o39cWCDHhVcjwCtJLes6HKWM8FpVK Take note of this value. We will refer to this as Alice_AEA's address .","title":"Install the Dependencies and Run Alice_AEA:"},{"location":"aea/aries-cloud-agent-demo/#faber_aea-method-1-construct-the-agent","text":"In the fourth terminal, create Faber_AEA and move into its project folder: aea create aries_faber cd aries_faber","title":"Faber_AEA -- Method 1: Construct the Agent"},{"location":"aea/aries-cloud-agent-demo/#add-and-configure-the-skill_1","text":"Add the aries_faber skill: aea add skill fetchai/aries_faber:0.1.0 You now need to configure this skill to ensure admin_host and admin_port values in the skill's configuration file faber/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_port 8021 aea config set --type int vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_port 8021 Additionally, make sure that the value of alice_id matches Alice_AEA's address as displayed in the third terminal. aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.alice_id <Alice_AEA ' s address>","title":"Add and Configure the Skill:"},{"location":"aea/aries-cloud-agent-demo/#add-and-configure-the-connections_1","text":"Add http_client , oef and webhook connections: aea add connection fetchai/http_client:0.2.0 aea add connection fetchai/webhook:0.1.0 aea add connection fetchai/oef:0.3.0 You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file faber/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Add and Configure the Connections:"},{"location":"aea/aries-cloud-agent-demo/#configure-faber_aea","text":"Now you must ensure Faber_AEA 's default connection is http_client . aea config set agent.default_connection fetchai/http_client:0.2.0","title":"Configure Faber_AEA:"},{"location":"aea/aries-cloud-agent-demo/#alice_aea-method-2-fetch-the-agent_1","text":"Alternatively, in the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.2.0 cd aries_faber","title":"Alice_AEA -- Method 2: Fetch the Agent"},{"location":"aea/aries-cloud-agent-demo/#configure-the-skill-and-connections_1","text":"You need to configure the aries_faber skill of the AEA to ensure admin_host and admin_port values in the skill's configuration file faber/vendor/fetchai/skills/aries_alice/skill.yaml match with the values you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_host 127 .0.0.1 aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.behaviours.aries_demo_faber.args.admin_port 8021 aea config set --type int vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.admin_port 8021 Additionally, make sure that the value of alice_id matches Alice_AEA's address as displayed in the third terminal. aea config set vendor.fetchai.skills.aries_faber.handlers.aries_demo_http.args.alice_id <Alice_AEA ' s address> You now need to configure the webhook connection. First is ensuring the value of webhook_port in webhook connection's configuration file faber/vendor/fetchai/connections/webhook/connection.yaml matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the skill and connections:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-faber_aea","text":"After creating Faber_AEA using either of the methods above, you must install all the dependencies: aea install Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved.","title":"Install the Dependencies and Run Faber_AEA:"},{"location":"aea/aries-cloud-agent-demo/#terminate-and-delete-the-agents","text":"You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice","title":"Terminate and Delete the Agents"},{"location":"aea/aries-cloud-agent-demo/#further-developments","text":"In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, config, creds) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Further developments"},{"location":"aea/aries-cloud-agent-example/","text":"Demonstrating interactions between AEAs and and an instance of Aries Cloud Agent (ACA). Discussion This demo illustrates how an AEA may connect to an Aries Cloud Agent (ACA). Hyperledger Aries Cloud Agent is a foundation for building self-sovereign identity/decentralized identity services using verifiable credentials. You can read more about Hyperledger here and the Aries project here . In this demo, you will learn how an AEA could connect with an ACA, to send it administrative commands (e.g. issue verifiable credential to another AEA) and receive DID related notifications (e.g. receive a request for a credential proof from another AEA). Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. ACA Install ACA Install Aries cloud-agents (run pip install aries-cloudagent or see here ) if you do not have it on your machine. Run the demo test Run the following test file using PyTest: pytest tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py You should see that the two tests pass. Demo code Take a look at the test file you ran above tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py . The main class is TestAEAToACA . The setup_class method initialises the scenario. @pytest . mark . asyncio class TestAEAToACA : \"\"\"End-to-end test for an AEA connecting to an ACA via the http client connection.\"\"\" @classmethod def setup_class ( cls ): \"\"\"Initialise the class.\"\"\" cls . aca_admin_address = \"127.0.0.1\" cls . aca_admin_port = 8020 The address and port fields cls.aca_admin_address and cls.aca_admin_port specify where the ACA should listen to receive administrative commands from the AEA. The following runs an ACA: cls . process = subprocess . Popen ( # nosec [ \"aca-py\" , \"start\" , \"--admin\" , cls . aca_admin_address , str ( cls . aca_admin_port ), \"--admin-insecure-mode\" , \"--inbound-transport\" , \"http\" , \"0.0.0.0\" , \"8000\" , \"--outbound-transport\" , \"http\" , ] ) Now take a look at the following method. This is where the demo resides. It first creates an AEA programmatically. @pytest . mark . asyncio async def test_end_to_end_aea_aca ( self ): # AEA components ledger_apis = LedgerApis ({}, FetchAICrypto . identifier ) wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( name = \"my_aea_1\" , address = wallet . addresses . get ( FetchAICrypto . identifier ), default_address_key = FetchAICrypto . identifier , ) http_client_connection = HTTPClientConnection ( address = self . aea_address , provider_address = self . aca_admin_address , provider_port = self . aca_admin_port , ) resources = Resources () # create AEA aea = AEA ( identity , [ http_client_connection ], wallet , ledger_apis , resources ) It then adds the HTTP protocol to the AEA. THe HTTP protocol defines the format of HTTP interactions (e.g. HTTP Request and Response). # Add http protocol to AEA resources http_protocol_configuration = ProtocolConfig . from_json ( yaml . safe_load ( open ( os . path . join ( self . cwd , \"packages\" , \"fetchai\" , \"protocols\" , \"http\" , \"protocol.yaml\" , ) ) ) ) http_protocol = Protocol ( http_protocol_configuration , HttpSerializer ()) resources . add_protocol ( http_protocol ) Then, the request message and envelope is created: # Request message & envelope request_http_message = HttpMessage ( dialogue_reference = ( \"\" , \"\" ), target = 0 , message_id = 1 , performative = HttpMessage . Performative . REQUEST , method = \"GET\" , url = \"http:// {} : {} /status\" . format ( self . aca_admin_address , self . aca_admin_port ), headers = \"\" , version = \"\" , bodyy = b \"\" , ) request_envelope = Envelope ( to = \"ACA\" , sender = \"AEA\" , protocol_id = HTTP_PROTOCOL_PUBLIC_ID , message = HttpSerializer () . encode ( request_http_message ), ) Note that the performative is set to HttpMessage.Performative.REQUEST , the method GET corresponds with HTTP GET method, and url is where the request is sent. This is the location the ACA is listening for administrative commands. In the following part, the AEA is started in another thread t_aea = Thread(target=aea.start) , the HTTP request message created above is placed in the agent's outbox aea.outbox.put(request_envelope) to be sent to the ACA, and the received response is checked for success (e.g. assert aea_handler.handled_message.status_text == \"OK\" ). # start AEA thread t_aea = Thread ( target = aea . start ) try : t_aea . start () time . sleep ( 1.0 ) aea . outbox . put ( request_envelope ) time . sleep ( 5.0 ) assert ( aea_handler . handled_message . performative == HttpMessage . Performative . RESPONSE ) assert aea_handler . handled_message . version == \"\" assert aea_handler . handled_message . status_code == 200 assert aea_handler . handled_message . status_text == \"OK\" assert aea_handler . handled_message . headers is not None assert aea_handler . handled_message . version is not None finally : aea . stop () t_aea . join () Note that the response from the ACA is caught by the AEAHandler class which just saves the handled message. In the above interaction, and in general, the HTTP client connection the added to the AEA, takes care of the translation between messages and envelopes in the AEA world and the HTTP request/response format in the HTTP connection with the ACA.","title":"Identity - Aries Cloud Agent"},{"location":"aea/aries-cloud-agent-example/#discussion","text":"This demo illustrates how an AEA may connect to an Aries Cloud Agent (ACA). Hyperledger Aries Cloud Agent is a foundation for building self-sovereign identity/decentralized identity services using verifiable credentials. You can read more about Hyperledger here and the Aries project here . In this demo, you will learn how an AEA could connect with an ACA, to send it administrative commands (e.g. issue verifiable credential to another AEA) and receive DID related notifications (e.g. receive a request for a credential proof from another AEA).","title":"Discussion"},{"location":"aea/aries-cloud-agent-example/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/aries-cloud-agent-example/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/aries-cloud-agent-example/#aca","text":"","title":"ACA"},{"location":"aea/aries-cloud-agent-example/#install-aca","text":"Install Aries cloud-agents (run pip install aries-cloudagent or see here ) if you do not have it on your machine.","title":"Install ACA"},{"location":"aea/aries-cloud-agent-example/#run-the-demo-test","text":"Run the following test file using PyTest: pytest tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py You should see that the two tests pass.","title":"Run the demo test"},{"location":"aea/aries-cloud-agent-example/#demo-code","text":"Take a look at the test file you ran above tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py . The main class is TestAEAToACA . The setup_class method initialises the scenario. @pytest . mark . asyncio class TestAEAToACA : \"\"\"End-to-end test for an AEA connecting to an ACA via the http client connection.\"\"\" @classmethod def setup_class ( cls ): \"\"\"Initialise the class.\"\"\" cls . aca_admin_address = \"127.0.0.1\" cls . aca_admin_port = 8020 The address and port fields cls.aca_admin_address and cls.aca_admin_port specify where the ACA should listen to receive administrative commands from the AEA. The following runs an ACA: cls . process = subprocess . Popen ( # nosec [ \"aca-py\" , \"start\" , \"--admin\" , cls . aca_admin_address , str ( cls . aca_admin_port ), \"--admin-insecure-mode\" , \"--inbound-transport\" , \"http\" , \"0.0.0.0\" , \"8000\" , \"--outbound-transport\" , \"http\" , ] ) Now take a look at the following method. This is where the demo resides. It first creates an AEA programmatically. @pytest . mark . asyncio async def test_end_to_end_aea_aca ( self ): # AEA components ledger_apis = LedgerApis ({}, FetchAICrypto . identifier ) wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( name = \"my_aea_1\" , address = wallet . addresses . get ( FetchAICrypto . identifier ), default_address_key = FetchAICrypto . identifier , ) http_client_connection = HTTPClientConnection ( address = self . aea_address , provider_address = self . aca_admin_address , provider_port = self . aca_admin_port , ) resources = Resources () # create AEA aea = AEA ( identity , [ http_client_connection ], wallet , ledger_apis , resources ) It then adds the HTTP protocol to the AEA. THe HTTP protocol defines the format of HTTP interactions (e.g. HTTP Request and Response). # Add http protocol to AEA resources http_protocol_configuration = ProtocolConfig . from_json ( yaml . safe_load ( open ( os . path . join ( self . cwd , \"packages\" , \"fetchai\" , \"protocols\" , \"http\" , \"protocol.yaml\" , ) ) ) ) http_protocol = Protocol ( http_protocol_configuration , HttpSerializer ()) resources . add_protocol ( http_protocol ) Then, the request message and envelope is created: # Request message & envelope request_http_message = HttpMessage ( dialogue_reference = ( \"\" , \"\" ), target = 0 , message_id = 1 , performative = HttpMessage . Performative . REQUEST , method = \"GET\" , url = \"http:// {} : {} /status\" . format ( self . aca_admin_address , self . aca_admin_port ), headers = \"\" , version = \"\" , bodyy = b \"\" , ) request_envelope = Envelope ( to = \"ACA\" , sender = \"AEA\" , protocol_id = HTTP_PROTOCOL_PUBLIC_ID , message = HttpSerializer () . encode ( request_http_message ), ) Note that the performative is set to HttpMessage.Performative.REQUEST , the method GET corresponds with HTTP GET method, and url is where the request is sent. This is the location the ACA is listening for administrative commands. In the following part, the AEA is started in another thread t_aea = Thread(target=aea.start) , the HTTP request message created above is placed in the agent's outbox aea.outbox.put(request_envelope) to be sent to the ACA, and the received response is checked for success (e.g. assert aea_handler.handled_message.status_text == \"OK\" ). # start AEA thread t_aea = Thread ( target = aea . start ) try : t_aea . start () time . sleep ( 1.0 ) aea . outbox . put ( request_envelope ) time . sleep ( 5.0 ) assert ( aea_handler . handled_message . performative == HttpMessage . Performative . RESPONSE ) assert aea_handler . handled_message . version == \"\" assert aea_handler . handled_message . status_code == 200 assert aea_handler . handled_message . status_text == \"OK\" assert aea_handler . handled_message . headers is not None assert aea_handler . handled_message . version is not None finally : aea . stop () t_aea . join () Note that the response from the ACA is caught by the AEAHandler class which just saves the handled message. In the above interaction, and in general, the HTTP client connection the added to the AEA, takes care of the translation between messages and envelopes in the AEA world and the HTTP request/response format in the HTTP connection with the ACA.","title":"Demo code"},{"location":"aea/build-aea-programmatically/","text":"Preliminaries These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. This guide assumes you have already followed the Preliminaries and Installation section in the quick start guide and so have the framework installed and the packages and scripts directory downloaded into the directory you are working in. Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" Create a private key We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier ) Clearing the input and output files We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) Initialise the AEA We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:0.1.0 protocol, the fetchai/stub:0.4.0 connection and the fetchai/error:0.2.0 skill. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.skills.base import Handler class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build () Start the AEA We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) Send and receive an envelope We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) Shutdown Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None Running the AEA If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello output message: other_agent,my_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello Entire code listing If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" def run (): # Create a private key create_private_key ( FetchAICrypto . identifier ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.skills.base import Handler class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Build an AEA programmatically"},{"location":"aea/build-aea-programmatically/#preliminaries","text":"These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. This guide assumes you have already followed the Preliminaries and Installation section in the quick start guide and so have the framework installed and the packages and scripts directory downloaded into the directory you are working in.","title":"Preliminaries"},{"location":"aea/build-aea-programmatically/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\"","title":"Imports"},{"location":"aea/build-aea-programmatically/#create-a-private-key","text":"We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier )","title":"Create a private key"},{"location":"aea/build-aea-programmatically/#clearing-the-input-and-output-files","text":"We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE )","title":"Clearing the input and output files"},{"location":"aea/build-aea-programmatically/#initialise-the-aea","text":"We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:0.1.0 protocol, the fetchai/stub:0.4.0 connection and the fetchai/error:0.2.0 skill. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.skills.base import Handler class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build ()","title":"Initialise the AEA"},{"location":"aea/build-aea-programmatically/#start-the-aea","text":"We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 )","title":"Start the AEA"},{"location":"aea/build-aea-programmatically/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/build-aea-programmatically/#shutdown","text":"Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None","title":"Shutdown"},{"location":"aea/build-aea-programmatically/#running-the-aea","text":"If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello output message: other_agent,my_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello","title":"Running the AEA"},{"location":"aea/build-aea-programmatically/#entire-code-listing","text":"If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" def run (): # Create a private key create_private_key ( FetchAICrypto . identifier ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.skills.base import Handler class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/build-aea-step-by-step/","text":"Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first): Set up your AEA project with the CLI: aea create my_aea && cd my_aea Look at, then add the right connections for your usecase: aea search connections , then aea add connection [public_id] Look for, then add or generate the protocols you require: aea search protocols , then aea add protocol [public_id] or aea generate protocol [path_to_specification] Look for, then add or code the skills you need: aea search skills , then aea add skill [public_id] . This guide shows you step by step how to develop a skill. Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator . Now, run your AEA: aea run --connections [public_id] See information on the CLI tool here for all the available commands.","title":"Build an AEA with the CLI"},{"location":"aea/car-park-skills/","text":"The AEA car-park skills demonstrate an interaction between two AEAs. The carpark_detection AEA provides information on the number of car parking spaces available in a given vicinity. The carpark_client AEA is interested in purchasing information on available car parking spaces in the same vicinity. Discussion The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information. Communication This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch the OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following. Demo instructions Create car detector AEA First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.4.0 cd car_detector aea install Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/oef:0.3.0 aea add skill fetchai/carpark_detection:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `car_detector/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Create car data buyer AEA Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.4.0 cd car_data_buyer aea install Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/carpark_client:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `car_data_buyer/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Generate wealth for the car data buyer AEA The car data buyer needs to have some wealth to purchase the car park information. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `car_data_buyer/aea-config.yaml` and `car_detector/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos Update the skill configs The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Car detector: Ensure you are in the car detector project directory. For ethereum, update the skill config of the car detector via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id cosmos This updates the carpark detection skill config (`car_detector/vendor/fetchai/skills/carpark_detection/skill.yaml`). Car data buyer: Ensure you are in the car data buyer project directory. For ethereum, update the skill config of the car detector via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id cosmos This updates the car data buyer skill config (`car_data_buyer/vendor/fetchai/skills/carpark_client/skill.yaml`). Run both AEAs Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Car park skills"},{"location":"aea/car-park-skills/#discussion","text":"The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information.","title":"Discussion"},{"location":"aea/car-park-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/car-park-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/car-park-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/car-park-skills/#launch-the-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following.","title":"Launch the OEF search and communication node"},{"location":"aea/car-park-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/car-park-skills/#create-car-detector-aea","text":"First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.4.0 cd car_detector aea install Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/oef:0.3.0 aea add skill fetchai/carpark_detection:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `car_detector/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create car detector AEA"},{"location":"aea/car-park-skills/#create-car-data-buyer-aea","text":"Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.4.0 cd car_data_buyer aea install Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/carpark_client:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `car_data_buyer/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create car data buyer AEA"},{"location":"aea/car-park-skills/#generate-wealth-for-the-car-data-buyer-aea","text":"The car data buyer needs to have some wealth to purchase the car park information. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `car_data_buyer/aea-config.yaml` and `car_detector/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos","title":"Generate wealth for the car data buyer AEA"},{"location":"aea/car-park-skills/#update-the-skill-configs","text":"The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Car detector: Ensure you are in the car detector project directory. For ethereum, update the skill config of the car detector via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id cosmos This updates the carpark detection skill config (`car_detector/vendor/fetchai/skills/carpark_detection/skill.yaml`). Car data buyer: Ensure you are in the car data buyer project directory. For ethereum, update the skill config of the car detector via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id cosmos This updates the car data buyer skill config (`car_data_buyer/vendor/fetchai/skills/carpark_client/skill.yaml`).","title":"Update the skill configs"},{"location":"aea/car-park-skills/#run-both-aeas","text":"Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/car-park-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Cleaning up"},{"location":"aea/cli-commands/","text":"CLI commands Command Description add connection/protocol/skill [public_id] Add connection, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . config get [path] Reads the config specified in [path] and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the [path] . Optionally cast to type. delete NAME Delete an aea project. See below for disabling a resource. fetch PUBLIC_ID Fetch an aea project with [public_id] . fetch --local to fetch from local packages directory. fingerprint c/p/s [public_id] Fingerprint connection, protocol, or skill, with [public_id] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key fetchai/ethereum/all Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth fetchai/ethereum Generate wealth for address on test network. get-address fetchai/ethereum Get the address associated with the private key. get-wealth fetchai/ethereum Get the wealth associated with the private key. install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) init Initialize your AEA configurations. (With --author to define author.) launch [path_to_agent_project]... Launch many agents at the same time. list protocols/connections/skills List the installed resources. login USERNAME [--password password] Login to a registry account with credentials. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push connection/protocol/skill [public_id] Push connection, protocol, or skill with [public_id] to registry. push --local to push to local packages directory. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from AEA. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. search --local protocols/connections/skills [--query searching_query] to search in local packages directory. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag `--skip-consistency-check`. E.g. `aea --skip-consistency-check run` will bypass the fingerprint checks.","title":"Commands"},{"location":"aea/cli-commands/#cli-commands","text":"Command Description add connection/protocol/skill [public_id] Add connection, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . config get [path] Reads the config specified in [path] and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the [path] . Optionally cast to type. delete NAME Delete an aea project. See below for disabling a resource. fetch PUBLIC_ID Fetch an aea project with [public_id] . fetch --local to fetch from local packages directory. fingerprint c/p/s [public_id] Fingerprint connection, protocol, or skill, with [public_id] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key fetchai/ethereum/all Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth fetchai/ethereum Generate wealth for address on test network. get-address fetchai/ethereum Get the address associated with the private key. get-wealth fetchai/ethereum Get the wealth associated with the private key. install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) init Initialize your AEA configurations. (With --author to define author.) launch [path_to_agent_project]... Launch many agents at the same time. list protocols/connections/skills List the installed resources. login USERNAME [--password password] Login to a registry account with credentials. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push connection/protocol/skill [public_id] Push connection, protocol, or skill with [public_id] to registry. push --local to push to local packages directory. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from AEA. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. search --local protocols/connections/skills [--query searching_query] to search in local packages directory. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag `--skip-consistency-check`. E.g. `aea --skip-consistency-check run` will bypass the fingerprint checks.","title":"CLI commands"},{"location":"aea/cli-gui/","text":"You can invoke the AEA Command Line Interface (CLI) from a Graphical User Interface (GUI) accessed from a web browser. These instructions will take you through building an AEA, starting an OEF search and communication node , and running the AEA - all from the GUI. Preliminaries Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ] Starting the GUI Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea. Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start an OEF search and communication node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"GUI"},{"location":"aea/cli-gui/#preliminaries","text":"Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ]","title":"Preliminaries"},{"location":"aea/cli-gui/#starting-the-gui","text":"Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea. Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start an OEF search and communication node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"Starting the GUI"},{"location":"aea/cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Installation"},{"location":"aea/cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively.","title":"Installation"},{"location":"aea/cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Troubleshooting"},{"location":"aea/cli-vs-programmatic-aeas/","text":"The AEA framework enables us to create agents either from the CLI tool or programmatically. The following demo demonstrates an interaction between two AEAs. The provider of weather data (managed with the CLI). The buyer of weather data (managed programmatically). Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Discussion The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the entire demo. Demo instructions If you want to create the weather station AEA step by step you can follow this guide here Create the weather station AEA Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.4.0 Update the AEA configs In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Run the weather station AEA aea run --connections fetchai/oef:0.3.0 Create the weather client AEA Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea import AEA_DIR from aea.aea import AEA from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill , SkillContext from packages.fetchai.connections.oef.connection import OEFConnection from packages.fetchai.skills.weather_client.strategy import Strategy HOST = \"127.0.0.1\" PORT = 10000 ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): # Create a private key create_private_key ( FetchAICrypto . identifier ) # Set up the wallet, identity, oef connection, ledger and (empty) resources wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ) ) oef_connection = OEFConnection ( address = identity . address , oef_addr = HOST , oef_port = PORT ) ledger_apis = LedgerApis ({}, FetchAICrypto . identifier ) resources = Resources () # create the AEA my_aea = AEA ( identity , [ oef_connection ], wallet , ledger_apis , resources , # stub_connection, ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the oef search protocol (which is a package) oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol (which is a package) fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the error and weather_station skills error_skill_context = SkillContext () error_skill_context . set_agent_context ( my_aea . context ) logger_name = \"aea.packages.fetchai.skills.error\" error_skill_context . logger = logging . getLogger ( logger_name ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), skill_context = error_skill_context ) weather_skill_context = SkillContext () weather_skill_context . set_agent_context ( my_aea . context ) logger_name = \"aea.packages.fetchai.skills.error\" weather_skill_context . logger = logging . getLogger ( logger_name ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), skill_context = weather_skill_context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () For more details on how to create an agent programmatically follow this guide here Run the weather station AEA In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"CLI vs programmatic AEAs"},{"location":"aea/cli-vs-programmatic-aeas/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/cli-vs-programmatic-aeas/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/cli-vs-programmatic-aeas/#discussion","text":"The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction.","title":"Discussion"},{"location":"aea/cli-vs-programmatic-aeas/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the entire demo.","title":"Launch an OEF search and communication node"},{"location":"aea/cli-vs-programmatic-aeas/#demo-instructions","text":"If you want to create the weather station AEA step by step you can follow this guide here","title":"Demo instructions"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-station-aea","text":"Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.4.0","title":"Create the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#update-the-aea-configs","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configs"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea","text":"aea run --connections fetchai/oef:0.3.0","title":"Run the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-client-aea","text":"Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea import AEA_DIR from aea.aea import AEA from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill , SkillContext from packages.fetchai.connections.oef.connection import OEFConnection from packages.fetchai.skills.weather_client.strategy import Strategy HOST = \"127.0.0.1\" PORT = 10000 ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): # Create a private key create_private_key ( FetchAICrypto . identifier ) # Set up the wallet, identity, oef connection, ledger and (empty) resources wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ) ) oef_connection = OEFConnection ( address = identity . address , oef_addr = HOST , oef_port = PORT ) ledger_apis = LedgerApis ({}, FetchAICrypto . identifier ) resources = Resources () # create the AEA my_aea = AEA ( identity , [ oef_connection ], wallet , ledger_apis , resources , # stub_connection, ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the oef search protocol (which is a package) oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol (which is a package) fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the error and weather_station skills error_skill_context = SkillContext () error_skill_context . set_agent_context ( my_aea . context ) logger_name = \"aea.packages.fetchai.skills.error\" error_skill_context . logger = logging . getLogger ( logger_name ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), skill_context = error_skill_context ) weather_skill_context = SkillContext () weather_skill_context . set_agent_context ( my_aea . context ) logger_name = \"aea.packages.fetchai.skills.error\" weather_skill_context . logger = logging . getLogger ( logger_name ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), skill_context = weather_skill_context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () For more details on how to create an agent programmatically follow this guide here","title":"Create the weather client AEA"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea_1","text":"In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"Run the weather station AEA"},{"location":"aea/config/","text":"This document describes the configuration files of the different packages. AEA config yaml The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsary components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.4.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:0.1.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.2.0 default_connection : fetchai/oef:0.3.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) ledger_apis : {} # The ledger api configurations the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be dictionaries) logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fet_private_key.txt registry_path : ../packages # The path to the local package registry (must be a directory path and point to a directory called `packages`) The aea-config.yaml can be extended with a number of optional fields: execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) agent_loop : async # The agent loop mode (must be one of \"sync\" or \"async\") Connection config yaml The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. Contract config yaml The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. path_to_contract_interface : '' # The path to the contract interface. config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. Protocol config yaml The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. Skill config yaml The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on.","title":"Configurations"},{"location":"aea/config/#aea-config-yaml","text":"The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsary components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.4.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:0.1.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.2.0 default_connection : fetchai/oef:0.3.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) ledger_apis : {} # The ledger api configurations the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be dictionaries) logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fet_private_key.txt registry_path : ../packages # The path to the local package registry (must be a directory path and point to a directory called `packages`) The aea-config.yaml can be extended with a number of optional fields: execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) agent_loop : async # The agent loop mode (must be one of \"sync\" or \"async\")","title":"AEA config yaml"},{"location":"aea/config/#connection-config-yaml","text":"The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on.","title":"Connection config yaml"},{"location":"aea/config/#contract-config-yaml","text":"The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. path_to_contract_interface : '' # The path to the contract interface. config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on.","title":"Contract config yaml"},{"location":"aea/config/#protocol-config-yaml","text":"The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on.","title":"Protocol config yaml"},{"location":"aea/config/#skill-config-yaml","text":"The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.3.0, <0.4.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on.","title":"Skill config yaml"},{"location":"aea/connect-a-frontend/","text":"This demo will discuss the options we have to connect a frontend to the AEA. The following diagram illustrates the two options we are going to discuss. Case 1 The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Connection package. The rest API should send CRUD requests to the HTTP Connection which translates these into Envelopes to be consumed by the correct skill. Case 2 The other option would be to create a stand-alone Multiplexer with an OEF connection. In this scenario, the frontend needs to incorporate a Multiplexer with an OEF connection. Then the OEF communication node can be used to send envelopes from the AEA to the frontend. Conclusion The major difference between these two approaches is that in the first case we should know the IP of the AEA to be able to communicate. In case 2 though, the whole communication is handled by the OEF communication node .","title":"Frontend intergration"},{"location":"aea/connect-a-frontend/#case-1","text":"The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Connection package. The rest API should send CRUD requests to the HTTP Connection which translates these into Envelopes to be consumed by the correct skill.","title":"Case 1"},{"location":"aea/connect-a-frontend/#case-2","text":"The other option would be to create a stand-alone Multiplexer with an OEF connection. In this scenario, the frontend needs to incorporate a Multiplexer with an OEF connection. Then the OEF communication node can be used to send envelopes from the AEA to the frontend.","title":"Case 2"},{"location":"aea/connect-a-frontend/#conclusion","text":"The major difference between these two approaches is that in the first case we should know the IP of the AEA to be able to communicate. In case 2 though, the whole communication is handled by the OEF communication node .","title":"Conclusion"},{"location":"aea/connection/","text":"A Connection is attached to an AEA within the AEA framework. The connection.py module in the connections directory contains a Connection class, which is a wrapper for an SDK or API An AEA can interact with multiple connections at the same time. Configuration The connection.yaml file in the AEA directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name : oef author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The oef connection provides a wrapper around the OEF SDK for connection with the OEF search and communication node.\" class_name : OEFConnection protocols : [ \"fetchai/oef_search:0.1.0\" , \"fetchai/fipa:0.2.0\" ] restricted_to_protocols : [] excluded_protocols : [ \"fetchai/gym:0.1.0\" ] config : addr : ${OEF_ADDR:127.0.0.1} port : ${OEF_PORT:10000} dependencies : colorlog : {} oef : version : ==0.8.1 The developer is left to implement the methods of the Connection dependent on the protocol type.","title":"Connection"},{"location":"aea/connection/#configuration","text":"The connection.yaml file in the AEA directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name : oef author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The oef connection provides a wrapper around the OEF SDK for connection with the OEF search and communication node.\" class_name : OEFConnection protocols : [ \"fetchai/oef_search:0.1.0\" , \"fetchai/fipa:0.2.0\" ] restricted_to_protocols : [] excluded_protocols : [ \"fetchai/gym:0.1.0\" ] config : addr : ${OEF_ADDR:127.0.0.1} port : ${OEF_PORT:10000} dependencies : colorlog : {} oef : version : ==0.8.1 The developer is left to implement the methods of the Connection dependent on the protocol type.","title":"Configuration"},{"location":"aea/core-components/","text":"Multiplexer The Multiplexer is responsible for maintaining potentially multiple connections. Connection Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which defines a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is, where necessary, responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides one default connection: stub : implements an I/O reader and writer to send messages to the agent from a local file. InBox and OutBox The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes . They are needed to separate the thread which runs the Multiplexer from the thread which runs the main agent loop. Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent or gets translated in the Connection to an external service or protocol. Envelope objects sent from other agents arrive in the InBox via a Connection . An Envelope is a vehicle for messages with five attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. The framework provides one default protocol: default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. Additional protocols can be added as packages, including: oef_search : this protocol provides the AEA protocol implementation for communication with the OEF search node including an OefSearchMessage class for hooking up to OEF search node services and search agents. Utility classes are available in the models.py module which provides OEF search node specific requirements, such as classes, needed to perform querying on the OEF search node , such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. For example, the FipaMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Skill Skills are a result of the framework's extensibility. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read (parts of) the state of the the AEA, and suggest action(s) to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the AEA. Behaviours implement AEAs' pro-activeness. Task : none, one or more Tasks encapsulate background work internal to the AEA. Skills further allow for Models . Classes that inherit from the Model can be accessed via the SkillContext . Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function dispatches the internal messages from the decision maker to the handler in the relevant skill. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. TransactionMessage and StateUpdateMessage Skills communicate with the decision maker via InternalMessages . There exist two types of these: TransactionMessage and StateUpdateMessage . The StateUpdateMessage is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place off chain. The TransactionMessage is used by a skill to propose a transaction to the decision maker. The performative TransactionMessage.Performative.PROPOSE_FOR_SETTLEMENT is used by a skill to propose a transaction which the decision maker is supposed to settle on chain. The performative TransactionMessage.Performative.PROPOSE_FOR_SIGNING is used by the skill to propose a transaction which the decision maker is supposed to sign and which will be settled later. The decision maker processes messages and can accept or reject them. Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change. Filter Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-active and re-activate themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills. Resource The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"aea/core-components/#multiplexer","text":"The Multiplexer is responsible for maintaining potentially multiple connections.","title":"Multiplexer"},{"location":"aea/core-components/#connection","text":"Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which defines a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is, where necessary, responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides one default connection: stub : implements an I/O reader and writer to send messages to the agent from a local file.","title":"Connection"},{"location":"aea/core-components/#inbox-and-outbox","text":"The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes . They are needed to separate the thread which runs the Multiplexer from the thread which runs the main agent loop.","title":"InBox and OutBox"},{"location":"aea/core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent or gets translated in the Connection to an external service or protocol. Envelope objects sent from other agents arrive in the InBox via a Connection . An Envelope is a vehicle for messages with five attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Optional[context] : an optional field to specify routing information in a URI.","title":"Envelope"},{"location":"aea/core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. The framework provides one default protocol: default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. Additional protocols can be added as packages, including: oef_search : this protocol provides the AEA protocol implementation for communication with the OEF search node including an OefSearchMessage class for hooking up to OEF search node services and search agents. Utility classes are available in the models.py module which provides OEF search node specific requirements, such as classes, needed to perform querying on the OEF search node , such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. For example, the FipaMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"aea/core-components/#skill","text":"Skills are a result of the framework's extensibility. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read (parts of) the state of the the AEA, and suggest action(s) to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the AEA. Behaviours implement AEAs' pro-activeness. Task : none, one or more Tasks encapsulate background work internal to the AEA. Skills further allow for Models . Classes that inherit from the Model can be accessed via the SkillContext .","title":"Skill"},{"location":"aea/core-components/#agent","text":"","title":"Agent"},{"location":"aea/core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function dispatches the internal messages from the decision maker to the handler in the relevant skill.","title":"Main loop"},{"location":"aea/core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA.","title":"Decision maker"},{"location":"aea/core-components/#transactionmessage-and-stateupdatemessage","text":"Skills communicate with the decision maker via InternalMessages . There exist two types of these: TransactionMessage and StateUpdateMessage . The StateUpdateMessage is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place off chain. The TransactionMessage is used by a skill to propose a transaction to the decision maker. The performative TransactionMessage.Performative.PROPOSE_FOR_SETTLEMENT is used by a skill to propose a transaction which the decision maker is supposed to settle on chain. The performative TransactionMessage.Performative.PROPOSE_FOR_SIGNING is used by the skill to propose a transaction which the decision maker is supposed to sign and which will be settled later. The decision maker processes messages and can accept or reject them. Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change.","title":"TransactionMessage and StateUpdateMessage"},{"location":"aea/core-components/#filter","text":"Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-active and re-activate themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills.","title":"Filter"},{"location":"aea/core-components/#resource","text":"The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"aea/decision-maker-transaction/","text":"This guide can be considered as a part 2 of the the stand-alone transaction demo we did in a previous guide. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer . The main difference is that now we are going to use the decision-maker to settle the transaction. First, import the libraries and the set the constant values. import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import ProtocolId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.skills.base import Handler , Skill , SkillContext logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" Create a private key and an AEA To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Create our AEA my_aea = builder . build () Generate wealth Since we want to send funds from our AEA's wallet , we need to generate some wealth for the wallet . We can do this with the following code where we use the default address # Generate some wealth for the default address try_generate_testnet_wealth ( FetchAICrypto . identifier , my_aea . identity . address ) Add a simple skill Add a simple skill with a transaction handler. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) tx_handler = TransactionHandler ( skill_context = skill_context , name = \"transaction_handler\" ) simple_skill = Skill ( skill_config , skill_context , handlers = { tx_handler . name : tx_handler } ) my_aea . resources . add_skill ( simple_skill ) Create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) Create the transaction message Next, we are creating the transaction message and we send it to the decision-maker. # create tx message for decision maker to process fetchai_ledger_api = my_aea . context . ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = fetchai_ledger_api . generate_tx_nonce ( my_aea . identity . address , counterparty_identity . address ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ skill_config . public_id ], tx_id = \"transaction0\" , tx_sender_addr = my_aea . identity . address , tx_counterparty_addr = counterparty_identity . address , tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FetchAICrypto . identifier , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) Run the agent Finally, we are running the agent and we expect the transaction digest to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () More details To be able to register a handler that reads the internal messages, we have to create a class at the end of the file with the name TransactionHandler class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import ProtocolId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.skills.base import Handler , Skill , SkillContext logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Create our AEA my_aea = builder . build () # Generate some wealth for the default address try_generate_testnet_wealth ( FetchAICrypto . identifier , my_aea . identity . address ) # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) tx_handler = TransactionHandler ( skill_context = skill_context , name = \"transaction_handler\" ) simple_skill = Skill ( skill_config , skill_context , handlers = { tx_handler . name : tx_handler } ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) # create tx message for decision maker to process fetchai_ledger_api = my_aea . context . ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = fetchai_ledger_api . generate_tx_nonce ( my_aea . identity . address , counterparty_identity . address ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ skill_config . public_id ], tx_id = \"transaction0\" , tx_sender_addr = my_aea . identity . address , tx_counterparty_addr = counterparty_identity . address , tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FetchAICrypto . identifier , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass if __name__ == \"__main__\" : run ()","title":"Create decision-maker transaction"},{"location":"aea/decision-maker-transaction/#create-a-private-key-and-an-aea","text":"To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Create our AEA my_aea = builder . build ()","title":"Create a private key and an AEA"},{"location":"aea/decision-maker-transaction/#generate-wealth","text":"Since we want to send funds from our AEA's wallet , we need to generate some wealth for the wallet . We can do this with the following code where we use the default address # Generate some wealth for the default address try_generate_testnet_wealth ( FetchAICrypto . identifier , my_aea . identity . address )","title":"Generate wealth"},{"location":"aea/decision-maker-transaction/#add-a-simple-skill","text":"Add a simple skill with a transaction handler. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) tx_handler = TransactionHandler ( skill_context = skill_context , name = \"transaction_handler\" ) simple_skill = Skill ( skill_config , skill_context , handlers = { tx_handler . name : tx_handler } ) my_aea . resources . add_skill ( simple_skill )","title":"Add a simple skill"},{"location":"aea/decision-maker-transaction/#create-a-second-identity","text":"create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , )","title":"Create a second identity"},{"location":"aea/decision-maker-transaction/#create-the-transaction-message","text":"Next, we are creating the transaction message and we send it to the decision-maker. # create tx message for decision maker to process fetchai_ledger_api = my_aea . context . ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = fetchai_ledger_api . generate_tx_nonce ( my_aea . identity . address , counterparty_identity . address ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ skill_config . public_id ], tx_id = \"transaction0\" , tx_sender_addr = my_aea . identity . address , tx_counterparty_addr = counterparty_identity . address , tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FetchAICrypto . identifier , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg )","title":"Create the transaction message"},{"location":"aea/decision-maker-transaction/#run-the-agent","text":"Finally, we are running the agent and we expect the transaction digest to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join ()","title":"Run the agent"},{"location":"aea/decision-maker-transaction/#more-details","text":"To be able to register a handler that reads the internal messages, we have to create a class at the end of the file with the name TransactionHandler class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import ProtocolId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.skills.base import Handler , Skill , SkillContext logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) builder . add_ledger_api_config ( FetchAICrypto . identifier , { \"network\" : \"testnet\" }) # Create our AEA my_aea = builder . build () # Generate some wealth for the default address try_generate_testnet_wealth ( FetchAICrypto . identifier , my_aea . identity . address ) # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) tx_handler = TransactionHandler ( skill_context = skill_context , name = \"transaction_handler\" ) simple_skill = Skill ( skill_config , skill_context , handlers = { tx_handler . name : tx_handler } ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) # create tx message for decision maker to process fetchai_ledger_api = my_aea . context . ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = fetchai_ledger_api . generate_tx_nonce ( my_aea . identity . address , counterparty_identity . address ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ skill_config . public_id ], tx_id = \"transaction0\" , tx_sender_addr = my_aea . identity . address , tx_counterparty_addr = counterparty_identity . address , tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FetchAICrypto . identifier , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass if __name__ == \"__main__\" : run ()","title":"More details"},{"location":"aea/defining-data-models/","text":"In this section, we explain how to define data models , an important component of the OEF Search & Discovery. It allows agents to describe themselves and to discover the services/resources they are interested in. In a sentence, a DataModel is a set of attributes , and a Description of a service/resource is an assignment of those attributes. All you need to specify data models and descriptions (that is, instances of the data model) can be found in the aea.helpers.search module. Attributes At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute. Data models A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model. Description A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Defining Data Models"},{"location":"aea/defining-data-models/#attributes","text":"At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute.","title":"Attributes"},{"location":"aea/defining-data-models/#data-models","text":"A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model.","title":"Data models"},{"location":"aea/defining-data-models/#description","text":"A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Description"},{"location":"aea/deployment/","text":"Note This section is incomplete and will soon be updated. The easiest way to run an AEA is using your development environment. If you would like to run an AEA from a browser you can use Google Colab . This gist can be opened in Colab and implements the quickstart .","title":"Deployment"},{"location":"aea/design-principles/","text":"Eight principles guide AEA framework development: Accessibility : ease of use. Modularity : encourages module creation, sharing and reuse. Openness : easily extensible with third-party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal-alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"aea/diagram/","text":"Note Work in progress. The framework has two distinctive parts. A core that is developed by the Fetch.ai team as well as external contributors. Extensions (also known as packages ) developed by any developer which promotes a modular and scalable framework. Currently, the framework supports three types of packages which can be added to the core as modules: Skills Protocols Connections The following figure illustrates the framework's architecture: In most cases, as a developer in the AEA framework, it is sufficient to focus on skills development, utilising existing protocols and connections. The later doesn't try to discourage you though, from creating your own connections or protocols but you will need a better understanding of the framework than creating a skill. The agent operation breaks down into three parts: Setup: calls the setup() method of all registered resources Operation: Main loop (Thread 1 - Synchronous): react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function on the Handler(s) responsible for them. act() : this function calls the act() function of all registered Behaviours. update() : this function enqueues scheduled tasks for execution with the TaskManager. Task loop (Thread 2- Synchronous): executes available tasks Decision maker loop (Thread 3- Synchronous): processes internal messages Multiplexer (Thread 4 - Asynchronous event loop): the multiplexer has an event loop which processes incoming and outgoing messages across several connections asynchronously. Teardown: calls the teardown() method of all registered resources To prevent a developer from blocking the main loop with custom skill code, an execution time limit is applied to every Behaviour.act and Handler.handle call. By default, the execution limit is set to 0 seconds, which disables the feature. You can set the limit to 0.1 seconds to test your AEA for production readiness. If the act or handle time exceed this limit, the call will be terminated. An appropriate message is added to the logs in the case of some code execution being terminated.","title":"Architectural diagram"},{"location":"aea/erc1155-skills/","text":"The AEA erc1155_deploy and erc1155_client skills demonstrate an interaction between two AEAs with the usage of a smart contract. The erc1155_deploy skill deploys the smart contract, creates and mints items. The erc1155_client skill signs a transaction to complete a trustless trade with the counterparty. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Discussion The scope of the specific demo is to demonstrate how to deploy a smart contract and interact with it. For the specific use-case, we create two AEAs one that deploys and creates tokens inside the smart contract and the other that signs a transaction so we can complete an atomic swap. The smart contract we are using is an ERC1155 smart contract with a one-step atomic swap functionality. That means the trade between the two AEAs can be trustless. Note This demo serves demonstrative purposes only. Since the AEA deploying the contract also has the ability to mint tokens, in reality the transfer of tokens from the AEA signing the transaction is worthless. Launch an OEF node In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo Create the deployer AEA Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/erc1155_deploy:0.4.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 Additionally, create the private key for the deployer AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Create the client AEA In another terminal, create the AEA that will sign the transaction. aea create erc1155_client cd erc1155_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/erc1155_client:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 Additionally, create the private key for the client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_erc1155_deploy/aea-config.yaml and my_erc1155_client/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect Connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 And change the default ledger: aea config set agent.default_ledger ethereum Fund the AEAs To create some wealth for your AEAs for the Ethereum ropsten network. Note that this needs to be executed from each AEA folder: aea generate-wealth ethereum To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum Note If no wealth appears after a while, then try funding the private key directly using a web faucet. Run the AEAs First, run the deployer AEA. aea run --connections fetchai/oef:0.3.0 It will perform the following steps: - deploy the smart contract - create a batch of items in the smart contract - mint a batch of itemsin the smart contract At some point you should see the log output: Successfully minted items. Transaction digest: ... Then, in the separate terminal run the client AEA. aea run --connections fetchai/oef:0.3.0 You will see that upon discovery the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client Communication This diagram shows the communication between the various entities as data is successfully trustless trade. sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Deployer_AEA activate Search activate Client_AEA activate Erc1155_contract activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Deployer_AEA deactivate Search deactivate Client_AEA deactivate ERC1155_contract deactivate Blockchain","title":"ERC1155 deploy and interact"},{"location":"aea/erc1155-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/erc1155-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/erc1155-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to deploy a smart contract and interact with it. For the specific use-case, we create two AEAs one that deploys and creates tokens inside the smart contract and the other that signs a transaction so we can complete an atomic swap. The smart contract we are using is an ERC1155 smart contract with a one-step atomic swap functionality. That means the trade between the two AEAs can be trustless. Note This demo serves demonstrative purposes only. Since the AEA deploying the contract also has the ability to mint tokens, in reality the transfer of tokens from the AEA signing the transaction is worthless.","title":"Discussion"},{"location":"aea/erc1155-skills/#launch-an-oef-node","text":"In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF node"},{"location":"aea/erc1155-skills/#demo","text":"","title":"Demo"},{"location":"aea/erc1155-skills/#create-the-deployer-aea","text":"Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/erc1155_deploy:0.4.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 Additionally, create the private key for the deployer AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the deployer AEA"},{"location":"aea/erc1155-skills/#create-the-client-aea","text":"In another terminal, create the AEA that will sign the transaction. aea create erc1155_client cd erc1155_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/erc1155_client:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 Additionally, create the private key for the client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the client AEA"},{"location":"aea/erc1155-skills/#update-the-aea-configs","text":"Both in my_erc1155_deploy/aea-config.yaml and my_erc1155_client/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect Connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 And change the default ledger: aea config set agent.default_ledger ethereum","title":"Update the AEA configs"},{"location":"aea/erc1155-skills/#fund-the-aeas","text":"To create some wealth for your AEAs for the Ethereum ropsten network. Note that this needs to be executed from each AEA folder: aea generate-wealth ethereum To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum Note If no wealth appears after a while, then try funding the private key directly using a web faucet.","title":"Fund the AEAs"},{"location":"aea/erc1155-skills/#run-the-aeas","text":"First, run the deployer AEA. aea run --connections fetchai/oef:0.3.0 It will perform the following steps: - deploy the smart contract - create a batch of items in the smart contract - mint a batch of itemsin the smart contract At some point you should see the log output: Successfully minted items. Transaction digest: ... Then, in the separate terminal run the client AEA. aea run --connections fetchai/oef:0.3.0 You will see that upon discovery the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored.","title":"Run the AEAs"},{"location":"aea/erc1155-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client","title":"Delete the AEAs"},{"location":"aea/erc1155-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully trustless trade. sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Deployer_AEA activate Search activate Client_AEA activate Erc1155_contract activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Deployer_AEA deactivate Search deactivate Client_AEA deactivate ERC1155_contract deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills/","text":"The AEA generic buyer and seller skills demonstrate an interaction between two AEAs. The provider of a service in the form of data for sale. The buyer of a service. Discussion The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True. Then you have to implement the method collect_from_data_source(self) inside the strategy.py file. Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions Create the seller AEA First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.1.0 --alias my_seller_aea cd generic_seller aea install Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_seller:0.4.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_seller_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Create the buyer AEA Then, fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.1.0 --alias my_buyer_aea cd generic_buyer aea install Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_buyer:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_buyer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Generate wealth for the buyer AEA The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_buyer_aea/aea-config.yaml` and `my_seller_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos Update the skill configs The default skill configs assume that the transaction is settled against the fetchai ledger. In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml the data_for_sale is the data the seller AEA is offering for sale. models : ... strategy : args : currency_id : FET data_for_sale : pressure : 20 temperature : 26 wind : 10 data_model : attribute_one : is_required : true name : country type : str attribute_two : is_required : true name : city type : str data_model_name : location has_data_source : false is_ledger_tx : true ledger_id : fetchai seller_tx_fee : 0 service_data : city : Cambridge country : UK total_price : 10 class_name : Strategy The data_model , data_model_name and the service_data are used to register the service in the OEF search node and make your agent discoverable. The name of each data_model attribute must be a key in the service_data dictionary. In the generic buyer skill config ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) defines the search_query , which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai max_buyer_tx_fee : 1 max_price : 4 search_query : constraint_type : == search_term : country search_value : UK class_name : Strategy Alternatively, configure skills for other test networks. Seller: Ensure you are in the seller project directory. For ethereum, update the skill config of the seller via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.ledger_id cosmos This updates the generic seller skill config (`my_seller_aea/vendor/fetchai/skills/generic_seller/skill.yaml`). Buyer: Ensure you are in the buyer project directory. For ethereum, update the skill config of the buyer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.ledger_id cosmos This updates the buyer skill config (`my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml`). Run the AEAs Run both AEAs from their respective terminals aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Generic skills"},{"location":"aea/generic-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True. Then you have to implement the method collect_from_data_source(self) inside the strategy.py file.","title":"Discussion"},{"location":"aea/generic-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/generic-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/generic-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/generic-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/generic-skills/#create-the-seller-aea","text":"First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.1.0 --alias my_seller_aea cd generic_seller aea install Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_seller:0.4.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_seller_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create the seller AEA"},{"location":"aea/generic-skills/#create-the-buyer-aea","text":"Then, fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.1.0 --alias my_buyer_aea cd generic_buyer aea install Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_buyer:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_buyer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create the buyer AEA"},{"location":"aea/generic-skills/#generate-wealth-for-the-buyer-aea","text":"The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_buyer_aea/aea-config.yaml` and `my_seller_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos","title":"Generate wealth for the buyer AEA"},{"location":"aea/generic-skills/#update-the-skill-configs","text":"The default skill configs assume that the transaction is settled against the fetchai ledger. In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml the data_for_sale is the data the seller AEA is offering for sale. models : ... strategy : args : currency_id : FET data_for_sale : pressure : 20 temperature : 26 wind : 10 data_model : attribute_one : is_required : true name : country type : str attribute_two : is_required : true name : city type : str data_model_name : location has_data_source : false is_ledger_tx : true ledger_id : fetchai seller_tx_fee : 0 service_data : city : Cambridge country : UK total_price : 10 class_name : Strategy The data_model , data_model_name and the service_data are used to register the service in the OEF search node and make your agent discoverable. The name of each data_model attribute must be a key in the service_data dictionary. In the generic buyer skill config ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) defines the search_query , which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai max_buyer_tx_fee : 1 max_price : 4 search_query : constraint_type : == search_term : country search_value : UK class_name : Strategy Alternatively, configure skills for other test networks. Seller: Ensure you are in the seller project directory. For ethereum, update the skill config of the seller via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.generic_seller.models.strategy.args.ledger_id cosmos This updates the generic seller skill config (`my_seller_aea/vendor/fetchai/skills/generic_seller/skill.yaml`). Buyer: Ensure you are in the buyer project directory. For ethereum, update the skill config of the buyer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.generic_buyer.models.strategy.args.ledger_id cosmos This updates the buyer skill config (`my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml`).","title":"Update the skill configs"},{"location":"aea/generic-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/generic-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/gym-example/","text":"The gym example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's gym framework. Discussion There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym Demo instructions Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym example"},{"location":"aea/gym-example/#discussion","text":"There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-example/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-example/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym","title":"Dependencies"},{"location":"aea/gym-example/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-example/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"aea/gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection. Discussion The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea Add the gym skill aea add skill fetchai/gym:0.2.0 Copy the gym environment to the AEA directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection fetchai/gym:0.1.0 aea config set agent.default_connection fetchai/gym:0.1.0 Update the connection config aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom' Install the skill dependencies To install the gym package, a dependency of the gym skill, from Pypi run aea install Run the AEA with the gym connection aea run --connections fetchai/gym:0.1.0 You will see the gym training logs. Delete the AEA When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea Communication This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment Skill Architecture The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Gym skill"},{"location":"aea/gym-skill/#discussion","text":"The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-skill/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-skill/#create-the-aea","text":"In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea","title":"Create the AEA"},{"location":"aea/gym-skill/#add-the-gym-skill","text":"aea add skill fetchai/gym:0.2.0","title":"Add the gym skill"},{"location":"aea/gym-skill/#copy-the-gym-environment-to-the-aea-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the AEA directory"},{"location":"aea/gym-skill/#add-a-gym-connection","text":"aea add connection fetchai/gym:0.1.0 aea config set agent.default_connection fetchai/gym:0.1.0","title":"Add a gym connection"},{"location":"aea/gym-skill/#update-the-connection-config","text":"aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'","title":"Update the connection config"},{"location":"aea/gym-skill/#install-the-skill-dependencies","text":"To install the gym package, a dependency of the gym skill, from Pypi run aea install","title":"Install the skill dependencies"},{"location":"aea/gym-skill/#run-the-aea-with-the-gym-connection","text":"aea run --connections fetchai/gym:0.1.0 You will see the gym training logs.","title":"Run the AEA with the gym connection"},{"location":"aea/gym-skill/#delete-the-aea","text":"When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea","title":"Delete the AEA"},{"location":"aea/gym-skill/#communication","text":"This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment","title":"Communication"},{"location":"aea/gym-skill/#skill-architecture","text":"The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Skill Architecture"},{"location":"aea/http-connection-and-skill/","text":"Description The HTTP server connection allows you to run a server inside a connection which accepts requests from clients. The HTTP server connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client. Steps Create a new AEA: aea create my_aea cd my_aea Add the http server connection package aea add connection fetchai/http_server:0.2.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.2.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We will implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, we delete the my_model.py and behaviour.py . The server will be pyrely reactive, so we only require the handlers.py file. We update the skill.yaml accordingly, so set models: {} and behaviours: {} . Next we implement a basic handler which prints the received envelopes and responds: import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.http.message import HttpMessage from packages.fetchai.protocols.http.serialization import HttpSerializer class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message :return: None \"\"\" http_msg = cast ( HttpMessage , message ) if http_msg . performative == HttpMessage . Performative . REQUEST : self . context . logger . info ( \"[ {} ] received http request with method= {} , url= {} and body= {} \" . format ( self . context . agent_name , http_msg . method , http_msg . url , http_msg . bodyy , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg ) else : self . context . logger . info ( \"[ {} ] received response ( {} ) unexpectedly!\" . format ( self . context . agent_name , http_msg ) ) def _handle_get ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"[ {} ] responding with: {} \" . format ( self . context . agent_name , http_response ) ) self . context . outbox . put_message ( sender = self . context . agent_address , to = http_msg . counterparty , protocol_id = http_response . protocol_id , message = HttpSerializer () . encode ( http_response ), ) def _handle_post ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = b \"\" , ) self . context . logger . info ( \"[ {} ] responding with: {} \" . format ( self . context . agent_name , http_response ) ) self . context . outbox . put_message ( sender = self . context . agent_address , to = http_msg . counterparty , protocol_id = http_response . protocol_id , message = HttpSerializer () . encode ( http_response ), ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass We also need to update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler Finally, we run the fingerprinter: aea fingerprint skill fetchai/http_echo:0.1.0 Note, you will have to replace the author name with your author handle. We can now run the AEA: aea run In a separate terminal, we can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Connection"},{"location":"aea/http-connection-and-skill/#description","text":"The HTTP server connection allows you to run a server inside a connection which accepts requests from clients. The HTTP server connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client.","title":"Description"},{"location":"aea/http-connection-and-skill/#steps","text":"Create a new AEA: aea create my_aea cd my_aea Add the http server connection package aea add connection fetchai/http_server:0.2.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.2.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We will implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, we delete the my_model.py and behaviour.py . The server will be pyrely reactive, so we only require the handlers.py file. We update the skill.yaml accordingly, so set models: {} and behaviours: {} . Next we implement a basic handler which prints the received envelopes and responds: import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.http.message import HttpMessage from packages.fetchai.protocols.http.serialization import HttpSerializer class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message :return: None \"\"\" http_msg = cast ( HttpMessage , message ) if http_msg . performative == HttpMessage . Performative . REQUEST : self . context . logger . info ( \"[ {} ] received http request with method= {} , url= {} and body= {} \" . format ( self . context . agent_name , http_msg . method , http_msg . url , http_msg . bodyy , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg ) else : self . context . logger . info ( \"[ {} ] received response ( {} ) unexpectedly!\" . format ( self . context . agent_name , http_msg ) ) def _handle_get ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"[ {} ] responding with: {} \" . format ( self . context . agent_name , http_response ) ) self . context . outbox . put_message ( sender = self . context . agent_address , to = http_msg . counterparty , protocol_id = http_response . protocol_id , message = HttpSerializer () . encode ( http_response ), ) def _handle_post ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = b \"\" , ) self . context . logger . info ( \"[ {} ] responding with: {} \" . format ( self . context . agent_name , http_response ) ) self . context . outbox . put_message ( sender = self . context . agent_address , to = http_msg . counterparty , protocol_id = http_response . protocol_id , message = HttpSerializer () . encode ( http_response ), ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass We also need to update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler Finally, we run the fingerprinter: aea fingerprint skill fetchai/http_echo:0.1.0 Note, you will have to replace the author name with your author handle. We can now run the AEA: aea run In a separate terminal, we can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"Steps"},{"location":"aea/identity/","text":"Note This section is incomplete and will soon be updated. The AEAs currently use the addresses associated with their private-public key pairs to identify themselves. To learn how to generate a private-public key pair check out this section . To learn more about public-key cryptography check out Wikipedia","title":"Identity"},{"location":"aea/known-limits/","text":"The AEA framework makes a multitude of tradeoffs. Here we present an incomplete list of known limitations: The AEABuilder checks the consistency of packages at the add stage. However, it does not currently check the consistency again at the load stage. This means, if a package is tampered with after it is added to the AEABuilder then these inconsistencies might not be detected by the AEABuilder. The AEABuilder assumes that packages with public ids of identical author and package name have a matching version. As a result, if a developer uses a package with matching author and package name but different version in the public id, then the AEABuilder will not detect this and simply use the last loaded package.","title":"Known limitations"},{"location":"aea/ledger-integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers. The framework currently natively supports two ledgers: Fetch.ai Ethereum To this end, the framework wraps APIs to interact with the two ledgers and exposes them in the LedgerApis class. The framework also wraps the account APIs to create identities on both ledgers and exposes them in the Wallet . The Wallet holds instantiation of the abstract Crypto base class, in particular FetchaiCrypto and EthereumCrypto . The LedgerApis holds instantiation of the abstract LedgerApi base class, in particular FetchaiLedgerApi and EthereumLedgerApi . You can think the concrete implementations of the base class LedgerApi as wrappers of the blockchain specific python SDK. Abstract class LedgerApi Each LedgerApi must implement all the methods based on the abstract class. class LedgerApi ( ABC ): \"\"\"Interface for ledger APIs.\"\"\" identifier = \"base\" # type: str @property @abstractmethod def api ( self ) -> Any : \"\"\" Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. \"\"\" The api property can be used for low-level operation with the concrete ledger APIs. @abstractmethod def get_balance ( self , address : Address ) -> Optional [ int ]: \"\"\" Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. :param address: the address. :return: the balance. \"\"\" The get_balance method returns the amount of tokens we hold for a specific address. @abstractmethod def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param tx_nonce: verifies the authenticity of the tx :return: tx digest if successful, otherwise None \"\"\" The transfer is where we must implement the logic for sending a transaction to the ledger. @abstractmethod def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" @abstractmethod def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the transaction referenced by the tx_digest matches the terms. \"\"\" The is_transaction_settled and is_transaction_valid are two functions that helps us to verify a transaction digest. @abstractmethod def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" Lastly, we implemented a support function that generates a random hash to help us with verifying the uniqueness of transactions. The sender of the funds must include this hash in the transaction as extra data for the transaction to be considered valid. Next, we are going to discuss the different implementation of send_transaction and validate_transacaction for the two natively supported ledgers of the framework. Fetch.ai Ledger def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , is_waiting_for_confirmation : bool = True , ** kwargs , ) -> Optional [ str ]: \"\"\"Submit a transaction to the ledger.\"\"\" tx_digest = self . _try_transfer_tokens ( crypto , destination_address , amount , tx_fee ) return tx_digest As you can see, the implementation for sending a transcation to the Fetch.ai ledger is relatively trivial. Note We cannot use the tx_nonce yet in the Fetch.ai ledger. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = cast ( TxStatus , self . _try_get_transaction_receipt ( tx_digest )) is_successful = False if tx_status is not None : is_successful = tx_status . status in SUCCESSFUL_TERMINAL_STATES return is_successful def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" is_valid = False tx_contents = self . _try_get_transaction ( tx_digest ) if tx_contents is not None : seller_address = FetchaiAddress ( seller ) is_valid = ( str ( tx_contents . from_address ) == client and amount == tx_contents . transfers [ seller_address ] and self . is_transaction_settled ( tx_digest = tx_digest ) ) return is_valid Inside the validate_transcation we request the contents of the transaction based on the tx_digest we received. We are checking that the address of the client is the same as the one that is inside the from field of the transaction. Lastly, we are checking that the transaction is settled. If both of these checks return True we consider the transaction as valid. Ethereum Ledger def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 1 , ** kwargs , ) -> Optional [ str ]: \"\"\" Submit a transfer transaction to the ledger. :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param tx_nonce: verifies the authenticity of the tx :param chain_id: the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). :return: tx digest if present, otherwise None \"\"\" tx_digest = None nonce = self . _try_get_transaction_count ( crypto . address ) if nonce is None : return tx_digest transaction = { \"nonce\" : nonce , \"chainId\" : chain_id , \"to\" : destination_address , \"value\" : amount , \"gas\" : tx_fee , \"gasPrice\" : self . _api . toWei ( self . _gas_price , GAS_ID ), \"data\" : tx_nonce , } gas_estimate = self . _try_get_gas_estimate ( transaction ) if gas_estimate is None or tx_fee <= gas_estimate : # pragma: no cover logger . warning ( \"Need to increase tx_fee in the configs to cover the gas consumption of the transaction. Estimated gas consumption is: {} .\" . format ( gas_estimate ) ) return tx_digest signed_transaction = crypto . sign_transaction ( transaction ) tx_digest = self . send_signed_transaction ( tx_signed = signed_transaction ,) return tx_digest On contrary to the Fetch.ai implementation of the send_transaction function, the Ethereum implementation is more complicated. This happens because we must create the transaction dictionary and send a raw transaction. The nonce is a counter for the transaction we are sending. This is an auto-increment int based on how many transactions we are sending from the specific account. The chain_id specifies if we are trying to reach the mainnet or another testnet . The to field is the address we want to send the funds. The value is the number of tokens we want to transfer. The gas is the price we are paying to be able to send the transaction. The gasPrice is the price of the gas we want to pay. The data in the field that enables to send custom data (originally is used to send data to a smart contract). Once we filled the transaction dictionary. We are checking that the transaction fee is more than the estimated gas for the transaction otherwise we will not be able to complete the transfer. Then we are signing and we are sending the transaction. Once we get the transaction receipt we consider the transaction completed and we return the transaction digest. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" is_successful = False tx_receipt = self . get_transaction_receipt ( tx_digest ) if tx_receipt is not None : is_successful = tx_receipt . status == 1 return is_successful def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param tx_digest: the transaction digest. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :return: True if the random_message is equals to tx['input'] \"\"\" is_valid = False tx = self . _try_get_transaction ( tx_digest ) if tx is not None : is_valid = ( tx . get ( \"input\" ) == tx_nonce and tx . get ( \"value\" ) == amount and tx . get ( \"from\" ) == client and tx . get ( \"to\" ) == seller ) return is_valid The validate_transaction and is_transaction_settled functions help us to check if a transaction digest is valid and is settled. In the Ethereum API, we can pass the tx_nonce , so we can check that it's the same. If it is different, we consider that transaction as no valid. The same happens if any of amount , client address or the seller address is different. Lastly, the generate_tx_nonce function is the same for both LedgerApi implementations but we use different hashing functions. Both use the timestamp as a random factor alongside the seller and client addresses. Fetch.ai implementation def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = sha256_hash ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex () Ethereum implementation def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a unique hash to distinguish txs with the same terms. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = Web3 . keccak ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Using public ledgers"},{"location":"aea/ledger-integration/#abstract-class-ledgerapi","text":"Each LedgerApi must implement all the methods based on the abstract class. class LedgerApi ( ABC ): \"\"\"Interface for ledger APIs.\"\"\" identifier = \"base\" # type: str @property @abstractmethod def api ( self ) -> Any : \"\"\" Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. \"\"\" The api property can be used for low-level operation with the concrete ledger APIs. @abstractmethod def get_balance ( self , address : Address ) -> Optional [ int ]: \"\"\" Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. :param address: the address. :return: the balance. \"\"\" The get_balance method returns the amount of tokens we hold for a specific address. @abstractmethod def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param tx_nonce: verifies the authenticity of the tx :return: tx digest if successful, otherwise None \"\"\" The transfer is where we must implement the logic for sending a transaction to the ledger. @abstractmethod def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" @abstractmethod def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the transaction referenced by the tx_digest matches the terms. \"\"\" The is_transaction_settled and is_transaction_valid are two functions that helps us to verify a transaction digest. @abstractmethod def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" Lastly, we implemented a support function that generates a random hash to help us with verifying the uniqueness of transactions. The sender of the funds must include this hash in the transaction as extra data for the transaction to be considered valid. Next, we are going to discuss the different implementation of send_transaction and validate_transacaction for the two natively supported ledgers of the framework.","title":"Abstract class LedgerApi"},{"location":"aea/ledger-integration/#fetchai-ledger","text":"def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , is_waiting_for_confirmation : bool = True , ** kwargs , ) -> Optional [ str ]: \"\"\"Submit a transaction to the ledger.\"\"\" tx_digest = self . _try_transfer_tokens ( crypto , destination_address , amount , tx_fee ) return tx_digest As you can see, the implementation for sending a transcation to the Fetch.ai ledger is relatively trivial. Note We cannot use the tx_nonce yet in the Fetch.ai ledger. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = cast ( TxStatus , self . _try_get_transaction_receipt ( tx_digest )) is_successful = False if tx_status is not None : is_successful = tx_status . status in SUCCESSFUL_TERMINAL_STATES return is_successful def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" is_valid = False tx_contents = self . _try_get_transaction ( tx_digest ) if tx_contents is not None : seller_address = FetchaiAddress ( seller ) is_valid = ( str ( tx_contents . from_address ) == client and amount == tx_contents . transfers [ seller_address ] and self . is_transaction_settled ( tx_digest = tx_digest ) ) return is_valid Inside the validate_transcation we request the contents of the transaction based on the tx_digest we received. We are checking that the address of the client is the same as the one that is inside the from field of the transaction. Lastly, we are checking that the transaction is settled. If both of these checks return True we consider the transaction as valid.","title":"Fetch.ai Ledger"},{"location":"aea/ledger-integration/#ethereum-ledger","text":"def transfer ( self , crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 1 , ** kwargs , ) -> Optional [ str ]: \"\"\" Submit a transfer transaction to the ledger. :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param tx_nonce: verifies the authenticity of the tx :param chain_id: the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). :return: tx digest if present, otherwise None \"\"\" tx_digest = None nonce = self . _try_get_transaction_count ( crypto . address ) if nonce is None : return tx_digest transaction = { \"nonce\" : nonce , \"chainId\" : chain_id , \"to\" : destination_address , \"value\" : amount , \"gas\" : tx_fee , \"gasPrice\" : self . _api . toWei ( self . _gas_price , GAS_ID ), \"data\" : tx_nonce , } gas_estimate = self . _try_get_gas_estimate ( transaction ) if gas_estimate is None or tx_fee <= gas_estimate : # pragma: no cover logger . warning ( \"Need to increase tx_fee in the configs to cover the gas consumption of the transaction. Estimated gas consumption is: {} .\" . format ( gas_estimate ) ) return tx_digest signed_transaction = crypto . sign_transaction ( transaction ) tx_digest = self . send_signed_transaction ( tx_signed = signed_transaction ,) return tx_digest On contrary to the Fetch.ai implementation of the send_transaction function, the Ethereum implementation is more complicated. This happens because we must create the transaction dictionary and send a raw transaction. The nonce is a counter for the transaction we are sending. This is an auto-increment int based on how many transactions we are sending from the specific account. The chain_id specifies if we are trying to reach the mainnet or another testnet . The to field is the address we want to send the funds. The value is the number of tokens we want to transfer. The gas is the price we are paying to be able to send the transaction. The gasPrice is the price of the gas we want to pay. The data in the field that enables to send custom data (originally is used to send data to a smart contract). Once we filled the transaction dictionary. We are checking that the transaction fee is more than the estimated gas for the transaction otherwise we will not be able to complete the transfer. Then we are signing and we are sending the transaction. Once we get the transaction receipt we consider the transaction completed and we return the transaction digest. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" is_successful = False tx_receipt = self . get_transaction_receipt ( tx_digest ) if tx_receipt is not None : is_successful = tx_receipt . status == 1 return is_successful def is_transaction_valid ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not (non-blocking). :param tx_digest: the transaction digest. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :return: True if the random_message is equals to tx['input'] \"\"\" is_valid = False tx = self . _try_get_transaction ( tx_digest ) if tx is not None : is_valid = ( tx . get ( \"input\" ) == tx_nonce and tx . get ( \"value\" ) == amount and tx . get ( \"from\" ) == client and tx . get ( \"to\" ) == seller ) return is_valid The validate_transaction and is_transaction_settled functions help us to check if a transaction digest is valid and is settled. In the Ethereum API, we can pass the tx_nonce , so we can check that it's the same. If it is different, we consider that transaction as no valid. The same happens if any of amount , client address or the seller address is different. Lastly, the generate_tx_nonce function is the same for both LedgerApi implementations but we use different hashing functions. Both use the timestamp as a random factor alongside the seller and client addresses.","title":"Ethereum Ledger"},{"location":"aea/ledger-integration/#fetchai-implementation","text":"def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = sha256_hash ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Fetch.ai implementation"},{"location":"aea/ledger-integration/#ethereum-implementation","text":"def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a unique hash to distinguish txs with the same terms. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = Web3 . keccak ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Ethereum implementation"},{"location":"aea/logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an AEA. First of all, create your AEA. aea create my_aea cd my_aea The aea-config.yaml file should look like this. aea_version : '>=0.3.0, <0.4.0' agent_name : my_aea author : '' connections : - fetchai/stub:0.4.0 default_connection : fetchai/stub:0.4.0 default_ledger : fetchai description : '' fingerprint : '' ledger_apis : {} license : '' logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} protocols : - fetchai/default:0.1.0 registry_path : ../packages skills : - fetchai/error:0.2.0 version : 0.1.0 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : False formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : False This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter.","title":"Logging"},{"location":"aea/ml-skills/","text":"The AEA ML (machine learning) skills demonstrate an interaction between two AEAs trading data. There are two types of AEAs: The ml_data_provider which sells training data. The ml_model_trainer which trains a model Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. Communication This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo. Demo instructions Create data provider AEA First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.4.0 cd ml_data_provider aea install Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.3.0 aea add skill fetchai/ml_data_provider:0.3.0 aea config set agent.default_connection fetchai/oef:0.3.0 aea install In `ml_data_provider/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Create model trainer AEA Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.4.0 cd ml_model_trainer aea install Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/ml_train:0.3.0 aea config set agent.default_connection fetchai/oef:0.3.0 aea install In `ml_model_trainer/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Generate wealth for the model trainer AEA The model trainer needs to have some wealth to purchase the training data. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `ml_model_trainer/aea-config.yaml` and `ml_data_provider/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos Update the skill configs The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Data provider: Ensure you are in the ml_data_provider project directory. For ethereum, update the skill config of the data provider via the `aea config get/set` command like so: aea config set vendor.fetchai.skills. ml_data_provider.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id cosmos This updates the ml_data_provider skill config (`ml_data_provider/vendor/fetchai/skills/ml_data_provider/skill.yaml`). Model trainer: Ensure you are in the ml_model_trainer project directory. For ethereum, update the skill config of the ml_model_trainer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.ml_trainer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_trainer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.ml_train.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.ml_train.models.strategy.args.ledger_id cosmos This updates the ml_nodel_trainer skill config (`ml_model_trainer/vendor/fetchai/skills/ml_train/skill.yaml`). Run both AEAs Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"ML skills"},{"location":"aea/ml-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/ml-skills/#communication","text":"This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger","title":"Communication"},{"location":"aea/ml-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/ml-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/ml-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo.","title":"Launch an OEF search and communication node"},{"location":"aea/ml-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/ml-skills/#create-data-provider-aea","text":"First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.4.0 cd ml_data_provider aea install Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.3.0 aea add skill fetchai/ml_data_provider:0.3.0 aea config set agent.default_connection fetchai/oef:0.3.0 aea install In `ml_data_provider/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create data provider AEA"},{"location":"aea/ml-skills/#create-model-trainer-aea","text":"Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.4.0 cd ml_model_trainer aea install Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.3.0 aea add skill fetchai/ml_train:0.3.0 aea config set agent.default_connection fetchai/oef:0.3.0 aea install In `ml_model_trainer/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create model trainer AEA"},{"location":"aea/ml-skills/#generate-wealth-for-the-model-trainer-aea","text":"The model trainer needs to have some wealth to purchase the training data. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `ml_model_trainer/aea-config.yaml` and `ml_data_provider/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos","title":"Generate wealth for the model trainer AEA"},{"location":"aea/ml-skills/#update-the-skill-configs","text":"The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Data provider: Ensure you are in the ml_data_provider project directory. For ethereum, update the skill config of the data provider via the `aea config get/set` command like so: aea config set vendor.fetchai.skills. ml_data_provider.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id cosmos This updates the ml_data_provider skill config (`ml_data_provider/vendor/fetchai/skills/ml_data_provider/skill.yaml`). Model trainer: Ensure you are in the ml_model_trainer project directory. For ethereum, update the skill config of the ml_model_trainer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.ml_trainer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_trainer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.ml_train.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.ml_train.models.strategy.args.ledger_id cosmos This updates the ml_nodel_trainer skill config (`ml_model_trainer/vendor/fetchai/skills/ml_train/skill.yaml`).","title":"Update the skill configs"},{"location":"aea/ml-skills/#run-both-aeas","text":"Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/ml-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"Cleaning up"},{"location":"aea/multiplexer-standalone/","text":"The Multiplexer can be used stand-alone. This way a developer can utilise the protocols and connections indendent of the Agent or AEA classes. First, import the python and application specific libraries and set the static variables. import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Instantiate a Multiplexer A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) Start the Multiplexer We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) Shutdown Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join () Your turn Now it is your turn to develop a simple usecase which utilises the Multiplexer to send and receive Envelopes. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Use multiplexer stand-alone"},{"location":"aea/multiplexer-standalone/#instantiate-a-multiplexer","text":"A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ])","title":"Instantiate a Multiplexer"},{"location":"aea/multiplexer-standalone/#start-the-multiplexer","text":"We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the Multiplexer"},{"location":"aea/multiplexer-standalone/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/multiplexer-standalone/#shutdown","text":"Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join ()","title":"Shutdown"},{"location":"aea/multiplexer-standalone/#your-turn","text":"Now it is your turn to develop a simple usecase which utilises the Multiplexer to send and receive Envelopes.","title":"Your turn"},{"location":"aea/multiplexer-standalone/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/oef-ledger/","text":"The Open Economic Framework and the Ledgers allow AEAs to create value through their interaction with other AEAs. The following diagram illustrates the relation of AEAs to the OEF and Ledgers. Open Economic Framework (OEF) The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF services are fulfilled by an OEF search and communication node . This node consists of two parts. A search node part enables agents to register their services and search and discover other agents' services. A communication node part enables agents to communicate with each other. For two agents to be able to find each other, at least one must register as a service and the other must query the OEF search node for this service. For an example of such an interaction see this guide . Agents can receive messages from other agents if they are both connected to the same OEF communication node . Currently, you need to run your own OEF search and communication node for local development and testing. To start an OEF search and communication node follow the Preliminaries sections from the AEA quick start. Then run: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json When it is live you will see the sentence 'A thing of beauty is a joy forever...'. To view the OEF search and communication node logs for debugging, navigate to data/oef-logs . To connect to an OEF search and communication node an AEA uses the OEFConnection connection package ( fetchai/oef:0.3.0 ). Note In the current implementation agents act as clients to the `OEF search and communication node`. We are working on a fully decentralized peer-to-peer implementation which will remove the need for a central entity. Ledgers Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain.","title":"Relation to OEF and Ledger"},{"location":"aea/oef-ledger/#open-economic-framework-oef","text":"The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF services are fulfilled by an OEF search and communication node . This node consists of two parts. A search node part enables agents to register their services and search and discover other agents' services. A communication node part enables agents to communicate with each other. For two agents to be able to find each other, at least one must register as a service and the other must query the OEF search node for this service. For an example of such an interaction see this guide . Agents can receive messages from other agents if they are both connected to the same OEF communication node . Currently, you need to run your own OEF search and communication node for local development and testing. To start an OEF search and communication node follow the Preliminaries sections from the AEA quick start. Then run: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json When it is live you will see the sentence 'A thing of beauty is a joy forever...'. To view the OEF search and communication node logs for debugging, navigate to data/oef-logs . To connect to an OEF search and communication node an AEA uses the OEFConnection connection package ( fetchai/oef:0.3.0 ). Note In the current implementation agents act as clients to the `OEF search and communication node`. We are working on a fully decentralized peer-to-peer implementation which will remove the need for a central entity.","title":"Open Economic Framework (OEF)"},{"location":"aea/oef-ledger/#ledgers","text":"Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain.","title":"Ledgers"},{"location":"aea/orm-integration/","text":"The AEA generic seller with ORM integration demonstrate how to interact with a database using python-sql objects. The provider of a service in the form of data retrieved from a database. The buyer of a service. Discussion Object-relational-mapping is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. This demo will not use any smart contract, because these would be out of the scope of the tutorial. We assume, that you followed the guide for the generic-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo: Ledger payment A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the seller AEA (ledger version) Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_seller:0.4.0 Create the buyer client (ledger version) In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_buyer:0.3.0 Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Update the seller and buyer AEA skill configs In my_seller_aea/vendor/fetchai/generic_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | dialogues : | dialogues : | | args : {} | args : {} | | class_name : Dialogues | class_name : Dialogues | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : True | has_data_source : True | | data_for_sale : {} | data_for_sale : {} | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | |dependencies : |dependencies : | | SQLAlchemy : {} | SQLAlchemy : {} | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | dialogues : | dialogues : | | args : {} | args : {} | | class_name : Dialogues | class_name : Dialogues | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 40 | max_price : 40 | | max_buyer_tx_fee : 100 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| After changing the skill config files you should run the following command for both agents to install each dependency: aea install Modify the seller's strategy Open the strategy.py with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _total_price = kwargs . pop ( \"total_price\" , DEFAULT_TOTAL_PRICE ) self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) data_for_sale = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () # Read the data from the sensor if the bool is set to True. # Enables us to let the user implement his data collection logic without major changes. if self . _has_data_source : self . _data_for_sale = self . collect_from_data_source () else : self . _data_for_sale = data_for_sale At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , Any ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () self . context . logger . info ( \"Populating the database...\" ) for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query ) Fund the buyer AEA To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum Run the AEAs You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"ORM integration"},{"location":"aea/orm-integration/#discussion","text":"Object-relational-mapping is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. This demo will not use any smart contract, because these would be out of the scope of the tutorial. We assume, that you followed the guide for the generic-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/orm-integration/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/orm-integration/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/orm-integration/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/orm-integration/#demo-ledger-payment","text":"A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo: Ledger payment"},{"location":"aea/orm-integration/#create-the-seller-aea-ledger-version","text":"Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_seller:0.4.0","title":"Create the seller AEA (ledger version)"},{"location":"aea/orm-integration/#create-the-buyer-client-ledger-version","text":"In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/generic_buyer:0.3.0 Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the buyer client (ledger version)"},{"location":"aea/orm-integration/#update-the-aea-configs","text":"Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/orm-integration/#update-the-seller-and-buyer-aea-skill-configs","text":"In my_seller_aea/vendor/fetchai/generic_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | dialogues : | dialogues : | | args : {} | args : {} | | class_name : Dialogues | class_name : Dialogues | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : True | has_data_source : True | | data_for_sale : {} | data_for_sale : {} | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | |dependencies : |dependencies : | | SQLAlchemy : {} | SQLAlchemy : {} | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | dialogues : | dialogues : | | args : {} | args : {} | | class_name : Dialogues | class_name : Dialogues | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 40 | max_price : 40 | | max_buyer_tx_fee : 100 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| After changing the skill config files you should run the following command for both agents to install each dependency: aea install","title":"Update the seller and buyer AEA skill configs"},{"location":"aea/orm-integration/#modify-the-sellers-strategy","text":"Open the strategy.py with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _total_price = kwargs . pop ( \"total_price\" , DEFAULT_TOTAL_PRICE ) self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) data_for_sale = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () # Read the data from the sensor if the bool is set to True. # Enables us to let the user implement his data collection logic without major changes. if self . _has_data_source : self . _data_for_sale = self . collect_from_data_source () else : self . _data_for_sale = data_for_sale At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , Any ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () self . context . logger . info ( \"Populating the database...\" ) for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query )","title":"Modify the seller's strategy"},{"location":"aea/orm-integration/#fund-the-buyer-aea","text":"To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum","title":"Fund the buyer AEA"},{"location":"aea/orm-integration/#run-the-aeas","text":"You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/orm-integration/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/orm-integration/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/p2p-connection/","text":"Note This section is highly experimental. We will update it soon. The fetchai/p2p_libp2p:0.2.0 connection allows AEAs to create a peer-to-peer communication network. In particular, the connection creates an overlay network which maps agents' public keys to IP addresses. Local Demo Create and run the genesis AEA Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 aea run --connections fetchai/p2p_libp2p:0.1.0 Create and run another AEA Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 Provide the AEA with the information it needs to find the genesis by adding the following block to vendor/fetchai/connnections/p2p_libp2p/connection.yaml : config : libp2p_entry_peers : MULTI_ADDRESSES libp2p_host : 0.0.0.0 libp2p_log_file : libp2p_node.log libp2p_port : 9001 Here MULTI_ADDRESSES needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.1.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Local Demo with skills Fetch the weather station and client Create one AEA as follows: aea fetch fetchai/weather_station:0.4.0 aea fetch fetchai/weather_client:0.4.0 Then enter each project individually and execute the following to add the p2p_libp2p connection: aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 Then extend the aea-config.yaml of each project as follows: default_routing : ? \"fetchai/oef_search:0.1.0\" : \"fetchai/oef:0.3.0\" Run OEF Run the oef for search and discovery: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Run weather station Run the weather station first: aea run --connections \"fetchai/p2p_libp2p:0.1.0,fetchai/oef:0.3.0\" The weather station will form the genesis node. Wait until you see the lines: My libp2p addresses: ... Take note of these as the genesis' MULTI_ADDRESSES = [\"{addr1}\", \"{addr2}\"] . Generate wealth for the weather client AEA The weather client needs to have some wealth to purchase the weather station information. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Run the weather client Provide the weather client AEA with the information it needs to find the genesis by adding the following block to vendor/fetchai/connnections/p2p_libp2p/connection.yaml : config : libp2p_entry_peers : MULTI_ADDRESSES libp2p_host : 0.0.0.0 libp2p_log_file : libp2p_node.log libp2p_port : 9001 Here MULTI_ADDRESSES needs to be replaced with the list of multi addresses displayed in the log output of the weather station AEA. Then fund your Now run the weather client: aea run --connections \"fetchai/p2p_libp2p:0.1.0,fetchai/oef:0.3.0\" Deployed Test Network Note Coming soon.","title":"P2P Connection"},{"location":"aea/p2p-connection/#local-demo","text":"","title":"Local Demo"},{"location":"aea/p2p-connection/#create-and-run-the-genesis-aea","text":"Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 aea run --connections fetchai/p2p_libp2p:0.1.0","title":"Create and run the genesis AEA"},{"location":"aea/p2p-connection/#create-and-run-another-aea","text":"Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 Provide the AEA with the information it needs to find the genesis by adding the following block to vendor/fetchai/connnections/p2p_libp2p/connection.yaml : config : libp2p_entry_peers : MULTI_ADDRESSES libp2p_host : 0.0.0.0 libp2p_log_file : libp2p_node.log libp2p_port : 9001 Here MULTI_ADDRESSES needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.1.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other.","title":"Create and run another AEA"},{"location":"aea/p2p-connection/#local-demo-with-skills","text":"","title":"Local Demo with skills"},{"location":"aea/p2p-connection/#fetch-the-weather-station-and-client","text":"Create one AEA as follows: aea fetch fetchai/weather_station:0.4.0 aea fetch fetchai/weather_client:0.4.0 Then enter each project individually and execute the following to add the p2p_libp2p connection: aea add connection fetchai/p2p_libp2p:0.1.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.1.0 Then extend the aea-config.yaml of each project as follows: default_routing : ? \"fetchai/oef_search:0.1.0\" : \"fetchai/oef:0.3.0\"","title":"Fetch the weather station and client"},{"location":"aea/p2p-connection/#run-oef","text":"Run the oef for search and discovery: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json","title":"Run OEF"},{"location":"aea/p2p-connection/#run-weather-station","text":"Run the weather station first: aea run --connections \"fetchai/p2p_libp2p:0.1.0,fetchai/oef:0.3.0\" The weather station will form the genesis node. Wait until you see the lines: My libp2p addresses: ... Take note of these as the genesis' MULTI_ADDRESSES = [\"{addr1}\", \"{addr2}\"] .","title":"Run weather station"},{"location":"aea/p2p-connection/#generate-wealth-for-the-weather-client-aea","text":"The weather client needs to have some wealth to purchase the weather station information. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai","title":"Generate wealth for the weather client AEA"},{"location":"aea/p2p-connection/#run-the-weather-client","text":"Provide the weather client AEA with the information it needs to find the genesis by adding the following block to vendor/fetchai/connnections/p2p_libp2p/connection.yaml : config : libp2p_entry_peers : MULTI_ADDRESSES libp2p_host : 0.0.0.0 libp2p_log_file : libp2p_node.log libp2p_port : 9001 Here MULTI_ADDRESSES needs to be replaced with the list of multi addresses displayed in the log output of the weather station AEA. Then fund your Now run the weather client: aea run --connections \"fetchai/p2p_libp2p:0.1.0,fetchai/oef:0.3.0\"","title":"Run the weather client"},{"location":"aea/p2p-connection/#deployed-test-network","text":"Note Coming soon.","title":"Deployed Test Network"},{"location":"aea/package-imports/","text":"An agent that is generated using the AEA framework is a modular system with different connections, contracts, protocols and skills. File structure The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry are located in vendor and sorted by author. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fet_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same. AEA Config Yaml The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.4.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package. Vendor and package directories The vendor folder contains the packages from the registry which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder. Importing modules from packages The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem. Python dependencies of packages Python dependencies of packages are specified in their respective configuration files under dependencies . Create a package If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). Use published packages from the registry If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local . Package versioning By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 .","title":"File structure"},{"location":"aea/package-imports/#file-structure","text":"The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry are located in vendor and sorted by author. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fet_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same.","title":"File structure"},{"location":"aea/package-imports/#aea-config-yaml","text":"The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.4.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package.","title":"AEA Config Yaml"},{"location":"aea/package-imports/#vendor-and-package-directories","text":"The vendor folder contains the packages from the registry which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder.","title":"Vendor and package directories"},{"location":"aea/package-imports/#importing-modules-from-packages","text":"The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem.","title":"Importing modules from packages"},{"location":"aea/package-imports/#python-dependencies-of-packages","text":"Python dependencies of packages are specified in their respective configuration files under dependencies .","title":"Python dependencies of packages"},{"location":"aea/package-imports/#create-a-package","text":"If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ).","title":"Create a package"},{"location":"aea/package-imports/#use-published-packages-from-the-registry","text":"If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local .","title":"Use published packages from the registry"},{"location":"aea/package-imports/#package-versioning","text":"By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 .","title":"Package versioning"},{"location":"aea/performance-benchmark/","text":"Test AEA framework performance. What is it? The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results. How does it work? The framework: * spawns a dedicated process for each test run to execute the function to test. * measures CPU and RAM usage periodically. * waits for function exits or terminates them by timeout. * repeats test execution multiple times to get more accurate results. How to use Steps to run a test: Write a function you would like to test with all arguments you would like to parameterise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results. Simple example cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see cPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution. Requirements for tested function The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while. Execution options To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by whitespace 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values. Limitations Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually. Testing AEA. Handlers example: Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () create AEA wrapper with specified handler skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) populate inbox with dummy messages for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) set timeout 0, for maximum messages processing speed aea_test_wrapper.set_loop_timeout(0.0) start benchmark benchmark.start() start/stop AEA aea_test_wrapper . start () ... aea_test_wrapper . stop () wait till messages present in inbox. while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Performance benchmark"},{"location":"aea/performance-benchmark/#what-is-it","text":"The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results.","title":"What is it?"},{"location":"aea/performance-benchmark/#how-does-it-work","text":"The framework: * spawns a dedicated process for each test run to execute the function to test. * measures CPU and RAM usage periodically. * waits for function exits or terminates them by timeout. * repeats test execution multiple times to get more accurate results.","title":"How does it work?"},{"location":"aea/performance-benchmark/#how-to-use","text":"Steps to run a test: Write a function you would like to test with all arguments you would like to parameterise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results.","title":"How to use"},{"location":"aea/performance-benchmark/#simple-example","text":"cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see cPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution.","title":"Simple example"},{"location":"aea/performance-benchmark/#requirements-for-tested-function","text":"The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while.","title":"Requirements for tested function"},{"location":"aea/performance-benchmark/#execution-options","text":"To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by whitespace 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values.","title":"Execution options"},{"location":"aea/performance-benchmark/#limitations","text":"Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually.","title":"Limitations"},{"location":"aea/performance-benchmark/#testing-aea-handlers-example","text":"Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () create AEA wrapper with specified handler skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) populate inbox with dummy messages for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) set timeout 0, for maximum messages processing speed aea_test_wrapper.set_loop_timeout(0.0) start benchmark benchmark.start() start/stop AEA aea_test_wrapper . start () ... aea_test_wrapper . stop () wait till messages present in inbox. while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Testing AEA. Handlers example:"},{"location":"aea/protocol-generator/","text":"Note This is currently an experimental feature. To try it follow this guide. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. How to run First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. Protocol Specification A protocol can be described in a yaml file. As such, it needs to follow the yaml format . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' description : 'A protocol for negotiation over a fixed set of resources involving two parties.' speech_acts : cfp : query : ct:DataModel propose : offer : ct:DataModel price : pt:float accept : {} decline : {} match_accept : {} ... --- ct:DataModel : | bytes data_model = 1; ... --- reply : cfp : [ propose , decline ] propose : [ accept , decline ] accept : [ decline , match_accept ] decline : [] match_accept : [] roles : { buyer , seller } end_states : [ successful , failed ] ... Each protocol specification yaml file must have a minimum of one, and a maximum of three yaml documents (each yaml document is enclosed within --- and ...). Basic Protocol Detail and Messages Syntax The first yaml document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol All of the above fields are mandatory and each is a key/value pair, where both key and value are yaml strings. In addition, the first yaml document in a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, there is another mandatory field: speech-acts , which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (yaml string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, e.g. accept , decline and match_accept in the above specification. A content dictionary in turn is composed of key/value pairs, where each key is the name of a content (yaml string) and the value is its type (yaml string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:DataModel . Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types, e.g. <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or an <MT> . A multi type denotes an \"or\" separated set of sub-types, e.g. pt:union[pt:str, pt:int] as the type of a content means content should either be a pt:int or a pt:float . An optional type for a content denotes that the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here Protocol Buffer Schema Currently, there are no official method provided by the AEA framework for describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Therefore, if any of the contents declared in `speech-acts is of a custom type, the specification must then have a second yaml document, containing the protocol buffer schema code for every custom type. You can see an example of the second yaml document in the above protocol specification. Dialogues You can optionally describe some of the structural details of dialogues conforming to your protocol in a third yaml document in the protocol specification. The allowed fields and what they represent are: reply : The reply structure of speech-acts roles : The roles of agents participating in dialogues end_states : The final states a dialogue could end up in. All of the above fields are mandatory. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a dictionary, where the keys are the performatives (yaml string) defined in speech-acts . For each performtaive key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . roles lists the roles are agents which participate in dialogues conforming with your protocol. roles takes a set, which may contain two or one roles, each role being a yaml string. If there are two roles, each agent has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is one role, then the two agents in a dialogue take the same role. end_states lists the final states a dialogue based on your protocol may terminate in. end_states is a list of yaml strings. Notes Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents. Generated protocol package The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains basic information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types) Demo instructions First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Generating protocols"},{"location":"aea/protocol-generator/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/protocol-generator/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/protocol-generator/#how-to-run","text":"First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification.","title":"How to run"},{"location":"aea/protocol-generator/#protocol-specification","text":"A protocol can be described in a yaml file. As such, it needs to follow the yaml format . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' description : 'A protocol for negotiation over a fixed set of resources involving two parties.' speech_acts : cfp : query : ct:DataModel propose : offer : ct:DataModel price : pt:float accept : {} decline : {} match_accept : {} ... --- ct:DataModel : | bytes data_model = 1; ... --- reply : cfp : [ propose , decline ] propose : [ accept , decline ] accept : [ decline , match_accept ] decline : [] match_accept : [] roles : { buyer , seller } end_states : [ successful , failed ] ... Each protocol specification yaml file must have a minimum of one, and a maximum of three yaml documents (each yaml document is enclosed within --- and ...).","title":"Protocol Specification"},{"location":"aea/protocol-generator/#basic-protocol-detail-and-messages-syntax","text":"The first yaml document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol All of the above fields are mandatory and each is a key/value pair, where both key and value are yaml strings. In addition, the first yaml document in a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, there is another mandatory field: speech-acts , which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (yaml string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, e.g. accept , decline and match_accept in the above specification. A content dictionary in turn is composed of key/value pairs, where each key is the name of a content (yaml string) and the value is its type (yaml string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:DataModel .","title":"Basic Protocol Detail and Messages Syntax"},{"location":"aea/protocol-generator/#types","text":"The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types, e.g. <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or an <MT> . A multi type denotes an \"or\" separated set of sub-types, e.g. pt:union[pt:str, pt:int] as the type of a content means content should either be a pt:int or a pt:float . An optional type for a content denotes that the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here","title":"Types"},{"location":"aea/protocol-generator/#protocol-buffer-schema","text":"Currently, there are no official method provided by the AEA framework for describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Therefore, if any of the contents declared in `speech-acts is of a custom type, the specification must then have a second yaml document, containing the protocol buffer schema code for every custom type. You can see an example of the second yaml document in the above protocol specification.","title":"Protocol Buffer Schema"},{"location":"aea/protocol-generator/#dialogues","text":"You can optionally describe some of the structural details of dialogues conforming to your protocol in a third yaml document in the protocol specification. The allowed fields and what they represent are: reply : The reply structure of speech-acts roles : The roles of agents participating in dialogues end_states : The final states a dialogue could end up in. All of the above fields are mandatory. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a dictionary, where the keys are the performatives (yaml string) defined in speech-acts . For each performtaive key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . roles lists the roles are agents which participate in dialogues conforming with your protocol. roles takes a set, which may contain two or one roles, each role being a yaml string. If there are two roles, each agent has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is one role, then the two agents in a dialogue take the same role. end_states lists the final states a dialogue based on your protocol may terminate in. end_states is a list of yaml strings.","title":"Dialogues"},{"location":"aea/protocol-generator/#notes","text":"Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents.","title":"Notes"},{"location":"aea/protocol-generator/#generated-protocol-package","text":"The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains basic information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types)","title":"Generated protocol package"},{"location":"aea/protocol-generator/#demo-instructions","text":"First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Demo instructions"},{"location":"aea/protocol/","text":"A Protocol manages message representation (syntax in message.py ), optionally rules of the message exchange (semantics in dialogues.py ), as well as encoding and decoding (in serialization.py ). All protocols are for point to point interactions between two agents. Agents can be AEAs or other types of agent-like services. Metadata Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. * dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . Performative: Enum , the purpose/intention of the message. is_incoming: bool , a boolean specifying whether the message is outgoing (from the agent), or incoming (from the other agent). The default value is False . counterparty: Address , the address of the counterparty of this agent; the other agent, this agent is communicating with. The default values for the above fields assume the message is the first message by the agent in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue, target is 0 since the first message is the only message that does not reply to any other, and is_incoming is False indicating the message is by the agent itself. By default, the values of dialogue_reference , message_id , target , is_incoming , counterparty are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with a another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one. Contents Each message may optionally have any number of contents of varying types. Dialogue rules Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single dialogue, respectively all dialogues, associated with the protocol. Custom protocol The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). fetchai/default:0.1.0 protocol The fetchai/default:0.1.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from aea.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.2.0 skill utilises the fetchai/default:0.1.0 protocol for error handling. fetchai/oef_search:0.1.0 protocol The fetchai/oef_search:0.1.0 protocol is used by AEAs to interact with an OEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.1.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The OEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the OEF communication node and any protocol other than fetchai/oef_search:0.1.0 . If the OEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000 fetchai/fipa:0.2.0 protocol The fetchai/fipa:0.2.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:0.2.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:0.2.0 protocol check out the thermometer skill step by step guide .","title":"Protocol"},{"location":"aea/protocol/#metadata","text":"Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. * dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . Performative: Enum , the purpose/intention of the message. is_incoming: bool , a boolean specifying whether the message is outgoing (from the agent), or incoming (from the other agent). The default value is False . counterparty: Address , the address of the counterparty of this agent; the other agent, this agent is communicating with. The default values for the above fields assume the message is the first message by the agent in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue, target is 0 since the first message is the only message that does not reply to any other, and is_incoming is False indicating the message is by the agent itself. By default, the values of dialogue_reference , message_id , target , is_incoming , counterparty are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with a another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one.","title":"Metadata"},{"location":"aea/protocol/#contents","text":"Each message may optionally have any number of contents of varying types.","title":"Contents"},{"location":"aea/protocol/#dialogue-rules","text":"Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single dialogue, respectively all dialogues, associated with the protocol.","title":"Dialogue rules"},{"location":"aea/protocol/#custom-protocol","text":"The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue).","title":"Custom protocol"},{"location":"aea/protocol/#fetchaidefault010-protocol","text":"The fetchai/default:0.1.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from aea.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.2.0 skill utilises the fetchai/default:0.1.0 protocol for error handling.","title":"fetchai/default:0.1.0 protocol"},{"location":"aea/protocol/#fetchaioef_search010-protocol","text":"The fetchai/oef_search:0.1.0 protocol is used by AEAs to interact with an OEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.1.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The OEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the OEF communication node and any protocol other than fetchai/oef_search:0.1.0 . If the OEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000","title":"fetchai/oef_search:0.1.0 protocol"},{"location":"aea/protocol/#fetchaifipa020-protocol","text":"The fetchai/fipa:0.2.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:0.2.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:0.2.0 protocol check out the thermometer skill step by step guide .","title":"fetchai/fipa:0.2.0 protocol"},{"location":"aea/query-language/","text":"We recommend reading Defining a Data Model before reading this section. Along with the Data Model language, the AEA framework offers the possibility to specify queries defined over data models. The aea.helpers.search module implements the API that allows you to build queries. In one sentence, a Query is a set of constraints , defined over a cata model . The outcome is a set of description (that is, instances of Description ) matching with the query. That is, all the description whose attributes satisfy the constraints in the query. In the next sections, we describe how to build queries. Constraints A constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them. Relation There are several constraint types that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 )) Set The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , [ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , [ 1990 , 1995 , 2000 ])) Range The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 ))) Distance The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the center ), such that will be considered only the instances whose location attribute value is within a distance from the center. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location , # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint Expressions The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite constraint expressions, e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or . Not The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 )))) And The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))]) Or The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))]) Queries A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it. The check method The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid wrt the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid wrt a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (wrt to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type wrt the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"The Query Language"},{"location":"aea/query-language/#constraints","text":"A constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them.","title":"Constraints"},{"location":"aea/query-language/#relation","text":"There are several constraint types that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 ))","title":"Relation"},{"location":"aea/query-language/#set","text":"The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , [ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , [ 1990 , 1995 , 2000 ]))","title":"Set"},{"location":"aea/query-language/#range","text":"The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 )))","title":"Range"},{"location":"aea/query-language/#distance","text":"The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the center ), such that will be considered only the instances whose location attribute value is within a distance from the center. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location , # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False`","title":"Distance"},{"location":"aea/query-language/#constraint-expressions","text":"The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite constraint expressions, e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or .","title":"Constraint Expressions"},{"location":"aea/query-language/#not","text":"The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 ))))","title":"Not"},{"location":"aea/query-language/#and","text":"The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))])","title":"And"},{"location":"aea/query-language/#or","text":"The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))])","title":"Or"},{"location":"aea/query-language/#queries","text":"A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it.","title":"Queries"},{"location":"aea/query-language/#the-check-method","text":"The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False","title":"The check method"},{"location":"aea/query-language/#validity","text":"A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid wrt the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid wrt a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (wrt to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type wrt the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"aea/questions-and-answers/","text":"What is the Open Economic Framework (OEF)? The 'Open Economic Framework' (OEF) is a node that enables search, discovery and communicate with possible clients or services. You can read more about the ledgers and the OEF here What is the AEA? AEA is short for Autonomous Economic Agents. AEAs act independently of constant user input and autonomously execute actions to achieve their objective. Their goal is to create economic value for you, their owner. You can read more about the AEAs here How do agents talk to others when they don't know each other? For the Autonomous Economic Agents (AEAs) to be able to talk to others, firstly they need to find them, and then, implement the same protocols in order to be able to deserialize the envelops they receive. You can read more about the Search and Discovery here and more about envelops and protocols here How does an AEA use blockchain? The AEA framework enables the agents to interact with public blockchains to complete transactions. Currently, the framework supports two different networks natively: the `Fetch.ai` network and the `Ethereum` network. You can read more about the intergration of ledger here How does one install third party libraries? The framework supports the use of third-party libraries hosted on PyPI we can directly reference the external dependencies. The `aea install` command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. How does one connect to a database? You have two options to connect to a database: - Creating a wrapper that communicates with the database and imports a Model. You can find an example implementation in the `weather_station` package - Using an ORM (object-relational mapping) library, and implementing the logic inside a class that inherits from the Model abstract class. For a detailed example of how to use an ORM follow the ORM use case How does one connect to a live-stream of data? You can create a wrapper class that communicates with the source and import this class in your skill, or you can use a third-party library by listing the dependency in the skill's `.yaml` file. Then you can import this library in a strategy class that inherits from the Model abstract class. You can find example of this implementation in the thermometer step by step guide How does one connect a frontend? There are two options that one could connect a frontend. The first option would be to create an HTTP connection and then create an app that will communicate with this connections. The other option is to create a frontend client that will communicate with the agent via the [OEF communication network](../oef-ledger). You can find a more detailed approach here Is the AEA framework ideal for agent-based modeling? The goal of agent-based modeling is to search for explanatory insight into the collective behavior of agents obeying simple rules, typically in natural systems rather than in designing agents or solving specific practical or engineering problems. Although it would be potentially possible, it would be inefficient to use the AEA framework for that kind of problem. You can find more details here Can you manage multiple AEA projects at once with the CLI? Individual CLI calls are currently scoped to a single project. You can have multiple AEA projects in a given root directory but you will have to use the CLI for each project independently. We are looking to add support for interacting with multiple AEA projects via a single CLI call in the future. You can find more details about the CLI commands here When a new AEA is created, is the `vendor` folder populated with some default packages? All AEA projects by default hold the `fetchai/stub:0.4.0` connection, the `fetchai/default:0.1.0` protocol and the `fetchai/error:0.1.0` skill. These (as all other packages installed from the registry) are placed in the vendor's folder. You can find more details about the file structure here Is there a standardization for private key files? Currently, the private keys are stored in `.txt` files. This is temporary and will be improved soon. How to use the same protocol in different skills? By default, envelopes of a given protocol get routed to all skills which have a handler supporting that protocol. The `URI` in the `EnvelopeContext` can be used to route envelopes of a given protocol to a specific skill. The `URI` path needs to be set to the skill's `public_id.to_uri_path`.","title":"Q&A"},{"location":"aea/quickstart/","text":"If you want to create Autonomous Economic Agents (AEAs) that can act independently of constant user input and autonomously execute actions to achieve their objective, you can use the Fetch.ai AEA framework. This example will take you through the simplest AEA in order to make you familiar with the framework. Preliminaries Create and enter into a new working directory. mkdir my_aea_projects/ cd my_aea_projects/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell Installing docker Note For the purpose of the quickstart only, you can skip installation of docker. At some point, you will need Docker installed on your machine (e.g. to run an OEF search and communication node ). Download the scripts and examples directories Note For the purpose of the quickstart only, you can skip downloading the scripts and examples directories. Download folders containing examples and scripts: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts You can install the svn command with ( brew install subversion or sudo apt-get install subversion ). Installation The following installs the entire AEA package which also includes a command-line interface (CLI) . pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' Known issues If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio . Setup Author name You can now setup your author name: aea init This is your unique author name in the Fetch.ai ecosystem. You should see a similar output (with your input replacing the sample input): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.3.3 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run `aea init --local` instead. Echo skill demo The echo skill is a simple demo that introduces you to the main business logic components of an AEA. The fastest way to create your first AEA is to fetch it! If you want to follow a step by step guide we show you how to do it at the end of the file. aea fetch fetchai/my_first_aea:0.4.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here . Usage of the stub connection AEAs use envelopes containing messages for communication. We use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.1.0, \\x 08 \\x 01 * \\x 07 \\n\\x 05hello, Run the AEA Run the AEA with the default fetchai/stub:0.4.0 connection. aea run or aea run --connections fetchai/stub:0.4.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.3.3 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act. This is the main agent loop in action. Let's look at the Handler in more depth. Add a message to the input file From a different terminal and same directory, we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Stop the AEA Stop the AEA by pressing CTRL C You should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. Write a test for the AEA We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Step by step install The following test class replicates the preceding demo and tests it's correct behaviour. The `AEATestCase` classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. import signal import time from aea.mail.base import Envelope from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = \"sender_aea\" , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id assert sent_envelope . message == received_envelope . message check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file `test.py` in your AEA project directory (the same level as the `aea-config.yaml` file). To run, execute the following: pytest test . py Delete the AEA Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea Next steps For more detailed analysis of the core components of the framework, please check the following: Core components We recommend you learn more about the protocols agents use to communicate with each other. Understanding protocols is core to developing your own agent. Check out the following: Protocols We also recommend you have a look at skill development. Skills are the core business logic commponents of an AEA. Check out the following: Skills For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Thermometer step by step guide Step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.1.0 This copies the `fetchai/echo:0.1.0` skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill `fetchai/echo:0.1.0` consists of the name of the author of the skill, followed by the skill name and its version.","title":"AEA quick start"},{"location":"aea/quickstart/#preliminaries","text":"Create and enter into a new working directory. mkdir my_aea_projects/ cd my_aea_projects/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"aea/quickstart/#installing-docker","text":"Note For the purpose of the quickstart only, you can skip installation of docker. At some point, you will need Docker installed on your machine (e.g. to run an OEF search and communication node ).","title":"Installing docker"},{"location":"aea/quickstart/#download-the-scripts-and-examples-directories","text":"Note For the purpose of the quickstart only, you can skip downloading the scripts and examples directories. Download folders containing examples and scripts: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts You can install the svn command with ( brew install subversion or sudo apt-get install subversion ).","title":"Download the scripts and examples directories"},{"location":"aea/quickstart/#installation","text":"The following installs the entire AEA package which also includes a command-line interface (CLI) . pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]'","title":"Installation"},{"location":"aea/quickstart/#known-issues","text":"If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio .","title":"Known issues"},{"location":"aea/quickstart/#setup-author-name","text":"You can now setup your author name: aea init This is your unique author name in the Fetch.ai ecosystem. You should see a similar output (with your input replacing the sample input): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.3.3 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run `aea init --local` instead.","title":"Setup Author name"},{"location":"aea/quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that introduces you to the main business logic components of an AEA. The fastest way to create your first AEA is to fetch it! If you want to follow a step by step guide we show you how to do it at the end of the file. aea fetch fetchai/my_first_aea:0.4.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here .","title":"Echo skill demo"},{"location":"aea/quickstart/#usage-of-the-stub-connection","text":"AEAs use envelopes containing messages for communication. We use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.1.0, \\x 08 \\x 01 * \\x 07 \\n\\x 05hello,","title":"Usage of the stub connection"},{"location":"aea/quickstart/#run-the-aea","text":"Run the AEA with the default fetchai/stub:0.4.0 connection. aea run or aea run --connections fetchai/stub:0.4.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.3.3 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act. This is the main agent loop in action. Let's look at the Handler in more depth.","title":"Run the AEA"},{"location":"aea/quickstart/#add-a-message-to-the-input-file","text":"From a different terminal and same directory, we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called.","title":"Add a message to the input file"},{"location":"aea/quickstart/#stop-the-aea","text":"Stop the AEA by pressing CTRL C You should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called.","title":"Stop the AEA"},{"location":"aea/quickstart/#write-a-test-for-the-aea","text":"We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Step by step install The following test class replicates the preceding demo and tests it's correct behaviour. The `AEATestCase` classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. import signal import time from aea.mail.base import Envelope from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = \"sender_aea\" , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id assert sent_envelope . message == received_envelope . message check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file `test.py` in your AEA project directory (the same level as the `aea-config.yaml` file). To run, execute the following: pytest test . py","title":"Write a test for the AEA"},{"location":"aea/quickstart/#delete-the-aea","text":"Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea","title":"Delete the AEA"},{"location":"aea/quickstart/#next-steps","text":"For more detailed analysis of the core components of the framework, please check the following: Core components We recommend you learn more about the protocols agents use to communicate with each other. Understanding protocols is core to developing your own agent. Check out the following: Protocols We also recommend you have a look at skill development. Skills are the core business logic commponents of an AEA. Check out the following: Skills For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Thermometer step by step guide Step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.1.0 This copies the `fetchai/echo:0.1.0` skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill `fetchai/echo:0.1.0` consists of the name of the author of the skill, followed by the skill name and its version.","title":"Next steps"},{"location":"aea/raspberry-set-up/","text":"Prerequisites Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible. Preparing the Raspberry Pi If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Rasperry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below. NOOBS NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your sd card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your wifi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade Install a virtual environment You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv Create and launch a virtual environment pipenv --python 3 .7 && pipenv shell Installing the AEA-framework Install the package from source: pip install aea [ all ]","title":"Build an AEA on a Raspberry Pi"},{"location":"aea/raspberry-set-up/#prerequisites","text":"Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible.","title":"Prerequisites"},{"location":"aea/raspberry-set-up/#preparing-the-raspberry-pi","text":"If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Rasperry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below.","title":"Preparing the Raspberry Pi"},{"location":"aea/raspberry-set-up/#noobs","text":"NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your sd card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your wifi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade","title":"NOOBS"},{"location":"aea/raspberry-set-up/#install-a-virtual-environment","text":"You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv","title":"Install a virtual environment"},{"location":"aea/raspberry-set-up/#create-and-launch-a-virtual-environment","text":"pipenv --python 3 .7 && pipenv shell","title":"Create and launch a virtual environment"},{"location":"aea/raspberry-set-up/#installing-the-aea-framework","text":"Install the package from source: pip install aea [ all ]","title":"Installing the AEA-framework"},{"location":"aea/scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, cd into your project directory and scaffold your project skill, protocol, or connection. Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you are ready to develop your own skill, protocol and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] Then you are ready to run the AEA.","title":"Scaffolding packages"},{"location":"aea/scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, cd into your project directory and scaffold your project skill, protocol, or connection.","title":"Scaffold generator"},{"location":"aea/scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"aea/scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"aea/scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you are ready to develop your own skill, protocol and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] Then you are ready to run the AEA.","title":"Scaffold a connection"},{"location":"aea/skill-guide/","text":"Note Before developing your first skill, please read the skill guide . Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Step 1: Setup We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the OEF search node and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF search node via the OEF communication network . from aea.helpers.search.models import Constraint , ConstraintType , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( self . sent_search_count ), \"\" ), query = search_query_w_empty_model , ) self . context . logger . info ( \"[ {} ]: sending search request to OEF search node, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count ) ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( search_request ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name ) ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Step 3: Develop a Handler So far, we have tasked the AEA with sending search requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node at the moment. The AEA would simply respond to the OEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OefSearchMessage ) -> None : \"\"\" Handle the message. :param message: the message. :return: None \"\"\" msg_type = OefSearchMessage . Performative ( message . performative ) if msg_type is OefSearchMessage . Performative . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) self . context . logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name ) ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context . We place this code in my_aea/skills/my_search/handlers.py . Step 4: Remove unused Model We have implemented a behaviour and a handler. We could also implement a model , but instead we delete this file in this case, to keep it simple. We remove the file my_aea/skills/my_search/my_model.py . Step 5: Create the config file Based on our skill components above, we create the following config file. name : my_search author : fetchai version : 0.1.0 description : 'A simple search skill utilising the OEF search and communication node.' license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' fingerprint : {} fingerprint_ignore_patterns : [] contracts : [] protocols : - 'fetchai/oef_search:0.1.0' behaviours : my_search_behaviour : args : tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : {} dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Step 6: Update fingerprint We need to update the fingerprint of our skill next: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.) Step 7: Add the oef protocol and connection Our AEA does not have the oef protocol yet so let's add it. aea add protocol fetchai/oef_search:0.1.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the oef connection and install its dependencies: aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 Step 8: Run a service provider AEA We first start a local OEF search and communication node in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json In order to be able to find another AEA when searching, from a different terminal window, we fetch and run another finished AEA: aea fetch fetchai/simple_service_registration:0.4.0 && cd simple_service_registration aea run --connections fetchai/oef:0.3.0 This AEA will simply register a location service on the OEF search node so we can search for it. Click here to see full code We use a ticker behaviour to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating services on OEF service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF Service Directory. :return: None \"\"\" if self . _registered_service_description is not None : strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering services from OEF service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None We create a `model` type strategy class and place it in `strategy.py`. We use a generic data model to register the service. from typing import Any , Dict , Optional from aea.helpers.search.generic import GenericDataModel from aea.helpers.search.models import Description from aea.skills.base import Model DEFAULT_DATA_MODEL_NAME = \"location\" DEFAULT_DATA_MODEL = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, } # type: Optional[Dict[str, Any]] DEFAULT_SERVICE_DATA = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( self . _service_data , data_model = GenericDataModel ( self . _data_model_name , self . _data_model ), ) return desc The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.2.0 description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' fingerprint : __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmT4nDbtEz5BDtSbw34fXzdZg4HfbYgV3dfMfsGe9R61n4 strategy.py : QmWwPzDvmeuVutPwxL5taU1tBGA6aiMDRwo6bTTtLxxHRn fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.1.0 behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : {} models : strategy : args : data_model : attribute_one : is_required : true name : country type : str attribute_two : is_required : true name : city type : str data_model_name : location service_data : city : Cambridge country : UK class_name : Strategy dependencies : {} Step 9: Run the Search AEA We can then launch our AEA. aea run --connections fetchai/oef:0.3.0 We can see that the AEA sends search requests to the OEF search node and receives search responses from the OEF search node . Since our AEA is only searching on the OEF search node - and not registered on the OEF search node - the search response returns a single agent (the service provider). We stop the AEA with CTRL + C . Now it's your turn We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Build a skill for an AEA"},{"location":"aea/skill-guide/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/skill-guide/#step-1-setup","text":"We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the OEF search node and process the resulting response.","title":"Step 1: Setup"},{"location":"aea/skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF search node via the OEF communication network . from aea.helpers.search.models import Constraint , ConstraintType , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( self . sent_search_count ), \"\" ), query = search_query_w_empty_model , ) self . context . logger . info ( \"[ {} ]: sending search request to OEF search node, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count ) ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( search_request ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name ) ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py .","title":"Step 2: Develop a Behaviour"},{"location":"aea/skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the AEA with sending search requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node at the moment. The AEA would simply respond to the OEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OefSearchMessage ) -> None : \"\"\" Handle the message. :param message: the message. :return: None \"\"\" msg_type = OefSearchMessage . Performative ( message . performative ) if msg_type is OefSearchMessage . Performative . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) self . context . logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name ) ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context . We place this code in my_aea/skills/my_search/handlers.py .","title":"Step 3: Develop a Handler"},{"location":"aea/skill-guide/#step-4-remove-unused-model","text":"We have implemented a behaviour and a handler. We could also implement a model , but instead we delete this file in this case, to keep it simple. We remove the file my_aea/skills/my_search/my_model.py .","title":"Step 4: Remove unused Model"},{"location":"aea/skill-guide/#step-5-create-the-config-file","text":"Based on our skill components above, we create the following config file. name : my_search author : fetchai version : 0.1.0 description : 'A simple search skill utilising the OEF search and communication node.' license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' fingerprint : {} fingerprint_ignore_patterns : [] contracts : [] protocols : - 'fetchai/oef_search:0.1.0' behaviours : my_search_behaviour : args : tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : {} dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml .","title":"Step 5: Create the config file"},{"location":"aea/skill-guide/#step-6-update-fingerprint","text":"We need to update the fingerprint of our skill next: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.)","title":"Step 6: Update fingerprint"},{"location":"aea/skill-guide/#step-7-add-the-oef-protocol-and-connection","text":"Our AEA does not have the oef protocol yet so let's add it. aea add protocol fetchai/oef_search:0.1.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the oef connection and install its dependencies: aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0","title":"Step 7: Add the oef protocol and connection"},{"location":"aea/skill-guide/#step-8-run-a-service-provider-aea","text":"We first start a local OEF search and communication node in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json In order to be able to find another AEA when searching, from a different terminal window, we fetch and run another finished AEA: aea fetch fetchai/simple_service_registration:0.4.0 && cd simple_service_registration aea run --connections fetchai/oef:0.3.0 This AEA will simply register a location service on the OEF search node so we can search for it. Click here to see full code We use a ticker behaviour to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating services on OEF service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF Service Directory. :return: None \"\"\" if self . _registered_service_description is not None : strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering services from OEF service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None We create a `model` type strategy class and place it in `strategy.py`. We use a generic data model to register the service. from typing import Any , Dict , Optional from aea.helpers.search.generic import GenericDataModel from aea.helpers.search.models import Description from aea.skills.base import Model DEFAULT_DATA_MODEL_NAME = \"location\" DEFAULT_DATA_MODEL = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, } # type: Optional[Dict[str, Any]] DEFAULT_SERVICE_DATA = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( self . _service_data , data_model = GenericDataModel ( self . _data_model_name , self . _data_model ), ) return desc The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.2.0 description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=0.3.0, <0.4.0' fingerprint : __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmT4nDbtEz5BDtSbw34fXzdZg4HfbYgV3dfMfsGe9R61n4 strategy.py : QmWwPzDvmeuVutPwxL5taU1tBGA6aiMDRwo6bTTtLxxHRn fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.1.0 behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : {} models : strategy : args : data_model : attribute_one : is_required : true name : country type : str attribute_two : is_required : true name : city type : str data_model_name : location service_data : city : Cambridge country : UK class_name : Strategy dependencies : {}","title":"Step 8: Run a service provider AEA"},{"location":"aea/skill-guide/#step-9-run-the-search-aea","text":"We can then launch our AEA. aea run --connections fetchai/oef:0.3.0 We can see that the AEA sends search requests to the OEF search node and receives search responses from the OEF search node . Since our AEA is only searching on the OEF search node - and not registered on the OEF search node - the search response returns a single agent (the service provider). We stop the AEA with CTRL + C .","title":"Step 9: Run the Search AEA"},{"location":"aea/skill-guide/#now-its-your-turn","text":"We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Now it's your turn"},{"location":"aea/skill/","text":"An AEA developer writes skills that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour , Task , and Handler classes as well as a configuration file skill.yaml . Independence of skills Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker . Context The skill has a SkillContext object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . self . context . outbox . put_message ( to = recipient , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . act(self) : is how the framework calls the Behaviour code. The framework supports different types of behaviours: - OneShotBehaviour : this behaviour is executed only once. - CyclicBehaviour : this behaviour is executed many times, as long as done() returns True .) - TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour . - SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. - FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. !! Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution. tasks.py Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass Models The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:0.1.0 Error skill All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.1.0 protocol which provides error codes for the above.","title":"Skill"},{"location":"aea/skill/#independence-of-skills","text":"Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker .","title":"Independence of skills"},{"location":"aea/skill/#context","text":"The skill has a SkillContext object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . self . context . outbox . put_message ( to = recipient , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"aea/skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"aea/skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"aea/skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . act(self) : is how the framework calls the Behaviour code. The framework supports different types of behaviours: - OneShotBehaviour : this behaviour is executed only once. - CyclicBehaviour : this behaviour is executed many times, as long as done() returns True .) - TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour . - SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. - FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. !! Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution.","title":"behaviours.py"},{"location":"aea/skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass","title":"tasks.py"},{"location":"aea/skill/#models","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model","title":"Models"},{"location":"aea/skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:0.1.0","title":"Skill config"},{"location":"aea/skill/#error-skill","text":"All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.1.0 protocol which provides error codes for the above.","title":"Error skill"},{"location":"aea/standalone-transaction/","text":"In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer First, import the python and application specific libraries and set the static variables. import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" Create the private keys # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) Create LedgerApis We need to create the LedgerApis object in order to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ( { FetchAICrypto . identifier : { \"network\" : \"testnet\" }}, FetchAICrypto . identifier ) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) Send transaction Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) tx_digest = ledger_api . transfer ( crypto = wallet_1 . crypto_objects . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Set up the LedgerApis ledger_apis = LedgerApis ( { FetchAICrypto . identifier : { \"network\" : \"testnet\" }}, FetchAICrypto . identifier ) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) tx_digest = ledger_api . transfer ( crypto = wallet_1 . crypto_objects . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) if __name__ == \"__main__\" : run ()","title":"Create stand-alone transaction"},{"location":"aea/standalone-transaction/#create-the-private-keys","text":"# Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"aea/standalone-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"aea/standalone-transaction/#create-ledgerapis","text":"We need to create the LedgerApis object in order to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ( { FetchAICrypto . identifier : { \"network\" : \"testnet\" }}, FetchAICrypto . identifier )","title":"Create LedgerApis"},{"location":"aea/standalone-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] )","title":"Generate wealth"},{"location":"aea/standalone-transaction/#send-transaction","text":"Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) tx_digest = ledger_api . transfer ( crypto = wallet_1 . crypto_objects . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Set up the LedgerApis ledger_apis = LedgerApis ( { FetchAICrypto . identifier : { \"network\" : \"testnet\" }}, FetchAICrypto . identifier ) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FetchAICrypto . identifier ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) tx_digest = ledger_api . transfer ( crypto = wallet_1 . crypto_objects . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) if __name__ == \"__main__\" : run ()","title":"Send transaction"},{"location":"aea/steps/","text":"There are a number of ways to build an AEA: To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here . Using the CLI aea fetch command, pull in an already built project and run as is or extend it to your needs. The last option is to build an AEA programmatically as described here . Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides: the AEA vs Agents guide shows the difference between an agent and an AEA in code, the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.","title":"Ways to build an AEA"},{"location":"aea/tac-skills-contract/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. This demo uses another AEA - a controller AEA - to take the role of running the competition. Transactions are validated on an ERC1155 smart contract on the Ropsten Ethereum testnet. Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo. Demo instructions: Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.1.0 cd tac_controller_contract aea install Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_control_contract:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Add the following configs to the aea config: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 20 Fund the controller AEA We first generate a private key. aea generate-key ethereum aea add-key ethereum eth_private_key.txt To create some wealth for your AEAs for the Ethereum ropsten network. Note that this needs to be executed from each AEA folder: aea generate-wealth ethereum To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum Note If no wealth appears after a while, then try funding the private key directly using a web faucet. Create the TAC participant AEAs In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_one cd tac_participant_one aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool cd .. aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_two cd tac_participant_two aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea install Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool Then, build participant two: cd tac_participant_two aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool Update the game parameters in the controller Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least five minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.start_time '01 01 2020 00:01' Run the AEAs The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch all the TAC agents as follows from the root directory: aea launch tac_controller_contract tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"Tac skills contract"},{"location":"aea/tac-skills-contract/#discussion","text":"The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. This demo uses another AEA - a controller AEA - to take the role of running the competition. Transactions are validated on an ERC1155 smart contract on the Ropsten Ethereum testnet.","title":"Discussion"},{"location":"aea/tac-skills-contract/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills-contract/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills-contract/#transaction-communication","text":"This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills-contract/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills-contract/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills-contract/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo.","title":"Launch an OEF search and communication node"},{"location":"aea/tac-skills-contract/#demo-instructions","text":"","title":"Demo instructions:"},{"location":"aea/tac-skills-contract/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.1.0 cd tac_controller_contract aea install Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_control_contract:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Add the following configs to the aea config: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 20","title":"Create TAC controller AEA"},{"location":"aea/tac-skills-contract/#fund-the-controller-aea","text":"We first generate a private key. aea generate-key ethereum aea add-key ethereum eth_private_key.txt To create some wealth for your AEAs for the Ethereum ropsten network. Note that this needs to be executed from each AEA folder: aea generate-wealth ethereum To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum Note If no wealth appears after a while, then try funding the private key directly using a web faucet.","title":"Fund the controller AEA"},{"location":"aea/tac-skills-contract/#create-the-tac-participant-aeas","text":"In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_one cd tac_participant_one aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool cd .. aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_two cd tac_participant_two aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea install Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool Then, build participant two: cd tac_participant_two aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool","title":"Create the TAC participant AEAs"},{"location":"aea/tac-skills-contract/#update-the-game-parameters-in-the-controller","text":"Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least five minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.start_time '01 01 2020 00:01'","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills-contract/#run-the-aeas","text":"The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch all the TAC agents as follows from the root directory: aea launch tac_controller_contract tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills-contract/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac-skills/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger. Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent. We also have an AEA in the role of the biyer, referred to as Buyer_Agent. During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo. Demo instructions: Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.1.0 cd tac_controller aea install Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_control:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Create the TAC participant AEAs In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_one aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_two cd tac_participant_two aea install Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Then, build participant two: cd tac_participant_two aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Update the game parameters in the controller Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.start_time '01 01 2020 00:01' Run the AEAs The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch all the TAC agents as follows from the root directory: aea launch tac_controller tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"TAC skills"},{"location":"aea/tac-skills/#discussion","text":"The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger.","title":"Discussion"},{"location":"aea/tac-skills/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills/#transaction-communication","text":"This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent. We also have an AEA in the role of the biyer, referred to as Buyer_Agent. During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the following demo.","title":"Launch an OEF search and communication node"},{"location":"aea/tac-skills/#demo-instructions","text":"","title":"Demo instructions:"},{"location":"aea/tac-skills/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.1.0 cd tac_controller aea install Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_control:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum","title":"Create TAC controller AEA"},{"location":"aea/tac-skills/#create-the-tac-participant-aeas","text":"In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_one aea fetch fetchai/tac_participant:0.1.0 --alias tac_participant_two cd tac_participant_two aea install Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum Then, build participant two: cd tac_participant_two aea add connection fetchai/oef:0.3.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea config set agent.default_ledger ethereum","title":"Create the TAC participant AEAs"},{"location":"aea/tac-skills/#update-the-game-parameters-in-the-controller","text":"Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.start_time '01 01 2020 00:01'","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills/#run-the-aeas","text":"The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch all the TAC agents as follows from the root directory: aea launch tac_controller tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac/","text":"The original TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"aea/tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"aea/tac/#quick-start","text":"Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"aea/tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"aea/tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"aea/tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"aea/thermometer-skills-step-by-step/","text":"This guide is a step-by-step introduction to building an AEA that represents static, and dynamic data to be advertised on the Open Economic Framework. If you simply want to run the resulting AEAs go here . Planning the AEA To follow this tutorial to completion you will need: - Raspberry Pi 4 Mini SD card Thermometer sensor AEA Framework The AEA will \u201clive\u201d inside the Raspberry Pi and will read the data from a sensor. Then it will connect to the OEF search and communication node and will identify itself as a seller of that data. Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Setup the environment You can follow this link here in order to setup your environment and prepare your raspberry. Once you setup your raspberry Open a terminal and navigate to /etc/udev/rules.d/ . Create a new file there (I named mine 99-hidraw-permissions.rules) sudo nano 99 -hidraw-permissions.rules and add the following inside the file: KERNEL == \"hidraw*\" , SUBSYSTEM == \"hidraw\" , MODE = \"0664\" , GROUP = \"plugdev\" this assigns all devices coming out of the hidraw subsystem in the kernel to the group plugdev and sets the permissions to r/w r/w r (for root [the default owner], plugdev, and everyone else respectively) Thermometer AEA Step 1: Create the AEA Create a new AEA by typing the following command in the terminal: aea create my_thermometer cd my_thermometer Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of the thermomemeter data. Type the following command: aea scaffold skill thermometer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: behaviours.py handlers.py my_model.py skills.yaml __init__.py Step 2: Create the behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_thermometer/skills/thermometer/behaviours.py ) and add the following code: from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) if balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on {} ledger!\" . format ( self . context . agent_name , strategy . ledger_id ) ) self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . logger . info ( \"[ {} ]: ending balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating thermometer services on OEF service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering thermometer station services from OEF service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None This Behaviour will register and de-register our AEA\u2019s service on the OEF search node at regular tick intervals (here 30 seconds). By registering, the AEA becomes discoverable to possible clients. The act method unregisters and registers the AEA to the OEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances. Currently, the AEA-framework supports two different blockchains [Ethereum, Fetchai], and that\u2019s the reason we are checking if we have balance for these two blockchains in the setup method. Step 3: Create the handler So far, we have tasked the AEA with sending register/unregister requests to the OEF search node . However, we have so far no way of handling the responses sent to the AEA by the OEF search node or messages sent from any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a client_AEA. sequenceDiagram participant Search participant Client_AEA participant Seller_AEA participant Blockchain activate Client_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Client_AEA: propose Client_AEA->>Seller_AEA: accept Seller_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In the context of our thermometer use-case, the my_thermometer AEA is the seller. Let us now implement a handler to deal with the incoming messages. Open the handlers.py file ( my_thermometer/skills/thermometer/handlers.py ) and add the following code: import time from typing import Optional , cast from aea.configurations.base import ProtocolId from aea.helpers.search.models import Description , Query from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.skills.thermometer.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) fipa_dialogue = cast ( Dialogue , dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling FipaMessages received by the my_thermometer AEA. We use Dialogues to keep track of the dialogue state between the my_thermometer and the client_aea . First, we check if the message is registered to an existing dialogue or if we have to create a new dialogue. The second part assigns messages to their handler based on the message's performative. We are going to implement each case in a different function. Below the teardown function, we continue by adding the following code: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. Respond to the sender with a default message containing the appropriate error information. :param msg: the message :return: None \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name ) ) default_msg = DefaultMessage ( dialogue_reference = ( \"\" , \"\" ), message_id = 1 , target = 0 , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : FipaSerializer () . encode ( msg )}, ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles the CFP message, paste the code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) query = cast ( Query , msg . query ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_matching_supply ( query ): proposal , temp_data = strategy . generate_proposal_and_data ( query , msg . counterparty ) dialogue . temp_data = temp_data dialogue . proposal = proposal self . context . logger . info ( \"[ {} ]: sending a PROPOSE with proposal= {} to sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) proposal_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = msg . counterparty dialogue . update ( proposal_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( proposal_msg ), ) else : self . context . logger . info ( \"[ {} ]: declined the CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) decline_msg . counterparty = msg . counterparty dialogue . update ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) The above code will respond with a Proposal to the client if the CFP matches the supplied services and our strategy otherwise it will respond with a Decline message. The next code-block handles the decline message we receive from the client. Add the following code below the _handle_cfp function: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_PROPOSE , dialogue . is_self_initiated ) If we receive a decline message from the client we close the dialogue and terminate this conversation with the client_aea . Alternatively, we might receive an Accept message. Inorder to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received ACCEPT from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) self . context . logger . info ( \"[ {} ]: sending MATCH_ACCEPT_W_INFORM to sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) proposal = cast ( Description , dialogue . proposal ) identifier = cast ( str , proposal . values . get ( \"ledger_id\" )) match_accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , info = { \"address\" : self . context . agent_addresses [ identifier ]}, ) match_accept_msg . counterparty = msg . counterparty dialogue . update ( match_accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( match_accept_msg ), ) When the client_aea accepts the Proposal we send it, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to inform the client about the address we would like it to send the funds to. Lastly, when we receive the Inform message it means that the client has sent the funds to the provided address. Add the following code: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the temperature data, otherwise do nothing. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx and ( \"transaction_digest\" in msg . info . keys ()): is_valid = False tx_digest = msg . info [ \"transaction_digest\" ] self . context . logger . info ( \"[ {} ]: checking whether transaction= {} has been received ...\" . format ( self . context . agent_name , tx_digest ) ) proposal = cast ( Description , dialogue . proposal ) ledger_id = cast ( str , proposal . values . get ( \"ledger_id\" )) not_settled = True time_elapsed = 0 # TODO: fix blocking code; move into behaviour! while not_settled and time_elapsed < 60 : is_valid = self . context . ledger_apis . is_tx_valid ( ledger_id , tx_digest , self . context . agent_addresses [ ledger_id ], msg . counterparty , cast ( str , proposal . values . get ( \"tx_nonce\" )), cast ( int , proposal . values . get ( \"price\" )), ) not_settled = not is_valid if not_settled : time . sleep ( 2 ) time_elapsed += 2 # TODO: check the tx_digest references a transaction with the correct terms if is_valid : token_balance = self . context . ledger_apis . token_balance ( ledger_id , cast ( str , self . context . agent_addresses . get ( ledger_id )) ) self . context . logger . info ( \"[ {} ]: transaction= {} settled, new balance= {} . Sending data to sender= {} \" . format ( self . context . agent_name , tx_digest , token_balance , msg . counterparty [ - 5 :], ) ) inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: transaction= {} not settled, aborting\" . format ( self . context . agent_name , tx_digest ) ) elif \"Done\" in msg . info . keys (): inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . warning ( \"[ {} ]: did not receive transaction digest from sender= {} .\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the client accepted. If the transaction is valid and we received the funds then we send the data to the client. Otherwise we do not send the data. Step 4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from random import randrange from typing import Any , Dict , Tuple from temper import Temper from aea.helpers.search.models import Description , Query from aea.mail.base import Address from aea.skills.base import Model from packages.fetchai.skills.thermometer.thermometer_data_model import ( SCHEME , Thermometer_Datamodel , ) DEFAULT_PRICE_PER_ROW = 1 DEFAULT_SELLER_TX_FEE = 0 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True DEFAULT_HAS_SENSOR = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _price_per_row = kwargs . pop ( \"price_per_row\" , DEFAULT_PRICE_PER_ROW ) self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _has_sensor = kwargs . pop ( \"has_sensor\" , DEFAULT_HAS_SENSOR ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 We initialise the strategy class. We are trying to read the strategy variables from the yaml file. If this is not possible we specified some default values. The following functions are related with the OEF search node registration and we assume that the query matches the supply. Add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( SCHEME , data_model = Thermometer_Datamodel ()) return desc def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indiciating whether matches or not \"\"\" # TODO, this is a stub return True def generate_proposal_and_data ( self , query : Query , counterparty : Address ) -> Tuple [ Description , Dict [ str , Any ]]: \"\"\" Generate a proposal matching the query. :param counterparty: the counterparty of the proposal. :param query: the query :return: a tuple of proposal and the temprature data \"\"\" if self . is_ledger_tx : tx_nonce = self . context . ledger_apis . generate_tx_nonce ( identifier = self . _ledger_id , seller = self . context . agent_addresses [ self . _ledger_id ], client = counterparty , ) else : tx_nonce = uuid . uuid4 () . hex temp_data = self . _build_data_payload () total_price = self . _price_per_row assert ( total_price - self . _seller_tx_fee > 0 ), \"This sale would generate a loss, change the configs!\" proposal = Description ( { \"price\" : total_price , \"seller_tx_fee\" : self . _seller_tx_fee , \"currency_id\" : self . _currency_id , \"ledger_id\" : self . _ledger_id , \"tx_nonce\" : tx_nonce , } ) return proposal , temp_data def _build_data_payload ( self ) -> Dict [ str , Any ]: \"\"\" Build the data payload. :return: a tuple of the data and the rows \"\"\" if self . _has_sensor : temper = Temper () while True : results = temper . read () if \"internal temperature\" in results [ 0 ] . keys (): degrees = { \"thermometer_data\" : str ( results )} else : self . context . logger . debug ( \"Couldn't read the sensor I am re-trying.\" ) else : degrees = { \"thermometer_data\" : str ( randrange ( 10 , 25 ))} # nosec self . context . logger . info ( degrees ) return degrees Before the creation of the actual proposal, we have to check if this sale generates value for us or a loss. If it is a loss, we abort and warn the developer. The helper private function _build_data_payload , is where we read data from our sensor or in case we don\u2019t have a sensor generate a random number. Step 5: Create the dialogues When we are negotiating with other AEA we would like to keep track on these negotiations for various reasons. So create a new file and name it dialogues.py. Inside this file add the following code: from typing import Dict , Optional from aea.helpers.dialogue.base import Dialogue as BaseDialogue from aea.helpers.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.helpers.search.models import Description from aea.mail.base import Address from aea.protocols.base import Message from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , agent_address : Address , role : BaseDialogue . Role , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param agent_address: the address of the agent for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , agent_address = agent_address , role = role ) self . temp_data = None # type: Optional[Dict[str, str]] self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self , self . context . agent_address ) @staticmethod def role_from_first_message ( message : Message ) -> BaseDialogue . Role : \"\"\" Infer the role of the agent from an incoming or outgoing first message :param message: an incoming/outgoing first message :return: the agent's role \"\"\" return FipaDialogue . AgentRole . SELLER def create_dialogue ( self , dialogue_label : BaseDialogueLabel , role : BaseDialogue . Role , ) -> Dialogue : \"\"\" Create an instance of dialogue. :param dialogue_label: the identifier of the dialogue :param role: the role of the agent this dialogue is maintained for :return: the created dialogue \"\"\" dialogue = Dialogue ( dialogue_label = dialogue_label , agent_address = self . agent_address , role = role ) return dialogue The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the my_thermometer AEA and the my_client AEA. It also keeps track of the data that we offer for sale during the proposal phase. Step 6: Create the data_model Each AEA in the oef needs a Description in order to be able to register as a service. The data model will help us create this description. Create a new file and call it thermometer_data_model.py and paste the following code: from aea.helpers.search.models import Attribute , DataModel SCHEME = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Thermometer_Datamodel ( DataModel ): \"\"\"Data model for the thermo Agent.\"\"\" def __init__ ( self ): \"\"\"Initialise the dataModel.\"\"\" self . attribute_country = Attribute ( \"country\" , str , True ) self . attribute_city = Attribute ( \"city\" , str , True ) super () . __init__ ( \"thermometer_datamodel\" , [ self . attribute_country , self . attribute_city ] ) This data model registers to the OEF search node as an AEA that is in the UK and specifically in Cambridge. If a client_AEA searches for AEA in the UK the OEF search node will respond with the address of our AEA. Step 7: Update the YAML files Since we made so many changes to our AEA we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml . Make sure that your skill.yaml matches with the following code name : thermometer author : fetchai version : 0.2.0 license : Apache-2.0 fingerprint : {} aea_version : '>=0.3.0, <0.4.0' description : \"The thermometer skill implements the functionality to sell data.\" behaviours : service_registration : class_name : ServiceRegistrationBehaviour args : services_interval : 60 handlers : fipa : class_name : FIPAHandler args : {} models : strategy : class_name : Strategy args : price_per_row : 1 seller_tx_fee : 0 currency_id : 'FET' ledger_id : 'fetchai' has_sensor : True is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.2.0' , 'fetchai/oef_search:0.1.0' , 'fetchai/default:0.1.0' ] ledgers : [ 'fetchai' ] dependencies : pyserial : {} temper-py : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to sell each reading for or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill thermometer This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Client_AEA Step 1: Create the AEA Create a new AEA by typing the following command in the terminal: aea create my_client cd my_client Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the purchase of the thermometer data. Type the following command: aea scaffold skill thermometer_client This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: behaviours.py handlers.py my_model.py skills.yaml __init__.py Step 2: Create the behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_client/skills/thermometer_client/behaviours.py ) and add the following code: from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer_client.strategy import Strategy DEFAULT_SEARCH_INTERVAL = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) if balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on {} ledger!\" . format ( self . context . agent_name , strategy . ledger_id ) ) self . context . is_active = False def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_service_query () search_id = strategy . get_next_search_id () oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( search_id ), \"\" ), query = query , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( oef_msg ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . logger . info ( \"[ {} ]: ending balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) This Behaviour will search on the OEF search node with a specific query at regular tick intervals. Step 3: Create the handler So far, we have tasked the AEA with sending search queries to the OEF search node . However, we have so far no way of handling the responses sent to the AEA by the OEF search node or messages sent by other agent. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow: import pprint from typing import Any , Dict , Optional , Tuple , cast from aea.configurations.base import ProtocolId from aea.decision_maker.messages.transaction import TransactionMessage from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.thermometer_client.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer_client.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) fipa_dialogue = cast ( Dialogue , dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic when we develop the client\u2019s side of the negotiation. The first thing is that we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name ) ) default_msg = DefaultMessage ( dialogue_reference = ( \"\" , \"\" ), message_id = 1 , target = 0 , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : FipaSerializer () . encode ( msg )}, ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the proposal that we receive from the my_thermometer AEA: def _handle_propose ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the propose. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id proposal = msg . proposal self . context . logger . info ( \"[ {} ]: received proposal= {} from sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( proposal ) affordable = strategy . is_affordable_proposal ( proposal ) if acceptable and affordable : strategy . is_searching = False self . context . logger . info ( \"[ {} ]: accepting the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogue . proposal = proposal accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . ACCEPT , ) accept_msg . counterparty = msg . counterparty dialogue . update ( accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( accept_msg ), ) else : self . context . logger . info ( \"[ {} ]: declining the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) decline_msg . counterparty = msg . counterparty dialogue . update ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a decline message. Otherwise, we send an accept message to the seller. The next code-block handles the decline message that we may receive from the client on our CFP message or our ACCEPT message: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the decline. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) target = msg . get ( \"target\" ) dialogues = cast ( Dialogues , self . context . dialogues ) if target == 1 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_CFP , dialogue . is_self_initiated ) elif target == 3 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_ACCEPT , dialogue . is_self_initiated ) The above code terminates each dialogue with the specific aea and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case you didn\u2019t receive any decline message that means that the my_thermometer AEA want to move on with the sale, in that case, it will send a match_accept message in order to handle this add the following code : def _handle_match_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match accept. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx : self . context . logger . info ( \"[ {} ]: received MATCH_ACCEPT_W_INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) info = msg . info address = cast ( str , info . get ( \"address\" )) proposal = cast ( Description , dialogue . proposal ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ self . context . skill_id ], tx_id = \"transaction0\" , tx_sender_addr = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ] ], tx_counterparty_addr = address , tx_amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, tx_sender_fee = strategy . max_buyer_tx_fee , tx_counterparty_fee = proposal . values [ \"seller_tx_fee\" ], tx_quantities_by_good_id = {}, ledger_id = proposal . values [ \"ledger_id\" ], info = { \"dialogue_label\" : dialogue . dialogue_label . json }, tx_nonce = proposal . values [ \"tx_nonce\" ], ) self . context . decision_maker_message_queue . put_nowait ( tx_msg ) self . context . logger . info ( \"[ {} ]: proposing the transaction to the decision maker. Waiting for confirmation ...\" . format ( self . context . agent_name ) ) else : new_message_id = msg . message_id + 1 new_target = msg . message_id inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of payment.\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The first thing we are checking is if we enabled our aea to transact with a ledger. If we can transact with a ledger we generate a transaction message and we propose it to the decision_maker . The decision_maker then will check the transaction message if it is acceptable, we have the funds, etc, it signs and sends the transaction to the specified ledger. Then it returns us the transaction digest. Lastly, we need to handle the inform message because this is the message that will have our data: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match inform. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) if \"thermometer_data\" in msg . info . keys (): thermometer_data = msg . info [ \"thermometer_data\" ] self . context . logger . info ( \"[ {} ]: received the following thermometer data= {} \" . format ( self . context . agent_name , pprint . pformat ( thermometer_data ) ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: received no data from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The main difference between this handler and the thermometer skill handler is that in this one we create more than one handler. The reason is that we receive messages not only from the my_thermometer AEA but also from the decision_maker and the OEF search node . So we need a handler to be able to read different kinds of messages. To handle the OEF search node response on our search request adds the following code in the same file: class OEFSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations oef_msg = cast ( OefSearchMessage , message ) if oef_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : agents = oef_msg . agents self . _handle_search ( agents ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_search ( self , agents : Tuple [ str , ... ]) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( agents ) > 0 : self . context . logger . info ( \"[ {} ]: found agents= {} , stopping search.\" . format ( self . context . agent_name , list ( map ( lambda x : x [ - 5 :], agents )) ) ) strategy = cast ( Strategy , self . context . strategy ) # stopping search strategy . is_searching = False # pick first agent found opponent_addr = agents [ 0 ] dialogues = cast ( Dialogues , self . context . dialogues ) query = strategy . get_service_query () self . context . logger . info ( \"[ {} ]: sending CFP to agent= {} \" . format ( self . context . agent_name , opponent_addr [ - 5 :] ) ) cfp_msg = FipaMessage ( message_id = Dialogue . STARTING_MESSAGE_ID , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), performative = FipaMessage . Performative . CFP , target = Dialogue . STARTING_TARGET , query = query , ) cfp_msg . counterparty = opponent_addr dialogues . update ( cfp_msg ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) else : self . context . logger . info ( \"[ {} ]: found no agents, continue searching.\" . format ( self . context . agent_name ) ) When we receive a message from the oef of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the handle function. The latest calls the _handle_search function and passes as input to the agent list. There we are checking that the list contains some agents and we stop the search. We pick our first agent and we send a CFP message. The last handler we will need is the MyTransactionHandler . This one will handle the internal messages that we receive from the decision_maker . class MyTransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): self . context . logger . info ( \"[ {} ]: transaction was successful.\" . format ( self . context . agent_name ) ) json_data = { \"transaction_digest\" : tx_msg_response . tx_digest } info = cast ( Dict [ str , Any ], tx_msg_response . info ) dialogue_label = DialogueLabel . from_json ( cast ( Dict [ str , str ], info . get ( \"dialogue_label\" )) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . dialogues [ dialogue_label ] fipa_msg = cast ( FipaMessage , dialogue . last_incoming_message ) new_message_id = fipa_msg . message_id + 1 new_target_id = fipa_msg . message_id counterparty_addr = dialogue . dialogue_label . dialogue_opponent_addr inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . INFORM , info = json_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = counterparty_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of transaction digest.\" . format ( self . context . agent_name , counterparty_addr [ - 5 :] ) ) else : self . context . logger . info ( \"[ {} ]: transaction was not successful.\" . format ( self . context . agent_name ) ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass Remember that we send a message to the decision_maker with a transaction proposal? Here we handle the response from the decision_maker . If the message is of type SUCCESFUL_SETTLEMENT, we generate the inform_msg for the seller_aea to inform him that we completed the transaction and transferred the funds to the address that he sent us and we pass the transaction digest so the other aea can verify the transaction. Otherwise, the decision_maker will inform us that something went wrong and the transaction was not successful. Step 4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.skills.base import Model DEFAULT_COUNTRY = \"UK\" SEARCH_TERM = \"country\" DEFAULT_MAX_ROW_PRICE = 5 DEFAULT_MAX_TX_FEE = 20000000 DEFAULT_CURRENCY_PBK = \"ETH\" DEFAULT_LEDGER_ID = \"ethereum\" DEFAULT_IS_LEDGER_TX = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _country = kwargs . pop ( \"country\" , DEFAULT_COUNTRY ) self . _max_row_price = kwargs . pop ( \"max_row_price\" , DEFAULT_MAX_ROW_PRICE ) self . max_buyer_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) super () . __init__ ( ** kwargs ) self . _search_id = 0 self . is_searching = True We initialize the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two functions are related to the oef search service, add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id def get_next_search_id ( self ) -> int : \"\"\" Get the next search id and set the search time. :return: the next search id \"\"\" self . _search_id += 1 return self . _search_id def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" query = Query ( [ Constraint ( SEARCH_TERM , ConstraintType ( \"==\" , self . _country ))], model = None ) return query The following code block checks if the proposal that we received is acceptable based on the strategy def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( ( proposal . values [ \"price\" ] - proposal . values [ \"seller_tx_fee\" ] > 0 ) and ( proposal . values [ \"price\" ] <= self . _max_row_price ) and ( proposal . values [ \"currency_id\" ] == self . _currency_id ) and ( proposal . values [ \"ledger_id\" ] == self . _ledger_id ) ) return result The is_affordable_proposal checks if we can afford the transaction based on the funds we have in our wallet on the ledger. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values [ \"price\" ] + self . max_buyer_tx_fee ledger_id = proposal . values [ \"ledger_id\" ] address = cast ( str , self . context . agent_addresses . get ( ledger_id )) balance = self . context . ledger_apis . token_balance ( ledger_id , address ) result = balance >= payable else : result = True return result Step 5: Create the dialogues When we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py . Inside this file add the following code: from typing import Optional from aea.helpers.dialogue.base import Dialogue as BaseDialogue from aea.helpers.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.helpers.search.models import Description from aea.mail.base import Address from aea.protocols.base import Message from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , agent_address : Address , role : BaseDialogue . Role , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param agent_address: the address of the agent for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , agent_address = agent_address , role = role ) self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self , self . context . agent_address ) @staticmethod def role_from_first_message ( message : Message ) -> BaseDialogue . Role : \"\"\" Infer the role of the agent from an incoming or outgoing first message :param message: an incoming/outgoing first message :return: the agent's role \"\"\" return FipaDialogue . AgentRole . BUYER def _create_dialogue ( self , dialogue_label : BaseDialogueLabel , role : BaseDialogue . Role , ) -> Dialogue : \"\"\" Create an instance of fipa dialogue. :param dialogue_label: the identifier of the dialogue :param role: the role of the agent this dialogue is maintained for :return: the created dialogue \"\"\" dialogue = Dialogue ( dialogue_label = dialogue_label , agent_address = self . agent_address , role = role ) return dialogue The dialogues class stores dialogue with each my_thermometer AEA in a list so we can have access to previous messages and enable us to identify possible communications problems between the my_thermometer AEA and the my_client AEA. Step 6: Update the YAML files Since we made so many changes to our aea we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml . Make sure that your skill.yaml matches with the following code: name : thermometer_client author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : {} aea_version : '>=0.3.0, <0.4.0' description : \"The thermometer client skill implements the skill to purchase temperature data.\" behaviours : search : class_name : MySearchBehaviour args : search_interval : 5 handlers : fipa : class_name : FIPAHandler args : {} oef : class_name : OEFHandler args : {} transaction : class_name : MyTransactionHandler args : {} models : strategy : class_name : Strategy args : country : UK max_row_price : 4 max_tx_fee : 2000000 currency_id : 'FET' ledger_id : 'fetchai' is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.2.0' , 'fetchai/default:0.1.0' , 'fetchai/oef_search:0.1.0' ] ledgers : [ 'fetchai' ] We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading or the currency we would like to transact with. Finally, we fingerprint our new skill: aea fingerprint skill thermometer This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Run the AEAs Note Make sure that your thermometer sensor is connected to the Raspberry's usb port. You can change the end-point's address and port by modifying the connection's yaml file ( */connection/oef/connection.yaml ) Under config locate: addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Fetch.ai ledger payment Create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt Update the AEA configs Both in my_thermometer/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis : {} with the following. ledger_apis : fetchai : network : testnet Fund the temperature client AEA Create some wealth for your weather client on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai Run both AEAs from their respective terminals aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Ethereum ledger payment A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet. This demo assumes the temperature client trusts our AEA to send the temperature data upon successful payment. Create the private key for the my_client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_thermometer/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis: {} with the following. ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Update the skill configs In the thermometer skill config ( my_thermometer/skills/thermometer/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True In the temprature_client skill config ( my_client/skills/temprature_client/skill.yaml ) under strategy change the currency_id and ledger_id . max_buyer_tx_fee : 20000 currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True Fund the thermometer client AEA Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_client/eth_private_key.txt . Run both AEAs from their respective terminals. aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Ethereum testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer aea delete my_client","title":"Thermometer skills step by step"},{"location":"aea/thermometer-skills-step-by-step/#planning-the-aea","text":"To follow this tutorial to completion you will need: - Raspberry Pi 4 Mini SD card Thermometer sensor AEA Framework The AEA will \u201clive\u201d inside the Raspberry Pi and will read the data from a sensor. Then it will connect to the OEF search and communication node and will identify itself as a seller of that data.","title":"Planning the AEA"},{"location":"aea/thermometer-skills-step-by-step/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/thermometer-skills-step-by-step/#setup-the-environment","text":"You can follow this link here in order to setup your environment and prepare your raspberry. Once you setup your raspberry Open a terminal and navigate to /etc/udev/rules.d/ . Create a new file there (I named mine 99-hidraw-permissions.rules) sudo nano 99 -hidraw-permissions.rules and add the following inside the file: KERNEL == \"hidraw*\" , SUBSYSTEM == \"hidraw\" , MODE = \"0664\" , GROUP = \"plugdev\" this assigns all devices coming out of the hidraw subsystem in the kernel to the group plugdev and sets the permissions to r/w r/w r (for root [the default owner], plugdev, and everyone else respectively)","title":"Setup the environment"},{"location":"aea/thermometer-skills-step-by-step/#thermometer-aea","text":"","title":"Thermometer AEA"},{"location":"aea/thermometer-skills-step-by-step/#step-1-create-the-aea","text":"Create a new AEA by typing the following command in the terminal: aea create my_thermometer cd my_thermometer Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of the thermomemeter data. Type the following command: aea scaffold skill thermometer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: behaviours.py handlers.py my_model.py skills.yaml __init__.py","title":"Step 1: Create the AEA"},{"location":"aea/thermometer-skills-step-by-step/#step-2-create-the-behaviour","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_thermometer/skills/thermometer/behaviours.py ) and add the following code: from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) if balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on {} ledger!\" . format ( self . context . agent_name , strategy . ledger_id ) ) self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . logger . info ( \"[ {} ]: ending balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating thermometer services on OEF service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF Service Directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering thermometer station services from OEF service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None This Behaviour will register and de-register our AEA\u2019s service on the OEF search node at regular tick intervals (here 30 seconds). By registering, the AEA becomes discoverable to possible clients. The act method unregisters and registers the AEA to the OEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances. Currently, the AEA-framework supports two different blockchains [Ethereum, Fetchai], and that\u2019s the reason we are checking if we have balance for these two blockchains in the setup method.","title":"Step 2: Create the behaviour"},{"location":"aea/thermometer-skills-step-by-step/#step-3-create-the-handler","text":"So far, we have tasked the AEA with sending register/unregister requests to the OEF search node . However, we have so far no way of handling the responses sent to the AEA by the OEF search node or messages sent from any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a client_AEA. sequenceDiagram participant Search participant Client_AEA participant Seller_AEA participant Blockchain activate Client_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Client_AEA: propose Client_AEA->>Seller_AEA: accept Seller_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In the context of our thermometer use-case, the my_thermometer AEA is the seller. Let us now implement a handler to deal with the incoming messages. Open the handlers.py file ( my_thermometer/skills/thermometer/handlers.py ) and add the following code: import time from typing import Optional , cast from aea.configurations.base import ProtocolId from aea.helpers.search.models import Description , Query from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.skills.thermometer.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) fipa_dialogue = cast ( Dialogue , dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling FipaMessages received by the my_thermometer AEA. We use Dialogues to keep track of the dialogue state between the my_thermometer and the client_aea . First, we check if the message is registered to an existing dialogue or if we have to create a new dialogue. The second part assigns messages to their handler based on the message's performative. We are going to implement each case in a different function. Below the teardown function, we continue by adding the following code: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. Respond to the sender with a default message containing the appropriate error information. :param msg: the message :return: None \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name ) ) default_msg = DefaultMessage ( dialogue_reference = ( \"\" , \"\" ), message_id = 1 , target = 0 , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : FipaSerializer () . encode ( msg )}, ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles the CFP message, paste the code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) query = cast ( Query , msg . query ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_matching_supply ( query ): proposal , temp_data = strategy . generate_proposal_and_data ( query , msg . counterparty ) dialogue . temp_data = temp_data dialogue . proposal = proposal self . context . logger . info ( \"[ {} ]: sending a PROPOSE with proposal= {} to sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) proposal_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = msg . counterparty dialogue . update ( proposal_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( proposal_msg ), ) else : self . context . logger . info ( \"[ {} ]: declined the CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) decline_msg . counterparty = msg . counterparty dialogue . update ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) The above code will respond with a Proposal to the client if the CFP matches the supplied services and our strategy otherwise it will respond with a Decline message. The next code-block handles the decline message we receive from the client. Add the following code below the _handle_cfp function: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_PROPOSE , dialogue . is_self_initiated ) If we receive a decline message from the client we close the dialogue and terminate this conversation with the client_aea . Alternatively, we might receive an Accept message. Inorder to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received ACCEPT from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) self . context . logger . info ( \"[ {} ]: sending MATCH_ACCEPT_W_INFORM to sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) proposal = cast ( Description , dialogue . proposal ) identifier = cast ( str , proposal . values . get ( \"ledger_id\" )) match_accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , info = { \"address\" : self . context . agent_addresses [ identifier ]}, ) match_accept_msg . counterparty = msg . counterparty dialogue . update ( match_accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( match_accept_msg ), ) When the client_aea accepts the Proposal we send it, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to inform the client about the address we would like it to send the funds to. Lastly, when we receive the Inform message it means that the client has sent the funds to the provided address. Add the following code: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the temperature data, otherwise do nothing. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx and ( \"transaction_digest\" in msg . info . keys ()): is_valid = False tx_digest = msg . info [ \"transaction_digest\" ] self . context . logger . info ( \"[ {} ]: checking whether transaction= {} has been received ...\" . format ( self . context . agent_name , tx_digest ) ) proposal = cast ( Description , dialogue . proposal ) ledger_id = cast ( str , proposal . values . get ( \"ledger_id\" )) not_settled = True time_elapsed = 0 # TODO: fix blocking code; move into behaviour! while not_settled and time_elapsed < 60 : is_valid = self . context . ledger_apis . is_tx_valid ( ledger_id , tx_digest , self . context . agent_addresses [ ledger_id ], msg . counterparty , cast ( str , proposal . values . get ( \"tx_nonce\" )), cast ( int , proposal . values . get ( \"price\" )), ) not_settled = not is_valid if not_settled : time . sleep ( 2 ) time_elapsed += 2 # TODO: check the tx_digest references a transaction with the correct terms if is_valid : token_balance = self . context . ledger_apis . token_balance ( ledger_id , cast ( str , self . context . agent_addresses . get ( ledger_id )) ) self . context . logger . info ( \"[ {} ]: transaction= {} settled, new balance= {} . Sending data to sender= {} \" . format ( self . context . agent_name , tx_digest , token_balance , msg . counterparty [ - 5 :], ) ) inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: transaction= {} not settled, aborting\" . format ( self . context . agent_name , tx_digest ) ) elif \"Done\" in msg . info . keys (): inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . warning ( \"[ {} ]: did not receive transaction digest from sender= {} .\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the client accepted. If the transaction is valid and we received the funds then we send the data to the client. Otherwise we do not send the data.","title":"Step 3: Create the handler"},{"location":"aea/thermometer-skills-step-by-step/#step-4-create-the-strategy","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from random import randrange from typing import Any , Dict , Tuple from temper import Temper from aea.helpers.search.models import Description , Query from aea.mail.base import Address from aea.skills.base import Model from packages.fetchai.skills.thermometer.thermometer_data_model import ( SCHEME , Thermometer_Datamodel , ) DEFAULT_PRICE_PER_ROW = 1 DEFAULT_SELLER_TX_FEE = 0 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True DEFAULT_HAS_SENSOR = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _price_per_row = kwargs . pop ( \"price_per_row\" , DEFAULT_PRICE_PER_ROW ) self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _has_sensor = kwargs . pop ( \"has_sensor\" , DEFAULT_HAS_SENSOR ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 We initialise the strategy class. We are trying to read the strategy variables from the yaml file. If this is not possible we specified some default values. The following functions are related with the OEF search node registration and we assume that the query matches the supply. Add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( SCHEME , data_model = Thermometer_Datamodel ()) return desc def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indiciating whether matches or not \"\"\" # TODO, this is a stub return True def generate_proposal_and_data ( self , query : Query , counterparty : Address ) -> Tuple [ Description , Dict [ str , Any ]]: \"\"\" Generate a proposal matching the query. :param counterparty: the counterparty of the proposal. :param query: the query :return: a tuple of proposal and the temprature data \"\"\" if self . is_ledger_tx : tx_nonce = self . context . ledger_apis . generate_tx_nonce ( identifier = self . _ledger_id , seller = self . context . agent_addresses [ self . _ledger_id ], client = counterparty , ) else : tx_nonce = uuid . uuid4 () . hex temp_data = self . _build_data_payload () total_price = self . _price_per_row assert ( total_price - self . _seller_tx_fee > 0 ), \"This sale would generate a loss, change the configs!\" proposal = Description ( { \"price\" : total_price , \"seller_tx_fee\" : self . _seller_tx_fee , \"currency_id\" : self . _currency_id , \"ledger_id\" : self . _ledger_id , \"tx_nonce\" : tx_nonce , } ) return proposal , temp_data def _build_data_payload ( self ) -> Dict [ str , Any ]: \"\"\" Build the data payload. :return: a tuple of the data and the rows \"\"\" if self . _has_sensor : temper = Temper () while True : results = temper . read () if \"internal temperature\" in results [ 0 ] . keys (): degrees = { \"thermometer_data\" : str ( results )} else : self . context . logger . debug ( \"Couldn't read the sensor I am re-trying.\" ) else : degrees = { \"thermometer_data\" : str ( randrange ( 10 , 25 ))} # nosec self . context . logger . info ( degrees ) return degrees Before the creation of the actual proposal, we have to check if this sale generates value for us or a loss. If it is a loss, we abort and warn the developer. The helper private function _build_data_payload , is where we read data from our sensor or in case we don\u2019t have a sensor generate a random number.","title":"Step 4: Create the strategy"},{"location":"aea/thermometer-skills-step-by-step/#step-5-create-the-dialogues","text":"When we are negotiating with other AEA we would like to keep track on these negotiations for various reasons. So create a new file and name it dialogues.py. Inside this file add the following code: from typing import Dict , Optional from aea.helpers.dialogue.base import Dialogue as BaseDialogue from aea.helpers.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.helpers.search.models import Description from aea.mail.base import Address from aea.protocols.base import Message from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , agent_address : Address , role : BaseDialogue . Role , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param agent_address: the address of the agent for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , agent_address = agent_address , role = role ) self . temp_data = None # type: Optional[Dict[str, str]] self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self , self . context . agent_address ) @staticmethod def role_from_first_message ( message : Message ) -> BaseDialogue . Role : \"\"\" Infer the role of the agent from an incoming or outgoing first message :param message: an incoming/outgoing first message :return: the agent's role \"\"\" return FipaDialogue . AgentRole . SELLER def create_dialogue ( self , dialogue_label : BaseDialogueLabel , role : BaseDialogue . Role , ) -> Dialogue : \"\"\" Create an instance of dialogue. :param dialogue_label: the identifier of the dialogue :param role: the role of the agent this dialogue is maintained for :return: the created dialogue \"\"\" dialogue = Dialogue ( dialogue_label = dialogue_label , agent_address = self . agent_address , role = role ) return dialogue The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the my_thermometer AEA and the my_client AEA. It also keeps track of the data that we offer for sale during the proposal phase.","title":"Step 5: Create the dialogues"},{"location":"aea/thermometer-skills-step-by-step/#step-6-create-the-data_model","text":"Each AEA in the oef needs a Description in order to be able to register as a service. The data model will help us create this description. Create a new file and call it thermometer_data_model.py and paste the following code: from aea.helpers.search.models import Attribute , DataModel SCHEME = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Thermometer_Datamodel ( DataModel ): \"\"\"Data model for the thermo Agent.\"\"\" def __init__ ( self ): \"\"\"Initialise the dataModel.\"\"\" self . attribute_country = Attribute ( \"country\" , str , True ) self . attribute_city = Attribute ( \"city\" , str , True ) super () . __init__ ( \"thermometer_datamodel\" , [ self . attribute_country , self . attribute_city ] ) This data model registers to the OEF search node as an AEA that is in the UK and specifically in Cambridge. If a client_AEA searches for AEA in the UK the OEF search node will respond with the address of our AEA.","title":"Step 6: Create the data_model"},{"location":"aea/thermometer-skills-step-by-step/#step-7-update-the-yaml-files","text":"Since we made so many changes to our AEA we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml . Make sure that your skill.yaml matches with the following code name : thermometer author : fetchai version : 0.2.0 license : Apache-2.0 fingerprint : {} aea_version : '>=0.3.0, <0.4.0' description : \"The thermometer skill implements the functionality to sell data.\" behaviours : service_registration : class_name : ServiceRegistrationBehaviour args : services_interval : 60 handlers : fipa : class_name : FIPAHandler args : {} models : strategy : class_name : Strategy args : price_per_row : 1 seller_tx_fee : 0 currency_id : 'FET' ledger_id : 'fetchai' has_sensor : True is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.2.0' , 'fetchai/oef_search:0.1.0' , 'fetchai/default:0.1.0' ] ledgers : [ 'fetchai' ] dependencies : pyserial : {} temper-py : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to sell each reading for or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill thermometer This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 7: Update the YAML files"},{"location":"aea/thermometer-skills-step-by-step/#client_aea","text":"","title":"Client_AEA"},{"location":"aea/thermometer-skills-step-by-step/#step-1-create-the-aea_1","text":"Create a new AEA by typing the following command in the terminal: aea create my_client cd my_client Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the purchase of the thermometer data. Type the following command: aea scaffold skill thermometer_client This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: behaviours.py handlers.py my_model.py skills.yaml __init__.py","title":"Step 1: Create the AEA"},{"location":"aea/thermometer-skills-step-by-step/#step-2-create-the-behaviour_1","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_client/skills/thermometer_client/behaviours.py ) and add the following code: from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer_client.strategy import Strategy DEFAULT_SEARCH_INTERVAL = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) if balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on {} ledger!\" . format ( self . context . agent_name , strategy . ledger_id ) ) self . context . is_active = False def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_service_query () search_id = strategy . get_next_search_id () oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( search_id ), \"\" ), query = query , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( oef_msg ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if self . context . ledger_apis . has_ledger ( strategy . ledger_id ): balance = self . context . ledger_apis . token_balance ( strategy . ledger_id , cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . logger . info ( \"[ {} ]: ending balance on {} ledger= {} .\" . format ( self . context . agent_name , strategy . ledger_id , balance ) ) This Behaviour will search on the OEF search node with a specific query at regular tick intervals.","title":"Step 2: Create the behaviour"},{"location":"aea/thermometer-skills-step-by-step/#step-3-create-the-handler_1","text":"So far, we have tasked the AEA with sending search queries to the OEF search node . However, we have so far no way of handling the responses sent to the AEA by the OEF search node or messages sent by other agent. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow: import pprint from typing import Any , Dict , Optional , Tuple , cast from aea.configurations.base import ProtocolId from aea.decision_maker.messages.transaction import TransactionMessage from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.thermometer_client.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer_client.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) fipa_dialogue = cast ( Dialogue , dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic when we develop the client\u2019s side of the negotiation. The first thing is that we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name ) ) default_msg = DefaultMessage ( dialogue_reference = ( \"\" , \"\" ), message_id = 1 , target = 0 , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : FipaSerializer () . encode ( msg )}, ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the proposal that we receive from the my_thermometer AEA: def _handle_propose ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the propose. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id proposal = msg . proposal self . context . logger . info ( \"[ {} ]: received proposal= {} from sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( proposal ) affordable = strategy . is_affordable_proposal ( proposal ) if acceptable and affordable : strategy . is_searching = False self . context . logger . info ( \"[ {} ]: accepting the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogue . proposal = proposal accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . ACCEPT , ) accept_msg . counterparty = msg . counterparty dialogue . update ( accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( accept_msg ), ) else : self . context . logger . info ( \"[ {} ]: declining the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) decline_msg . counterparty = msg . counterparty dialogue . update ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a decline message. Otherwise, we send an accept message to the seller. The next code-block handles the decline message that we may receive from the client on our CFP message or our ACCEPT message: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the decline. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) target = msg . get ( \"target\" ) dialogues = cast ( Dialogues , self . context . dialogues ) if target == 1 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_CFP , dialogue . is_self_initiated ) elif target == 3 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_ACCEPT , dialogue . is_self_initiated ) The above code terminates each dialogue with the specific aea and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case you didn\u2019t receive any decline message that means that the my_thermometer AEA want to move on with the sale, in that case, it will send a match_accept message in order to handle this add the following code : def _handle_match_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match accept. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx : self . context . logger . info ( \"[ {} ]: received MATCH_ACCEPT_W_INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) info = msg . info address = cast ( str , info . get ( \"address\" )) proposal = cast ( Description , dialogue . proposal ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ self . context . skill_id ], tx_id = \"transaction0\" , tx_sender_addr = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ] ], tx_counterparty_addr = address , tx_amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, tx_sender_fee = strategy . max_buyer_tx_fee , tx_counterparty_fee = proposal . values [ \"seller_tx_fee\" ], tx_quantities_by_good_id = {}, ledger_id = proposal . values [ \"ledger_id\" ], info = { \"dialogue_label\" : dialogue . dialogue_label . json }, tx_nonce = proposal . values [ \"tx_nonce\" ], ) self . context . decision_maker_message_queue . put_nowait ( tx_msg ) self . context . logger . info ( \"[ {} ]: proposing the transaction to the decision maker. Waiting for confirmation ...\" . format ( self . context . agent_name ) ) else : new_message_id = msg . message_id + 1 new_target = msg . message_id inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) inform_msg . counterparty = msg . counterparty dialogue . update ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of payment.\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The first thing we are checking is if we enabled our aea to transact with a ledger. If we can transact with a ledger we generate a transaction message and we propose it to the decision_maker . The decision_maker then will check the transaction message if it is acceptable, we have the funds, etc, it signs and sends the transaction to the specified ledger. Then it returns us the transaction digest. Lastly, we need to handle the inform message because this is the message that will have our data: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match inform. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) if \"thermometer_data\" in msg . info . keys (): thermometer_data = msg . info [ \"thermometer_data\" ] self . context . logger . info ( \"[ {} ]: received the following thermometer data= {} \" . format ( self . context . agent_name , pprint . pformat ( thermometer_data ) ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: received no data from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The main difference between this handler and the thermometer skill handler is that in this one we create more than one handler. The reason is that we receive messages not only from the my_thermometer AEA but also from the decision_maker and the OEF search node . So we need a handler to be able to read different kinds of messages. To handle the OEF search node response on our search request adds the following code in the same file: class OEFSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations oef_msg = cast ( OefSearchMessage , message ) if oef_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : agents = oef_msg . agents self . _handle_search ( agents ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_search ( self , agents : Tuple [ str , ... ]) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( agents ) > 0 : self . context . logger . info ( \"[ {} ]: found agents= {} , stopping search.\" . format ( self . context . agent_name , list ( map ( lambda x : x [ - 5 :], agents )) ) ) strategy = cast ( Strategy , self . context . strategy ) # stopping search strategy . is_searching = False # pick first agent found opponent_addr = agents [ 0 ] dialogues = cast ( Dialogues , self . context . dialogues ) query = strategy . get_service_query () self . context . logger . info ( \"[ {} ]: sending CFP to agent= {} \" . format ( self . context . agent_name , opponent_addr [ - 5 :] ) ) cfp_msg = FipaMessage ( message_id = Dialogue . STARTING_MESSAGE_ID , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), performative = FipaMessage . Performative . CFP , target = Dialogue . STARTING_TARGET , query = query , ) cfp_msg . counterparty = opponent_addr dialogues . update ( cfp_msg ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) else : self . context . logger . info ( \"[ {} ]: found no agents, continue searching.\" . format ( self . context . agent_name ) ) When we receive a message from the oef of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the handle function. The latest calls the _handle_search function and passes as input to the agent list. There we are checking that the list contains some agents and we stop the search. We pick our first agent and we send a CFP message. The last handler we will need is the MyTransactionHandler . This one will handle the internal messages that we receive from the decision_maker . class MyTransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): self . context . logger . info ( \"[ {} ]: transaction was successful.\" . format ( self . context . agent_name ) ) json_data = { \"transaction_digest\" : tx_msg_response . tx_digest } info = cast ( Dict [ str , Any ], tx_msg_response . info ) dialogue_label = DialogueLabel . from_json ( cast ( Dict [ str , str ], info . get ( \"dialogue_label\" )) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . dialogues [ dialogue_label ] fipa_msg = cast ( FipaMessage , dialogue . last_incoming_message ) new_message_id = fipa_msg . message_id + 1 new_target_id = fipa_msg . message_id counterparty_addr = dialogue . dialogue_label . dialogue_opponent_addr inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . INFORM , info = json_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = counterparty_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of transaction digest.\" . format ( self . context . agent_name , counterparty_addr [ - 5 :] ) ) else : self . context . logger . info ( \"[ {} ]: transaction was not successful.\" . format ( self . context . agent_name ) ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass Remember that we send a message to the decision_maker with a transaction proposal? Here we handle the response from the decision_maker . If the message is of type SUCCESFUL_SETTLEMENT, we generate the inform_msg for the seller_aea to inform him that we completed the transaction and transferred the funds to the address that he sent us and we pass the transaction digest so the other aea can verify the transaction. Otherwise, the decision_maker will inform us that something went wrong and the transaction was not successful.","title":"Step 3: Create the handler"},{"location":"aea/thermometer-skills-step-by-step/#step-4-create-the-strategy_1","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.skills.base import Model DEFAULT_COUNTRY = \"UK\" SEARCH_TERM = \"country\" DEFAULT_MAX_ROW_PRICE = 5 DEFAULT_MAX_TX_FEE = 20000000 DEFAULT_CURRENCY_PBK = \"ETH\" DEFAULT_LEDGER_ID = \"ethereum\" DEFAULT_IS_LEDGER_TX = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _country = kwargs . pop ( \"country\" , DEFAULT_COUNTRY ) self . _max_row_price = kwargs . pop ( \"max_row_price\" , DEFAULT_MAX_ROW_PRICE ) self . max_buyer_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) super () . __init__ ( ** kwargs ) self . _search_id = 0 self . is_searching = True We initialize the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two functions are related to the oef search service, add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id def get_next_search_id ( self ) -> int : \"\"\" Get the next search id and set the search time. :return: the next search id \"\"\" self . _search_id += 1 return self . _search_id def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" query = Query ( [ Constraint ( SEARCH_TERM , ConstraintType ( \"==\" , self . _country ))], model = None ) return query The following code block checks if the proposal that we received is acceptable based on the strategy def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( ( proposal . values [ \"price\" ] - proposal . values [ \"seller_tx_fee\" ] > 0 ) and ( proposal . values [ \"price\" ] <= self . _max_row_price ) and ( proposal . values [ \"currency_id\" ] == self . _currency_id ) and ( proposal . values [ \"ledger_id\" ] == self . _ledger_id ) ) return result The is_affordable_proposal checks if we can afford the transaction based on the funds we have in our wallet on the ledger. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values [ \"price\" ] + self . max_buyer_tx_fee ledger_id = proposal . values [ \"ledger_id\" ] address = cast ( str , self . context . agent_addresses . get ( ledger_id )) balance = self . context . ledger_apis . token_balance ( ledger_id , address ) result = balance >= payable else : result = True return result","title":"Step 4: Create the strategy"},{"location":"aea/thermometer-skills-step-by-step/#step-5-create-the-dialogues_1","text":"When we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py . Inside this file add the following code: from typing import Optional from aea.helpers.dialogue.base import Dialogue as BaseDialogue from aea.helpers.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.helpers.search.models import Description from aea.mail.base import Address from aea.protocols.base import Message from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , agent_address : Address , role : BaseDialogue . Role , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param agent_address: the address of the agent for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , agent_address = agent_address , role = role ) self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self , self . context . agent_address ) @staticmethod def role_from_first_message ( message : Message ) -> BaseDialogue . Role : \"\"\" Infer the role of the agent from an incoming or outgoing first message :param message: an incoming/outgoing first message :return: the agent's role \"\"\" return FipaDialogue . AgentRole . BUYER def _create_dialogue ( self , dialogue_label : BaseDialogueLabel , role : BaseDialogue . Role , ) -> Dialogue : \"\"\" Create an instance of fipa dialogue. :param dialogue_label: the identifier of the dialogue :param role: the role of the agent this dialogue is maintained for :return: the created dialogue \"\"\" dialogue = Dialogue ( dialogue_label = dialogue_label , agent_address = self . agent_address , role = role ) return dialogue The dialogues class stores dialogue with each my_thermometer AEA in a list so we can have access to previous messages and enable us to identify possible communications problems between the my_thermometer AEA and the my_client AEA.","title":"Step 5: Create the dialogues"},{"location":"aea/thermometer-skills-step-by-step/#step-6-update-the-yaml-files","text":"Since we made so many changes to our aea we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml . Make sure that your skill.yaml matches with the following code: name : thermometer_client author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : {} aea_version : '>=0.3.0, <0.4.0' description : \"The thermometer client skill implements the skill to purchase temperature data.\" behaviours : search : class_name : MySearchBehaviour args : search_interval : 5 handlers : fipa : class_name : FIPAHandler args : {} oef : class_name : OEFHandler args : {} transaction : class_name : MyTransactionHandler args : {} models : strategy : class_name : Strategy args : country : UK max_row_price : 4 max_tx_fee : 2000000 currency_id : 'FET' ledger_id : 'fetchai' is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.2.0' , 'fetchai/default:0.1.0' , 'fetchai/oef_search:0.1.0' ] ledgers : [ 'fetchai' ] We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading or the currency we would like to transact with. Finally, we fingerprint our new skill: aea fingerprint skill thermometer This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 6: Update the YAML files"},{"location":"aea/thermometer-skills-step-by-step/#run-the-aeas","text":"Note Make sure that your thermometer sensor is connected to the Raspberry's usb port. You can change the end-point's address and port by modifying the connection's yaml file ( */connection/oef/connection.yaml ) Under config locate: addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json","title":"Run the AEAs"},{"location":"aea/thermometer-skills-step-by-step/#fetchai-ledger-payment","text":"Create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt","title":"Fetch.ai ledger payment"},{"location":"aea/thermometer-skills-step-by-step/#update-the-aea-configs","text":"Both in my_thermometer/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis : {} with the following. ledger_apis : fetchai : network : testnet","title":"Update the AEA configs"},{"location":"aea/thermometer-skills-step-by-step/#fund-the-temperature-client-aea","text":"Create some wealth for your weather client on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai Run both AEAs from their respective terminals aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Fund the temperature client AEA"},{"location":"aea/thermometer-skills-step-by-step/#ethereum-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet. This demo assumes the temperature client trusts our AEA to send the temperature data upon successful payment. Create the private key for the my_client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Ethereum ledger payment"},{"location":"aea/thermometer-skills-step-by-step/#update-the-aea-configs_1","text":"Both in my_thermometer/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis: {} with the following. ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/thermometer-skills-step-by-step/#update-the-skill-configs","text":"In the thermometer skill config ( my_thermometer/skills/thermometer/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True In the temprature_client skill config ( my_client/skills/temprature_client/skill.yaml ) under strategy change the currency_id and ledger_id . max_buyer_tx_fee : 20000 currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True","title":"Update the skill configs"},{"location":"aea/thermometer-skills-step-by-step/#fund-the-thermometer-client-aea","text":"Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_client/eth_private_key.txt . Run both AEAs from their respective terminals. aea add connection fetchai/oef:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the Ethereum testnet.","title":"Fund the thermometer client AEA"},{"location":"aea/thermometer-skills-step-by-step/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer aea delete my_client","title":"Delete the AEAs"},{"location":"aea/thermometer-skills/","text":"The AEA thermometer skills demonstrate an interaction between two AEAs. The provider of thermometer data (the thermometer ). The buyer of thermometer data (the thermometer_client ). Discussion The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework, a Raspberry Pi, and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. The AEA must run inside a Raspberry Pi or any other Linux system, and the sensor must be connected to the USB port. Communication This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create thermometer AEA First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.2.0 --alias my_thermometer_aea cd thermometer_aea aea install Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/thermometer:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_thermometer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Create thermometer client Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.2.0 --alias my_thermometer_client cd my_thermometer_client aea install Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/thermometer_client:0.2.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_thermometer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Generate wealth for the thermometer client AEA The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_thermometer_aea/aea-config.yaml` and `my_thermometer_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos Update the skill configs The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Thermometer: Ensure you are in the thermometer project directory. For ethereum, update the skill config of the thermometer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id cosmos This updates the thermometer skill config (`my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml`). Thermometer client: Ensure you are in the thermometer client project directory. For ethereum, update the skill config of the thermometer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id cosmos This updates the thermometer client skill config (`my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml`). Run both AEAs Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Thermometer skills"},{"location":"aea/thermometer-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework, a Raspberry Pi, and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. The AEA must run inside a Raspberry Pi or any other Linux system, and the sensor must be connected to the USB port.","title":"Discussion"},{"location":"aea/thermometer-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/thermometer-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/thermometer-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/thermometer-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/thermometer-skills/#demo-instructions","text":"A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions"},{"location":"aea/thermometer-skills/#create-thermometer-aea","text":"First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.2.0 --alias my_thermometer_aea cd thermometer_aea aea install Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/oef:0.3.0 aea add skill fetchai/thermometer:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_thermometer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create thermometer AEA"},{"location":"aea/thermometer-skills/#create-thermometer-client","text":"Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.2.0 --alias my_thermometer_client cd my_thermometer_client aea install Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/thermometer_client:0.2.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_thermometer_aea/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create thermometer client"},{"location":"aea/thermometer-skills/#generate-wealth-for-the-thermometer-client-aea","text":"The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_thermometer_aea/aea-config.yaml` and `my_thermometer_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos","title":"Generate wealth for the thermometer client AEA"},{"location":"aea/thermometer-skills/#update-the-skill-configs","text":"The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Thermometer: Ensure you are in the thermometer project directory. For ethereum, update the skill config of the thermometer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id cosmos This updates the thermometer skill config (`my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml`). Thermometer client: Ensure you are in the thermometer client project directory. For ethereum, update the skill config of the thermometer via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id cosmos This updates the thermometer client skill config (`my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml`).","title":"Update the skill configs"},{"location":"aea/thermometer-skills/#run-both-aeas","text":"Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.3.0 You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/thermometer-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Cleaning up"},{"location":"aea/trust/","text":"AEA applications operate within different orders of trustlessness. For example, using the AEA weather skills demo without ledger payments means that clients must trust that any data the weather station sends is sufficient, including no data at all. Similarly, the weather station must trust the weather clients to send payment via some mechanism. A step up, if you run the weather skills demo with a ledger (Fetch.ai or Ethereum) then the clients must again trust the weather station to send sufficient data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the weather clients as it can observe the transactions taking place on the public ledger. We can expand trustlessness even further by incorporating a third-party as an arbitrator or some escrow contract. However, in the weather skills demo there are limits to trustlessness as the station ultimately offers unverifiable data. Finally, in the case of (non-fungible) token transactions where there is an atomic swap, full trustlessness is apparent. This is demonstrated in the TAC.","title":"Trust issues"},{"location":"aea/version/","text":"The current version of the Autonomous Economic Agent framework is . The framework is under rapid development with frequent breaking changes. To check which version you have installed locally, run aea --version","title":"Version"},{"location":"aea/vision/","text":"The AEA framework has two commercial roles which are outlined below. Open source technology We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers. Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Vision"},{"location":"aea/vision/#open-source-technology","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers.","title":"Open source technology"},{"location":"aea/vision/#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Platform for start ups"},{"location":"aea/wealth/","text":"To fund an AEA for testing on a test-net you need to request some test tokens from a faucet. Add a private key to the agent: aea generate-key fetchai aea add-key fetchai fet_private_key.txt or aea generate-key ethereum aea add-key ethereum eth_private_key.txt Ensure the ledger apis are set in the aea config: ledger_apis : fetchai : network : testnet for fetchai or ledger_apis : fetchai : host : testnet.fetch-ai.com port : 80 or ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 or both ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 fetchai : network : testnet Using a faucet website First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum Using the cli Simply generate wealth via the cli: aea generate-wealth fetchai or aea generate-wealth ethereum","title":"Generating wealth"},{"location":"aea/wealth/#using-a-faucet-website","text":"First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum","title":"Using a faucet website"},{"location":"aea/wealth/#using-the-cli","text":"Simply generate wealth via the cli: aea generate-wealth fetchai or aea generate-wealth ethereum","title":"Using the cli"},{"location":"aea/weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs. The provider of weather data (the weather_station ). The buyer of weather data (the weather_client ). Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients. Communication This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions: A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the weather station First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.4.0 --alias my_weather_station cd my_weather_station aea install Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/oef:0.3.0 aea add skill fetchai/weather_station:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `weather_station/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Create the weather client In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.4.0 --alias my_weather_client cd my_weather_client aea install Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/weather_client:0.2.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_weather_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet Generate wealth for the weather client AEA The weather client needs to have some wealth to purchase the weather station information. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_weather_station/aea-config.yaml` and `my_weather_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos Update the skill configs The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Weather station: Ensure you are in the weather station project directory. For ethereum, update the skill config of the weather station via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_station.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.weather_station.models.strategy.args.ledger_id cosmos This updates the weather station skill config (`my_weather_station/vendor/fetchai/skills/weather_station/skill.yaml`). Weather client: Ensure you are in the weather client project directory. For ethereum, update the skill config of the weather client via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id cosmos This updates the weather client skill config (`my_weather_client/vendor/fetchai/skills/weather_client/skill.yaml`). Run the AEAs Run both AEAs from their respective terminals. aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the selected ledger. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"aea/weather-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients.","title":"Discussion"},{"location":"aea/weather-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/weather-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/weather-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/weather-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/weather-skills/#demo-instructions","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions:"},{"location":"aea/weather-skills/#create-the-weather-station","text":"First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.4.0 --alias my_weather_station cd my_weather_station aea install Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/oef:0.3.0 aea add skill fetchai/weather_station:0.3.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `weather_station/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create the weather station"},{"location":"aea/weather-skills/#create-the-weather-client","text":"In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.4.0 --alias my_weather_client cd my_weather_client aea install Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/oef:0.3.0 aea add skill fetchai/weather_client:0.2.0 aea install aea config set agent.default_connection fetchai/oef:0.3.0 In `my_weather_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet","title":"Create the weather client"},{"location":"aea/weather-skills/#generate-wealth-for-the-weather-client-aea","text":"The weather client needs to have some wealth to purchase the weather station information. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Alternatively, create wealth for other test networks. Ledger Config: In `my_weather_station/aea-config.yaml` and `my_weather_client/aea-config.yaml` replace `ledger_apis: {}` with the following based on the network you want to connect. To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Alternatively, to connect to Cosmos: ledger_apis : cosmos : address : http://aea-testnet.sandbox.fetch-ai.com:1317 Wealth: To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt On the Ethereum `ropsten` network. aea generate-wealth ethereum Alternatively, to generate and add a private-public key pair for Cosmos use: aea generate-key cosmos aea add-key cosmos cosmos_private_key.txt On the Cosmos `testnet` network. aea generate-wealth cosmos","title":"Generate wealth for the weather client AEA"},{"location":"aea/weather-skills/#update-the-skill-configs","text":"The default skill configs assume that the transaction is settled against the fetchai ledger. Alternatively, configure skills for other test networks. Weather station: Ensure you are in the weather station project directory. For ethereum, update the skill config of the weather station via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_station.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.weather_station.models.strategy.args.ledger_id cosmos This updates the weather station skill config (`my_weather_station/vendor/fetchai/skills/weather_station/skill.yaml`). Weather client: Ensure you are in the weather client project directory. For ethereum, update the skill config of the weather client via the `aea config get/set` command like so: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id ethereum Or for cosmos, like so: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ATOM aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id cosmos This updates the weather client skill config (`my_weather_client/vendor/fetchai/skills/weather_client/skill.yaml`).","title":"Update the skill configs"},{"location":"aea/weather-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. aea run --connections fetchai/oef:0.3.0 You will see that the AEAs negotiate and then transact using the selected ledger.","title":"Run the AEAs"},{"location":"aea/weather-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/api/aea/","text":"aea.aea This module contains the implementation of an autonomous economic agent (AEA). AEA class AEA ( Agent ) This class implements an autonomous economic agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], wallet : Wallet , ledger_apis : LedgerApis , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , timeout : float = 0.05 , execution_timeout : float = 0 , is_debug : bool = False , max_reactions : int = 20 , decision_maker_handler_class : Type [ | DecisionMakerHandler | ] = DefaultDecisionMakerHandler , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , ** kwargs , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent connections : the list of connections of the agent. wallet : the wallet of the agent. ledger_apis : the APIs the agent will use to connect to ledgers. resources : the resources (protocols and skills) of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react exeution_timeout : amount of time to limit single act/handle to execute. is_debug : if True, run the agent in debug mode (does not connect the multiplexer). loop_mode : loop_mode to choose agent run loop. max_reactions : the processing rate of envelopes per tick (i.e. single loop). decision_maker_handler_class : the class implementing the decision maker handler to be used. skill_exception_policy : the skill exception policy enum kwargs : keyword arguments to be attached in the agent context namespace. Returns : None decision _ maker | @property | decision_maker () -> DecisionMaker Get decision maker. context | @property | context () -> AgentContext Get (agent) context. resources | @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources. task _ manager | @property | task_manager () -> TaskManager Get the task manager. setup | setup () -> None Set up the agent. Performs the following: loads the resources (unless in programmatic mode) starts the task manager starts the decision maker calls setup() on the resources Returns : None act | act () -> None Perform actions. Calls act() of each active behaviour. Returns : None react | react () -> None React to incoming envelopes. Gets up to max_reactions number of envelopes from the inbox and handles each envelope, which entailes: fetching the protocol referenced by the envelope, and returning an envelope to sender if the protocol is unsupported, using the error handler, or returning an envelope to sender if there is a decoding error, using the error handler, or returning an envelope to sender if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Returns : None update | update () -> None Update the current state of the agent. Handles the internal messages from the skills to the decision maker. :return None teardown | teardown () -> None Tear down the agent. Performs the following: stops the decision maker stops the task manager tears down the resources. Returns : None","title":"AEA"},{"location":"aea/api/aea/#aeaaea","text":"This module contains the implementation of an autonomous economic agent (AEA).","title":"aea.aea"},{"location":"aea/api/aea/#aea","text":"class AEA ( Agent ) This class implements an autonomous economic agent.","title":"AEA"},{"location":"aea/api/aea/#__init__","text":"| __init__ ( identity : Identity , connections : List [ Connection ], wallet : Wallet , ledger_apis : LedgerApis , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , timeout : float = 0.05 , execution_timeout : float = 0 , is_debug : bool = False , max_reactions : int = 20 , decision_maker_handler_class : Type [ | DecisionMakerHandler | ] = DefaultDecisionMakerHandler , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , ** kwargs , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent connections : the list of connections of the agent. wallet : the wallet of the agent. ledger_apis : the APIs the agent will use to connect to ledgers. resources : the resources (protocols and skills) of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react exeution_timeout : amount of time to limit single act/handle to execute. is_debug : if True, run the agent in debug mode (does not connect the multiplexer). loop_mode : loop_mode to choose agent run loop. max_reactions : the processing rate of envelopes per tick (i.e. single loop). decision_maker_handler_class : the class implementing the decision maker handler to be used. skill_exception_policy : the skill exception policy enum kwargs : keyword arguments to be attached in the agent context namespace. Returns : None","title":"__init__"},{"location":"aea/api/aea/#decision_maker","text":"| @property | decision_maker () -> DecisionMaker Get decision maker.","title":"decision_maker"},{"location":"aea/api/aea/#context","text":"| @property | context () -> AgentContext Get (agent) context.","title":"context"},{"location":"aea/api/aea/#resources","text":"| @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources.","title":"resources"},{"location":"aea/api/aea/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/aea/#setup","text":"| setup () -> None Set up the agent. Performs the following: loads the resources (unless in programmatic mode) starts the task manager starts the decision maker calls setup() on the resources Returns : None","title":"setup"},{"location":"aea/api/aea/#act","text":"| act () -> None Perform actions. Calls act() of each active behaviour. Returns : None","title":"act"},{"location":"aea/api/aea/#react","text":"| react () -> None React to incoming envelopes. Gets up to max_reactions number of envelopes from the inbox and handles each envelope, which entailes: fetching the protocol referenced by the envelope, and returning an envelope to sender if the protocol is unsupported, using the error handler, or returning an envelope to sender if there is a decoding error, using the error handler, or returning an envelope to sender if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Returns : None","title":"react"},{"location":"aea/api/aea/#update","text":"| update () -> None Update the current state of the agent. Handles the internal messages from the skills to the decision maker. :return None","title":"update"},{"location":"aea/api/aea/#teardown","text":"| teardown () -> None Tear down the agent. Performs the following: stops the decision maker stops the task manager tears down the resources. Returns : None","title":"teardown"},{"location":"aea/api/aea_builder/","text":"aea.aea _ builder This module contains utilities for building an AEA. AEABuilder class AEABuilder () This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. __ init __ | __init__ ( with_default_packages : bool = True ) Initialize the builder. Arguments : with_default_packages : add the default packages. set _ timeout | set_timeout ( timeout : Optional [ float ]) -> \"AEABuilder\" Set agent loop idle timeout in seconds. Arguments : timeout : timeout in seconds Returns : self set _ execution _ timeout | set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self set _ max _ reactions | set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self set _ decision _ maker _ handler | set_decision_maker_handler ( decision_maker_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set decision maker handler class. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler Returns : self set _ skill _ exception _ policy | set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self set _ default _ routing | set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self set _ loop _ mode | set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self set _ name | set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder set _ default _ connection | set_default_connection ( public_id : PublicId ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder add _ private _ key | add_private_key ( identifier : str , private_key_path : PathLike ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : path to the private key file. Returns : the AEABuilder remove _ private _ key | remove_private_key ( identifier : str ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. Returns : the AEABuilder private _ key _ paths | @property | private_key_paths () -> Dict [ str , str ] Get the private key paths. add _ ledger _ api _ config | add_ledger_api_config ( identifier : str , config : Dict ) -> \"AEABuilder\" Add a configuration for a ledger API to be supported by the agent. Arguments : identifier : the identifier of the ledger api config : the configuration of the ledger api Returns : the AEABuilder remove _ ledger _ api _ config | remove_ledger_api_config ( identifier : str ) -> \"AEABuilder\" Remove a ledger API configuration. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder ledger _ apis _ config | @property | ledger_apis_config () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the ledger api configurations. set _ default _ ledger | set_default_ledger ( identifier : str ) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder add _ component | add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. | or if there's a missing dependency. Returns : the AEABuilder add _ component _ instance | add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. :params component: Component instance already initialized. set _ context _ namespace | set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace. remove _ component | remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder add _ protocol | add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder remove _ protocol | remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder add _ connection | add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder remove _ connection | remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder add _ skill | add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder remove _ skill | remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder add _ contract | add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder remove _ contract | remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder build | build ( connection_ids : Optional [ Collection [ PublicId ]] = None , ledger_apis : Optional [ LedgerApis ] = None ) -> AEA Build the AEA. Arguments : connection_ids : select only these connections to run the AEA. ledger_apis : the api ledger that we want to use. Returns : the AEA object. from _ aea _ project | @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. Returns : an AEABuilder.","title":"AEA Builder"},{"location":"aea/api/aea_builder/#aeaaea_builder","text":"This module contains utilities for building an AEA.","title":"aea.aea_builder"},{"location":"aea/api/aea_builder/#aeabuilder","text":"class AEABuilder () This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself.","title":"AEABuilder"},{"location":"aea/api/aea_builder/#__init__","text":"| __init__ ( with_default_packages : bool = True ) Initialize the builder. Arguments : with_default_packages : add the default packages.","title":"__init__"},{"location":"aea/api/aea_builder/#set_timeout","text":"| set_timeout ( timeout : Optional [ float ]) -> \"AEABuilder\" Set agent loop idle timeout in seconds. Arguments : timeout : timeout in seconds Returns : self","title":"set_timeout"},{"location":"aea/api/aea_builder/#set_execution_timeout","text":"| set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self","title":"set_execution_timeout"},{"location":"aea/api/aea_builder/#set_max_reactions","text":"| set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self","title":"set_max_reactions"},{"location":"aea/api/aea_builder/#set_decision_maker_handler","text":"| set_decision_maker_handler ( decision_maker_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set decision maker handler class. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler Returns : self","title":"set_decision_maker_handler"},{"location":"aea/api/aea_builder/#set_skill_exception_policy","text":"| set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self","title":"set_skill_exception_policy"},{"location":"aea/api/aea_builder/#set_default_routing","text":"| set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self","title":"set_default_routing"},{"location":"aea/api/aea_builder/#set_loop_mode","text":"| set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self","title":"set_loop_mode"},{"location":"aea/api/aea_builder/#set_name","text":"| set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder","title":"set_name"},{"location":"aea/api/aea_builder/#set_default_connection","text":"| set_default_connection ( public_id : PublicId ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder","title":"set_default_connection"},{"location":"aea/api/aea_builder/#add_private_key","text":"| add_private_key ( identifier : str , private_key_path : PathLike ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : path to the private key file. Returns : the AEABuilder","title":"add_private_key"},{"location":"aea/api/aea_builder/#remove_private_key","text":"| remove_private_key ( identifier : str ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. Returns : the AEABuilder","title":"remove_private_key"},{"location":"aea/api/aea_builder/#private_key_paths","text":"| @property | private_key_paths () -> Dict [ str , str ] Get the private key paths.","title":"private_key_paths"},{"location":"aea/api/aea_builder/#add_ledger_api_config","text":"| add_ledger_api_config ( identifier : str , config : Dict ) -> \"AEABuilder\" Add a configuration for a ledger API to be supported by the agent. Arguments : identifier : the identifier of the ledger api config : the configuration of the ledger api Returns : the AEABuilder","title":"add_ledger_api_config"},{"location":"aea/api/aea_builder/#remove_ledger_api_config","text":"| remove_ledger_api_config ( identifier : str ) -> \"AEABuilder\" Remove a ledger API configuration. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder","title":"remove_ledger_api_config"},{"location":"aea/api/aea_builder/#ledger_apis_config","text":"| @property | ledger_apis_config () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the ledger api configurations.","title":"ledger_apis_config"},{"location":"aea/api/aea_builder/#set_default_ledger","text":"| set_default_ledger ( identifier : str ) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder","title":"set_default_ledger"},{"location":"aea/api/aea_builder/#add_component","text":"| add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. | or if there's a missing dependency. Returns : the AEABuilder","title":"add_component"},{"location":"aea/api/aea_builder/#add_component_instance","text":"| add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. :params component: Component instance already initialized.","title":"add_component_instance"},{"location":"aea/api/aea_builder/#set_context_namespace","text":"| set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace.","title":"set_context_namespace"},{"location":"aea/api/aea_builder/#remove_component","text":"| remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder","title":"remove_component"},{"location":"aea/api/aea_builder/#add_protocol","text":"| add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder","title":"add_protocol"},{"location":"aea/api/aea_builder/#remove_protocol","text":"| remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder","title":"remove_protocol"},{"location":"aea/api/aea_builder/#add_connection","text":"| add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder","title":"add_connection"},{"location":"aea/api/aea_builder/#remove_connection","text":"| remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder","title":"remove_connection"},{"location":"aea/api/aea_builder/#add_skill","text":"| add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder","title":"add_skill"},{"location":"aea/api/aea_builder/#remove_skill","text":"| remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder","title":"remove_skill"},{"location":"aea/api/aea_builder/#add_contract","text":"| add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder","title":"add_contract"},{"location":"aea/api/aea_builder/#remove_contract","text":"| remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder","title":"remove_contract"},{"location":"aea/api/aea_builder/#build","text":"| build ( connection_ids : Optional [ Collection [ PublicId ]] = None , ledger_apis : Optional [ LedgerApis ] = None ) -> AEA Build the AEA. Arguments : connection_ids : select only these connections to run the AEA. ledger_apis : the api ledger that we want to use. Returns : the AEA object.","title":"build"},{"location":"aea/api/aea_builder/#from_aea_project","text":"| @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. Returns : an AEABuilder.","title":"from_aea_project"},{"location":"aea/api/agent/","text":"aea.agent This module contains the implementation of a generic agent. AgentState class AgentState ( Enum ) Enumeration for an agent state. In particular, it can be one of the following states: AgentState.INITIATED: when the Agent object has been created. AgentState.CONNECTED: when the agent is connected. AgentState.RUNNING: when the agent is running. Liveness class Liveness () Determines the liveness of the agent. __ init __ | __init__ () Instantiate the liveness. is _ stopped | @property | is_stopped () -> bool Check whether the liveness is stopped. start | start () -> None Start the liveness. stop | stop () -> None Stop the liveness. Agent class Agent ( ABC ) This class provides an abstract base class for a generic agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , timeout : float = 1.0 , is_debug : bool = False , loop_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode (does not connect the multiplexer). loop_mode : loop_mode to choose agent run loop. Returns : None identity | @property | identity () -> Identity Get the identity. multiplexer | @property | multiplexer () -> Multiplexer Get the multiplexer. inbox | @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. outbox | @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. name | @property | name () -> str Get the agent name. liveness | @property | liveness () -> Liveness Get the liveness. tick | @property | tick () -> int Get the tick (or agent loop count). Each agent loop (one call to each one of act(), react(), update()) increments the tick. agent _ state | @property | agent_state () -> AgentState Get the state of the agent. Raises : ValueError : if the state does not satisfy any of the foreseen conditions. Returns : None start | start () -> None Start the agent. Performs the following: calls connect() on the multiplexer (unless in debug mode), and calls setup(), and calls start() on the liveness, and enters the agent main loop. While the liveness of the agent is not stopped it continues to loop over: increment the tick, call to act(), sleep for specified timeout, call to react(), call to update(). Arguments : loop_mode : loop mode to choose agent run loop. if not specified default one will be used Returns : None stop | stop () -> None Stop the agent. Performs the following: calls stop() on the liveness, and calls teardown(), and calls disconnect() on the multiplexer. Returns : None setup | @abstractmethod | setup () -> None Set up the agent. Returns : None act | @abstractmethod | act () -> None Perform actions. Returns : None react | @abstractmethod | react () -> None React to events. Returns : None update | @abstractmethod | update () -> None Update the internals of the agent which are not exposed to the skills. :return None teardown | @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"Agent"},{"location":"aea/api/agent/#aeaagent","text":"This module contains the implementation of a generic agent.","title":"aea.agent"},{"location":"aea/api/agent/#agentstate","text":"class AgentState ( Enum ) Enumeration for an agent state. In particular, it can be one of the following states: AgentState.INITIATED: when the Agent object has been created. AgentState.CONNECTED: when the agent is connected. AgentState.RUNNING: when the agent is running.","title":"AgentState"},{"location":"aea/api/agent/#liveness","text":"class Liveness () Determines the liveness of the agent.","title":"Liveness"},{"location":"aea/api/agent/#__init__","text":"| __init__ () Instantiate the liveness.","title":"__init__"},{"location":"aea/api/agent/#is_stopped","text":"| @property | is_stopped () -> bool Check whether the liveness is stopped.","title":"is_stopped"},{"location":"aea/api/agent/#start","text":"| start () -> None Start the liveness.","title":"start"},{"location":"aea/api/agent/#stop","text":"| stop () -> None Stop the liveness.","title":"stop"},{"location":"aea/api/agent/#agent","text":"class Agent ( ABC ) This class provides an abstract base class for a generic agent.","title":"Agent"},{"location":"aea/api/agent/#__init___1","text":"| __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , timeout : float = 1.0 , is_debug : bool = False , loop_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode (does not connect the multiplexer). loop_mode : loop_mode to choose agent run loop. Returns : None","title":"__init__"},{"location":"aea/api/agent/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/agent/#multiplexer","text":"| @property | multiplexer () -> Multiplexer Get the multiplexer.","title":"multiplexer"},{"location":"aea/api/agent/#inbox","text":"| @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing.","title":"inbox"},{"location":"aea/api/agent/#outbox","text":"| @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer.","title":"outbox"},{"location":"aea/api/agent/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/agent/#liveness_1","text":"| @property | liveness () -> Liveness Get the liveness.","title":"liveness"},{"location":"aea/api/agent/#tick","text":"| @property | tick () -> int Get the tick (or agent loop count). Each agent loop (one call to each one of act(), react(), update()) increments the tick.","title":"tick"},{"location":"aea/api/agent/#agent_state","text":"| @property | agent_state () -> AgentState Get the state of the agent. Raises : ValueError : if the state does not satisfy any of the foreseen conditions. Returns : None","title":"agent_state"},{"location":"aea/api/agent/#start_1","text":"| start () -> None Start the agent. Performs the following: calls connect() on the multiplexer (unless in debug mode), and calls setup(), and calls start() on the liveness, and enters the agent main loop. While the liveness of the agent is not stopped it continues to loop over: increment the tick, call to act(), sleep for specified timeout, call to react(), call to update(). Arguments : loop_mode : loop mode to choose agent run loop. if not specified default one will be used Returns : None","title":"start"},{"location":"aea/api/agent/#stop_1","text":"| stop () -> None Stop the agent. Performs the following: calls stop() on the liveness, and calls teardown(), and calls disconnect() on the multiplexer. Returns : None","title":"stop"},{"location":"aea/api/agent/#setup","text":"| @abstractmethod | setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"aea/api/agent/#act","text":"| @abstractmethod | act () -> None Perform actions. Returns : None","title":"act"},{"location":"aea/api/agent/#react","text":"| @abstractmethod | react () -> None React to events. Returns : None","title":"react"},{"location":"aea/api/agent/#update","text":"| @abstractmethod | update () -> None Update the internals of the agent which are not exposed to the skills. :return None","title":"update"},{"location":"aea/api/agent/#teardown","text":"| @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"aea/api/agent_loop/","text":"aea.agent _ loop This module contains the implementation of an agent loop using asyncio. ensure _ list ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence. AsyncState class AsyncState () Awaitable state. __ init __ | __init__ ( initial_state : Any = None , loop : AbstractEventLoop = None ) Init async state. Arguments : initial_state : state to set on start. loop : optional asyncio event loop. state | @state . setter | state ( state : Any ) -> None Set state. wait | async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. :params state_or_states: state or list of states. Returns : tuple of previous state and new state. PeriodicCaller class PeriodicCaller () Schedule a periodic call of callable using event loop. __ init __ | __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop start | start () -> None Activate period calls. stop | stop () -> None Remove from schedule. BaseAgentLoop class BaseAgentLoop ( ABC ) Base abstract agent loop class. __ init __ | __init__ ( agent : \"Agent\" ) -> None Init loop. :params agent: Agent or AEA to run. start | @abstractmethod | start () -> None Start agent loop. stop | @abstractmethod | stop () -> None Stop agent loop. AgentLoopException class AgentLoopException ( AEAException ) Exception for agent loop runtime errors. AgentLoopStates class AgentLoopStates ( Enum ) Internal agent loop states. AsyncAgentLoop class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA. __ init __ | __init__ ( agent : \"AEA\" , loop : AbstractEventLoop = None ) Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional start | start () Start agent loop. stop | stop () Stop agent loop. is _ running | @property | is_running () -> bool Get running state of the loop. SyncAgentLoop class SyncAgentLoop ( BaseAgentLoop ) Synchronous agent loop. __ init __ | __init__ ( agent : \"Agent\" ) -> None Init agent loop. Arguments : agent : agent or AEA instance. start | start () -> None Start agent loop. stop | stop () Stop agent loop.","title":"Agent Loop"},{"location":"aea/api/agent_loop/#aeaagent_loop","text":"This module contains the implementation of an agent loop using asyncio.","title":"aea.agent_loop"},{"location":"aea/api/agent_loop/#ensure_list","text":"ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence.","title":"ensure_list"},{"location":"aea/api/agent_loop/#asyncstate","text":"class AsyncState () Awaitable state.","title":"AsyncState"},{"location":"aea/api/agent_loop/#__init__","text":"| __init__ ( initial_state : Any = None , loop : AbstractEventLoop = None ) Init async state. Arguments : initial_state : state to set on start. loop : optional asyncio event loop.","title":"__init__"},{"location":"aea/api/agent_loop/#state","text":"| @state . setter | state ( state : Any ) -> None Set state.","title":"state"},{"location":"aea/api/agent_loop/#wait","text":"| async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. :params state_or_states: state or list of states. Returns : tuple of previous state and new state.","title":"wait"},{"location":"aea/api/agent_loop/#periodiccaller","text":"class PeriodicCaller () Schedule a periodic call of callable using event loop.","title":"PeriodicCaller"},{"location":"aea/api/agent_loop/#__init___1","text":"| __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop","title":"__init__"},{"location":"aea/api/agent_loop/#start","text":"| start () -> None Activate period calls.","title":"start"},{"location":"aea/api/agent_loop/#stop","text":"| stop () -> None Remove from schedule.","title":"stop"},{"location":"aea/api/agent_loop/#baseagentloop","text":"class BaseAgentLoop ( ABC ) Base abstract agent loop class.","title":"BaseAgentLoop"},{"location":"aea/api/agent_loop/#__init___2","text":"| __init__ ( agent : \"Agent\" ) -> None Init loop. :params agent: Agent or AEA to run.","title":"__init__"},{"location":"aea/api/agent_loop/#start_1","text":"| @abstractmethod | start () -> None Start agent loop.","title":"start"},{"location":"aea/api/agent_loop/#stop_1","text":"| @abstractmethod | stop () -> None Stop agent loop.","title":"stop"},{"location":"aea/api/agent_loop/#agentloopexception","text":"class AgentLoopException ( AEAException ) Exception for agent loop runtime errors.","title":"AgentLoopException"},{"location":"aea/api/agent_loop/#agentloopstates","text":"class AgentLoopStates ( Enum ) Internal agent loop states.","title":"AgentLoopStates"},{"location":"aea/api/agent_loop/#asyncagentloop","text":"class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA.","title":"AsyncAgentLoop"},{"location":"aea/api/agent_loop/#__init___3","text":"| __init__ ( agent : \"AEA\" , loop : AbstractEventLoop = None ) Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional","title":"__init__"},{"location":"aea/api/agent_loop/#start_2","text":"| start () Start agent loop.","title":"start"},{"location":"aea/api/agent_loop/#stop_2","text":"| stop () Stop agent loop.","title":"stop"},{"location":"aea/api/agent_loop/#is_running","text":"| @property | is_running () -> bool Get running state of the loop.","title":"is_running"},{"location":"aea/api/agent_loop/#syncagentloop","text":"class SyncAgentLoop ( BaseAgentLoop ) Synchronous agent loop.","title":"SyncAgentLoop"},{"location":"aea/api/agent_loop/#__init___4","text":"| __init__ ( agent : \"Agent\" ) -> None Init agent loop. Arguments : agent : agent or AEA instance.","title":"__init__"},{"location":"aea/api/agent_loop/#start_3","text":"| start () -> None Start agent loop.","title":"start"},{"location":"aea/api/agent_loop/#stop_3","text":"| stop () Stop agent loop.","title":"stop"},{"location":"aea/api/configurations/base/","text":"aea.configurations.base Classes to handle AEA configurations. Dependency A dependency is a dictionary with the following (optional) keys: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command. Dependencies A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set. PackageType class PackageType ( Enum ) Package types. to _ plural | to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' __ str __ | __str__ () Convert to string. ComponentType class ComponentType ( Enum ) Enum of component types supported. to _ configuration _ type | to_configuration_type () -> PackageType Get package type for component type. to _ plural | to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' __ str __ | __str__ () -> str Get the string representation. ProtocolSpecificationParseError class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file. JSONSerializable class JSONSerializable ( ABC ) Interface for JSON-serializable objects. json | @property | @abstractmethod | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. Configuration class Configuration ( JSONSerializable , ABC ) Configuration class. __ init __ | __init__ () Initialize a configuration object. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object. ordered _ json | @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary. CRUDCollection class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection. __ init __ | __init__ () Instantiate a CRUD collection. create | create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection. read | read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present. update | update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None delete | delete ( item_id : str ) -> None Delete an item. read _ all | read_all () -> List [ Tuple [ str , T ]] Read all the items. PublicId class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id __ init __ | __init__ ( author : str , name : str , version : PackageVersionLike ) Initialize the public identifier. author | @property | author () -> str Get the author. name | @property | name () -> str Get the name. version | @property | version () -> str Get the version. version _ info | @property | version_info () -> PackageVersion Get the package version. from _ str | @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. from _ uri _ path | @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. __ hash __ | __hash__ () Get the hash. __ str __ | __str__ () Get the string representation. __ repr __ | __repr__ () Get the representation. __ eq __ | __eq__ ( other ) Compare with another object. __ lt __ | __lt__ ( other ) Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author and name attributes are different. PackageId class PackageId () A package identifier. __ init __ | __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) Initialize the package id. Arguments : package_type : the package type. public_id : the public id. package _ type | @property | package_type () -> PackageType Get the package type. public _ id | @property | public_id () -> PublicId Get the public id. author | @property | author () -> str Get the author of the package. name | @property | name () -> str Get the name of the package. version | @property | version () -> str Get the version of the package. package _ prefix | @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version. __ hash __ | __hash__ () Get the hash. __ str __ | __str__ () Get the string representation. __ eq __ | __eq__ ( other ) Compare with another object. __ lt __ | __lt__ ( other ) Compare two public ids. ComponentId class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False __ init __ | __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) Initialize the component id. Arguments : component_type : the component type. public_id : the public id. component _ type | @property | component_type () -> ComponentType Get the component type. component _ prefix | @property | component_prefix () -> Tuple [ ComponentType , str , str ] Get the component identifier without the version. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. PackageConfiguration class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None ) Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint. directory | @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any. aea _ version _ specifiers | @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier. public _ id | @property | public_id () -> PublicId Get the public id. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. ComponentConfiguration class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , dependencies : Optional [ Dependencies ] = None ) Set component configuration. pypi _ dependencies | @property | pypi_dependencies () -> Dependencies Get PyPI dependencies. component _ type | @property | @abstractmethod | component_type () -> ComponentType Get the component type. component _ id | @property | component_id () -> ComponentId Get the component id. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. load | @staticmethod | load ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False ) -> \"ComponentConfiguration\" Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object. check _ fingerprint | check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. :raises ValueError if: - the argument is not a valid package directory - the fingerprints do not match. check _ aea _ version | check_aea_version () Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier. ConnectionConfig class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , ** config , ,) Initialize a connection configuration object. component _ type | @property | component_type () -> ComponentType Get the component type. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ProtocolConfig class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object. component _ type | @property | component_type () -> ComponentType Get the component type. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. SkillComponentConfiguration class SkillComponentConfiguration () This class represent a skill component configuration. __ init __ | __init__ ( class_name : str , ** args ) Initialize a skill component configuration. Arguments : skill_component_type : the skill component type. class_name : the class name of the component. args : keyword arguments. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. SkillConfig class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , protocols : List [ PublicId ] = None , contracts : List [ PublicId ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a skill configuration. component _ type | @property | component_type () -> ComponentType Get the component type. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. AgentConfig class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file. __ init __ | __init__ ( agent_name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , registry_path : str = DEFAULT_REGISTRY_PATH , description : str = \"\" , logging_config : Optional [ Dict ] = None , timeout : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , default_routing : Optional [ Dict ] = None , loop_mode : Optional [ str ] = None ) Instantiate the agent configuration object. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. private _ key _ paths _ dict | @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths. ledger _ apis _ dict | @property | ledger_apis_dict () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get dictionary version of ledger apis. default _ connection | @default_connection . setter | default_connection ( connection_id : Optional [ Union [ str , PublicId ]]) Set the default connection. Arguments : connection_id : the name of the default connection. Returns : None default _ ledger | @default_ledger . setter | default_ledger ( ledger_id : str ) Set the default ledger. Arguments : ledger_id : the id of the default ledger. Returns : None json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. SpeechActContentConfig class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration. __ init __ | __init__ ( ** args ) Initialize a speech_act content configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ProtocolSpecification class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , description : str = \"\" ) Initialize a protocol specification configuration object. protobuf _ snippets | @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) Set the protobuf snippets. dialogue _ config | @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) Set the dialogue config. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ContractConfig class ContractConfig ( ComponentConfiguration ) Handle contract configuration. __ init __ | __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , path_to_contract_interface : str = \"\" , class_name : str = \"\" ) Initialize a protocol configuration object. component _ type | @property | component_type () -> ComponentType Get the component type. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"Base"},{"location":"aea/api/configurations/base/#aeaconfigurationsbase","text":"Classes to handle AEA configurations.","title":"aea.configurations.base"},{"location":"aea/api/configurations/base/#dependency","text":"A dependency is a dictionary with the following (optional) keys: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command.","title":"Dependency"},{"location":"aea/api/configurations/base/#dependencies","text":"A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.","title":"Dependencies"},{"location":"aea/api/configurations/base/#packagetype","text":"class PackageType ( Enum ) Package types.","title":"PackageType"},{"location":"aea/api/configurations/base/#to_plural","text":"| to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts'","title":"to_plural"},{"location":"aea/api/configurations/base/#__str__","text":"| __str__ () Convert to string.","title":"__str__"},{"location":"aea/api/configurations/base/#componenttype","text":"class ComponentType ( Enum ) Enum of component types supported.","title":"ComponentType"},{"location":"aea/api/configurations/base/#to_configuration_type","text":"| to_configuration_type () -> PackageType Get package type for component type.","title":"to_configuration_type"},{"location":"aea/api/configurations/base/#to_plural_1","text":"| to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts'","title":"to_plural"},{"location":"aea/api/configurations/base/#__str___1","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/base/#protocolspecificationparseerror","text":"class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file.","title":"ProtocolSpecificationParseError"},{"location":"aea/api/configurations/base/#jsonserializable","text":"class JSONSerializable ( ABC ) Interface for JSON-serializable objects.","title":"JSONSerializable"},{"location":"aea/api/configurations/base/#json","text":"| @property | @abstractmethod | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#configuration","text":"class Configuration ( JSONSerializable , ABC ) Configuration class.","title":"Configuration"},{"location":"aea/api/configurations/base/#__init__","text":"| __init__ () Initialize a configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#ordered_json","text":"| @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary.","title":"ordered_json"},{"location":"aea/api/configurations/base/#crudcollection","text":"class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection.","title":"CRUDCollection"},{"location":"aea/api/configurations/base/#__init___1","text":"| __init__ () Instantiate a CRUD collection.","title":"__init__"},{"location":"aea/api/configurations/base/#create","text":"| create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection.","title":"create"},{"location":"aea/api/configurations/base/#read","text":"| read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present.","title":"read"},{"location":"aea/api/configurations/base/#update","text":"| update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None","title":"update"},{"location":"aea/api/configurations/base/#delete","text":"| delete ( item_id : str ) -> None Delete an item.","title":"delete"},{"location":"aea/api/configurations/base/#read_all","text":"| read_all () -> List [ Tuple [ str , T ]] Read all the items.","title":"read_all"},{"location":"aea/api/configurations/base/#publicid","text":"class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id","title":"PublicId"},{"location":"aea/api/configurations/base/#__init___2","text":"| __init__ ( author : str , name : str , version : PackageVersionLike ) Initialize the public identifier.","title":"__init__"},{"location":"aea/api/configurations/base/#author","text":"| @property | author () -> str Get the author.","title":"author"},{"location":"aea/api/configurations/base/#name","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/base/#version","text":"| @property | version () -> str Get the version.","title":"version"},{"location":"aea/api/configurations/base/#version_info","text":"| @property | version_info () -> PackageVersion Get the package version.","title":"version_info"},{"location":"aea/api/configurations/base/#from_str","text":"| @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_str"},{"location":"aea/api/configurations/base/#from_uri_path","text":"| @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/base/#to_uri_path","text":"| @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/base/#json_1","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_2","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#__hash__","text":"| __hash__ () Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/base/#__str___2","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/base/#__repr__","text":"| __repr__ () Get the representation.","title":"__repr__"},{"location":"aea/api/configurations/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/base/#__lt__","text":"| __lt__ ( other ) Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author and name attributes are different.","title":"__lt__"},{"location":"aea/api/configurations/base/#packageid","text":"class PackageId () A package identifier.","title":"PackageId"},{"location":"aea/api/configurations/base/#__init___3","text":"| __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) Initialize the package id. Arguments : package_type : the package type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/base/#package_type","text":"| @property | package_type () -> PackageType Get the package type.","title":"package_type"},{"location":"aea/api/configurations/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/base/#author_1","text":"| @property | author () -> str Get the author of the package.","title":"author"},{"location":"aea/api/configurations/base/#name_1","text":"| @property | name () -> str Get the name of the package.","title":"name"},{"location":"aea/api/configurations/base/#version_1","text":"| @property | version () -> str Get the version of the package.","title":"version"},{"location":"aea/api/configurations/base/#package_prefix","text":"| @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version.","title":"package_prefix"},{"location":"aea/api/configurations/base/#__hash___1","text":"| __hash__ () Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/base/#__str___3","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/base/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/base/#__lt___1","text":"| __lt__ ( other ) Compare two public ids.","title":"__lt__"},{"location":"aea/api/configurations/base/#componentid","text":"class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False","title":"ComponentId"},{"location":"aea/api/configurations/base/#__init___4","text":"| __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) Initialize the component id. Arguments : component_type : the component type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#component_prefix","text":"| @property | component_prefix () -> Tuple [ ComponentType , str , str ] Get the component identifier without the version.","title":"component_prefix"},{"location":"aea/api/configurations/base/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/base/#packageconfiguration","text":"class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts","title":"PackageConfiguration"},{"location":"aea/api/configurations/base/#__init___5","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None ) Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint.","title":"__init__"},{"location":"aea/api/configurations/base/#directory","text":"| @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any.","title":"directory"},{"location":"aea/api/configurations/base/#aea_version_specifiers","text":"| @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier.","title":"aea_version_specifiers"},{"location":"aea/api/configurations/base/#public_id_1","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/base/#package_dependencies","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#componentconfiguration","text":"class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration.","title":"ComponentConfiguration"},{"location":"aea/api/configurations/base/#__init___6","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , dependencies : Optional [ Dependencies ] = None ) Set component configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#pypi_dependencies","text":"| @property | pypi_dependencies () -> Dependencies Get PyPI dependencies.","title":"pypi_dependencies"},{"location":"aea/api/configurations/base/#component_type_1","text":"| @property | @abstractmethod | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#component_id","text":"| @property | component_id () -> ComponentId Get the component id.","title":"component_id"},{"location":"aea/api/configurations/base/#prefix_import_path_1","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/base/#load","text":"| @staticmethod | load ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False ) -> \"ComponentConfiguration\" Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object.","title":"load"},{"location":"aea/api/configurations/base/#check_fingerprint","text":"| check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. :raises ValueError if: - the argument is not a valid package directory - the fingerprints do not match.","title":"check_fingerprint"},{"location":"aea/api/configurations/base/#check_aea_version","text":"| check_aea_version () Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier.","title":"check_aea_version"},{"location":"aea/api/configurations/base/#connectionconfig","text":"class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration.","title":"ConnectionConfig"},{"location":"aea/api/configurations/base/#__init___7","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , ** config , ,) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#component_type_2","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#package_dependencies_1","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#json_2","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolconfig","text":"class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration.","title":"ProtocolConfig"},{"location":"aea/api/configurations/base/#__init___8","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#component_type_3","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#json_3","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_4","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#skillcomponentconfiguration","text":"class SkillComponentConfiguration () This class represent a skill component configuration.","title":"SkillComponentConfiguration"},{"location":"aea/api/configurations/base/#__init___9","text":"| __init__ ( class_name : str , ** args ) Initialize a skill component configuration. Arguments : skill_component_type : the skill component type. class_name : the class name of the component. args : keyword arguments.","title":"__init__"},{"location":"aea/api/configurations/base/#json_4","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_5","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#skillconfig","text":"class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file.","title":"SkillConfig"},{"location":"aea/api/configurations/base/#__init___10","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , protocols : List [ PublicId ] = None , contracts : List [ PublicId ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a skill configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#component_type_4","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#package_dependencies_2","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#json_5","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_6","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#agentconfig","text":"class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file.","title":"AgentConfig"},{"location":"aea/api/configurations/base/#__init___11","text":"| __init__ ( agent_name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , registry_path : str = DEFAULT_REGISTRY_PATH , description : str = \"\" , logging_config : Optional [ Dict ] = None , timeout : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , default_routing : Optional [ Dict ] = None , loop_mode : Optional [ str ] = None ) Instantiate the agent configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#package_dependencies_3","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#private_key_paths_dict","text":"| @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths.","title":"private_key_paths_dict"},{"location":"aea/api/configurations/base/#ledger_apis_dict","text":"| @property | ledger_apis_dict () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get dictionary version of ledger apis.","title":"ledger_apis_dict"},{"location":"aea/api/configurations/base/#default_connection","text":"| @default_connection . setter | default_connection ( connection_id : Optional [ Union [ str , PublicId ]]) Set the default connection. Arguments : connection_id : the name of the default connection. Returns : None","title":"default_connection"},{"location":"aea/api/configurations/base/#default_ledger","text":"| @default_ledger . setter | default_ledger ( ledger_id : str ) Set the default ledger. Arguments : ledger_id : the id of the default ledger. Returns : None","title":"default_ledger"},{"location":"aea/api/configurations/base/#json_6","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_7","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#speechactcontentconfig","text":"class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration.","title":"SpeechActContentConfig"},{"location":"aea/api/configurations/base/#__init___12","text":"| __init__ ( ** args ) Initialize a speech_act content configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_7","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_8","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolspecification","text":"class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification.","title":"ProtocolSpecification"},{"location":"aea/api/configurations/base/#__init___13","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , description : str = \"\" ) Initialize a protocol specification configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#protobuf_snippets","text":"| @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) Set the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#dialogue_config","text":"| @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) Set the dialogue config.","title":"dialogue_config"},{"location":"aea/api/configurations/base/#json_8","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_9","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#contractconfig","text":"class ContractConfig ( ComponentConfiguration ) Handle contract configuration.","title":"ContractConfig"},{"location":"aea/api/configurations/base/#__init___14","text":"| __init__ ( name : str , author : str , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , path_to_contract_interface : str = \"\" , class_name : str = \"\" ) Initialize a protocol configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#component_type_5","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#json_9","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_10","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/components/","text":"aea.configurations.components This module contains definitions of agent components. Component class Component ( ABC ) Abstract class for an agent component. __ init __ | __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False ) Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized. component _ type | @property | component_type () -> ComponentType Get the component type. is _ vendor | @property | is_vendor () -> bool Get whether the component is vendorized or not. prefix _ import _ path | @property | prefix_import_path () Get the prefix import path for this component. component _ id | @property | component_id () -> ComponentId Ge the package id. public _ id | @property | public_id () -> PublicId Get the public id. configuration | @property | configuration () -> ComponentConfiguration Get the component configuration. directory | @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set.","title":"Components"},{"location":"aea/api/configurations/components/#aeaconfigurationscomponents","text":"This module contains definitions of agent components.","title":"aea.configurations.components"},{"location":"aea/api/configurations/components/#component","text":"class Component ( ABC ) Abstract class for an agent component.","title":"Component"},{"location":"aea/api/configurations/components/#__init__","text":"| __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False ) Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized.","title":"__init__"},{"location":"aea/api/configurations/components/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/components/#is_vendor","text":"| @property | is_vendor () -> bool Get whether the component is vendorized or not.","title":"is_vendor"},{"location":"aea/api/configurations/components/#prefix_import_path","text":"| @property | prefix_import_path () Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/components/#component_id","text":"| @property | component_id () -> ComponentId Ge the package id.","title":"component_id"},{"location":"aea/api/configurations/components/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/components/#configuration","text":"| @property | configuration () -> ComponentConfiguration Get the component configuration.","title":"configuration"},{"location":"aea/api/configurations/components/#directory","text":"| @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set.","title":"directory"},{"location":"aea/api/configurations/loader/","text":"aea.configurations.loader Implementation of the parser for configuration file. make _ jsonschema _ base _ uri make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form. ConfigLoader class ConfigLoader ( Generic [ T ]) This class implement parsing, serialization and validation functionalities for the 'aea' configuration files. __ init __ | __init__ ( schema_filename : str , configuration_class : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.) validator | @property | validator () -> Draft4Validator Get the json schema validator. configuration _ class | @property | configuration_class () -> Type [ T ] Get the configuration class of the loader. load _ protocol _ specification | load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises load | load ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises dump | dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None from _ configuration _ type | @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type.","title":"Loader"},{"location":"aea/api/configurations/loader/#aeaconfigurationsloader","text":"Implementation of the parser for configuration file.","title":"aea.configurations.loader"},{"location":"aea/api/configurations/loader/#make_jsonschema_base_uri","text":"make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form.","title":"make_jsonschema_base_uri"},{"location":"aea/api/configurations/loader/#configloader","text":"class ConfigLoader ( Generic [ T ]) This class implement parsing, serialization and validation functionalities for the 'aea' configuration files.","title":"ConfigLoader"},{"location":"aea/api/configurations/loader/#__init__","text":"| __init__ ( schema_filename : str , configuration_class : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.)","title":"__init__"},{"location":"aea/api/configurations/loader/#validator","text":"| @property | validator () -> Draft4Validator Get the json schema validator.","title":"validator"},{"location":"aea/api/configurations/loader/#configuration_class","text":"| @property | configuration_class () -> Type [ T ] Get the configuration class of the loader.","title":"configuration_class"},{"location":"aea/api/configurations/loader/#load_protocol_specification","text":"| load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load_protocol_specification"},{"location":"aea/api/configurations/loader/#load","text":"| load ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load"},{"location":"aea/api/configurations/loader/#dump","text":"| dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None","title":"dump"},{"location":"aea/api/configurations/loader/#from_configuration_type","text":"| @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type.","title":"from_configuration_type"},{"location":"aea/api/connections/base/","text":"aea.connections.base The base connection package. ConnectionStatus class ConnectionStatus () The connection status class. __ init __ | __init__ () Initialize the connection status. Connection class Connection ( Component , ABC ) Abstract definition of a connection. __ init __ | __init__ ( configuration : Optional [ ConnectionConfig ] = None , address : Optional [ \"Address\" ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , connection_id : Optional [ PublicId ] = None ) Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. address : the address. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. connection_id : the connection identifier. loop | @loop . setter | loop ( loop : AbstractEventLoop ) -> None Set the event loop. Arguments : loop : the event loop. Returns : None address | @address . setter | address ( address : \"Address\" ) -> None Set the address to be used by the connection. Arguments : address : a public key. Returns : None component _ type | @property | component_type () -> ComponentType Get the component type. connection _ id | @property | connection_id () -> PublicId Get the id of the connection. configuration | @property | configuration () -> ConnectionConfig Get the connection configuration. excluded _ protocols | @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection. connection _ status | @property | connection_status () -> ConnectionStatus Get the connection status. connect | @abstractmethod | async connect () Set up the connection. disconnect | @abstractmethod | async disconnect () Tear down the connection. send | @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None receive | @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred. from _ config | @classmethod | from_config ( cls , address : \"Address\" , configuration : ConnectionConfig ) -> \"Connection\" Initialize a connection instance from a configuration. Arguments : address : the address of the agent. configuration : the connection configuration. Returns : an instance of the concrete connection class.","title":"Base"},{"location":"aea/api/connections/base/#aeaconnectionsbase","text":"The base connection package.","title":"aea.connections.base"},{"location":"aea/api/connections/base/#connectionstatus","text":"class ConnectionStatus () The connection status class.","title":"ConnectionStatus"},{"location":"aea/api/connections/base/#__init__","text":"| __init__ () Initialize the connection status.","title":"__init__"},{"location":"aea/api/connections/base/#connection","text":"class Connection ( Component , ABC ) Abstract definition of a connection.","title":"Connection"},{"location":"aea/api/connections/base/#__init___1","text":"| __init__ ( configuration : Optional [ ConnectionConfig ] = None , address : Optional [ \"Address\" ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , connection_id : Optional [ PublicId ] = None ) Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. address : the address. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. connection_id : the connection identifier.","title":"__init__"},{"location":"aea/api/connections/base/#loop","text":"| @loop . setter | loop ( loop : AbstractEventLoop ) -> None Set the event loop. Arguments : loop : the event loop. Returns : None","title":"loop"},{"location":"aea/api/connections/base/#address","text":"| @address . setter | address ( address : \"Address\" ) -> None Set the address to be used by the connection. Arguments : address : a public key. Returns : None","title":"address"},{"location":"aea/api/connections/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/connections/base/#connection_id","text":"| @property | connection_id () -> PublicId Get the id of the connection.","title":"connection_id"},{"location":"aea/api/connections/base/#configuration","text":"| @property | configuration () -> ConnectionConfig Get the connection configuration.","title":"configuration"},{"location":"aea/api/connections/base/#excluded_protocols","text":"| @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection.","title":"excluded_protocols"},{"location":"aea/api/connections/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/connections/base/#connect","text":"| @abstractmethod | async connect () Set up the connection.","title":"connect"},{"location":"aea/api/connections/base/#disconnect","text":"| @abstractmethod | async disconnect () Tear down the connection.","title":"disconnect"},{"location":"aea/api/connections/base/#send","text":"| @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None","title":"send"},{"location":"aea/api/connections/base/#receive","text":"| @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred.","title":"receive"},{"location":"aea/api/connections/base/#from_config","text":"| @classmethod | from_config ( cls , address : \"Address\" , configuration : ConnectionConfig ) -> \"Connection\" Initialize a connection instance from a configuration. Arguments : address : the address of the agent. configuration : the connection configuration. Returns : an instance of the concrete connection class.","title":"from_config"},{"location":"aea/api/connections/stub/connection/","text":"aea.connections.stub.connection This module contains the stub connection. lock _ file @contextmanager lock_file ( file_descriptor : IO [ bytes ]) Lock file in context manager. Arguments : file_descriptor : file descriptio of file to lock. read _ envelopes read_envelopes ( file_pointer : IO [ bytes ]) -> List [ Envelope ] Receive new envelopes, if any. write _ envelope write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ]) -> None Write envelope to file. __ init __ | __init__ ( input_file_path : Union [ str , Path ], output_file_path : Union [ str , Path ], ** kwargs ) Initialize a stub connection. Arguments : input_file_path : the input file for the incoming messages. output_file_path : the output file for the outgoing messages. read _ envelopes | read_envelopes () -> None Receive new envelopes, if any. receive | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. connect | async connect () -> None Set up the connection. disconnect | async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect. send | async send ( envelope : Envelope ) Send messages. Returns : None from _ config | @classmethod | from_config ( cls , address : Address , configuration : ConnectionConfig ) -> \"Connection\" Get the stub connection from the connection configuration. Arguments : address : the address of the agent. configuration : the connection configuration object. Returns : the connection object","title":"Stub Connection"},{"location":"aea/api/connections/stub/connection/#aeaconnectionsstubconnection","text":"This module contains the stub connection.","title":"aea.connections.stub.connection"},{"location":"aea/api/connections/stub/connection/#lock_file","text":"@contextmanager lock_file ( file_descriptor : IO [ bytes ]) Lock file in context manager. Arguments : file_descriptor : file descriptio of file to lock.","title":"lock_file"},{"location":"aea/api/connections/stub/connection/#read_envelopes","text":"read_envelopes ( file_pointer : IO [ bytes ]) -> List [ Envelope ] Receive new envelopes, if any.","title":"read_envelopes"},{"location":"aea/api/connections/stub/connection/#write_envelope","text":"write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ]) -> None Write envelope to file.","title":"write_envelope"},{"location":"aea/api/connections/stub/connection/#__init__","text":"| __init__ ( input_file_path : Union [ str , Path ], output_file_path : Union [ str , Path ], ** kwargs ) Initialize a stub connection. Arguments : input_file_path : the input file for the incoming messages. output_file_path : the output file for the outgoing messages.","title":"__init__"},{"location":"aea/api/connections/stub/connection/#read_envelopes_1","text":"| read_envelopes () -> None Receive new envelopes, if any.","title":"read_envelopes"},{"location":"aea/api/connections/stub/connection/#receive","text":"| async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope.","title":"receive"},{"location":"aea/api/connections/stub/connection/#connect","text":"| async connect () -> None Set up the connection.","title":"connect"},{"location":"aea/api/connections/stub/connection/#disconnect","text":"| async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect.","title":"disconnect"},{"location":"aea/api/connections/stub/connection/#send","text":"| async send ( envelope : Envelope ) Send messages. Returns : None","title":"send"},{"location":"aea/api/connections/stub/connection/#from_config","text":"| @classmethod | from_config ( cls , address : Address , configuration : ConnectionConfig ) -> \"Connection\" Get the stub connection from the connection configuration. Arguments : address : the address of the agent. configuration : the connection configuration object. Returns : the connection object","title":"from_config"},{"location":"aea/api/context/base/","text":"aea.context.base This module contains the agent context class. AgentContext class AgentContext () Provide read access to relevant objects of the agent for the skills. __ init __ | __init__ ( identity : Identity , ledger_apis : LedgerApis , connection_status : ConnectionStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , ** kwargs ) Initialize an agent context. Arguments : identity : the identity object ledger_apis : the APIs the agent will use to connect to ledgers. connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager kwargs : keyword arguments to be attached in the agent context namespace. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. identity | @property | identity () -> Identity Get the identity. agent _ name | @property | agent_name () -> str Get agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get addresses. address | @property | address () -> Address Get the default address. connection _ status | @property | connection_status () -> ConnectionStatus Get connection status of the multiplexer. outbox | @property | outbox () -> OutBox Get outbox. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get decision maker queue. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context. ledger _ apis | @property | ledger_apis () -> LedgerApis Get the ledger APIs. task _ manager | @property | task_manager () -> TaskManager Get the task manager. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"Context"},{"location":"aea/api/context/base/#aeacontextbase","text":"This module contains the agent context class.","title":"aea.context.base"},{"location":"aea/api/context/base/#agentcontext","text":"class AgentContext () Provide read access to relevant objects of the agent for the skills.","title":"AgentContext"},{"location":"aea/api/context/base/#__init__","text":"| __init__ ( identity : Identity , ledger_apis : LedgerApis , connection_status : ConnectionStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , ** kwargs ) Initialize an agent context. Arguments : identity : the identity object ledger_apis : the APIs the agent will use to connect to ledgers. connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager kwargs : keyword arguments to be attached in the agent context namespace.","title":"__init__"},{"location":"aea/api/context/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills.","title":"shared_state"},{"location":"aea/api/context/base/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/context/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/context/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get addresses.","title":"addresses"},{"location":"aea/api/context/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/context/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get connection status of the multiplexer.","title":"connection_status"},{"location":"aea/api/context/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/context/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get decision maker queue.","title":"decision_maker_message_queue"},{"location":"aea/api/context/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/context/base/#ledger_apis","text":"| @property | ledger_apis () -> LedgerApis Get the ledger APIs.","title":"ledger_apis"},{"location":"aea/api/context/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/context/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/context/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/contracts/base/","text":"aea.contracts.base The base contract. Contract class Contract ( Component , ABC ) Abstract definition of a contract. __ init __ | __init__ ( config : ContractConfig , contract_interface : Dict [ str , Any ]) Initialize the contract. Arguments : config : the contract configurations. contract_interface : the contract interface id | @property | id () -> ContractId Get the name. config | @property | config () -> ContractConfig Get the configuration. contract _ interface | @property | contract_interface () -> Dict [ str , Any ] Get the contract interface. set _ instance | @abstractmethod | set_instance ( ledger_api : LedgerApi ) -> None Set the instance. Arguments : ledger_api : the ledger api we are using. Returns : None set _ address | @abstractmethod | set_address ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None set _ deployed _ instance | @abstractmethod | set_deployed_instance ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None from _ dir | @classmethod | from_dir ( cls , directory : str ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the contract object. from _ config | @classmethod | from_config ( cls , configuration : ContractConfig ) -> \"Contract\" Load contract from configuration Arguments : configuration : the contract configuration. Returns : the contract object.","title":"Base"},{"location":"aea/api/contracts/base/#aeacontractsbase","text":"The base contract.","title":"aea.contracts.base"},{"location":"aea/api/contracts/base/#contract","text":"class Contract ( Component , ABC ) Abstract definition of a contract.","title":"Contract"},{"location":"aea/api/contracts/base/#__init__","text":"| __init__ ( config : ContractConfig , contract_interface : Dict [ str , Any ]) Initialize the contract. Arguments : config : the contract configurations. contract_interface : the contract interface","title":"__init__"},{"location":"aea/api/contracts/base/#id","text":"| @property | id () -> ContractId Get the name.","title":"id"},{"location":"aea/api/contracts/base/#config","text":"| @property | config () -> ContractConfig Get the configuration.","title":"config"},{"location":"aea/api/contracts/base/#contract_interface","text":"| @property | contract_interface () -> Dict [ str , Any ] Get the contract interface.","title":"contract_interface"},{"location":"aea/api/contracts/base/#set_instance","text":"| @abstractmethod | set_instance ( ledger_api : LedgerApi ) -> None Set the instance. Arguments : ledger_api : the ledger api we are using. Returns : None","title":"set_instance"},{"location":"aea/api/contracts/base/#set_address","text":"| @abstractmethod | set_address ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None","title":"set_address"},{"location":"aea/api/contracts/base/#set_deployed_instance","text":"| @abstractmethod | set_deployed_instance ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None","title":"set_deployed_instance"},{"location":"aea/api/contracts/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the contract object.","title":"from_dir"},{"location":"aea/api/contracts/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ContractConfig ) -> \"Contract\" Load contract from configuration Arguments : configuration : the contract configuration. Returns : the contract object.","title":"from_config"},{"location":"aea/api/contracts/ethereum/","text":"aea.contracts.ethereum The base ethereum contract. Contract class Contract ( BaseContract ) Definition of an ethereum contract. __ init __ | __init__ ( config : ContractConfig , contract_interface : Dict [ str , Any ]) Initialize the contract. Arguments : config : the contract configurations. contract_interface : the contract interface. set _ instance | set_instance ( ledger_api : LedgerApi ) -> None Set the instance. Arguments : ledger_api : the ledger api we are using. Returns : None set _ address | set_address ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None set _ deployed _ instance | set_deployed_instance ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None","title":"Ethereum"},{"location":"aea/api/contracts/ethereum/#aeacontractsethereum","text":"The base ethereum contract.","title":"aea.contracts.ethereum"},{"location":"aea/api/contracts/ethereum/#contract","text":"class Contract ( BaseContract ) Definition of an ethereum contract.","title":"Contract"},{"location":"aea/api/contracts/ethereum/#__init__","text":"| __init__ ( config : ContractConfig , contract_interface : Dict [ str , Any ]) Initialize the contract. Arguments : config : the contract configurations. contract_interface : the contract interface.","title":"__init__"},{"location":"aea/api/contracts/ethereum/#set_instance","text":"| set_instance ( ledger_api : LedgerApi ) -> None Set the instance. Arguments : ledger_api : the ledger api we are using. Returns : None","title":"set_instance"},{"location":"aea/api/contracts/ethereum/#set_address","text":"| set_address ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None","title":"set_address"},{"location":"aea/api/contracts/ethereum/#set_deployed_instance","text":"| set_deployed_instance ( ledger_api : LedgerApi , contract_address : str ) -> None Set the contract address. Arguments : ledger_api : the ledger_api we are using. contract_address : the contract address Returns : None","title":"set_deployed_instance"},{"location":"aea/api/crypto/base/","text":"aea.crypto.base Abstract module wrapping the public and private key cryptography and ledger api. Crypto class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , ** kwargs ) Initialize the crypto object. The actual behaivour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. kwargs : keyword arguments. generate _ private _ key | @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent. load _ private _ key _ from _ path | @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str ) -> EntityClass Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the entity object. entity | @property | entity () -> EntityClass Return an entity object. Returns : an entity object public _ key | @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string address | @property | @abstractmethod | address () -> str Return the address. Returns : an address string get _ address _ from _ public _ key | @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str sign _ message | @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | @abstractmethod | sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction recover _ message | @abstractmethod | recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses dump | @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None LedgerApi class LedgerApi ( ABC ) Interface for ledger APIs. api | @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. get _ balance | @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance. transfer | @abstractmethod | transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx Returns : tx digest if successful, otherwise None send _ signed _ transaction | @abstractmethod | send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction is _ transaction _ settled | @abstractmethod | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. is _ transaction _ valid | @abstractmethod | is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the transaction referenced by the tx_digest matches the terms. get _ transaction _ receipt | @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present generate _ tx _ nonce | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. FaucetApi class FaucetApi ( ABC ) Interface for testnet faucet APIs. get _ wealth | @abstractmethod | get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"Base"},{"location":"aea/api/crypto/base/#aeacryptobase","text":"Abstract module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.base"},{"location":"aea/api/crypto/base/#crypto","text":"class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object.","title":"Crypto"},{"location":"aea/api/crypto/base/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , ** kwargs ) Initialize the crypto object. The actual behaivour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. kwargs : keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/base/#generate_private_key","text":"| @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent.","title":"generate_private_key"},{"location":"aea/api/crypto/base/#load_private_key_from_path","text":"| @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str ) -> EntityClass Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the entity object.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/base/#entity","text":"| @property | entity () -> EntityClass Return an entity object. Returns : an entity object","title":"entity"},{"location":"aea/api/crypto/base/#public_key","text":"| @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string","title":"public_key"},{"location":"aea/api/crypto/base/#address","text":"| @property | @abstractmethod | address () -> str Return the address. Returns : an address string","title":"address"},{"location":"aea/api/crypto/base/#get_address_from_public_key","text":"| @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/base/#sign_message","text":"| @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/base/#sign_transaction","text":"| @abstractmethod | sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/base/#recover_message","text":"| @abstractmethod | recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/base/#dump","text":"| @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/base/#ledgerapi","text":"class LedgerApi ( ABC ) Interface for ledger APIs.","title":"LedgerApi"},{"location":"aea/api/crypto/base/#api","text":"| @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None.","title":"api"},{"location":"aea/api/crypto/base/#get_balance","text":"| @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance.","title":"get_balance"},{"location":"aea/api/crypto/base/#transfer","text":"| @abstractmethod | transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx Returns : tx digest if successful, otherwise None","title":"transfer"},{"location":"aea/api/crypto/base/#send_signed_transaction","text":"| @abstractmethod | send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction","title":"send_signed_transaction"},{"location":"aea/api/crypto/base/#is_transaction_settled","text":"| @abstractmethod | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/base/#is_transaction_valid","text":"| @abstractmethod | is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the transaction referenced by the tx_digest matches the terms.","title":"is_transaction_valid"},{"location":"aea/api/crypto/base/#get_transaction_receipt","text":"| @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/base/#generate_tx_nonce","text":"| @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/base/#faucetapi","text":"class FaucetApi ( ABC ) Interface for testnet faucet APIs.","title":"FaucetApi"},{"location":"aea/api/crypto/base/#get_wealth","text":"| @abstractmethod | get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/cosmos/","text":"aea.crypto.cosmos Cosmos module wrapping the public and private key cryptography and ledger api. CosmosCrypto class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction recover _ message | recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses generate _ private _ key | @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None CosmosApi class CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs. api | @property | api () -> None Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. transfer | transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str = \"\" , denom : str = \"testfet\" , account_number : int = 0 , sequence : int = 0 , gas : int = 80000 , memo : str = \"\" , sync_mode : str = \"sync\" , chain_id : str = \"aea-testnet\" , ** kwargs , ,) -> Optional [ str ] Submit a transfer transaction to the ledger. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : tx digest if present, otherwise None send _ signed _ transaction | send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present is _ transaction _ settled | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present generate _ tx _ nonce | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. is _ transaction _ valid | is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : tx_digest : the transaction digest. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] CosmosFaucetApi class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API. get _ wealth | get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"Cosmos"},{"location":"aea/api/crypto/cosmos/#aeacryptocosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.cosmos"},{"location":"aea/api/crypto/cosmos/#cosmoscrypto","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto"},{"location":"aea/api/crypto/cosmos/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/cosmos/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/cosmos/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/cosmos/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/cosmos/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/cosmos/#sign_transaction","text":"| sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/cosmos/#recover_message","text":"| recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/cosmos/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"aea/api/crypto/cosmos/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/cosmos/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/cosmos/#cosmosapi","text":"class CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"CosmosApi"},{"location":"aea/api/crypto/cosmos/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs.","title":"__init__"},{"location":"aea/api/crypto/cosmos/#api","text":"| @property | api () -> None Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/cosmos/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/cosmos/#transfer","text":"| transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str = \"\" , denom : str = \"testfet\" , account_number : int = 0 , sequence : int = 0 , gas : int = 80000 , memo : str = \"\" , sync_mode : str = \"sync\" , chain_id : str = \"aea-testnet\" , ** kwargs , ,) -> Optional [ str ] Submit a transfer transaction to the ledger. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : tx digest if present, otherwise None","title":"transfer"},{"location":"aea/api/crypto/cosmos/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/cosmos/#is_transaction_settled","text":"| is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/cosmos/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/cosmos/#generate_tx_nonce","text":"| generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/cosmos/#is_transaction_valid","text":"| is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : tx_digest : the transaction digest. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/cosmos/#cosmosfaucetapi","text":"class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API.","title":"CosmosFaucetApi"},{"location":"aea/api/crypto/cosmos/#get_wealth","text":"| get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/ethereum/","text":"aea.crypto.ethereum Ethereum module wrapping the public and private key cryptography and ledger api. EthereumCrypto class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction recover _ message | recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses generate _ private _ key | @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None EthereumApi class EthereumApi ( LedgerApi ) Class to interact with the Ethereum Web3 APIs. __ init __ | __init__ ( address : str , gas_price : str = DEFAULT_GAS_PRICE ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs. api | @property | api () -> Web3 Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. transfer | transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 1 , ** kwargs , ,) -> Optional [ str ] Submit a transfer transaction to the ledger. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : tx digest if present, otherwise None send _ signed _ transaction | send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present is _ transaction _ settled | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present generate _ tx _ nonce | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. is _ transaction _ valid | is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : tx_digest : the transaction digest. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] EthereumFaucetApi class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API. get _ wealth | get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"Ethereum"},{"location":"aea/api/crypto/ethereum/#aeacryptoethereum","text":"Ethereum module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.ethereum"},{"location":"aea/api/crypto/ethereum/#ethereumcrypto","text":"class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger.","title":"EthereumCrypto"},{"location":"aea/api/crypto/ethereum/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/ethereum/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/ethereum/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/ethereum/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/ethereum/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/ethereum/#sign_transaction","text":"| sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/ethereum/#recover_message","text":"| recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/ethereum/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network.","title":"generate_private_key"},{"location":"aea/api/crypto/ethereum/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/ethereum/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/ethereum/#ethereumapi","text":"class EthereumApi ( LedgerApi ) Class to interact with the Ethereum Web3 APIs.","title":"EthereumApi"},{"location":"aea/api/crypto/ethereum/#__init___1","text":"| __init__ ( address : str , gas_price : str = DEFAULT_GAS_PRICE ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs.","title":"__init__"},{"location":"aea/api/crypto/ethereum/#api","text":"| @property | api () -> Web3 Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/ethereum/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/ethereum/#transfer","text":"| transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 1 , ** kwargs , ,) -> Optional [ str ] Submit a transfer transaction to the ledger. Arguments : crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : tx digest if present, otherwise None","title":"transfer"},{"location":"aea/api/crypto/ethereum/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/ethereum/#is_transaction_settled","text":"| is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/ethereum/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/ethereum/#generate_tx_nonce","text":"| generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ethereum/#is_transaction_valid","text":"| is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : tx_digest : the transaction digest. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/ethereum/#ethereumfaucetapi","text":"class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API.","title":"EthereumFaucetApi"},{"location":"aea/api/crypto/ethereum/#get_wealth","text":"| get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/fetchai/","text":"aea.crypto.fetchai Fetchai module wrapping the public and private key cryptography and ledger api. FetchAICrypto class FetchAICrypto ( Crypto [ Entity ]) Class wrapping the Entity Generation from Fetch.AI ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate a fetchai crypto object. Arguments : private_key_path : the private key path of the agent public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name : str ) -> Entity Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message we want to send is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction recover _ message | recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> Address Get the address from the public key. Arguments : public_key : the public key Returns : str dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None FetchAIApi class FetchAIApi ( LedgerApi ) Class to interact with the Fetch ledger APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Fetch.AI ledger APIs. Arguments : kwargs : key word arguments (expects either a pair of 'host' and 'port' or a 'network') api | @property | api () -> FetchaiLedgerApi Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. Arguments : address : the address for which to retrieve the balance. Returns : the balance, if retrivable, otherwise None transfer | transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , is_waiting_for_confirmation : bool = True , ** kwargs , ,) -> Optional [ str ] Submit a transaction to the ledger. send _ signed _ transaction | send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction is _ transaction _ settled | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present generate _ tx _ nonce | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. is _ transaction _ valid | is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input'] FetchAIFaucetApi class FetchAIFaucetApi ( FaucetApi ) Fetchai testnet faucet API. get _ wealth | get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"Fetchai"},{"location":"aea/api/crypto/fetchai/#aeacryptofetchai","text":"Fetchai module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.fetchai"},{"location":"aea/api/crypto/fetchai/#fetchaicrypto","text":"class FetchAICrypto ( Crypto [ Entity ]) Class wrapping the Entity Generation from Fetch.AI ledger.","title":"FetchAICrypto"},{"location":"aea/api/crypto/fetchai/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate a fetchai crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/fetchai/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/fetchai/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/fetchai/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name : str ) -> Entity Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/fetchai/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message we want to send is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/fetchai/#sign_transaction","text":"| sign_transaction ( transaction : Any ) -> Any Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/fetchai/#recover_message","text":"| recover_message ( message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/fetchai/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> Address Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/fetchai/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/fetchai/#fetchaiapi","text":"class FetchAIApi ( LedgerApi ) Class to interact with the Fetch ledger APIs.","title":"FetchAIApi"},{"location":"aea/api/crypto/fetchai/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the Fetch.AI ledger APIs. Arguments : kwargs : key word arguments (expects either a pair of 'host' and 'port' or a 'network')","title":"__init__"},{"location":"aea/api/crypto/fetchai/#api","text":"| @property | api () -> FetchaiLedgerApi Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/fetchai/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. Arguments : address : the address for which to retrieve the balance. Returns : the balance, if retrivable, otherwise None","title":"get_balance"},{"location":"aea/api/crypto/fetchai/#transfer","text":"| transfer ( crypto : Crypto , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , is_waiting_for_confirmation : bool = True , ** kwargs , ,) -> Optional [ str ] Submit a transaction to the ledger.","title":"transfer"},{"location":"aea/api/crypto/fetchai/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction","title":"send_signed_transaction"},{"location":"aea/api/crypto/fetchai/#is_transaction_settled","text":"| is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not.","title":"is_transaction_settled"},{"location":"aea/api/crypto/fetchai/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest (non-blocking). Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/fetchai/#generate_tx_nonce","text":"| generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/fetchai/#is_transaction_valid","text":"| is_transaction_valid ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not (non-blocking). Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/fetchai/#fetchaifaucetapi","text":"class FetchAIFaucetApi ( FaucetApi ) Fetchai testnet faucet API.","title":"FetchAIFaucetApi"},{"location":"aea/api/crypto/fetchai/#get_wealth","text":"| get_wealth ( address : Address ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/ledger_apis/","text":"aea.crypto.ledger _ apis Module wrapping all the public and private keys cryptography. LedgerApis class LedgerApis () Store all the ledger apis we initialise. __ init __ | __init__ ( ledger_api_configs : Dict [ str , Dict [ str , Union [ str , int ]]], default_ledger_id : str ) Instantiate a wallet object. Arguments : ledger_api_configs : the ledger api configs. default_ledger_id : the default ledger id. configs | @property | configs () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the configs. apis | @property | apis () -> Dict [ str , LedgerApi ] Get the apis. has _ ledger | has_ledger ( identifier : str ) -> bool Check if it has a . get _ api | get_api ( identifier : str ) -> LedgerApi Get the ledger API. has _ default _ ledger | @property | has_default_ledger () -> bool Check if it has the default ledger API. last _ tx _ statuses | @property | last_tx_statuses () -> Dict [ str , str ] Get last tx statuses. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. token _ balance | token_balance ( identifier : str , address : str ) -> int Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance transfer | transfer ( crypto_object : Crypto , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Transfer from self to destination. Arguments : tx_nonce : verifies the authenticity of the tx crypto_object : the crypto object that contains the fucntions for signing transactions. destination_address : the address of the receive amount : the amount tx_fee : the tx fee Returns : tx digest if successful, otherwise None send _ signed _ transaction | send_signed_transaction ( identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : the tx_digest, if present is _ transaction _ settled | is_transaction_settled ( identifier : str , tx_digest : str ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_digest : the transaction digest Returns : True if correctly settled, False otherwise is _ tx _ valid | is_tx_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Kept for backwards compatibility! is _ transaction _ valid | is_transaction_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid Arguments : identifier : Ledger identifier tx_digest : the transaction digest seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise generate _ tx _ nonce | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#aeacryptoledger_apis","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.ledger_apis"},{"location":"aea/api/crypto/ledger_apis/#ledgerapis","text":"class LedgerApis () Store all the ledger apis we initialise.","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#__init__","text":"| __init__ ( ledger_api_configs : Dict [ str , Dict [ str , Union [ str , int ]]], default_ledger_id : str ) Instantiate a wallet object. Arguments : ledger_api_configs : the ledger api configs. default_ledger_id : the default ledger id.","title":"__init__"},{"location":"aea/api/crypto/ledger_apis/#configs","text":"| @property | configs () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the configs.","title":"configs"},{"location":"aea/api/crypto/ledger_apis/#apis","text":"| @property | apis () -> Dict [ str , LedgerApi ] Get the apis.","title":"apis"},{"location":"aea/api/crypto/ledger_apis/#has_ledger","text":"| has_ledger ( identifier : str ) -> bool Check if it has a .","title":"has_ledger"},{"location":"aea/api/crypto/ledger_apis/#get_api","text":"| get_api ( identifier : str ) -> LedgerApi Get the ledger API.","title":"get_api"},{"location":"aea/api/crypto/ledger_apis/#has_default_ledger","text":"| @property | has_default_ledger () -> bool Check if it has the default ledger API.","title":"has_default_ledger"},{"location":"aea/api/crypto/ledger_apis/#last_tx_statuses","text":"| @property | last_tx_statuses () -> Dict [ str , str ] Get last tx statuses.","title":"last_tx_statuses"},{"location":"aea/api/crypto/ledger_apis/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/crypto/ledger_apis/#token_balance","text":"| token_balance ( identifier : str , address : str ) -> int Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance","title":"token_balance"},{"location":"aea/api/crypto/ledger_apis/#transfer","text":"| transfer ( crypto_object : Crypto , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Transfer from self to destination. Arguments : tx_nonce : verifies the authenticity of the tx crypto_object : the crypto object that contains the fucntions for signing transactions. destination_address : the address of the receive amount : the amount tx_fee : the tx fee Returns : tx digest if successful, otherwise None","title":"transfer"},{"location":"aea/api/crypto/ledger_apis/#send_signed_transaction","text":"| send_signed_transaction ( identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : the tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_settled","text":"| is_transaction_settled ( identifier : str , tx_digest : str ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_digest : the transaction digest Returns : True if correctly settled, False otherwise","title":"is_transaction_settled"},{"location":"aea/api/crypto/ledger_apis/#is_tx_valid","text":"| is_tx_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Kept for backwards compatibility!","title":"is_tx_valid"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_valid","text":"| is_transaction_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid Arguments : identifier : Ledger identifier tx_digest : the transaction digest seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise","title":"is_transaction_valid"},{"location":"aea/api/crypto/ledger_apis/#generate_tx_nonce","text":"| generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/registry/","text":"aea.crypto.registry This module implements the crypto registry. CryptoId class CryptoId ( RegexConstrainedString ) The identifier of a crypto class. __ init __ | __init__ ( seq ) Initialize the crypto id. name | @property | name () Get the id name. EntryPoint class EntryPoint ( RegexConstrainedString ) The entry point for a Crypto resource. The regular expression matches the strings in the following format: path.to.module:className __ init __ | __init__ ( seq ) Initialize the entrypoint. import _ path | @property | import_path () -> str Get the import path. class _ name | @property | class_name () -> str Get the class name. load | load () -> Type [ Crypto ] Load the crypto object. Returns : the cyrpto object, loaded following the spec. CryptoSpec class CryptoSpec ( object ) A specification for a particular instance of a crypto object. __ init __ | __init__ ( id : CryptoId , entry_point : EntryPoint , ** kwargs : Dict , ,) Initialize a crypto specification. Arguments : id : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). kwargs : other custom keyword arguments. make | make ( ** kwargs ) -> Crypto Instantiates an instance of the crypto object with appropriate arguments. CryptoRegistry class CryptoRegistry ( object ) Registry for Crypto classes. __ init __ | __init__ () Initialize the Crypto registry. supported _ crypto _ ids | @property | supported_crypto_ids () -> Set [ str ] Get the supported crypto ids. register | register ( id : CryptoId , entry_point : EntryPoint , ** kwargs ) Register a Crypto module. Arguments : id : the Cyrpto identifier (e.g. 'fetchai', 'ethereum' etc.) entry_point : the entry point, i.e. 'path.to.module:ClassName' Returns : None make | make ( id : CryptoId , module : Optional [ str ] = None , ** kwargs ) -> Crypto Make an instance of the crypto class associated to the given id. Arguments : id : the id of the crypto class. module : see 'module' parameter to 'make'. kwargs : keyword arguments to be forwarded to the Crypto object. Returns : the new Crypto instance. has _ spec | has_spec ( id : CryptoId ) -> bool Check whether there exist a spec associated with a crypto id. Arguments : id : the crypto identifier. Returns : True if it is registered, False otherwise. register register ( id : Union [ CryptoId , str ], entry_point : Union [ EntryPoint , str ], ** kwargs ) -> None Register a crypto type. Arguments : id : the identifier for the crypto type. entry_point : the entry point to load the crypto object. kwargs : arguments to provide to the crypto class. Returns : None. make make ( id : Union [ CryptoId , str ], module : Optional [ str ] = None , ** kwargs ) -> Crypto Create a crypto instance. Arguments : id : the id of the crypto object. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom crypto object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the Crypto object. Returns :","title":"Registry"},{"location":"aea/api/crypto/registry/#aeacryptoregistry","text":"This module implements the crypto registry.","title":"aea.crypto.registry"},{"location":"aea/api/crypto/registry/#cryptoid","text":"class CryptoId ( RegexConstrainedString ) The identifier of a crypto class.","title":"CryptoId"},{"location":"aea/api/crypto/registry/#__init__","text":"| __init__ ( seq ) Initialize the crypto id.","title":"__init__"},{"location":"aea/api/crypto/registry/#name","text":"| @property | name () Get the id name.","title":"name"},{"location":"aea/api/crypto/registry/#entrypoint","text":"class EntryPoint ( RegexConstrainedString ) The entry point for a Crypto resource. The regular expression matches the strings in the following format: path.to.module:className","title":"EntryPoint"},{"location":"aea/api/crypto/registry/#__init___1","text":"| __init__ ( seq ) Initialize the entrypoint.","title":"__init__"},{"location":"aea/api/crypto/registry/#import_path","text":"| @property | import_path () -> str Get the import path.","title":"import_path"},{"location":"aea/api/crypto/registry/#class_name","text":"| @property | class_name () -> str Get the class name.","title":"class_name"},{"location":"aea/api/crypto/registry/#load","text":"| load () -> Type [ Crypto ] Load the crypto object. Returns : the cyrpto object, loaded following the spec.","title":"load"},{"location":"aea/api/crypto/registry/#cryptospec","text":"class CryptoSpec ( object ) A specification for a particular instance of a crypto object.","title":"CryptoSpec"},{"location":"aea/api/crypto/registry/#__init___2","text":"| __init__ ( id : CryptoId , entry_point : EntryPoint , ** kwargs : Dict , ,) Initialize a crypto specification. Arguments : id : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). kwargs : other custom keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/registry/#make","text":"| make ( ** kwargs ) -> Crypto Instantiates an instance of the crypto object with appropriate arguments.","title":"make"},{"location":"aea/api/crypto/registry/#cryptoregistry","text":"class CryptoRegistry ( object ) Registry for Crypto classes.","title":"CryptoRegistry"},{"location":"aea/api/crypto/registry/#__init___3","text":"| __init__ () Initialize the Crypto registry.","title":"__init__"},{"location":"aea/api/crypto/registry/#supported_crypto_ids","text":"| @property | supported_crypto_ids () -> Set [ str ] Get the supported crypto ids.","title":"supported_crypto_ids"},{"location":"aea/api/crypto/registry/#register","text":"| register ( id : CryptoId , entry_point : EntryPoint , ** kwargs ) Register a Crypto module. Arguments : id : the Cyrpto identifier (e.g. 'fetchai', 'ethereum' etc.) entry_point : the entry point, i.e. 'path.to.module:ClassName' Returns : None","title":"register"},{"location":"aea/api/crypto/registry/#make_1","text":"| make ( id : CryptoId , module : Optional [ str ] = None , ** kwargs ) -> Crypto Make an instance of the crypto class associated to the given id. Arguments : id : the id of the crypto class. module : see 'module' parameter to 'make'. kwargs : keyword arguments to be forwarded to the Crypto object. Returns : the new Crypto instance.","title":"make"},{"location":"aea/api/crypto/registry/#has_spec","text":"| has_spec ( id : CryptoId ) -> bool Check whether there exist a spec associated with a crypto id. Arguments : id : the crypto identifier. Returns : True if it is registered, False otherwise.","title":"has_spec"},{"location":"aea/api/crypto/registry/#register_1","text":"register ( id : Union [ CryptoId , str ], entry_point : Union [ EntryPoint , str ], ** kwargs ) -> None Register a crypto type. Arguments : id : the identifier for the crypto type. entry_point : the entry point to load the crypto object. kwargs : arguments to provide to the crypto class. Returns : None.","title":"register"},{"location":"aea/api/crypto/registry/#make_2","text":"make ( id : Union [ CryptoId , str ], module : Optional [ str ] = None , ** kwargs ) -> Crypto Create a crypto instance. Arguments : id : the id of the crypto object. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom crypto object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the Crypto object. Returns :","title":"make"},{"location":"aea/api/crypto/wallet/","text":"aea.crypto.wallet Module wrapping all the public and private keys cryptography. Wallet class Wallet () Store all the cryptos we initialise. __ init __ | __init__ ( private_key_paths : Dict [ str , str ]) Instantiate a wallet object. Arguments : private_key_paths : the private key paths public _ keys | @property | public_keys () Get the public_key dictionary. crypto _ objects | @property | crypto_objects () Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"Wallet"},{"location":"aea/api/crypto/wallet/#aeacryptowallet","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.wallet"},{"location":"aea/api/crypto/wallet/#wallet","text":"class Wallet () Store all the cryptos we initialise.","title":"Wallet"},{"location":"aea/api/crypto/wallet/#__init__","text":"| __init__ ( private_key_paths : Dict [ str , str ]) Instantiate a wallet object. Arguments : private_key_paths : the private key paths","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys","text":"| @property | public_keys () Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects","text":"| @property | crypto_objects () Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/decision_maker/base/","text":"aea.decision _ maker.base This module contains the decision maker class. OwnershipState class OwnershipState ( ABC ) Represent the ownership state of an agent. set | @abstractmethod | set ( ** kwargs ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments Returns : None apply _ delta | @abstractmethod | apply_delta ( ** kwargs ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments Returns : None is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. is _ affordable _ transaction | @abstractmethod | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable (and consistent). Arguments : tx_message : the transaction message Returns : True if the transaction is legal wrt the current state, false otherwise. apply _ transactions | @abstractmethod | apply_transactions ( transactions : List [ TransactionMessage ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : transactions : the sequence of transaction messages. Returns : the final state. __ copy __ | @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object. LedgerStateProxy class LedgerStateProxy ( ABC ) Class to represent a proxy to a ledger state. is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. is _ affordable _ transaction | @abstractmethod | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable on the default ledger. Arguments : tx_message : the transaction message Returns : whether the transaction is affordable on the ledger Preferences class Preferences ( ABC ) Class to represent the preferences. set | @abstractmethod | set ( ** kwargs , ,) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. marginal _ utility | @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword argyments Returns : the marginal utility score utility _ diff _ from _ transaction | @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , tx_message : TransactionMessage ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. tx_message : a transaction message. Returns : the score. __ copy __ | @abstractmethod | __copy__ () -> \"Preferences\" Copy the object. ProtectedQueue class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it. __ init __ | __init__ ( access_code : str ) Initialize the protected queue. Arguments : access_code : the access code to read from the queue put | put ( internal_message : Optional [ InternalMessage ], block = True , timeout = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None put _ nowait | put_nowait ( internal_message : Optional [ InternalMessage ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None get | get ( block = True , timeout = None ) -> None Inaccessible get method. :raises: ValueError, access not permitted. Returns : None get _ nowait | get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted. Returns : None protected _ get | protected_get ( access_code : str , block = True , timeout = None ) -> Optional [ InternalMessage ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message DecisionMakerHandler class DecisionMakerHandler ( ABC ) This class implements the decision maker. __ init __ | __init__ ( identity : Identity , wallet : Wallet , ** kwargs ) Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet kwargs : the key word arguments identity | @property | identity () -> Identity The identity of the agent. wallet | @property | wallet () -> Wallet The wallet of the agent. context | @property | context () -> SimpleNamespace Get the context. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. handle | @abstractmethod | handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None DecisionMaker class DecisionMaker () This class implements the decision maker. __ init __ | __init__ ( decision_maker_handler : DecisionMakerHandler ) Initialize the decision maker. Arguments : agent_name : the agent name decision_maker_handler : the decision maker handler message _ in _ queue | @property | message_in_queue () -> ProtectedQueue Get (in) queue. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. decision _ maker _ handler | @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler. start | start () -> None Start the decision maker. stop | stop () -> None Stop the decision maker. execute | execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them Returns : None handle | handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"Base"},{"location":"aea/api/decision_maker/base/#aeadecision_makerbase","text":"This module contains the decision maker class.","title":"aea.decision_maker.base"},{"location":"aea/api/decision_maker/base/#ownershipstate","text":"class OwnershipState ( ABC ) Represent the ownership state of an agent.","title":"OwnershipState"},{"location":"aea/api/decision_maker/base/#set","text":"| @abstractmethod | set ( ** kwargs ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments Returns : None","title":"set"},{"location":"aea/api/decision_maker/base/#apply_delta","text":"| @abstractmethod | apply_delta ( ** kwargs ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments Returns : None","title":"apply_delta"},{"location":"aea/api/decision_maker/base/#is_initialized","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#is_affordable_transaction","text":"| @abstractmethod | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable (and consistent). Arguments : tx_message : the transaction message Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/base/#apply_transactions","text":"| @abstractmethod | apply_transactions ( transactions : List [ TransactionMessage ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : transactions : the sequence of transaction messages. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/base/#__copy__","text":"| @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#ledgerstateproxy","text":"class LedgerStateProxy ( ABC ) Class to represent a proxy to a ledger state.","title":"LedgerStateProxy"},{"location":"aea/api/decision_maker/base/#is_initialized_1","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#is_affordable_transaction_1","text":"| @abstractmethod | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable on the default ledger. Arguments : tx_message : the transaction message Returns : whether the transaction is affordable on the ledger","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/base/#preferences","text":"class Preferences ( ABC ) Class to represent the preferences.","title":"Preferences"},{"location":"aea/api/decision_maker/base/#set_1","text":"| @abstractmethod | set ( ** kwargs , ,) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments","title":"set"},{"location":"aea/api/decision_maker/base/#is_initialized_2","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#marginal_utility","text":"| @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword argyments Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/base/#utility_diff_from_transaction","text":"| @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , tx_message : TransactionMessage ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. tx_message : a transaction message. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/base/#__copy___1","text":"| @abstractmethod | __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#protectedqueue","text":"class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it.","title":"ProtectedQueue"},{"location":"aea/api/decision_maker/base/#__init__","text":"| __init__ ( access_code : str ) Initialize the protected queue. Arguments : access_code : the access code to read from the queue","title":"__init__"},{"location":"aea/api/decision_maker/base/#put","text":"| put ( internal_message : Optional [ InternalMessage ], block = True , timeout = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None","title":"put"},{"location":"aea/api/decision_maker/base/#put_nowait","text":"| put_nowait ( internal_message : Optional [ InternalMessage ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None","title":"put_nowait"},{"location":"aea/api/decision_maker/base/#get","text":"| get ( block = True , timeout = None ) -> None Inaccessible get method. :raises: ValueError, access not permitted. Returns : None","title":"get"},{"location":"aea/api/decision_maker/base/#get_nowait","text":"| get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted. Returns : None","title":"get_nowait"},{"location":"aea/api/decision_maker/base/#protected_get","text":"| protected_get ( access_code : str , block = True , timeout = None ) -> Optional [ InternalMessage ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message","title":"protected_get"},{"location":"aea/api/decision_maker/base/#decisionmakerhandler","text":"class DecisionMakerHandler ( ABC ) This class implements the decision maker.","title":"DecisionMakerHandler"},{"location":"aea/api/decision_maker/base/#__init___1","text":"| __init__ ( identity : Identity , wallet : Wallet , ** kwargs ) Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet kwargs : the key word arguments","title":"__init__"},{"location":"aea/api/decision_maker/base/#identity","text":"| @property | identity () -> Identity The identity of the agent.","title":"identity"},{"location":"aea/api/decision_maker/base/#wallet","text":"| @property | wallet () -> Wallet The wallet of the agent.","title":"wallet"},{"location":"aea/api/decision_maker/base/#context","text":"| @property | context () -> SimpleNamespace Get the context.","title":"context"},{"location":"aea/api/decision_maker/base/#message_out_queue","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#handle","text":"| @abstractmethod | handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/decision_maker/base/#decisionmaker","text":"class DecisionMaker () This class implements the decision maker.","title":"DecisionMaker"},{"location":"aea/api/decision_maker/base/#__init___2","text":"| __init__ ( decision_maker_handler : DecisionMakerHandler ) Initialize the decision maker. Arguments : agent_name : the agent name decision_maker_handler : the decision maker handler","title":"__init__"},{"location":"aea/api/decision_maker/base/#message_in_queue","text":"| @property | message_in_queue () -> ProtectedQueue Get (in) queue.","title":"message_in_queue"},{"location":"aea/api/decision_maker/base/#message_out_queue_1","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#decision_maker_handler","text":"| @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler.","title":"decision_maker_handler"},{"location":"aea/api/decision_maker/base/#start","text":"| start () -> None Start the decision maker.","title":"start"},{"location":"aea/api/decision_maker/base/#stop","text":"| stop () -> None Stop the decision maker.","title":"stop"},{"location":"aea/api/decision_maker/base/#execute","text":"| execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them Returns : None","title":"execute"},{"location":"aea/api/decision_maker/base/#handle_1","text":"| handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/decision_maker/default/","text":"aea.decision _ maker.default This module contains the decision maker class. GoalPursuitReadiness class GoalPursuitReadiness () The goal pursuit readiness. Status class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal __ init __ | __init__ () Instantiate the goal pursuit readiness. is _ ready | @property | is_ready () -> bool Get the readiness. update | update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status Returns : None OwnershipState class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent. __ init __ | __init__ () Instantiate an ownership state object. Arguments : decision_maker : the decision maker set | set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state. apply _ delta | apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good Returns : None is _ initialized | @property | is_initialized () -> bool Get the initialization status. amount _ by _ currency _ id | @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state. quantities _ by _ good _ id | @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state. is _ affordable _ transaction | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : tx_message : the transaction message Returns : True if the transaction is legal wrt the current state, false otherwise. apply _ transactions | apply_transactions ( transactions : List [ TransactionMessage ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : transactions : the sequence of transaction messages. Returns : the final state. __ copy __ | __copy__ () -> \"OwnershipState\" Copy the object. LedgerStateProxy class LedgerStateProxy ( BaseLedgerStateProxy ) Class to represent a proxy to a ledger state. __ init __ | __init__ ( ledger_apis : LedgerApis ) Instantiate a ledger state proxy. ledger _ apis | @property | ledger_apis () -> LedgerApis Get the ledger_apis. is _ initialized | @property | is_initialized () -> bool Get the initialization status. is _ affordable _ transaction | is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable on the default ledger. Arguments : tx_message : the transaction message Returns : whether the transaction is affordable on the ledger Preferences class Preferences ( BasePreferences ) Class to represent the preferences. __ init __ | __init__ () Instantiate an agent preference object. set | set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , tx_fee : int = None , ** kwargs , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset. tx_fee : the acceptable transaction fee. is _ initialized | @property | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good. seller _ transaction _ fee | @property | seller_transaction_fee () -> int Get the transaction fee. buyer _ transaction _ fee | @property | buyer_transaction_fee () -> int Get the transaction fee. logarithmic _ utility | logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value linear _ utility | linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value utility | utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value. marginal _ utility | marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings Returns : the marginal utility score utility _ diff _ from _ transaction | utility_diff_from_transaction ( ownership_state : BaseOwnershipState , tx_message : TransactionMessage ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. tx_message : a transaction message. Returns : the score. __ copy __ | __copy__ () -> \"Preferences\" Copy the object. DecisionMakerHandler class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker. __ init __ | __init__ ( identity : Identity , wallet : Wallet , ledger_apis : LedgerApis ) Initialize the decision maker. Arguments : identity : the identity wallet : the wallet ledger_apis : the ledger apis handle | handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"Default"},{"location":"aea/api/decision_maker/default/#aeadecision_makerdefault","text":"This module contains the decision maker class.","title":"aea.decision_maker.default"},{"location":"aea/api/decision_maker/default/#goalpursuitreadiness","text":"class GoalPursuitReadiness () The goal pursuit readiness.","title":"GoalPursuitReadiness"},{"location":"aea/api/decision_maker/default/#status","text":"class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal","title":"Status"},{"location":"aea/api/decision_maker/default/#__init__","text":"| __init__ () Instantiate the goal pursuit readiness.","title":"__init__"},{"location":"aea/api/decision_maker/default/#is_ready","text":"| @property | is_ready () -> bool Get the readiness.","title":"is_ready"},{"location":"aea/api/decision_maker/default/#update","text":"| update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status Returns : None","title":"update"},{"location":"aea/api/decision_maker/default/#ownershipstate","text":"class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent.","title":"OwnershipState"},{"location":"aea/api/decision_maker/default/#__init___1","text":"| __init__ () Instantiate an ownership state object. Arguments : decision_maker : the decision maker","title":"__init__"},{"location":"aea/api/decision_maker/default/#set","text":"| set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state.","title":"set"},{"location":"aea/api/decision_maker/default/#apply_delta","text":"| apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good Returns : None","title":"apply_delta"},{"location":"aea/api/decision_maker/default/#is_initialized","text":"| @property | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/default/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state.","title":"amount_by_currency_id"},{"location":"aea/api/decision_maker/default/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state.","title":"quantities_by_good_id"},{"location":"aea/api/decision_maker/default/#is_affordable_transaction","text":"| is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : tx_message : the transaction message Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/default/#apply_transactions","text":"| apply_transactions ( transactions : List [ TransactionMessage ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : transactions : the sequence of transaction messages. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/default/#__copy__","text":"| __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/default/#ledgerstateproxy","text":"class LedgerStateProxy ( BaseLedgerStateProxy ) Class to represent a proxy to a ledger state.","title":"LedgerStateProxy"},{"location":"aea/api/decision_maker/default/#__init___2","text":"| __init__ ( ledger_apis : LedgerApis ) Instantiate a ledger state proxy.","title":"__init__"},{"location":"aea/api/decision_maker/default/#ledger_apis","text":"| @property | ledger_apis () -> LedgerApis Get the ledger_apis.","title":"ledger_apis"},{"location":"aea/api/decision_maker/default/#is_initialized_1","text":"| @property | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/default/#is_affordable_transaction_1","text":"| is_affordable_transaction ( tx_message : TransactionMessage ) -> bool Check if the transaction is affordable on the default ledger. Arguments : tx_message : the transaction message Returns : whether the transaction is affordable on the ledger","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/default/#preferences","text":"class Preferences ( BasePreferences ) Class to represent the preferences.","title":"Preferences"},{"location":"aea/api/decision_maker/default/#__init___3","text":"| __init__ () Instantiate an agent preference object.","title":"__init__"},{"location":"aea/api/decision_maker/default/#set_1","text":"| set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , tx_fee : int = None , ** kwargs , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset. tx_fee : the acceptable transaction fee.","title":"set"},{"location":"aea/api/decision_maker/default/#is_initialized_2","text":"| @property | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/default/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency.","title":"exchange_params_by_currency_id"},{"location":"aea/api/decision_maker/default/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good.","title":"utility_params_by_good_id"},{"location":"aea/api/decision_maker/default/#seller_transaction_fee","text":"| @property | seller_transaction_fee () -> int Get the transaction fee.","title":"seller_transaction_fee"},{"location":"aea/api/decision_maker/default/#buyer_transaction_fee","text":"| @property | buyer_transaction_fee () -> int Get the transaction fee.","title":"buyer_transaction_fee"},{"location":"aea/api/decision_maker/default/#logarithmic_utility","text":"| logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/decision_maker/default/#linear_utility","text":"| linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/decision_maker/default/#utility","text":"| utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value.","title":"utility"},{"location":"aea/api/decision_maker/default/#marginal_utility","text":"| marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/default/#utility_diff_from_transaction","text":"| utility_diff_from_transaction ( ownership_state : BaseOwnershipState , tx_message : TransactionMessage ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. tx_message : a transaction message. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/default/#__copy___1","text":"| __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/default/#decisionmakerhandler","text":"class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker.","title":"DecisionMakerHandler"},{"location":"aea/api/decision_maker/default/#__init___4","text":"| __init__ ( identity : Identity , wallet : Wallet , ledger_apis : LedgerApis ) Initialize the decision maker. Arguments : identity : the identity wallet : the wallet ledger_apis : the ledger apis","title":"__init__"},{"location":"aea/api/decision_maker/default/#handle","text":"| handle ( message : InternalMessage ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/decision_maker/messages/base/","text":"aea.decision _ maker.messages.base This module contains the base message and serialization definition. InternalMessage class InternalMessage () This class implements a message. __ init __ | __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. body | @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None set | set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None get | get ( key : str ) -> Optional [ Any ] Get value for key. unset | unset ( key : str ) -> None Unset value for key. Arguments : key : the key to unset the value of is _ set | is_set ( key : str ) -> bool Check value is set for key. Arguments : key : the key to check __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the message.","title":"Base"},{"location":"aea/api/decision_maker/messages/base/#aeadecision_makermessagesbase","text":"This module contains the base message and serialization definition.","title":"aea.decision_maker.messages.base"},{"location":"aea/api/decision_maker/messages/base/#internalmessage","text":"class InternalMessage () This class implements a message.","title":"InternalMessage"},{"location":"aea/api/decision_maker/messages/base/#__init__","text":"| __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"aea/api/decision_maker/messages/base/#body","text":"| @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None","title":"body"},{"location":"aea/api/decision_maker/messages/base/#set","text":"| set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None","title":"set"},{"location":"aea/api/decision_maker/messages/base/#get","text":"| get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"aea/api/decision_maker/messages/base/#unset","text":"| unset ( key : str ) -> None Unset value for key. Arguments : key : the key to unset the value of","title":"unset"},{"location":"aea/api/decision_maker/messages/base/#is_set","text":"| is_set ( key : str ) -> bool Check value is set for key. Arguments : key : the key to check","title":"is_set"},{"location":"aea/api/decision_maker/messages/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/decision_maker/messages/base/#__str__","text":"| __str__ () Get the string representation of the message.","title":"__str__"},{"location":"aea/api/decision_maker/messages/state_update/","text":"aea.decision _ maker.messages.state _ update The state update message module. StateUpdateMessage class StateUpdateMessage ( InternalMessage ) The state update message class. Performative class Performative ( Enum ) State update performative. __ init __ | __init__ ( performative : Performative , amount_by_currency_id : Currencies , quantities_by_good_id : Goods , ** kwargs ) Instantiate transaction message. Arguments : performative : the performative amount_by_currency_id : the amounts of currencies. quantities_by_good_id : the quantities of goods. performative | @property | performative () -> Performative Get the performative of the message. amount _ by _ currency _ id | @property | amount_by_currency_id () -> Currencies Get the amount by currency. quantities _ by _ good _ id | @property | quantities_by_good_id () -> Goods Get the quantities by good id. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> ExchangeParams Get the exchange parameters by currency from the message. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> UtilityParams Get the utility parameters by good id. tx _ fee | @property | tx_fee () -> int Get the transaction fee.","title":"State Update"},{"location":"aea/api/decision_maker/messages/state_update/#aeadecision_makermessagesstate_update","text":"The state update message module.","title":"aea.decision_maker.messages.state_update"},{"location":"aea/api/decision_maker/messages/state_update/#stateupdatemessage","text":"class StateUpdateMessage ( InternalMessage ) The state update message class.","title":"StateUpdateMessage"},{"location":"aea/api/decision_maker/messages/state_update/#performative","text":"class Performative ( Enum ) State update performative.","title":"Performative"},{"location":"aea/api/decision_maker/messages/state_update/#__init__","text":"| __init__ ( performative : Performative , amount_by_currency_id : Currencies , quantities_by_good_id : Goods , ** kwargs ) Instantiate transaction message. Arguments : performative : the performative amount_by_currency_id : the amounts of currencies. quantities_by_good_id : the quantities of goods.","title":"__init__"},{"location":"aea/api/decision_maker/messages/state_update/#performative_1","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/decision_maker/messages/state_update/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> Currencies Get the amount by currency.","title":"amount_by_currency_id"},{"location":"aea/api/decision_maker/messages/state_update/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> Goods Get the quantities by good id.","title":"quantities_by_good_id"},{"location":"aea/api/decision_maker/messages/state_update/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> ExchangeParams Get the exchange parameters by currency from the message.","title":"exchange_params_by_currency_id"},{"location":"aea/api/decision_maker/messages/state_update/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> UtilityParams Get the utility parameters by good id.","title":"utility_params_by_good_id"},{"location":"aea/api/decision_maker/messages/state_update/#tx_fee","text":"| @property | tx_fee () -> int Get the transaction fee.","title":"tx_fee"},{"location":"aea/api/decision_maker/messages/transaction/","text":"aea.decision _ maker.messages.transaction The transaction message module. TransactionMessage class TransactionMessage ( InternalMessage ) The transaction message class. Performative class Performative ( Enum ) Transaction performative. __ init __ | __init__ ( performative : Performative , skill_callback_ids : Sequence [ PublicId ], tx_id : TransactionId , tx_sender_addr : Address , tx_counterparty_addr : Address , tx_amount_by_currency_id : Dict [ str , int ], tx_sender_fee : int , tx_counterparty_fee : int , tx_quantities_by_good_id : Dict [ str , int ], ledger_id : LedgerId , info : Dict [ str , Any ], ** kwargs ) Instantiate transaction message. Arguments : performative : the performative skill_callback_ids : the list public ids of skills to receive the transaction message response tx_id : the id of the transaction. tx_sender_addr : the sender address of the transaction. tx_counterparty_addr : the counterparty address of the transaction. tx_amount_by_currency_id : the amount by the currency of the transaction. tx_sender_fee : the part of the tx fee paid by the sender tx_counterparty_fee : the part of the tx fee paid by the counterparty tx_quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. ledger_id : the ledger id info : a dictionary for arbitrary information performative | @property | performative () -> Performative Get the performative of the message. skill _ callback _ ids | @property | skill_callback_ids () -> List [ PublicId ] Get the list of skill_callback_ids from the message. tx _ id | @property | tx_id () -> str Get the transaction id. tx _ sender _ addr | @property | tx_sender_addr () -> Address Get the address of the sender. tx _ counterparty _ addr | @property | tx_counterparty_addr () -> Address Get the counterparty of the message. tx _ amount _ by _ currency _ id | @property | tx_amount_by_currency_id () -> Dict [ str , int ] Get the currency id. tx _ sender _ fee | @property | tx_sender_fee () -> int Get the fee for the sender from the messgae. tx _ counterparty _ fee | @property | tx_counterparty_fee () -> int Get the fee for the counterparty from the messgae. tx _ quantities _ by _ good _ id | @property | tx_quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good ids. ledger _ id | @property | ledger_id () -> LedgerId Get the ledger_id. info | @property | info () -> Dict [ str , Any ] Get the infos from the message. tx _ nonce | @property | tx_nonce () -> str Get the tx_nonce from the message. tx _ digest | @property | tx_digest () -> str Get the transaction digest. signing _ payload | @property | signing_payload () -> Dict [ str , Any ] Get the signing payload. signed _ payload | @property | signed_payload () -> Dict [ str , Any ] Get the signed payload. amount | @property | amount () -> int Get the amount. currency _ id | @property | currency_id () -> str Get the currency id. sender _ amount | @property | sender_amount () -> int Get the amount which the sender gets/pays as part of the tx. counterparty _ amount | @property | counterparty_amount () -> int Get the amount which the counterparty gets/pays as part of the tx. fees | @property | fees () -> int Get the tx fees. respond _ settlement | @classmethod | respond_settlement ( cls , other : \"TransactionMessage\" , performative : Performative , tx_digest : Optional [ str ] = None ) -> \"TransactionMessage\" Create response message. Arguments : other : TransactionMessage performative : the performative tx_digest : the transaction digest Returns : a transaction message object respond _ signing | @classmethod | respond_signing ( cls , other : \"TransactionMessage\" , performative : Performative , signed_payload : Optional [ Dict [ str , Any ]] = None ) -> \"TransactionMessage\" Create response message. Arguments : other : TransactionMessage performative : the performative signed_payload : the signed payload Returns : a transaction message object","title":"Transaction"},{"location":"aea/api/decision_maker/messages/transaction/#aeadecision_makermessagestransaction","text":"The transaction message module.","title":"aea.decision_maker.messages.transaction"},{"location":"aea/api/decision_maker/messages/transaction/#transactionmessage","text":"class TransactionMessage ( InternalMessage ) The transaction message class.","title":"TransactionMessage"},{"location":"aea/api/decision_maker/messages/transaction/#performative","text":"class Performative ( Enum ) Transaction performative.","title":"Performative"},{"location":"aea/api/decision_maker/messages/transaction/#__init__","text":"| __init__ ( performative : Performative , skill_callback_ids : Sequence [ PublicId ], tx_id : TransactionId , tx_sender_addr : Address , tx_counterparty_addr : Address , tx_amount_by_currency_id : Dict [ str , int ], tx_sender_fee : int , tx_counterparty_fee : int , tx_quantities_by_good_id : Dict [ str , int ], ledger_id : LedgerId , info : Dict [ str , Any ], ** kwargs ) Instantiate transaction message. Arguments : performative : the performative skill_callback_ids : the list public ids of skills to receive the transaction message response tx_id : the id of the transaction. tx_sender_addr : the sender address of the transaction. tx_counterparty_addr : the counterparty address of the transaction. tx_amount_by_currency_id : the amount by the currency of the transaction. tx_sender_fee : the part of the tx fee paid by the sender tx_counterparty_fee : the part of the tx fee paid by the counterparty tx_quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. ledger_id : the ledger id info : a dictionary for arbitrary information","title":"__init__"},{"location":"aea/api/decision_maker/messages/transaction/#performative_1","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/decision_maker/messages/transaction/#skill_callback_ids","text":"| @property | skill_callback_ids () -> List [ PublicId ] Get the list of skill_callback_ids from the message.","title":"skill_callback_ids"},{"location":"aea/api/decision_maker/messages/transaction/#tx_id","text":"| @property | tx_id () -> str Get the transaction id.","title":"tx_id"},{"location":"aea/api/decision_maker/messages/transaction/#tx_sender_addr","text":"| @property | tx_sender_addr () -> Address Get the address of the sender.","title":"tx_sender_addr"},{"location":"aea/api/decision_maker/messages/transaction/#tx_counterparty_addr","text":"| @property | tx_counterparty_addr () -> Address Get the counterparty of the message.","title":"tx_counterparty_addr"},{"location":"aea/api/decision_maker/messages/transaction/#tx_amount_by_currency_id","text":"| @property | tx_amount_by_currency_id () -> Dict [ str , int ] Get the currency id.","title":"tx_amount_by_currency_id"},{"location":"aea/api/decision_maker/messages/transaction/#tx_sender_fee","text":"| @property | tx_sender_fee () -> int Get the fee for the sender from the messgae.","title":"tx_sender_fee"},{"location":"aea/api/decision_maker/messages/transaction/#tx_counterparty_fee","text":"| @property | tx_counterparty_fee () -> int Get the fee for the counterparty from the messgae.","title":"tx_counterparty_fee"},{"location":"aea/api/decision_maker/messages/transaction/#tx_quantities_by_good_id","text":"| @property | tx_quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good ids.","title":"tx_quantities_by_good_id"},{"location":"aea/api/decision_maker/messages/transaction/#ledger_id","text":"| @property | ledger_id () -> LedgerId Get the ledger_id.","title":"ledger_id"},{"location":"aea/api/decision_maker/messages/transaction/#info","text":"| @property | info () -> Dict [ str , Any ] Get the infos from the message.","title":"info"},{"location":"aea/api/decision_maker/messages/transaction/#tx_nonce","text":"| @property | tx_nonce () -> str Get the tx_nonce from the message.","title":"tx_nonce"},{"location":"aea/api/decision_maker/messages/transaction/#tx_digest","text":"| @property | tx_digest () -> str Get the transaction digest.","title":"tx_digest"},{"location":"aea/api/decision_maker/messages/transaction/#signing_payload","text":"| @property | signing_payload () -> Dict [ str , Any ] Get the signing payload.","title":"signing_payload"},{"location":"aea/api/decision_maker/messages/transaction/#signed_payload","text":"| @property | signed_payload () -> Dict [ str , Any ] Get the signed payload.","title":"signed_payload"},{"location":"aea/api/decision_maker/messages/transaction/#amount","text":"| @property | amount () -> int Get the amount.","title":"amount"},{"location":"aea/api/decision_maker/messages/transaction/#currency_id","text":"| @property | currency_id () -> str Get the currency id.","title":"currency_id"},{"location":"aea/api/decision_maker/messages/transaction/#sender_amount","text":"| @property | sender_amount () -> int Get the amount which the sender gets/pays as part of the tx.","title":"sender_amount"},{"location":"aea/api/decision_maker/messages/transaction/#counterparty_amount","text":"| @property | counterparty_amount () -> int Get the amount which the counterparty gets/pays as part of the tx.","title":"counterparty_amount"},{"location":"aea/api/decision_maker/messages/transaction/#fees","text":"| @property | fees () -> int Get the tx fees.","title":"fees"},{"location":"aea/api/decision_maker/messages/transaction/#respond_settlement","text":"| @classmethod | respond_settlement ( cls , other : \"TransactionMessage\" , performative : Performative , tx_digest : Optional [ str ] = None ) -> \"TransactionMessage\" Create response message. Arguments : other : TransactionMessage performative : the performative tx_digest : the transaction digest Returns : a transaction message object","title":"respond_settlement"},{"location":"aea/api/decision_maker/messages/transaction/#respond_signing","text":"| @classmethod | respond_signing ( cls , other : \"TransactionMessage\" , performative : Performative , signed_payload : Optional [ Dict [ str , Any ]] = None ) -> \"TransactionMessage\" Create response message. Arguments : other : TransactionMessage performative : the performative signed_payload : the signed payload Returns : a transaction message object","title":"respond_signing"},{"location":"aea/api/helpers/async_friendly_queue/","text":"aea.helpers.async _ friendly _ queue This module contains the implementation of AsyncFriendlyQueue. AsyncFriendlyQueue class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method. __ init __ | __init__ ( * args , ** kwargs ) Init queue. put | put ( item : Any , * args , ** kwargs ) -> None Put an item into the queue. Arguments : item : item to put in the queue :param args, kwargs: similar to queue.Queue.put get | get ( * args , ** kwargs ) -> Any Get an item into the queue. :param args, kwargs: similar to queue.Queue.get async _ wait | async async_wait () -> None Wait an item appears in the queue. Returns : None async _ get | async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"Async Friendly Queue"},{"location":"aea/api/helpers/async_friendly_queue/#aeahelpersasync_friendly_queue","text":"This module contains the implementation of AsyncFriendlyQueue.","title":"aea.helpers.async_friendly_queue"},{"location":"aea/api/helpers/async_friendly_queue/#asyncfriendlyqueue","text":"class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method.","title":"AsyncFriendlyQueue"},{"location":"aea/api/helpers/async_friendly_queue/#__init__","text":"| __init__ ( * args , ** kwargs ) Init queue.","title":"__init__"},{"location":"aea/api/helpers/async_friendly_queue/#put","text":"| put ( item : Any , * args , ** kwargs ) -> None Put an item into the queue. Arguments : item : item to put in the queue :param args, kwargs: similar to queue.Queue.put","title":"put"},{"location":"aea/api/helpers/async_friendly_queue/#get","text":"| get ( * args , ** kwargs ) -> Any Get an item into the queue. :param args, kwargs: similar to queue.Queue.get","title":"get"},{"location":"aea/api/helpers/async_friendly_queue/#async_wait","text":"| async async_wait () -> None Wait an item appears in the queue. Returns : None","title":"async_wait"},{"location":"aea/api/helpers/async_friendly_queue/#async_get","text":"| async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"async_get"},{"location":"aea/api/helpers/base/","text":"aea.helpers.base Miscellaneous helpers. locate locate ( path ) Locate an object by name or dotted path, importing as necessary. load _ all _ modules load_all_modules ( directory : Path , glob : str = \"*.py\" , prefix : str = \"\" ) -> Dict [ str , types . ModuleType ] Load all modules of a directory, recursively. Arguments : directory : the directory where to search for .py modules. glob : the glob pattern to match. By default *.py prefix : the prefix to apply in the import path. Returns : a mapping from import path to module objects. load _ modules | @staticmethod | @contextmanager | load_modules ( modules : Sequence [ Tuple [ str , types . ModuleType ]]) Load modules as a context manager. Arguments : modules : a list of pairs (import path, module object). Returns : None. load _ module load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted path of the package/module. filepath : the file to the package/module. Returns : None Raises : ValueError : if the filepath provided is not a module. Exception : if the execution of the module raises exception. import _ aea _ module import_aea_module ( dotted_path : str , module_obj ) -> None Add an AEA module to sys.modules. The parameter dotted_path has the form: packages. . . If the closed-prefix packages are not present, add them to sys.modules. This is done in order to emulate the behaviour of the true Python import system, which in fact imports the packages recursively, for every prefix. E.g. see https://docs.python.org/3/library/importlib.html#approximating-importlib-import-module for an explanation on how the 'import' built-in function works. Arguments : dotted_path : the dotted path to be used in the imports. module_obj : the module object. It is assumed it has been already executed. Returns : None load _ agent _ component _ package load_agent_component_package ( item_type : str , item_name : str , author_name : str , directory : os . PathLike ) Load a Python package associated to a component.. Arguments : item_type : the type of the item. One of \"protocol\", \"connection\", \"skill\". item_name : the name of the item to load. author_name : the name of the author of the item to load. directory : the component directory. Returns : the module associated to the Python package of the component. add _ modules _ to _ sys _ modules add_modules_to_sys_modules ( modules_by_import_path : Dict [ str , types . ModuleType ]) -> None Load all modules in sys.modules. Arguments : modules_by_import_path : a dictionary from import path to module objects. Returns : None load _ env _ file load_env_file ( env_file : str ) Load the content of the environment file into the process environment. Arguments : env_file : path to the env file. Returns : None. sigint _ crossplatform sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. Returns : None RegexConstrainedString class RegexConstrainedString ( UserString ): | RegexConstrainedString ( seq ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour. cd @contextlib . contextmanager cd ( path ) Change working directory temporarily.","title":"Base"},{"location":"aea/api/helpers/base/#aeahelpersbase","text":"Miscellaneous helpers.","title":"aea.helpers.base"},{"location":"aea/api/helpers/base/#locate","text":"locate ( path ) Locate an object by name or dotted path, importing as necessary.","title":"locate"},{"location":"aea/api/helpers/base/#load_all_modules","text":"load_all_modules ( directory : Path , glob : str = \"*.py\" , prefix : str = \"\" ) -> Dict [ str , types . ModuleType ] Load all modules of a directory, recursively. Arguments : directory : the directory where to search for .py modules. glob : the glob pattern to match. By default *.py prefix : the prefix to apply in the import path. Returns : a mapping from import path to module objects.","title":"load_all_modules"},{"location":"aea/api/helpers/base/#load_modules","text":"| @staticmethod | @contextmanager | load_modules ( modules : Sequence [ Tuple [ str , types . ModuleType ]]) Load modules as a context manager. Arguments : modules : a list of pairs (import path, module object). Returns : None.","title":"load_modules"},{"location":"aea/api/helpers/base/#load_module","text":"load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted path of the package/module. filepath : the file to the package/module. Returns : None Raises : ValueError : if the filepath provided is not a module. Exception : if the execution of the module raises exception.","title":"load_module"},{"location":"aea/api/helpers/base/#import_aea_module","text":"import_aea_module ( dotted_path : str , module_obj ) -> None Add an AEA module to sys.modules. The parameter dotted_path has the form: packages. . . If the closed-prefix packages are not present, add them to sys.modules. This is done in order to emulate the behaviour of the true Python import system, which in fact imports the packages recursively, for every prefix. E.g. see https://docs.python.org/3/library/importlib.html#approximating-importlib-import-module for an explanation on how the 'import' built-in function works. Arguments : dotted_path : the dotted path to be used in the imports. module_obj : the module object. It is assumed it has been already executed. Returns : None","title":"import_aea_module"},{"location":"aea/api/helpers/base/#load_agent_component_package","text":"load_agent_component_package ( item_type : str , item_name : str , author_name : str , directory : os . PathLike ) Load a Python package associated to a component.. Arguments : item_type : the type of the item. One of \"protocol\", \"connection\", \"skill\". item_name : the name of the item to load. author_name : the name of the author of the item to load. directory : the component directory. Returns : the module associated to the Python package of the component.","title":"load_agent_component_package"},{"location":"aea/api/helpers/base/#add_modules_to_sys_modules","text":"add_modules_to_sys_modules ( modules_by_import_path : Dict [ str , types . ModuleType ]) -> None Load all modules in sys.modules. Arguments : modules_by_import_path : a dictionary from import path to module objects. Returns : None","title":"add_modules_to_sys_modules"},{"location":"aea/api/helpers/base/#load_env_file","text":"load_env_file ( env_file : str ) Load the content of the environment file into the process environment. Arguments : env_file : path to the env file. Returns : None.","title":"load_env_file"},{"location":"aea/api/helpers/base/#sigint_crossplatform","text":"sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. Returns : None","title":"sigint_crossplatform"},{"location":"aea/api/helpers/base/#regexconstrainedstring","text":"class RegexConstrainedString ( UserString ): | RegexConstrainedString ( seq ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour.","title":"RegexConstrainedString"},{"location":"aea/api/helpers/base/#cd","text":"@contextlib . contextmanager cd ( path ) Change working directory temporarily.","title":"cd"},{"location":"aea/api/helpers/exception_policy/","text":"aea.helpers.exception _ policy This module contains enum of aea exception policies. ExceptionPolicyEnum class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"Exception Policy"},{"location":"aea/api/helpers/exception_policy/#aeahelpersexception_policy","text":"This module contains enum of aea exception policies.","title":"aea.helpers.exception_policy"},{"location":"aea/api/helpers/exception_policy/#exceptionpolicyenum","text":"class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"ExceptionPolicyEnum"},{"location":"aea/api/helpers/exec_timeout/","text":"aea.helpers.exec _ timeout Python code execution time limit tools. TimeoutResult class TimeoutResult () Result of ExecTimeout context manager. __ init __ | __init__ () Init. set _ cancelled _ by _ timeout | set_cancelled_by_timeout () -> None Set code was terminated cause timeout. Returns : None is _ cancelled _ by _ timeout | is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool TimeoutException class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager BaseExecTimeout class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout. __ init __ | __init__ ( timeout : float = 0.0 ) Init. Arguments : timeout : number of seconds to execute code before interruption __ enter __ | __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult __ exit __ | __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Returns : bool ExecTimeoutSigAlarm class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread. ExecTimeoutThreadGuard class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled. __ init __ | __init__ ( timeout : float = 0.0 ) Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption start | @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. Returns : None stop | @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start. Returns : None","title":"Exec Timeout"},{"location":"aea/api/helpers/exec_timeout/#aeahelpersexec_timeout","text":"Python code execution time limit tools.","title":"aea.helpers.exec_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutresult","text":"class TimeoutResult () Result of ExecTimeout context manager.","title":"TimeoutResult"},{"location":"aea/api/helpers/exec_timeout/#__init__","text":"| __init__ () Init.","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#set_cancelled_by_timeout","text":"| set_cancelled_by_timeout () -> None Set code was terminated cause timeout. Returns : None","title":"set_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#is_cancelled_by_timeout","text":"| is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool","title":"is_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutexception","text":"class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager","title":"TimeoutException"},{"location":"aea/api/helpers/exec_timeout/#baseexectimeout","text":"class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout.","title":"BaseExecTimeout"},{"location":"aea/api/helpers/exec_timeout/#__init___1","text":"| __init__ ( timeout : float = 0.0 ) Init. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#__enter__","text":"| __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult","title":"__enter__"},{"location":"aea/api/helpers/exec_timeout/#__exit__","text":"| __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Returns : bool","title":"__exit__"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutsigalarm","text":"class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread.","title":"ExecTimeoutSigAlarm"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutthreadguard","text":"class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled.","title":"ExecTimeoutThreadGuard"},{"location":"aea/api/helpers/exec_timeout/#__init___2","text":"| __init__ ( timeout : float = 0.0 ) Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#start","text":"| @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. Returns : None","title":"start"},{"location":"aea/api/helpers/exec_timeout/#stop","text":"| @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start. Returns : None","title":"stop"},{"location":"aea/api/helpers/test_cases/","text":"aea.test _ tools.test _ cases This module contains test case classes based on pytest for AEA end-to-end testing. BaseAEATestCase class BaseAEATestCase ( ABC ) Base class for AEA test cases. set _ agent _ context | @classmethod | set_agent_context ( cls , agent_name : str ) Set the current agent context. unset _ agent _ context | @classmethod | unset_agent_context ( cls ) Unset the current agent context. set _ config | @classmethod | set_config ( cls , dotted_path : str , value : Any , type : str = \"str\" ) -> None Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type : the type Returns : None force _ set _ config | @classmethod | force_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config. disable _ aea _ logging | @classmethod | disable_aea_logging ( cls ) Disable AEA logging of specific agent. Run from agent's directory. Returns : None run _ cli _ command | @classmethod | run_cli_command ( cls , * args : str , cwd : str = \".\" ) -> None Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. Raises : AEATestingException : if command fails. Returns : None start _ subprocess | @classmethod | start_subprocess ( cls , * args : str , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args Returns : subprocess object. start _ thread | @classmethod | start_thread ( cls , target : Callable , ** kwargs ) -> None Start python Thread. Arguments : target : target method. process : subprocess passed to thread args. Returns : None. create _ agents | @classmethod | create_agents ( cls , * agents_names : str ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. Returns : None fetch _ agent | @classmethod | fetch_agent ( cls , public_id : str , agent_name : str ) -> None Create agents in current working directory. Arguments : public_id : str public id agents_name : str agent name. Returns : None difference _ to _ fetched _ agent | @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agents_name : str agent name. Returns : list of files differing in the projects delete _ agents | @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. Returns : None run _ agent | @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object. terminate _ agents | @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , signal : signal . Signals = signal . SIGINT , timeout : int = 10 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents signal : the signal for interuption timeout : the timeout for interuption is _ successfully _ terminated | @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) Check if all subprocesses terminated successfully initialize _ aea | @classmethod | initialize_aea ( cls , author ) -> None Initialize AEA locally with author name. Returns : None add _ item | @classmethod | add_item ( cls , item_type : str , public_id : str ) -> None Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None scaffold _ item | @classmethod | scaffold_item ( cls , item_type : str , name : str ) -> None Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. Returns : None fingerprint _ item | @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> None Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : public id of the item. Returns : None run _ install | @classmethod | run_install ( cls ) Execute AEA CLI install command. Run from agent's directory. Returns : None generate _ private _ key | @classmethod | generate_private_key ( cls , ledger_api_id : str = FETCHAI_NAME ) -> None Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : None add _ private _ key | @classmethod | add_private_key ( cls , ledger_api_id : str = FETCHAI_NAME , private_key_filepath : str = FETCHAI_PRIVATE_KEY_FILE ) -> None Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. Returns : None replace _ private _ key _ in _ file | @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = FETCHAI_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Returns : None :raises: exception if file does not exist generate _ wealth | @classmethod | generate_wealth ( cls , ledger_api_id : str = FETCHAI_NAME ) -> None Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : None get _ wealth | @classmethod | get_wealth ( cls , ledger_api_id : str = FETCHAI_NAME ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : command line output replace _ file _ content | @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the dest file. Arguments : src : the source file. dest : the destination file. Returns : None change _ directory | @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. Returns : None send _ envelope _ to _ agent | @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) Send an envelope to an agent, using the stub connection. read _ envelope _ from _ agent | @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection. missing _ from _ output | @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Tuple [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings. is _ running | @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test. AEATestCaseEmpty class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. AEATestCaseMany class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test class. AEATestCase class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test class.","title":"Test Cases"},{"location":"aea/api/helpers/test_cases/#aeatest_toolstest_cases","text":"This module contains test case classes based on pytest for AEA end-to-end testing.","title":"aea.test_tools.test_cases"},{"location":"aea/api/helpers/test_cases/#baseaeatestcase","text":"class BaseAEATestCase ( ABC ) Base class for AEA test cases.","title":"BaseAEATestCase"},{"location":"aea/api/helpers/test_cases/#set_agent_context","text":"| @classmethod | set_agent_context ( cls , agent_name : str ) Set the current agent context.","title":"set_agent_context"},{"location":"aea/api/helpers/test_cases/#unset_agent_context","text":"| @classmethod | unset_agent_context ( cls ) Unset the current agent context.","title":"unset_agent_context"},{"location":"aea/api/helpers/test_cases/#set_config","text":"| @classmethod | set_config ( cls , dotted_path : str , value : Any , type : str = \"str\" ) -> None Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type : the type Returns : None","title":"set_config"},{"location":"aea/api/helpers/test_cases/#force_set_config","text":"| @classmethod | force_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config.","title":"force_set_config"},{"location":"aea/api/helpers/test_cases/#disable_aea_logging","text":"| @classmethod | disable_aea_logging ( cls ) Disable AEA logging of specific agent. Run from agent's directory. Returns : None","title":"disable_aea_logging"},{"location":"aea/api/helpers/test_cases/#run_cli_command","text":"| @classmethod | run_cli_command ( cls , * args : str , cwd : str = \".\" ) -> None Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. Raises : AEATestingException : if command fails. Returns : None","title":"run_cli_command"},{"location":"aea/api/helpers/test_cases/#start_subprocess","text":"| @classmethod | start_subprocess ( cls , * args : str , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args Returns : subprocess object.","title":"start_subprocess"},{"location":"aea/api/helpers/test_cases/#start_thread","text":"| @classmethod | start_thread ( cls , target : Callable , ** kwargs ) -> None Start python Thread. Arguments : target : target method. process : subprocess passed to thread args. Returns : None.","title":"start_thread"},{"location":"aea/api/helpers/test_cases/#create_agents","text":"| @classmethod | create_agents ( cls , * agents_names : str ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. Returns : None","title":"create_agents"},{"location":"aea/api/helpers/test_cases/#fetch_agent","text":"| @classmethod | fetch_agent ( cls , public_id : str , agent_name : str ) -> None Create agents in current working directory. Arguments : public_id : str public id agents_name : str agent name. Returns : None","title":"fetch_agent"},{"location":"aea/api/helpers/test_cases/#difference_to_fetched_agent","text":"| @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agents_name : str agent name. Returns : list of files differing in the projects","title":"difference_to_fetched_agent"},{"location":"aea/api/helpers/test_cases/#delete_agents","text":"| @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. Returns : None","title":"delete_agents"},{"location":"aea/api/helpers/test_cases/#run_agent","text":"| @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object.","title":"run_agent"},{"location":"aea/api/helpers/test_cases/#terminate_agents","text":"| @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , signal : signal . Signals = signal . SIGINT , timeout : int = 10 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents signal : the signal for interuption timeout : the timeout for interuption","title":"terminate_agents"},{"location":"aea/api/helpers/test_cases/#is_successfully_terminated","text":"| @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) Check if all subprocesses terminated successfully","title":"is_successfully_terminated"},{"location":"aea/api/helpers/test_cases/#initialize_aea","text":"| @classmethod | initialize_aea ( cls , author ) -> None Initialize AEA locally with author name. Returns : None","title":"initialize_aea"},{"location":"aea/api/helpers/test_cases/#add_item","text":"| @classmethod | add_item ( cls , item_type : str , public_id : str ) -> None Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None","title":"add_item"},{"location":"aea/api/helpers/test_cases/#scaffold_item","text":"| @classmethod | scaffold_item ( cls , item_type : str , name : str ) -> None Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. Returns : None","title":"scaffold_item"},{"location":"aea/api/helpers/test_cases/#fingerprint_item","text":"| @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> None Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : public id of the item. Returns : None","title":"fingerprint_item"},{"location":"aea/api/helpers/test_cases/#run_install","text":"| @classmethod | run_install ( cls ) Execute AEA CLI install command. Run from agent's directory. Returns : None","title":"run_install"},{"location":"aea/api/helpers/test_cases/#generate_private_key","text":"| @classmethod | generate_private_key ( cls , ledger_api_id : str = FETCHAI_NAME ) -> None Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : None","title":"generate_private_key"},{"location":"aea/api/helpers/test_cases/#add_private_key","text":"| @classmethod | add_private_key ( cls , ledger_api_id : str = FETCHAI_NAME , private_key_filepath : str = FETCHAI_PRIVATE_KEY_FILE ) -> None Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. Returns : None","title":"add_private_key"},{"location":"aea/api/helpers/test_cases/#replace_private_key_in_file","text":"| @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = FETCHAI_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Returns : None :raises: exception if file does not exist","title":"replace_private_key_in_file"},{"location":"aea/api/helpers/test_cases/#generate_wealth","text":"| @classmethod | generate_wealth ( cls , ledger_api_id : str = FETCHAI_NAME ) -> None Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : None","title":"generate_wealth"},{"location":"aea/api/helpers/test_cases/#get_wealth","text":"| @classmethod | get_wealth ( cls , ledger_api_id : str = FETCHAI_NAME ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : command line output","title":"get_wealth"},{"location":"aea/api/helpers/test_cases/#replace_file_content","text":"| @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the dest file. Arguments : src : the source file. dest : the destination file. Returns : None","title":"replace_file_content"},{"location":"aea/api/helpers/test_cases/#change_directory","text":"| @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. Returns : None","title":"change_directory"},{"location":"aea/api/helpers/test_cases/#send_envelope_to_agent","text":"| @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) Send an envelope to an agent, using the stub connection.","title":"send_envelope_to_agent"},{"location":"aea/api/helpers/test_cases/#read_envelope_from_agent","text":"| @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection.","title":"read_envelope_from_agent"},{"location":"aea/api/helpers/test_cases/#missing_from_output","text":"| @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Tuple [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings.","title":"missing_from_output"},{"location":"aea/api/helpers/test_cases/#is_running","text":"| @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete","title":"is_running"},{"location":"aea/api/helpers/test_cases/#setup_class","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/helpers/test_cases/#teardown_class","text":"| @classmethod | teardown_class ( cls ) Teardown the test.","title":"teardown_class"},{"location":"aea/api/helpers/test_cases/#aeatestcaseempty","text":"class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project.","title":"AEATestCaseEmpty"},{"location":"aea/api/helpers/test_cases/#setup_class_1","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/helpers/test_cases/#aeatestcasemany","text":"class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects.","title":"AEATestCaseMany"},{"location":"aea/api/helpers/test_cases/#setup_class_2","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/helpers/test_cases/#teardown_class_1","text":"| @classmethod | teardown_class ( cls ) Teardown the test class.","title":"teardown_class"},{"location":"aea/api/helpers/test_cases/#aeatestcase","text":"class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory.","title":"AEATestCase"},{"location":"aea/api/helpers/test_cases/#setup_class_3","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/helpers/test_cases/#teardown_class_2","text":"| @classmethod | teardown_class ( cls ) Teardown the test class.","title":"teardown_class"},{"location":"aea/api/helpers/dialogue/base/","text":"aea.helpers.dialogue.base This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues. DialogueLabel class DialogueLabel () The dialogue label class acts as an identifier for dialogues. __ init __ | __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference. dialogue _ starter _ reference | @property | dialogue_starter_reference () -> str Get the dialogue starter reference. dialogue _ responder _ reference | @property | dialogue_responder_reference () -> str Get the dialogue responder reference. dialogue _ opponent _ addr | @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent. dialogue _ starter _ addr | @property | dialogue_starter_addr () -> str Get the address of the dialogue starter. __ eq __ | __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects. __ hash __ | __hash__ () -> int Turn object into hash. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json. __ str __ | __str__ () Get the string representation. Dialogue class Dialogue ( ABC ) The dialogue class maintains state of a dialogue and manages it. Role class Role ( Enum ) This class defines the agent's role in a dialogue. __ str __ | __str__ () Get the string representation. EndState class EndState ( Enum ) This class defines the end states of a dialogue. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( dialogue_label : DialogueLabel , agent_address : Optional [ Address ] = None , role : Optional [ Role ] = None ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue agent_address : the address of the agent for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None dialogue _ label | @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label agent _ address | @agent_address . setter | agent_address ( agent_address : Address ) -> None Set the address of the agent for whom this dialogues is maintained. :param: the agent address role | @role . setter | role ( role : \"Role\" ) -> None Set the agent's role in the dialogue. Arguments : role : the agent's role Returns : None is _ self _ initiated | @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise last _ incoming _ message | @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise last _ outgoing _ message | @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise last _ message | @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise get _ message | get_message ( message_id_to_find : int ) -> Optional [ Message ] Get the message whose id is 'message_id'. Arguments : message_id_to_find : the id of the message Returns : the message if it exists, None otherwise is _ empty | @property | is_empty () -> bool Check whether the dialogue is empty Returns : True if empty, False otherwise update | update ( message : Message ) -> bool Extend the list of incoming/outgoing messages with 'message', if 'message' is valid Arguments : message : a message to be added Returns : True if message successfully added, false otherwise is _ valid _ next _ message | is_valid_next_message ( message : Message ) -> bool Check whether 'message' is a valid next message in this dialogue. The evaluation of a message validity involves performing several categories of checks. Each category of checks resides in a separate method. Currently, basic rules are fundamental structural constraints, additional rules are applied for the time being, and more specific rules are captured in the is_valid method. Arguments : message : the message to be validated Returns : True if yes, False otherwise. initial _ performative | @abstractmethod | initial_performative () -> Enum Get the performative which the initial message in the dialogue must have Returns : the performative of the initial message get _ replies | @abstractmethod | get_replies ( performative : Enum ) -> FrozenSet Given a performative , return the list of performatives which are its valid replies in a dialogue Arguments : performative : the performative in a message Returns : list of valid performative replies is _ valid | @abstractmethod | is_valid ( message : Message ) -> bool Check whether 'message' is a valid next message in the dialogue. These rules capture specific constraints designed for dialogues which are instance of a concrete sub-class of this class. Arguments : message : the message to be validated Returns : True if valid, False otherwise. __ str __ | __str__ () -> str Get the string representation. Returns : The string representation of the dialogue outgoing _ extend | outgoing_extend ( message : Message ) -> None UNSAFE TO USE - IS DEPRECATED - USE update(message) METHOD INSTEAD Extend the list of outgoing messages with 'message' Arguments : message : a message to be added Returns : None incoming _ extend | incoming_extend ( message : Message ) -> None UNSAFE TO USE - IS DEPRECATED - USE update(message) METHOD INSTEAD Extend the list of incoming messages with 'message' Arguments : message : a message to be added Returns : None Dialogues class Dialogues ( ABC ) The dialogues class keeps track of all dialogues for an agent. __ init __ | __init__ ( agent_address : Address = \"\" ) -> None Initialize dialogues. Arguments : agent_address : the address of the agent for whom dialogues are maintained Returns : None dialogues | @property | dialogues () -> Dict [ DialogueLabel , Dialogue ] Get dictionary of dialogues in which the agent engages. agent _ address | @property | agent_address () -> Address Get the address of the agent for whom dialogues are maintained. new _ self _ initiated _ dialogue _ reference | new_self_initiated_dialogue_reference () -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue Returns : the next nonce update | update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new message Returns : the new or existing dialogue the message is intended for, or None in case of any errors. create _ dialogue | @abstractmethod | create_dialogue ( dialogue_label : DialogueLabel , role : Dialogue . Role ) -> Dialogue Create a dialogue instance. Arguments : dialogue_label : the identifier of the dialogue role : the role of the agent this dialogue is maintained for Returns : the created dialogue role _ from _ first _ message | @staticmethod | @abstractmethod | role_from_first_message ( message : Message ) -> Dialogue . Role Infer the role of the agent from an incoming or outgoing first message Arguments : message : an incoming/outgoing first message Returns : the agent's role is _ belonging _ to _ registered _ dialogue | is_belonging_to_registered_dialogue ( msg : Message , agent_addr : Address ) -> bool DEPRECATED Check whether an agent message is part of a registered dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : boolean indicating whether the message belongs to a registered dialogue is _ permitted _ for _ new _ dialogue | is_permitted_for_new_dialogue ( msg : Message ) -> bool DEPRECATED Check whether an agent message is permitted for a new dialogue. Arguments : msg : the agent message Returns : a boolean indicating whether the message is permitted for a new dialogue get _ dialogue | get_dialogue ( msg : Message , address : Address ) -> Dialogue DEPRECATED Retrieve dialogue. Arguments : fipa_msg : the fipa message agent_addr : the address of the agent Returns : the dialogue create _ self _ initiated | create_self_initiated ( dialogue_opponent_addr : Address , role : Dialogue . Role ) -> Dialogue DEPRECATED Create a self initiated dialogue. Arguments : dialogue_opponent_addr : the pbk of the agent with which the dialogue is kept. role : the agent's role Returns : the created dialogue. create _ opponent _ initiated | create_opponent_initiated ( dialogue_opponent_addr : Address , dialogue_reference : Tuple [ str , str ], role : Dialogue . Role ) -> Dialogue DEPRECATED Create an opponent initiated dialogue. Arguments : dialogue_opponent_addr : the address of the agent with which the dialogue is kept. dialogue_reference : the reference of the dialogue. role : the agent's role Returns : the created dialogue","title":"Base"},{"location":"aea/api/helpers/dialogue/base/#aeahelpersdialoguebase","text":"This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues.","title":"aea.helpers.dialogue.base"},{"location":"aea/api/helpers/dialogue/base/#dialoguelabel","text":"class DialogueLabel () The dialogue label class acts as an identifier for dialogues.","title":"DialogueLabel"},{"location":"aea/api/helpers/dialogue/base/#__init__","text":"| __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference.","title":"dialogue_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_starter_reference","text":"| @property | dialogue_starter_reference () -> str Get the dialogue starter reference.","title":"dialogue_starter_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_responder_reference","text":"| @property | dialogue_responder_reference () -> str Get the dialogue responder reference.","title":"dialogue_responder_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_opponent_addr","text":"| @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent.","title":"dialogue_opponent_addr"},{"location":"aea/api/helpers/dialogue/base/#dialogue_starter_addr","text":"| @property | dialogue_starter_addr () -> str Get the address of the dialogue starter.","title":"dialogue_starter_addr"},{"location":"aea/api/helpers/dialogue/base/#__eq__","text":"| __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects.","title":"__eq__"},{"location":"aea/api/helpers/dialogue/base/#__hash__","text":"| __hash__ () -> int Turn object into hash.","title":"__hash__"},{"location":"aea/api/helpers/dialogue/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/helpers/dialogue/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json.","title":"from_json"},{"location":"aea/api/helpers/dialogue/base/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/dialogue/base/#dialogue","text":"class Dialogue ( ABC ) The dialogue class maintains state of a dialogue and manages it.","title":"Dialogue"},{"location":"aea/api/helpers/dialogue/base/#role","text":"class Role ( Enum ) This class defines the agent's role in a dialogue.","title":"Role"},{"location":"aea/api/helpers/dialogue/base/#__str___1","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/dialogue/base/#endstate","text":"class EndState ( Enum ) This class defines the end states of a dialogue.","title":"EndState"},{"location":"aea/api/helpers/dialogue/base/#__str___2","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/dialogue/base/#__init___1","text":"| __init__ ( dialogue_label : DialogueLabel , agent_address : Optional [ Address ] = None , role : Optional [ Role ] = None ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue agent_address : the address of the agent for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogue_label","text":"| @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label","title":"dialogue_label"},{"location":"aea/api/helpers/dialogue/base/#agent_address","text":"| @agent_address . setter | agent_address ( agent_address : Address ) -> None Set the address of the agent for whom this dialogues is maintained. :param: the agent address","title":"agent_address"},{"location":"aea/api/helpers/dialogue/base/#role_1","text":"| @role . setter | role ( role : \"Role\" ) -> None Set the agent's role in the dialogue. Arguments : role : the agent's role Returns : None","title":"role"},{"location":"aea/api/helpers/dialogue/base/#is_self_initiated","text":"| @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise","title":"is_self_initiated"},{"location":"aea/api/helpers/dialogue/base/#last_incoming_message","text":"| @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise","title":"last_incoming_message"},{"location":"aea/api/helpers/dialogue/base/#last_outgoing_message","text":"| @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise","title":"last_outgoing_message"},{"location":"aea/api/helpers/dialogue/base/#last_message","text":"| @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise","title":"last_message"},{"location":"aea/api/helpers/dialogue/base/#get_message","text":"| get_message ( message_id_to_find : int ) -> Optional [ Message ] Get the message whose id is 'message_id'. Arguments : message_id_to_find : the id of the message Returns : the message if it exists, None otherwise","title":"get_message"},{"location":"aea/api/helpers/dialogue/base/#is_empty","text":"| @property | is_empty () -> bool Check whether the dialogue is empty Returns : True if empty, False otherwise","title":"is_empty"},{"location":"aea/api/helpers/dialogue/base/#update","text":"| update ( message : Message ) -> bool Extend the list of incoming/outgoing messages with 'message', if 'message' is valid Arguments : message : a message to be added Returns : True if message successfully added, false otherwise","title":"update"},{"location":"aea/api/helpers/dialogue/base/#is_valid_next_message","text":"| is_valid_next_message ( message : Message ) -> bool Check whether 'message' is a valid next message in this dialogue. The evaluation of a message validity involves performing several categories of checks. Each category of checks resides in a separate method. Currently, basic rules are fundamental structural constraints, additional rules are applied for the time being, and more specific rules are captured in the is_valid method. Arguments : message : the message to be validated Returns : True if yes, False otherwise.","title":"is_valid_next_message"},{"location":"aea/api/helpers/dialogue/base/#initial_performative","text":"| @abstractmethod | initial_performative () -> Enum Get the performative which the initial message in the dialogue must have Returns : the performative of the initial message","title":"initial_performative"},{"location":"aea/api/helpers/dialogue/base/#get_replies","text":"| @abstractmethod | get_replies ( performative : Enum ) -> FrozenSet Given a performative , return the list of performatives which are its valid replies in a dialogue Arguments : performative : the performative in a message Returns : list of valid performative replies","title":"get_replies"},{"location":"aea/api/helpers/dialogue/base/#is_valid","text":"| @abstractmethod | is_valid ( message : Message ) -> bool Check whether 'message' is a valid next message in the dialogue. These rules capture specific constraints designed for dialogues which are instance of a concrete sub-class of this class. Arguments : message : the message to be validated Returns : True if valid, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/dialogue/base/#__str___3","text":"| __str__ () -> str Get the string representation. Returns : The string representation of the dialogue","title":"__str__"},{"location":"aea/api/helpers/dialogue/base/#outgoing_extend","text":"| outgoing_extend ( message : Message ) -> None UNSAFE TO USE - IS DEPRECATED - USE update(message) METHOD INSTEAD Extend the list of outgoing messages with 'message' Arguments : message : a message to be added Returns : None","title":"outgoing_extend"},{"location":"aea/api/helpers/dialogue/base/#incoming_extend","text":"| incoming_extend ( message : Message ) -> None UNSAFE TO USE - IS DEPRECATED - USE update(message) METHOD INSTEAD Extend the list of incoming messages with 'message' Arguments : message : a message to be added Returns : None","title":"incoming_extend"},{"location":"aea/api/helpers/dialogue/base/#dialogues","text":"class Dialogues ( ABC ) The dialogues class keeps track of all dialogues for an agent.","title":"Dialogues"},{"location":"aea/api/helpers/dialogue/base/#__init___2","text":"| __init__ ( agent_address : Address = \"\" ) -> None Initialize dialogues. Arguments : agent_address : the address of the agent for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogues_1","text":"| @property | dialogues () -> Dict [ DialogueLabel , Dialogue ] Get dictionary of dialogues in which the agent engages.","title":"dialogues"},{"location":"aea/api/helpers/dialogue/base/#agent_address_1","text":"| @property | agent_address () -> Address Get the address of the agent for whom dialogues are maintained.","title":"agent_address"},{"location":"aea/api/helpers/dialogue/base/#new_self_initiated_dialogue_reference","text":"| new_self_initiated_dialogue_reference () -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue Returns : the next nonce","title":"new_self_initiated_dialogue_reference"},{"location":"aea/api/helpers/dialogue/base/#update_1","text":"| update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new message Returns : the new or existing dialogue the message is intended for, or None in case of any errors.","title":"update"},{"location":"aea/api/helpers/dialogue/base/#create_dialogue","text":"| @abstractmethod | create_dialogue ( dialogue_label : DialogueLabel , role : Dialogue . Role ) -> Dialogue Create a dialogue instance. Arguments : dialogue_label : the identifier of the dialogue role : the role of the agent this dialogue is maintained for Returns : the created dialogue","title":"create_dialogue"},{"location":"aea/api/helpers/dialogue/base/#role_from_first_message","text":"| @staticmethod | @abstractmethod | role_from_first_message ( message : Message ) -> Dialogue . Role Infer the role of the agent from an incoming or outgoing first message Arguments : message : an incoming/outgoing first message Returns : the agent's role","title":"role_from_first_message"},{"location":"aea/api/helpers/dialogue/base/#is_belonging_to_registered_dialogue","text":"| is_belonging_to_registered_dialogue ( msg : Message , agent_addr : Address ) -> bool DEPRECATED Check whether an agent message is part of a registered dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : boolean indicating whether the message belongs to a registered dialogue","title":"is_belonging_to_registered_dialogue"},{"location":"aea/api/helpers/dialogue/base/#is_permitted_for_new_dialogue","text":"| is_permitted_for_new_dialogue ( msg : Message ) -> bool DEPRECATED Check whether an agent message is permitted for a new dialogue. Arguments : msg : the agent message Returns : a boolean indicating whether the message is permitted for a new dialogue","title":"is_permitted_for_new_dialogue"},{"location":"aea/api/helpers/dialogue/base/#get_dialogue","text":"| get_dialogue ( msg : Message , address : Address ) -> Dialogue DEPRECATED Retrieve dialogue. Arguments : fipa_msg : the fipa message agent_addr : the address of the agent Returns : the dialogue","title":"get_dialogue"},{"location":"aea/api/helpers/dialogue/base/#create_self_initiated","text":"| create_self_initiated ( dialogue_opponent_addr : Address , role : Dialogue . Role ) -> Dialogue DEPRECATED Create a self initiated dialogue. Arguments : dialogue_opponent_addr : the pbk of the agent with which the dialogue is kept. role : the agent's role Returns : the created dialogue.","title":"create_self_initiated"},{"location":"aea/api/helpers/dialogue/base/#create_opponent_initiated","text":"| create_opponent_initiated ( dialogue_opponent_addr : Address , dialogue_reference : Tuple [ str , str ], role : Dialogue . Role ) -> Dialogue DEPRECATED Create an opponent initiated dialogue. Arguments : dialogue_opponent_addr : the address of the agent with which the dialogue is kept. dialogue_reference : the reference of the dialogue. role : the agent's role Returns : the created dialogue","title":"create_opponent_initiated"},{"location":"aea/api/helpers/ipfs/base/","text":"aea.helpers.ipfs.base This module contains helper methods and classes for the 'aea' package. IPFSHashOnly class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon. get | get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path","title":"Base"},{"location":"aea/api/helpers/ipfs/base/#aeahelpersipfsbase","text":"This module contains helper methods and classes for the 'aea' package.","title":"aea.helpers.ipfs.base"},{"location":"aea/api/helpers/ipfs/base/#ipfshashonly","text":"class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon.","title":"IPFSHashOnly"},{"location":"aea/api/helpers/ipfs/base/#get","text":"| get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path","title":"get"},{"location":"aea/api/helpers/preference_representations/base/","text":"aea.helpers.preference _ representations.base Preference representation helpers. logarithmic _ utility logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 1 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value linear _ utility linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"Base"},{"location":"aea/api/helpers/preference_representations/base/#aeahelperspreference_representationsbase","text":"Preference representation helpers.","title":"aea.helpers.preference_representations.base"},{"location":"aea/api/helpers/preference_representations/base/#logarithmic_utility","text":"logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 1 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/helpers/preference_representations/base/#linear_utility","text":"linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/helpers/search/generic/","text":"aea.helpers.search.generic This module contains a generic data model. GenericDataModel class GenericDataModel ( DataModel ) Generic data model. __ init __ | __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"Generic"},{"location":"aea/api/helpers/search/generic/#aeahelperssearchgeneric","text":"This module contains a generic data model.","title":"aea.helpers.search.generic"},{"location":"aea/api/helpers/search/generic/#genericdatamodel","text":"class GenericDataModel ( DataModel ) Generic data model.","title":"GenericDataModel"},{"location":"aea/api/helpers/search/generic/#__init__","text":"| __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"__init__"},{"location":"aea/api/helpers/search/models/","text":"aea.helpers.search.models Useful classes for the OEF search. Location class Location () Data structure to represent locations (i.e. a pair of latitude and longitude). __ init __ | __init__ ( latitude : float , longitude : float ) Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location. AttributeInconsistencyException class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type. Attribute class Attribute () Implements an attribute for an OEF data model. __ init __ | __init__ ( name : str , type : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute. __ eq __ | __eq__ ( other ) Compare with another object. DataModel class DataModel () Implements an OEF data model. __ init __ | __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model. __ eq __ | __eq__ ( other ) -> bool Compare with another object. generate _ data _ model generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified. Description class Description () Implements an OEF description. __ init __ | __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) :pram data_model_name: the data model name if a datamodel is created on the fly. values | @property | values () -> Dict Get the values. __ eq __ | __eq__ ( other ) -> bool Compare with another object. __ iter __ | __iter__ () Create an iterator. encode | @classmethod | encode ( cls , description_protobuf_object , description_object : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_protobuf_object : the protocol buffer object whose type corresponds with this class. description_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , description_protobuf_object ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument. ConstraintTypes class ConstraintTypes ( Enum ) Types of constraint. __ str __ | __str__ () Get the string representation. ConstraintType class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", [1, 2, 3]) not_in_a_set = ConstraintType(\"not_in\", {\"C\", \"Java\", \"Python\"}) __ init __ | __init__ ( type : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not is _ valid | is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise. get _ data _ type | get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type() check | check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized. __ eq __ | __eq__ ( other ) Check equality with another object. ConstraintExpr class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node. check | @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. And class And ( ConstraintExpr ) Implementation of the 'And' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Or class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Not class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression. __ init __ | __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate. check | check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Constraint class Constraint ( ConstraintExpr ) The atomic component of a constraint expression. __ init __ | __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type. check | check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", {\"horror\", \"science_fiction\"})) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Query class Query () This class lets you build a query for the OEF. __ init __ | __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to. check | check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Given a data model, check whether the query is valid for that data model. Returns : True if the query is compliant with the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. encode | @classmethod | encode ( cls , query_protobuf_object , query_object : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_protobuf_object : the protocol buffer object whose type corresponds with this class. query_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , query_protobuf_object ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument. haversine haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"Models"},{"location":"aea/api/helpers/search/models/#aeahelperssearchmodels","text":"Useful classes for the OEF search.","title":"aea.helpers.search.models"},{"location":"aea/api/helpers/search/models/#location","text":"class Location () Data structure to represent locations (i.e. a pair of latitude and longitude).","title":"Location"},{"location":"aea/api/helpers/search/models/#__init__","text":"| __init__ ( latitude : float , longitude : float ) Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location.","title":"__init__"},{"location":"aea/api/helpers/search/models/#attributeinconsistencyexception","text":"class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type.","title":"AttributeInconsistencyException"},{"location":"aea/api/helpers/search/models/#attribute","text":"class Attribute () Implements an attribute for an OEF data model.","title":"Attribute"},{"location":"aea/api/helpers/search/models/#__init___1","text":"| __init__ ( name : str , type : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#datamodel","text":"class DataModel () Implements an OEF data model.","title":"DataModel"},{"location":"aea/api/helpers/search/models/#__init___2","text":"| __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___1","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#generate_data_model","text":"generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified.","title":"generate_data_model"},{"location":"aea/api/helpers/search/models/#description","text":"class Description () Implements an OEF description.","title":"Description"},{"location":"aea/api/helpers/search/models/#__init___3","text":"| __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) :pram data_model_name: the data model name if a datamodel is created on the fly.","title":"__init__"},{"location":"aea/api/helpers/search/models/#values","text":"| @property | values () -> Dict Get the values.","title":"values"},{"location":"aea/api/helpers/search/models/#__eq___2","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__iter__","text":"| __iter__ () Create an iterator.","title":"__iter__"},{"location":"aea/api/helpers/search/models/#encode","text":"| @classmethod | encode ( cls , description_protobuf_object , description_object : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_protobuf_object : the protocol buffer object whose type corresponds with this class. description_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode","text":"| @classmethod | decode ( cls , description_protobuf_object ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#constrainttypes","text":"class ConstraintTypes ( Enum ) Types of constraint.","title":"ConstraintTypes"},{"location":"aea/api/helpers/search/models/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/search/models/#constrainttype","text":"class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", [1, 2, 3]) not_in_a_set = ConstraintType(\"not_in\", {\"C\", \"Java\", \"Python\"})","title":"ConstraintType"},{"location":"aea/api/helpers/search/models/#__init___4","text":"| __init__ ( type : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not","title":"__init__"},{"location":"aea/api/helpers/search/models/#is_valid","text":"| is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#get_data_type","text":"| get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type()","title":"get_data_type"},{"location":"aea/api/helpers/search/models/#check","text":"| check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___3","text":"| __eq__ ( other ) Check equality with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#constraintexpr","text":"class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node.","title":"ConstraintExpr"},{"location":"aea/api/helpers/search/models/#check_1","text":"| @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_1","text":"| @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#and","text":"class And ( ConstraintExpr ) Implementation of the 'And' constraint expression.","title":"And"},{"location":"aea/api/helpers/search/models/#__init___5","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_2","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_2","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___4","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#or","text":"class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression.","title":"Or"},{"location":"aea/api/helpers/search/models/#__init___6","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_3","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_3","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___5","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#not","text":"class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression.","title":"Not"},{"location":"aea/api/helpers/search/models/#__init___7","text":"| __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_4","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_4","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___6","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#constraint","text":"class Constraint ( ConstraintExpr ) The atomic component of a constraint expression.","title":"Constraint"},{"location":"aea/api/helpers/search/models/#__init___8","text":"| __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_5","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", {\"horror\", \"science_fiction\"})) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_5","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___7","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#query","text":"class Query () This class lets you build a query for the OEF.","title":"Query"},{"location":"aea/api/helpers/search/models/#__init___9","text":"| __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_6","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_6","text":"| is_valid ( data_model : DataModel ) -> bool Given a data model, check whether the query is valid for that data model. Returns : True if the query is compliant with the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___8","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_1","text":"| @classmethod | encode ( cls , query_protobuf_object , query_object : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_protobuf_object : the protocol buffer object whose type corresponds with this class. query_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_1","text":"| @classmethod | decode ( cls , query_protobuf_object ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#haversine","text":"haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"haversine"},{"location":"aea/api/identity/base/","text":"aea.identity.base This module contains the identity class. Identity class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair) __ init __ | __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_ADDRESS_KEY ) Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address. name | @property | name () -> str Get the agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get the addresses. address | @property | address () -> Address Get the default address.","title":"Identity"},{"location":"aea/api/identity/base/#aeaidentitybase","text":"This module contains the identity class.","title":"aea.identity.base"},{"location":"aea/api/identity/base/#identity","text":"class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair)","title":"Identity"},{"location":"aea/api/identity/base/#__init__","text":"| __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_ADDRESS_KEY ) Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address.","title":"__init__"},{"location":"aea/api/identity/base/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/identity/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get the addresses.","title":"addresses"},{"location":"aea/api/identity/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/mail/base/","text":"aea.mail.base Mail module abstract base classes. AEAConnectionError class AEAConnectionError ( Exception ) Exception class for connection errors. Empty class Empty ( Exception ) Exception for when the inbox is empty. URI class URI () URI following RFC3986. __ init __ | __init__ ( uri_raw : str ) Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant scheme | @property | scheme () -> str Get the scheme. netloc | @property | netloc () -> str Get the netloc. path | @property | path () -> str Get the path. params | @property | params () -> str Get the params. query | @property | query () -> str Get the query. fragment | @property | fragment () -> str Get the fragment. username | @property | username () -> Optional [ str ] Get the username. password | @property | password () -> Optional [ str ] Get the password. host | @property | host () -> Optional [ str ] Get the host. port | @property | port () -> Optional [ int ] Get the port. __ str __ | __str__ () Get string representation. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeContext class EnvelopeContext () Extra information for the handling of an envelope. __ init __ | __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope. uri _ raw | @property | uri_raw () -> str Get uri in string format. __ str __ | __str__ () Get the string representation. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeSerializer class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope. encode | @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope ProtobufEnvelopeSerializer class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf. encode | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope Envelope class Envelope () The top level message class for agent to agent communication. __ init __ | __init__ ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes , context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message. context : the optional envelope context. to | @to . setter | to ( to : Address ) -> None Set address of receiver. sender | @sender . setter | sender ( sender : Address ) -> None Set address of sender. protocol _ id | @protocol_id . setter | protocol_id ( protocol_id : ProtocolId ) -> None Set the protocol id. message | @message . setter | message ( message : bytes ) -> None Set the protocol-specific message. context | @property | context () -> EnvelopeContext Get the envelope context. skill _ id | @property | skill_id () -> Optional [ SkillId ] Get the skill id from an envelope context, if set. Returns : skill id __ eq __ | __eq__ ( other ) Compare with another object. encode | encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope. decode | @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope. __ str __ | __str__ () Get the string representation of an envelope. Multiplexer class Multiplexer () This class can handle multiple connections at once. __ init __ | __init__ ( connections : Sequence [ \"Connection\" ], default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created. in _ queue | @property | in_queue () -> AsyncFriendlyQueue Get the in queue. out _ queue | @property | out_queue () -> asyncio . Queue Get the out queue. connections | @property | connections () -> Tuple [ \"Connection\" ] Get the connections. is _ connected | @property | is_connected () -> bool Check whether the multiplexer is processing envelopes. default _ routing | @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) Set the default routing. connection _ status | @property | connection_status () -> ConnectionStatus Get the connection status. connect | connect () -> None Connect the multiplexer. disconnect | disconnect () -> None Disconnect the multiplexer. get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout. async _ get | async async_get () -> Envelope Get an envelope async way. Returns : the envelope async _ wait | async async_wait () -> None Get an envelope async way. Returns : the envelope put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None InBox class InBox () A queue from where you can only consume envelopes. __ init __ | __init__ ( multiplexer : Multiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails. get _ nowait | get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object async _ get | async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object. async _ wait | async async_wait () -> None Check for a envelope on the in queue. Returns : the envelope object. OutBox class OutBox () A queue from where you can only enqueue envelopes. __ init __ | __init__ ( multiplexer : Multiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not put | put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None put _ message | put_message ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : to : the recipient of the envelope. sender : the sender of the envelope. protocol_id : the protocol id. message : the content of the message. Returns : None","title":"Mail"},{"location":"aea/api/mail/base/#aeamailbase","text":"Mail module abstract base classes.","title":"aea.mail.base"},{"location":"aea/api/mail/base/#aeaconnectionerror","text":"class AEAConnectionError ( Exception ) Exception class for connection errors.","title":"AEAConnectionError"},{"location":"aea/api/mail/base/#empty","text":"class Empty ( Exception ) Exception for when the inbox is empty.","title":"Empty"},{"location":"aea/api/mail/base/#uri","text":"class URI () URI following RFC3986.","title":"URI"},{"location":"aea/api/mail/base/#__init__","text":"| __init__ ( uri_raw : str ) Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant","title":"__init__"},{"location":"aea/api/mail/base/#scheme","text":"| @property | scheme () -> str Get the scheme.","title":"scheme"},{"location":"aea/api/mail/base/#netloc","text":"| @property | netloc () -> str Get the netloc.","title":"netloc"},{"location":"aea/api/mail/base/#path","text":"| @property | path () -> str Get the path.","title":"path"},{"location":"aea/api/mail/base/#params","text":"| @property | params () -> str Get the params.","title":"params"},{"location":"aea/api/mail/base/#query","text":"| @property | query () -> str Get the query.","title":"query"},{"location":"aea/api/mail/base/#fragment","text":"| @property | fragment () -> str Get the fragment.","title":"fragment"},{"location":"aea/api/mail/base/#username","text":"| @property | username () -> Optional [ str ] Get the username.","title":"username"},{"location":"aea/api/mail/base/#password","text":"| @property | password () -> Optional [ str ] Get the password.","title":"password"},{"location":"aea/api/mail/base/#host","text":"| @property | host () -> Optional [ str ] Get the host.","title":"host"},{"location":"aea/api/mail/base/#port","text":"| @property | port () -> Optional [ int ] Get the port.","title":"port"},{"location":"aea/api/mail/base/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopecontext","text":"class EnvelopeContext () Extra information for the handling of an envelope.","title":"EnvelopeContext"},{"location":"aea/api/mail/base/#__init___1","text":"| __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope.","title":"__init__"},{"location":"aea/api/mail/base/#uri_raw","text":"| @property | uri_raw () -> str Get uri in string format.","title":"uri_raw"},{"location":"aea/api/mail/base/#__str___1","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopeserializer","text":"class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope.","title":"EnvelopeSerializer"},{"location":"aea/api/mail/base/#encode","text":"| @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode","text":"| @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#protobufenvelopeserializer","text":"class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf.","title":"ProtobufEnvelopeSerializer"},{"location":"aea/api/mail/base/#encode_1","text":"| encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode_1","text":"| decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#envelope","text":"class Envelope () The top level message class for agent to agent communication.","title":"Envelope"},{"location":"aea/api/mail/base/#__init___2","text":"| __init__ ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes , context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message. context : the optional envelope context.","title":"__init__"},{"location":"aea/api/mail/base/#to","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/mail/base/#sender","text":"| @sender . setter | sender ( sender : Address ) -> None Set address of sender.","title":"sender"},{"location":"aea/api/mail/base/#protocol_id","text":"| @protocol_id . setter | protocol_id ( protocol_id : ProtocolId ) -> None Set the protocol id.","title":"protocol_id"},{"location":"aea/api/mail/base/#message","text":"| @message . setter | message ( message : bytes ) -> None Set the protocol-specific message.","title":"message"},{"location":"aea/api/mail/base/#context","text":"| @property | context () -> EnvelopeContext Get the envelope context.","title":"context"},{"location":"aea/api/mail/base/#skill_id","text":"| @property | skill_id () -> Optional [ SkillId ] Get the skill id from an envelope context, if set. Returns : skill id","title":"skill_id"},{"location":"aea/api/mail/base/#__eq___2","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#encode_2","text":"| encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode_2","text":"| @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope.","title":"decode"},{"location":"aea/api/mail/base/#__str___2","text":"| __str__ () Get the string representation of an envelope.","title":"__str__"},{"location":"aea/api/mail/base/#multiplexer","text":"class Multiplexer () This class can handle multiple connections at once.","title":"Multiplexer"},{"location":"aea/api/mail/base/#__init___3","text":"| __init__ ( connections : Sequence [ \"Connection\" ], default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created.","title":"__init__"},{"location":"aea/api/mail/base/#in_queue","text":"| @property | in_queue () -> AsyncFriendlyQueue Get the in queue.","title":"in_queue"},{"location":"aea/api/mail/base/#out_queue","text":"| @property | out_queue () -> asyncio . Queue Get the out queue.","title":"out_queue"},{"location":"aea/api/mail/base/#connections","text":"| @property | connections () -> Tuple [ \"Connection\" ] Get the connections.","title":"connections"},{"location":"aea/api/mail/base/#is_connected","text":"| @property | is_connected () -> bool Check whether the multiplexer is processing envelopes.","title":"is_connected"},{"location":"aea/api/mail/base/#default_routing","text":"| @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) Set the default routing.","title":"default_routing"},{"location":"aea/api/mail/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/mail/base/#connect","text":"| connect () -> None Connect the multiplexer.","title":"connect"},{"location":"aea/api/mail/base/#disconnect","text":"| disconnect () -> None Disconnect the multiplexer.","title":"disconnect"},{"location":"aea/api/mail/base/#get","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout.","title":"get"},{"location":"aea/api/mail/base/#async_get","text":"| async async_get () -> Envelope Get an envelope async way. Returns : the envelope","title":"async_get"},{"location":"aea/api/mail/base/#async_wait","text":"| async async_wait () -> None Get an envelope async way. Returns : the envelope","title":"async_wait"},{"location":"aea/api/mail/base/#put","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None","title":"put"},{"location":"aea/api/mail/base/#inbox","text":"class InBox () A queue from where you can only consume envelopes.","title":"InBox"},{"location":"aea/api/mail/base/#__init___4","text":"| __init__ ( multiplexer : Multiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/mail/base/#empty_1","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/mail/base/#get_1","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails.","title":"get"},{"location":"aea/api/mail/base/#get_nowait","text":"| get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object","title":"get_nowait"},{"location":"aea/api/mail/base/#async_get_1","text":"| async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object.","title":"async_get"},{"location":"aea/api/mail/base/#async_wait_1","text":"| async async_wait () -> None Check for a envelope on the in queue. Returns : the envelope object.","title":"async_wait"},{"location":"aea/api/mail/base/#outbox","text":"class OutBox () A queue from where you can only enqueue envelopes.","title":"OutBox"},{"location":"aea/api/mail/base/#__init___5","text":"| __init__ ( multiplexer : Multiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/mail/base/#empty_2","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/mail/base/#put_1","text":"| put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None","title":"put"},{"location":"aea/api/mail/base/#put_message","text":"| put_message ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : to : the recipient of the envelope. sender : the sender of the envelope. protocol_id : the protocol id. message : the content of the message. Returns : None","title":"put_message"},{"location":"aea/api/protocols/base/","text":"aea.protocols.base This module contains the base message and serialization definition. Message class Message () This class implements a message. __ init __ | __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. counterparty | @counterparty . setter | counterparty ( counterparty : Address ) -> None Set the counterparty of the message. is _ incoming | @is_incoming . setter | is_incoming ( is_incoming : bool ) -> None Set the is_incoming of the message. body | @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None message _ id | @property | message_id () -> int Get the message id. set | set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None get | get ( key : str ) -> Optional [ Any ] Get value for key. unset | unset ( key : str ) -> None Unset valye for key. is _ set | is_set ( key : str ) -> bool Check value is set for key. __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the message. Encoder class Encoder ( ABC ) Encoder interface. encode | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message. Decoder class Decoder ( ABC ) Decoder interface. decode | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message. Serializer class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol. ProtobufSerializer class ProtobufSerializer ( Serializer ) Default Protobuf serializer. It assumes that the Message contains a JSON-serializable body. encode | encode ( msg : Message ) -> bytes Encode a message into bytes using Protobuf. decode | decode ( obj : bytes ) -> Message Decode bytes into a message using Protobuf. JSONSerializer class JSONSerializer ( Serializer ) Default serialization in JSON for the Message object. It assumes that the Message contains a JSON-serializable body. encode | encode ( msg : Message ) -> bytes Encode a message into bytes using JSON format. Arguments : msg : the message to be encoded. Returns : the serialized message. decode | decode ( obj : bytes ) -> Message Decode bytes into a message using JSON. Arguments : obj : the serialized message. Returns : the decoded message. Protocol class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message. __ init __ | __init__ ( configuration : ProtocolConfig , serializer : Serializer ) Initialize the protocol manager. Arguments : configuration : the protocol configurations. serializer : the serializer. serializer | @property | serializer () -> Serializer Get the serializer. from _ dir | @classmethod | from_dir ( cls , directory : str ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the protocol object. from _ config | @classmethod | from_config ( cls , configuration : ProtocolConfig ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. Returns : the protocol object.","title":"Base"},{"location":"aea/api/protocols/base/#aeaprotocolsbase","text":"This module contains the base message and serialization definition.","title":"aea.protocols.base"},{"location":"aea/api/protocols/base/#message","text":"class Message () This class implements a message.","title":"Message"},{"location":"aea/api/protocols/base/#__init__","text":"| __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"aea/api/protocols/base/#counterparty","text":"| @counterparty . setter | counterparty ( counterparty : Address ) -> None Set the counterparty of the message.","title":"counterparty"},{"location":"aea/api/protocols/base/#is_incoming","text":"| @is_incoming . setter | is_incoming ( is_incoming : bool ) -> None Set the is_incoming of the message.","title":"is_incoming"},{"location":"aea/api/protocols/base/#body","text":"| @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None","title":"body"},{"location":"aea/api/protocols/base/#message_id","text":"| @property | message_id () -> int Get the message id.","title":"message_id"},{"location":"aea/api/protocols/base/#set","text":"| set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None","title":"set"},{"location":"aea/api/protocols/base/#get","text":"| get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"aea/api/protocols/base/#unset","text":"| unset ( key : str ) -> None Unset valye for key.","title":"unset"},{"location":"aea/api/protocols/base/#is_set","text":"| is_set ( key : str ) -> bool Check value is set for key.","title":"is_set"},{"location":"aea/api/protocols/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/protocols/base/#__str__","text":"| __str__ () Get the string representation of the message.","title":"__str__"},{"location":"aea/api/protocols/base/#encoder","text":"class Encoder ( ABC ) Encoder interface.","title":"Encoder"},{"location":"aea/api/protocols/base/#encode","text":"| @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message.","title":"encode"},{"location":"aea/api/protocols/base/#decoder","text":"class Decoder ( ABC ) Decoder interface.","title":"Decoder"},{"location":"aea/api/protocols/base/#decode","text":"| @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#serializer","text":"class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol.","title":"Serializer"},{"location":"aea/api/protocols/base/#protobufserializer","text":"class ProtobufSerializer ( Serializer ) Default Protobuf serializer. It assumes that the Message contains a JSON-serializable body.","title":"ProtobufSerializer"},{"location":"aea/api/protocols/base/#encode_1","text":"| encode ( msg : Message ) -> bytes Encode a message into bytes using Protobuf.","title":"encode"},{"location":"aea/api/protocols/base/#decode_1","text":"| decode ( obj : bytes ) -> Message Decode bytes into a message using Protobuf.","title":"decode"},{"location":"aea/api/protocols/base/#jsonserializer","text":"class JSONSerializer ( Serializer ) Default serialization in JSON for the Message object. It assumes that the Message contains a JSON-serializable body.","title":"JSONSerializer"},{"location":"aea/api/protocols/base/#encode_2","text":"| encode ( msg : Message ) -> bytes Encode a message into bytes using JSON format. Arguments : msg : the message to be encoded. Returns : the serialized message.","title":"encode"},{"location":"aea/api/protocols/base/#decode_2","text":"| decode ( obj : bytes ) -> Message Decode bytes into a message using JSON. Arguments : obj : the serialized message. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#protocol","text":"class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message.","title":"Protocol"},{"location":"aea/api/protocols/base/#__init___1","text":"| __init__ ( configuration : ProtocolConfig , serializer : Serializer ) Initialize the protocol manager. Arguments : configuration : the protocol configurations. serializer : the serializer.","title":"__init__"},{"location":"aea/api/protocols/base/#serializer_1","text":"| @property | serializer () -> Serializer Get the serializer.","title":"serializer"},{"location":"aea/api/protocols/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the protocol object.","title":"from_dir"},{"location":"aea/api/protocols/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ProtocolConfig ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. Returns : the protocol object.","title":"from_config"},{"location":"aea/api/protocols/generator/","text":"aea.protocols.generator This module contains the protocol generator. ProtocolGenerator class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object. __ init __ | __init__ ( protocol_specification : ProtocolSpecification , output_path : str = \".\" , path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : protocol_specification : the protocol specification object output_path : the path to the location in which the protocol module is to be generated. Returns : None generate | generate () -> None Create the protocol package with Message, Serialization, init , protocol.yaml files. Returns : None","title":"Generator"},{"location":"aea/api/protocols/generator/#aeaprotocolsgenerator","text":"This module contains the protocol generator.","title":"aea.protocols.generator"},{"location":"aea/api/protocols/generator/#protocolgenerator","text":"class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object.","title":"ProtocolGenerator"},{"location":"aea/api/protocols/generator/#__init__","text":"| __init__ ( protocol_specification : ProtocolSpecification , output_path : str = \".\" , path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : protocol_specification : the protocol specification object output_path : the path to the location in which the protocol module is to be generated. Returns : None","title":"__init__"},{"location":"aea/api/protocols/generator/#generate","text":"| generate () -> None Create the protocol package with Message, Serialization, init , protocol.yaml files. Returns : None","title":"generate"},{"location":"aea/api/protocols/default/custom_types/","text":"aea.protocols.default.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode | @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"aea/api/protocols/default/custom_types/#aeaprotocolsdefaultcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"aea.protocols.default.custom_types"},{"location":"aea/api/protocols/default/custom_types/#errorcode","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode"},{"location":"aea/api/protocols/default/custom_types/#encode","text":"| @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/protocols/default/custom_types/#decode","text":"| @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"aea/api/protocols/default/message/","text":"aea.protocols.default.message This module contains default's message definition. DefaultMessage class DefaultMessage ( Message ) A protocol for exchanging any bytes message. Performative class Performative ( Enum ) Performatives for the default protocol. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. content | @property | content () -> bytes Get the 'content' content from the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. error _ data | @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message. error _ msg | @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"Message"},{"location":"aea/api/protocols/default/message/#aeaprotocolsdefaultmessage","text":"This module contains default's message definition.","title":"aea.protocols.default.message"},{"location":"aea/api/protocols/default/message/#defaultmessage","text":"class DefaultMessage ( Message ) A protocol for exchanging any bytes message.","title":"DefaultMessage"},{"location":"aea/api/protocols/default/message/#performative","text":"class Performative ( Enum ) Performatives for the default protocol.","title":"Performative"},{"location":"aea/api/protocols/default/message/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/default/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/default/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/default/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/default/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/default/message/#performative_1","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/default/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/default/message/#content","text":"| @property | content () -> bytes Get the 'content' content from the message.","title":"content"},{"location":"aea/api/protocols/default/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/default/message/#error_data","text":"| @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message.","title":"error_data"},{"location":"aea/api/protocols/default/message/#error_msg","text":"| @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"error_msg"},{"location":"aea/api/protocols/default/serialization/","text":"aea.protocols.default.serialization Serialization module for default protocol. DefaultSerializer class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol. encode | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"Serialization"},{"location":"aea/api/protocols/default/serialization/#aeaprotocolsdefaultserialization","text":"Serialization module for default protocol.","title":"aea.protocols.default.serialization"},{"location":"aea/api/protocols/default/serialization/#defaultserializer","text":"class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol.","title":"DefaultSerializer"},{"location":"aea/api/protocols/default/serialization/#encode","text":"| encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/default/serialization/#decode","text":"| decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"decode"},{"location":"aea/api/registries/resources/","text":"aea.registries.resources This module contains the resources class. Resources class Resources () This class implements the object that holds the resources of an AEA. __ init __ | __init__ ( directory : Optional [ Union [ str , os . PathLike ]] = None ) Instantiate the resources. Arguments : directory : the path to the directory which contains the resources (skills, connections and protocols) add _ component | add_component ( component : Component ) Add a component to resources. add _ protocol | add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol Returns : None get _ protocol | get_protocol ( protocol_id : ProtocolId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None get _ all _ protocols | get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols. remove _ protocol | remove_protocol ( protocol_id : ProtocolId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. Returns : None add _ contract | add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract Returns : None get _ contract | get_contract ( contract_id : ContractId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None get _ all _ contracts | get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts. remove _ contract | remove_contract ( contract_id : ContractId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. Returns : None add _ skill | add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill Returns : None get _ skill | get_skill ( skill_id : SkillId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None get _ all _ skills | get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills. remove _ skill | remove_skill ( skill_id : SkillId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. Returns : None get _ handler | get_handler ( protocol_id : ProtocolId , skill_id : SkillId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler get _ handlers | get_handlers ( protocol_id : ProtocolId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol get _ all _ handlers | get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers get _ behaviour | get_behaviour ( skill_id : SkillId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None get _ behaviours | get_behaviours ( skill_id : SkillId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill get _ all _ behaviours | get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours setup | setup () -> None Set up the resources. Calls setup on all resources. Returns : None teardown | teardown () -> None Teardown the resources. Calls teardown on all resources. Returns : None","title":"Resources"},{"location":"aea/api/registries/resources/#aearegistriesresources","text":"This module contains the resources class.","title":"aea.registries.resources"},{"location":"aea/api/registries/resources/#resources","text":"class Resources () This class implements the object that holds the resources of an AEA.","title":"Resources"},{"location":"aea/api/registries/resources/#__init__","text":"| __init__ ( directory : Optional [ Union [ str , os . PathLike ]] = None ) Instantiate the resources. Arguments : directory : the path to the directory which contains the resources (skills, connections and protocols)","title":"__init__"},{"location":"aea/api/registries/resources/#add_component","text":"| add_component ( component : Component ) Add a component to resources.","title":"add_component"},{"location":"aea/api/registries/resources/#add_protocol","text":"| add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol Returns : None","title":"add_protocol"},{"location":"aea/api/registries/resources/#get_protocol","text":"| get_protocol ( protocol_id : ProtocolId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol"},{"location":"aea/api/registries/resources/#get_all_protocols","text":"| get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols.","title":"get_all_protocols"},{"location":"aea/api/registries/resources/#remove_protocol","text":"| remove_protocol ( protocol_id : ProtocolId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. Returns : None","title":"remove_protocol"},{"location":"aea/api/registries/resources/#add_contract","text":"| add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract Returns : None","title":"add_contract"},{"location":"aea/api/registries/resources/#get_contract","text":"| get_contract ( contract_id : ContractId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None","title":"get_contract"},{"location":"aea/api/registries/resources/#get_all_contracts","text":"| get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts.","title":"get_all_contracts"},{"location":"aea/api/registries/resources/#remove_contract","text":"| remove_contract ( contract_id : ContractId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. Returns : None","title":"remove_contract"},{"location":"aea/api/registries/resources/#add_skill","text":"| add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill Returns : None","title":"add_skill"},{"location":"aea/api/registries/resources/#get_skill","text":"| get_skill ( skill_id : SkillId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None","title":"get_skill"},{"location":"aea/api/registries/resources/#get_all_skills","text":"| get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills.","title":"get_all_skills"},{"location":"aea/api/registries/resources/#remove_skill","text":"| remove_skill ( skill_id : SkillId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. Returns : None","title":"remove_skill"},{"location":"aea/api/registries/resources/#get_handler","text":"| get_handler ( protocol_id : ProtocolId , skill_id : SkillId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler","title":"get_handler"},{"location":"aea/api/registries/resources/#get_handlers","text":"| get_handlers ( protocol_id : ProtocolId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol","title":"get_handlers"},{"location":"aea/api/registries/resources/#get_all_handlers","text":"| get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers","title":"get_all_handlers"},{"location":"aea/api/registries/resources/#get_behaviour","text":"| get_behaviour ( skill_id : SkillId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None","title":"get_behaviour"},{"location":"aea/api/registries/resources/#get_behaviours","text":"| get_behaviours ( skill_id : SkillId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill","title":"get_behaviours"},{"location":"aea/api/registries/resources/#get_all_behaviours","text":"| get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours","title":"get_all_behaviours"},{"location":"aea/api/registries/resources/#setup","text":"| setup () -> None Set up the resources. Calls setup on all resources. Returns : None","title":"setup"},{"location":"aea/api/registries/resources/#teardown","text":"| teardown () -> None Teardown the resources. Calls teardown on all resources. Returns : None","title":"teardown"},{"location":"aea/api/skills/base/","text":"aea.skills.base This module contains the base classes for the skills. SkillContext class SkillContext () This class implements the context of a skill. __ init __ | __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) Initialize a skill context. set _ agent _ context | set_agent_context ( agent_context : AgentContext ) -> None Set the agent context. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. agent _ name | @property | agent_name () -> str Get agent name. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill context. is _ active | @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active). new _ behaviours | @property | new_behaviours () -> Queue The queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours. agent _ addresses | @property | agent_addresses () -> Dict [ str , str ] Get addresses. agent _ address | @property | agent_address () -> str Get address. connection _ status | @property | connection_status () -> ConnectionStatus Get connection status. outbox | @property | outbox () -> OutBox Get outbox. message _ in _ queue | @property | message_in_queue () -> Queue Get message in queue. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get message queue of decision maker. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context. task _ manager | @property | task_manager () -> TaskManager Get behaviours of the skill. ledger _ apis | @property | ledger_apis () -> LedgerApis Get ledger APIs. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. handlers | @property | handlers () -> SimpleNamespace Get handlers of the skill. behaviours | @property | behaviours () -> SimpleNamespace Get behaviours of the skill. contracts | @property | contracts () -> SimpleNamespace Get contracts the skill has access to. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace. __ getattr __ | __getattr__ ( item ) -> Any Get attribute. SkillComponent class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes. __ init __ | __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs , ,) Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. name | @property | name () -> str Get the name of the skill component. context | @property | context () -> SkillContext Get the context of the skill component. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill component. configuration | @property | configuration () -> SkillComponentConfiguration Get the skill component configuration. config | @property | config () -> Dict [ Any , Any ] Get the config of the skill component. setup | @abstractmethod | setup () -> None Implement the setup. Returns : None teardown | @abstractmethod | teardown () -> None Implement the teardown. Returns : None parse _ module | @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) Parse the component module. AbstractBehaviour class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls. Behaviour class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour. act | @abstractmethod | act () -> None Implement the behaviour. Returns : None is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour. Handler class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour. handle | @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None parse _ module | @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails. Model class Model ( SkillComponent , ABC ) This class implements an abstract model. setup | setup () -> None Set the class up. teardown | teardown () -> None Tear the class down. parse _ module | @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model. Skill class Skill ( Component ) This class implements a skill. __ init __ | __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None ) Initialize a skill. Arguments : configuration : the skill configuration. contracts | @property | contracts () -> Dict [ str , Contract ] Get the contracts associated with the skill. inject _ contracts | inject_contracts ( contracts : Dict [ str , Contract ]) -> None Add the contracts to the skill. skill _ context | @property | skill_context () -> SkillContext Get the skill context. handlers | @property | handlers () -> Dict [ str , Handler ] Get the handlers. behaviours | @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers. models | @property | models () -> Dict [ str , Model ] Get the handlers. from _ dir | @classmethod | from_dir ( cls , directory : str , skill_context : Optional [ SkillContext ] = None ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. skill_context : the skill context Returns : the skill object. from _ config | @classmethod | from_config ( cls , configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. Returns : the skill.","title":"Base"},{"location":"aea/api/skills/base/#aeaskillsbase","text":"This module contains the base classes for the skills.","title":"aea.skills.base"},{"location":"aea/api/skills/base/#skillcontext","text":"class SkillContext () This class implements the context of a skill.","title":"SkillContext"},{"location":"aea/api/skills/base/#__init__","text":"| __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) Initialize a skill context.","title":"__init__"},{"location":"aea/api/skills/base/#set_agent_context","text":"| set_agent_context ( agent_context : AgentContext ) -> None Set the agent context.","title":"set_agent_context"},{"location":"aea/api/skills/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"aea/api/skills/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/skills/base/#skill_id","text":"| @property | skill_id () -> PublicId Get the skill id of the skill context.","title":"skill_id"},{"location":"aea/api/skills/base/#is_active","text":"| @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#new_behaviours","text":"| @property | new_behaviours () -> Queue The queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours.","title":"new_behaviours"},{"location":"aea/api/skills/base/#agent_addresses","text":"| @property | agent_addresses () -> Dict [ str , str ] Get addresses.","title":"agent_addresses"},{"location":"aea/api/skills/base/#agent_address","text":"| @property | agent_address () -> str Get address.","title":"agent_address"},{"location":"aea/api/skills/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get connection status.","title":"connection_status"},{"location":"aea/api/skills/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/skills/base/#message_in_queue","text":"| @property | message_in_queue () -> Queue Get message in queue.","title":"message_in_queue"},{"location":"aea/api/skills/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get message queue of decision maker.","title":"decision_maker_message_queue"},{"location":"aea/api/skills/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/skills/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get behaviours of the skill.","title":"task_manager"},{"location":"aea/api/skills/base/#ledger_apis","text":"| @property | ledger_apis () -> LedgerApis Get ledger APIs.","title":"ledger_apis"},{"location":"aea/api/skills/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/skills/base/#handlers","text":"| @property | handlers () -> SimpleNamespace Get handlers of the skill.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours","text":"| @property | behaviours () -> SimpleNamespace Get behaviours of the skill.","title":"behaviours"},{"location":"aea/api/skills/base/#contracts","text":"| @property | contracts () -> SimpleNamespace Get contracts the skill has access to.","title":"contracts"},{"location":"aea/api/skills/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/skills/base/#__getattr__","text":"| __getattr__ ( item ) -> Any Get attribute.","title":"__getattr__"},{"location":"aea/api/skills/base/#skillcomponent","text":"class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes.","title":"SkillComponent"},{"location":"aea/api/skills/base/#__init___1","text":"| __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs , ,) Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context.","title":"__init__"},{"location":"aea/api/skills/base/#name","text":"| @property | name () -> str Get the name of the skill component.","title":"name"},{"location":"aea/api/skills/base/#context","text":"| @property | context () -> SkillContext Get the context of the skill component.","title":"context"},{"location":"aea/api/skills/base/#skill_id_1","text":"| @property | skill_id () -> PublicId Get the skill id of the skill component.","title":"skill_id"},{"location":"aea/api/skills/base/#configuration","text":"| @property | configuration () -> SkillComponentConfiguration Get the skill component configuration.","title":"configuration"},{"location":"aea/api/skills/base/#config","text":"| @property | config () -> Dict [ Any , Any ] Get the config of the skill component.","title":"config"},{"location":"aea/api/skills/base/#setup","text":"| @abstractmethod | setup () -> None Implement the setup. Returns : None","title":"setup"},{"location":"aea/api/skills/base/#teardown","text":"| @abstractmethod | teardown () -> None Implement the teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/base/#parse_module","text":"| @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) Parse the component module.","title":"parse_module"},{"location":"aea/api/skills/base/#abstractbehaviour","text":"class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls.","title":"AbstractBehaviour"},{"location":"aea/api/skills/base/#behaviour","text":"class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour.","title":"Behaviour"},{"location":"aea/api/skills/base/#act","text":"| @abstractmethod | act () -> None Implement the behaviour. Returns : None","title":"act"},{"location":"aea/api/skills/base/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/base/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/base/#parse_module_1","text":"| @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour.","title":"parse_module"},{"location":"aea/api/skills/base/#handler","text":"class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour.","title":"Handler"},{"location":"aea/api/skills/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None","title":"handle"},{"location":"aea/api/skills/base/#parse_module_2","text":"| @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails.","title":"parse_module"},{"location":"aea/api/skills/base/#model","text":"class Model ( SkillComponent , ABC ) This class implements an abstract model.","title":"Model"},{"location":"aea/api/skills/base/#setup_1","text":"| setup () -> None Set the class up.","title":"setup"},{"location":"aea/api/skills/base/#teardown_1","text":"| teardown () -> None Tear the class down.","title":"teardown"},{"location":"aea/api/skills/base/#parse_module_3","text":"| @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model.","title":"parse_module"},{"location":"aea/api/skills/base/#skill","text":"class Skill ( Component ) This class implements a skill.","title":"Skill"},{"location":"aea/api/skills/base/#__init___2","text":"| __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None ) Initialize a skill. Arguments : configuration : the skill configuration.","title":"__init__"},{"location":"aea/api/skills/base/#contracts_1","text":"| @property | contracts () -> Dict [ str , Contract ] Get the contracts associated with the skill.","title":"contracts"},{"location":"aea/api/skills/base/#inject_contracts","text":"| inject_contracts ( contracts : Dict [ str , Contract ]) -> None Add the contracts to the skill.","title":"inject_contracts"},{"location":"aea/api/skills/base/#skill_context","text":"| @property | skill_context () -> SkillContext Get the skill context.","title":"skill_context"},{"location":"aea/api/skills/base/#handlers_1","text":"| @property | handlers () -> Dict [ str , Handler ] Get the handlers.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours_1","text":"| @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers.","title":"behaviours"},{"location":"aea/api/skills/base/#models","text":"| @property | models () -> Dict [ str , Model ] Get the handlers.","title":"models"},{"location":"aea/api/skills/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , skill_context : Optional [ SkillContext ] = None ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. skill_context : the skill context Returns : the skill object.","title":"from_dir"},{"location":"aea/api/skills/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. Returns : the skill.","title":"from_config"},{"location":"aea/api/skills/behaviours/","text":"aea.skills.behaviours This module contains the classes for specific behaviours. SimpleBehaviour class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour. __ init __ | __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class. setup | setup () -> None Set the behaviour up. act | act () -> None Do the action. teardown | teardown () -> None Tear the behaviour down. CompositeBehaviour class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour. CyclicBehaviour class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. OneShotBehaviour class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. TickerBehaviour class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval. __ init __ | __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> datetime . datetime Get the start time. last _ act _ time | @property | last_act_time () -> datetime . datetime Get the last time the act method has been called. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ time _ to _ act | is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise. SequenceBehaviour class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially. __ init __ | __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : current _ behaviour | @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. act | act () -> None Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. State class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger. __ init __ | __init__ ( ** kwargs ) Initialize a state of the state machine. event | @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour. is _ done | @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise. reset | reset () -> None Reset initial conditions. FSMBehaviour class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour. __ init __ | __init__ ( ** kwargs ) Initialize the finite-state machine behaviour. is _ started | @property | is_started () -> bool Check if the behaviour is started. register _ state | register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists. register _ final _ state | register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists. unregister _ state | unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered. states | @property | states () -> Set [ str ] Get all the state names. initial _ state | @initial_state . setter | initial_state ( name : str ) Set the initial state. final _ states | @property | final_states () -> Set [ str ] Get the final state names. get _ state | get_state ( name ) -> Optional [ State ] Get a state from its name. act | act () Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. register _ transition | register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present. unregister _ transition | unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"Behaviors"},{"location":"aea/api/skills/behaviours/#aeaskillsbehaviours","text":"This module contains the classes for specific behaviours.","title":"aea.skills.behaviours"},{"location":"aea/api/skills/behaviours/#simplebehaviour","text":"class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour.","title":"SimpleBehaviour"},{"location":"aea/api/skills/behaviours/#__init__","text":"| __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class.","title":"__init__"},{"location":"aea/api/skills/behaviours/#setup","text":"| setup () -> None Set the behaviour up.","title":"setup"},{"location":"aea/api/skills/behaviours/#act","text":"| act () -> None Do the action.","title":"act"},{"location":"aea/api/skills/behaviours/#teardown","text":"| teardown () -> None Tear the behaviour down.","title":"teardown"},{"location":"aea/api/skills/behaviours/#compositebehaviour","text":"class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour.","title":"CompositeBehaviour"},{"location":"aea/api/skills/behaviours/#cyclicbehaviour","text":"class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped.","title":"CyclicBehaviour"},{"location":"aea/api/skills/behaviours/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition.","title":"is_done"},{"location":"aea/api/skills/behaviours/#oneshotbehaviour","text":"class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once.","title":"OneShotBehaviour"},{"location":"aea/api/skills/behaviours/#__init___2","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_done_1","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#act_wrapper_1","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#tickerbehaviour","text":"class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval.","title":"TickerBehaviour"},{"location":"aea/api/skills/behaviours/#__init___3","text":"| __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset.","title":"__init__"},{"location":"aea/api/skills/behaviours/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/behaviours/#start_at","text":"| @property | start_at () -> datetime . datetime Get the start time.","title":"start_at"},{"location":"aea/api/skills/behaviours/#last_act_time","text":"| @property | last_act_time () -> datetime . datetime Get the last time the act method has been called.","title":"last_act_time"},{"location":"aea/api/skills/behaviours/#act_wrapper_2","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_time_to_act","text":"| is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise.","title":"is_time_to_act"},{"location":"aea/api/skills/behaviours/#sequencebehaviour","text":"class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially.","title":"SequenceBehaviour"},{"location":"aea/api/skills/behaviours/#__init___4","text":"| __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs :","title":"__init__"},{"location":"aea/api/skills/behaviours/#current_behaviour","text":"| @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done.","title":"current_behaviour"},{"location":"aea/api/skills/behaviours/#act_1","text":"| act () -> None Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_2","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#state","text":"class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.","title":"State"},{"location":"aea/api/skills/behaviours/#__init___5","text":"| __init__ ( ** kwargs ) Initialize a state of the state machine.","title":"__init__"},{"location":"aea/api/skills/behaviours/#event","text":"| @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour.","title":"event"},{"location":"aea/api/skills/behaviours/#is_done_3","text":"| @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#reset","text":"| reset () -> None Reset initial conditions.","title":"reset"},{"location":"aea/api/skills/behaviours/#fsmbehaviour","text":"class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour.","title":"FSMBehaviour"},{"location":"aea/api/skills/behaviours/#__init___6","text":"| __init__ ( ** kwargs ) Initialize the finite-state machine behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_started","text":"| @property | is_started () -> bool Check if the behaviour is started.","title":"is_started"},{"location":"aea/api/skills/behaviours/#register_state","text":"| register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_state"},{"location":"aea/api/skills/behaviours/#register_final_state","text":"| register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_final_state"},{"location":"aea/api/skills/behaviours/#unregister_state","text":"| unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered.","title":"unregister_state"},{"location":"aea/api/skills/behaviours/#states","text":"| @property | states () -> Set [ str ] Get all the state names.","title":"states"},{"location":"aea/api/skills/behaviours/#initial_state","text":"| @initial_state . setter | initial_state ( name : str ) Set the initial state.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#final_states","text":"| @property | final_states () -> Set [ str ] Get the final state names.","title":"final_states"},{"location":"aea/api/skills/behaviours/#get_state","text":"| get_state ( name ) -> Optional [ State ] Get a state from its name.","title":"get_state"},{"location":"aea/api/skills/behaviours/#act_2","text":"| act () Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_4","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#register_transition","text":"| register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present.","title":"register_transition"},{"location":"aea/api/skills/behaviours/#unregister_transition","text":"| unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"unregister_transition"},{"location":"aea/api/skills/tasks/","text":"aea.skills.tasks This module contains the classes for tasks. Task class Task () This class implements an abstract task. __ init __ | __init__ ( ** kwargs ) Initialize a task. __ call __ | __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed. is _ executed | @property | is_executed () -> bool Check if the task has already been executed. result | @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet. setup | @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None execute | @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None teardown | @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None init _ worker init_worker () -> None Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296 Returns : None TaskManager class TaskManager () A Task manager. __ init __ | __init__ ( nb_workers : int = 1 , is_lazy_pool_start : bool = True ) Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. is _ started | @property | is_started () -> bool Get started status of TaskManager. Returns : bool nb _ workers | @property | nb_workers () -> int Get the number of workers. Returns : int enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running. get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id start | start () -> None Start the task manager. Returns : None stop | stop () -> None Stop the task manager. Returns : None","title":"Task"},{"location":"aea/api/skills/tasks/#aeaskillstasks","text":"This module contains the classes for tasks.","title":"aea.skills.tasks"},{"location":"aea/api/skills/tasks/#task","text":"class Task () This class implements an abstract task.","title":"Task"},{"location":"aea/api/skills/tasks/#__init__","text":"| __init__ ( ** kwargs ) Initialize a task.","title":"__init__"},{"location":"aea/api/skills/tasks/#__call__","text":"| __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed.","title":"__call__"},{"location":"aea/api/skills/tasks/#is_executed","text":"| @property | is_executed () -> bool Check if the task has already been executed.","title":"is_executed"},{"location":"aea/api/skills/tasks/#result","text":"| @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet.","title":"result"},{"location":"aea/api/skills/tasks/#setup","text":"| @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None","title":"setup"},{"location":"aea/api/skills/tasks/#execute","text":"| @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None","title":"execute"},{"location":"aea/api/skills/tasks/#teardown","text":"| @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/tasks/#init_worker","text":"init_worker () -> None Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296 Returns : None","title":"init_worker"},{"location":"aea/api/skills/tasks/#taskmanager","text":"class TaskManager () A Task manager.","title":"TaskManager"},{"location":"aea/api/skills/tasks/#__init___1","text":"| __init__ ( nb_workers : int = 1 , is_lazy_pool_start : bool = True ) Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called.","title":"__init__"},{"location":"aea/api/skills/tasks/#is_started","text":"| @property | is_started () -> bool Get started status of TaskManager. Returns : bool","title":"is_started"},{"location":"aea/api/skills/tasks/#nb_workers","text":"| @property | nb_workers () -> int Get the number of workers. Returns : int","title":"nb_workers"},{"location":"aea/api/skills/tasks/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"enqueue_task"},{"location":"aea/api/skills/tasks/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id","title":"get_task_result"},{"location":"aea/api/skills/tasks/#start","text":"| start () -> None Start the task manager. Returns : None","title":"start"},{"location":"aea/api/skills/tasks/#stop","text":"| stop () -> None Stop the task manager. Returns : None","title":"stop"},{"location":"aea/api/skills/error/handlers/","text":"aea.skills.error.handlers This package contains the implementation of the handler for the 'default' protocol. ErrorHandler class ErrorHandler ( Handler ) This class implements the error handler. setup | setup () -> None Implement the setup. Returns : None handle | handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message teardown | teardown () -> None Implement the handler teardown. Returns : None send _ unsupported _ protocol | send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None send _ decoding _ error | send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None send _ unsupported _ skill | send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"Error Skill"},{"location":"aea/api/skills/error/handlers/#aeaskillserrorhandlers","text":"This package contains the implementation of the handler for the 'default' protocol.","title":"aea.skills.error.handlers"},{"location":"aea/api/skills/error/handlers/#errorhandler","text":"class ErrorHandler ( Handler ) This class implements the error handler.","title":"ErrorHandler"},{"location":"aea/api/skills/error/handlers/#setup","text":"| setup () -> None Implement the setup. Returns : None","title":"setup"},{"location":"aea/api/skills/error/handlers/#handle","text":"| handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message","title":"handle"},{"location":"aea/api/skills/error/handlers/#teardown","text":"| teardown () -> None Implement the handler teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/error/handlers/#send_unsupported_protocol","text":"| send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/skills/error/handlers/#send_decoding_error","text":"| send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None","title":"send_decoding_error"},{"location":"aea/api/skills/error/handlers/#send_unsupported_skill","text":"| send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_skill"},{"location":"aea/api/test_tools/generic/","text":"aea.test _ tools.generic This module contains generic tools for AEA end-to-end testing. write _ envelope _ to _ file write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path Returns : None read _ envelope _ from _ file read_envelope_from_file ( file_path : str ) Read an envelope from a file. :param file_path the file path. Returns : envelope force _ set _ config force_set_config ( dotted_path : str , value : Any ) -> None Set an AEA config without validation. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. Returns : None.","title":"Test Tools"},{"location":"aea/api/test_tools/generic/#aeatest_toolsgeneric","text":"This module contains generic tools for AEA end-to-end testing.","title":"aea.test_tools.generic"},{"location":"aea/api/test_tools/generic/#write_envelope_to_file","text":"write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path Returns : None","title":"write_envelope_to_file"},{"location":"aea/api/test_tools/generic/#read_envelope_from_file","text":"read_envelope_from_file ( file_path : str ) Read an envelope from a file. :param file_path the file path. Returns : envelope","title":"read_envelope_from_file"},{"location":"aea/api/test_tools/generic/#force_set_config","text":"force_set_config ( dotted_path : str , value : Any ) -> None Set an AEA config without validation. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. Returns : None.","title":"force_set_config"},{"location":"ledger/","text":"Fetch.ai ledger The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below. Increased rate of transactions per second The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here . Custom consensus algorithm The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper . Support for on-chain ML and AI operations Coming soon.","title":"Introduction"},{"location":"ledger/#fetchai-ledger","text":"The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below.","title":"Fetch.ai ledger"},{"location":"ledger/#increased-rate-of-transactions-per-second","text":"The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here .","title":"Increased rate of transactions per second"},{"location":"ledger/#custom-consensus-algorithm","text":"The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper .","title":"Custom consensus algorithm"},{"location":"ledger/#support-for-on-chain-ml-and-ai-operations","text":"Coming soon.","title":"Support for on-chain ML and AI operations"},{"location":"ledger/architecture/","text":"Architecture This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct. Sharding In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load. HTTP pages and API Note Coming soon Networking Note Coming soon","title":"Architecture"},{"location":"ledger/architecture/#architecture","text":"This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct.","title":"Architecture"},{"location":"ledger/architecture/#sharding","text":"In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load.","title":"Sharding"},{"location":"ledger/architecture/#http-pages-and-api","text":"Note Coming soon","title":"HTTP pages and API"},{"location":"ledger/architecture/#networking","text":"Note Coming soon","title":"Networking"},{"location":"ledger/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/maths-lib-overview/","text":"etch mathematics and machine learning operations are supported by a header-only fully-templated C++ library. Detailed developer documentation for the C++ implementation of the maths libraries will be available in the Fetch Ledger section in due course. Developers should be comfortable with SFINAE. Architecture A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress. Tensor A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here . Working with the maths library When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Maths library"},{"location":"ledger/maths-lib-overview/#architecture","text":"A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress.","title":"Architecture"},{"location":"ledger/maths-lib-overview/#tensor","text":"A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here .","title":"Tensor"},{"location":"ledger/maths-lib-overview/#working-with-the-maths-library","text":"When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Working with the maths library"},{"location":"ledger/running-a-constellation/","text":"Local node From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Connect to a node on testnet From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet Compiler flags The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Running a node"},{"location":"ledger/running-a-constellation/#local-node","text":"From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents.","title":"Local node"},{"location":"ledger/running-a-constellation/#connect-to-a-node-on-testnet","text":"From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet","title":"Connect to a node on testnet"},{"location":"ledger/running-a-constellation/#compiler-flags","text":"The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Compiler flags"},{"location":"ledger/etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai Ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.ai Ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Design and test your smart contract code with the etch VM simulator before including it in a Python Ledger API script which takes care of deployment and other details. Find out how to run smart contract code with the Python Ledger API here . Note The `etch` language and the `etch` language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"Introduction"},{"location":"ledger/etch-language/addresses/","text":"Address type format The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) . Create an Address function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Type size in detail There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address ) SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready. Print Address Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Address"},{"location":"ledger/etch-language/addresses/#address-type-format","text":"The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) .","title":"Address type format"},{"location":"ledger/etch-language/addresses/#create-an-address","text":"function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction","title":"Create an Address"},{"location":"ledger/etch-language/addresses/#type-size-in-detail","text":"There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address )","title":"Type size in detail"},{"location":"ledger/etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"ledger/etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"ledger/etch-language/addresses/#print-address","text":"Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Print Address"},{"location":"ledger/etch-language/arrays/","text":"Arrays One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction Two dimensional arrays Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction Array functions Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction Pop back and front with n Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"ledger/etch-language/arrays/#arrays","text":"","title":"Arrays"},{"location":"ledger/etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction","title":"One dimensional arrays"},{"location":"ledger/etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"ledger/etch-language/arrays/#nested-arrays","text":"etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction","title":"Nested arrays"},{"location":"ledger/etch-language/arrays/#array-functions","text":"","title":"Array functions"},{"location":"ledger/etch-language/arrays/#count","text":"The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction","title":"Count"},{"location":"ledger/etch-language/arrays/#append","text":"The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Append"},{"location":"ledger/etch-language/arrays/#extend","text":"Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction","title":"Extend"},{"location":"ledger/etch-language/arrays/#pop-back-and-pop-front","text":"The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction","title":"Pop back and pop front"},{"location":"ledger/etch-language/arrays/#pop-back-and-front-with-n","text":"Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction","title":"Pop back and front with n"},{"location":"ledger/etch-language/arrays/#reverse","text":"The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Reverse"},{"location":"ledger/etch-language/arrays/#erase","text":"Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Erase"},{"location":"ledger/etch-language/balance-transfer/","text":"Like Context , Block , and Transaction , the balance and transfer functions must run against a Fetch.ai Ledger node. balance() The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear transfer(target : Address, amount : UInt64) The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear Example Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here . etch smart contract code The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other. Python Ledger API wrapper code from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Balance and Transfer"},{"location":"ledger/etch-language/balance-transfer/#balance","text":"The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear","title":"balance()"},{"location":"ledger/etch-language/balance-transfer/#transfertarget-address-amount-uint64","text":"The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear","title":"transfer(target : Address, amount : UInt64)"},{"location":"ledger/etch-language/balance-transfer/#example","text":"Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here .","title":"Example"},{"location":"ledger/etch-language/balance-transfer/#etch-smart-contract-code","text":"The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other.","title":"etch smart contract code"},{"location":"ledger/etch-language/balance-transfer/#python-ledger-api-wrapper-code","text":"from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Python Ledger API wrapper code"},{"location":"ledger/etch-language/context/","text":"Context is an etch language type that provides access to currently invoking ledger transaction data - such as block and transaction information - coming from smart contracts running against ledger nodes. Specific annotated functions Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node. Coding with Context Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. getContext() , block() , and blockNumber() To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); Example The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Context"},{"location":"ledger/etch-language/context/#specific-annotated-functions","text":"Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node.","title":"Specific annotated functions"},{"location":"ledger/etch-language/context/#coding-with-context","text":"Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates.","title":"Coding with Context"},{"location":"ledger/etch-language/context/#getcontext-block-and-blocknumber","text":"To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber ();","title":"getContext(), block(), and blockNumber()"},{"location":"ledger/etch-language/context/#example","text":"The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Example"},{"location":"ledger/etch-language/control-flow/","text":"Control flow Tip Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"ledger/etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction","title":"if-else"},{"location":"ledger/etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"ledger/etch-language/control-flow/#for","text":"function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction","title":"for"},{"location":"ledger/etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"ledger/etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"ledger/etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings and applying them to the SHA256() object. The example then resets the object and repeats the process with three more strings. function main () var my_string_value_1 = \"sdkjfhiuwehfesdfno ; s ; ' mADF ; LK \"; var my_string_value_2 = \"ipoiuwr8934jklnwlkj0892;m\" ; var my_string_value_3 = \"vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548\" ; // create a SHA256() context object var sha256_hash = SHA256 (); // give it your strings sha256_hash . update ( my_string_value_1 ); sha256_hash . update ( my_string_value_2 ); sha256_hash . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 1,2,3 = \" + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hash . reset (); // more strings var my_string_value_4 = \"12345fg\" ; var my_string_value_5 = \"@!#$@#%#\" ; var my_string_value_6 = \"{}:>L$%^:c\" ; // add to context sha256_hash . update ( my_string_value_4 ); sha256_hash . update ( my_string_value_5 ); sha256_hash . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 4,5,6 = \" + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"ledger/etch-language/data-loaders/","text":"A DataLoader is an object used by an Optimiser for loading data into a Graph . Usually this data is a pair of Tensor types (data and label). Declare and initialise a DataLoader giving a string parameter which defines the type of input data. The common generic DataLoader takes Tensor objects. function main () var dataLoader = DataLoader ( \"tensor\" ); endfunction There are currently three flavours of DataLoader in etch . Fetch.ai developers have built specific DataLoader types for research and example purposes that take MNIST files, and csv files for a commodity application. Tensor data loader Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction isDone() and getNext() DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction Serialisation A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"DataLoader"},{"location":"ledger/etch-language/data-loaders/#tensor-data-loader","text":"Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction","title":"Tensor data loader"},{"location":"ledger/etch-language/data-loaders/#isdone-and-getnext","text":"DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction","title":"isDone() and getNext()"},{"location":"ledger/etch-language/data-loaders/#serialisation","text":"A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the `etch` compiler will strip out `printLn()` statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"ledger/etch-language/debug/#compiling","text":"Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope.","title":"Compiling"},{"location":"ledger/etch-language/debug/#system-arguments","text":"System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"System arguments"},{"location":"ledger/etch-language/error-checking/","text":"The following functions help with diagnosing bugs and ensuring the correct state of variables and boolean tests. Panic Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction Assert Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"ledger/etch-language/error-checking/#panic","text":"Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Panic"},{"location":"ledger/etch-language/error-checking/#assert","text":"Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Assert"},{"location":"ledger/etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending `etch` in C++.","title":"Extending etch"},{"location":"ledger/etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv() Type casting toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here . Getters and setters Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Functions"},{"location":"ledger/etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"ledger/etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"ledger/etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"ledger/etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"ledger/etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"ledger/etch-language/functions/#print","text":"printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards.","title":"Print"},{"location":"ledger/etch-language/functions/#sysargs","text":"The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv()","title":"Sysargs"},{"location":"ledger/etch-language/functions/#type-casting","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction","title":"Type casting"},{"location":"ledger/etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here .","title":"Annotations"},{"location":"ledger/etch-language/functions/#getters-and-setters","text":"Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Getters and setters"},{"location":"ledger/etch-language/getstarted/","text":"Getting started Prerequisites To build with Etch, you will need a running node. Installation At the root of your ledger installation directory cd into build folder. Run make etch . Setup At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract. Hello world with Etch Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Compile and run two or more etch files It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch . Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Getting started"},{"location":"ledger/etch-language/getstarted/#getting-started","text":"","title":"Getting started"},{"location":"ledger/etch-language/getstarted/#prerequisites","text":"To build with Etch, you will need a running node.","title":"Prerequisites"},{"location":"ledger/etch-language/getstarted/#installation","text":"At the root of your ledger installation directory cd into build folder. Run make etch .","title":"Installation"},{"location":"ledger/etch-language/getstarted/#setup","text":"At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"ledger/etch-language/getstarted/#hello-world-with-etch","text":"Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with Etch"},{"location":"ledger/etch-language/getstarted/#compile-and-run-two-or-more-etch-files","text":"It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch .","title":"Compile and run two or more etch files"},{"location":"ledger/etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"ledger/etch-language/graph/","text":"Declare and initialise a Graph . function main () var graph = Graph (); endfunction A Graph is a directed acyclic computational graph used to process data through a sequence of operations. The current primary use case for these is the instantiation of neural networks. Each node in the Graph maintains responsibility for either a single operation or a layer of operations. The preferred method for training a Graph is to use a DataLoader and Optimiser . We describe these two objects in a later section. Placeholders Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction Layers Fully connected Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction 1D convolution The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction Operations Activations ReLU The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction Softmax The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction Dropout The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction Transpose The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction Exp The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction Loss functions Cross entropy loss The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction Mean square error loss The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction Serialisation For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction Serialise to string It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction Deserialise from string Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction Build a Graph example The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction Training a Graph example Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section. 1. Set input Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction 2. Evaluate The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction 3. Back propagate Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction 4. Step Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"Graph"},{"location":"ledger/etch-language/graph/#placeholders","text":"Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction","title":"Placeholders"},{"location":"ledger/etch-language/graph/#layers","text":"","title":"Layers"},{"location":"ledger/etch-language/graph/#fully-connected","text":"Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction","title":"Fully connected"},{"location":"ledger/etch-language/graph/#1d-convolution","text":"The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction","title":"1D convolution"},{"location":"ledger/etch-language/graph/#operations","text":"","title":"Operations"},{"location":"ledger/etch-language/graph/#activations","text":"","title":"Activations"},{"location":"ledger/etch-language/graph/#relu","text":"The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction","title":"ReLU"},{"location":"ledger/etch-language/graph/#softmax","text":"The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction","title":"Softmax"},{"location":"ledger/etch-language/graph/#dropout","text":"The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction","title":"Dropout"},{"location":"ledger/etch-language/graph/#transpose","text":"The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction","title":"Transpose"},{"location":"ledger/etch-language/graph/#exp","text":"The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction","title":"Exp"},{"location":"ledger/etch-language/graph/#loss-functions","text":"","title":"Loss functions"},{"location":"ledger/etch-language/graph/#cross-entropy-loss","text":"The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction","title":"Cross entropy loss"},{"location":"ledger/etch-language/graph/#mean-square-error-loss","text":"The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction","title":"Mean square error loss"},{"location":"ledger/etch-language/graph/#serialisation","text":"For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/graph/#serialise-to-string","text":"It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction","title":"Serialise to string"},{"location":"ledger/etch-language/graph/#deserialise-from-string","text":"Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction","title":"Deserialise from string"},{"location":"ledger/etch-language/graph/#build-a-graph-example","text":"The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction","title":"Build a Graph example"},{"location":"ledger/etch-language/graph/#training-a-graph-example","text":"Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section.","title":"Training a Graph example"},{"location":"ledger/etch-language/graph/#1-set-input","text":"Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction","title":"1. Set input"},{"location":"ledger/etch-language/graph/#2-evaluate","text":"The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction","title":"2. Evaluate"},{"location":"ledger/etch-language/graph/#3-back-propagate","text":"Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction","title":"3. Back propagate"},{"location":"ledger/etch-language/graph/#4-step","text":"Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"4. Step"},{"location":"ledger/etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Xor Note Coming soon: support for `xor`.","title":"Logical operators"},{"location":"ledger/etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction","title":"Equal to"},{"location":"ledger/etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction","title":"Not equal to"},{"location":"ledger/etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction","title":"Less than"},{"location":"ledger/etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction","title":"More than"},{"location":"ledger/etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"And"},{"location":"ledger/etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"Or"},{"location":"ledger/etch-language/logic/#xor","text":"Note Coming soon: support for `xor`.","title":"Xor"},{"location":"ledger/etch-language/maths-functions/","text":"Tip `Fixed64` is the default variable data type used by the `etch` mathematics and machine learning libraries. In the current version, and further to the common mathematical operations provided by the etch language already discussed here , the following functions are available. Absolute value abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = - 1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction Exponential function The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction Range restrictions Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range. Special cases Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x) Errors for x \u2208 (-10, 5) Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07 Power The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));` Special cases Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x Errors for x \u2208 (0, 100), y \u2208 (0, 10.5) Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10 Errors for x \u2208 (-10, 10), y \u2208 (-4, 4) Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10 Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction Square root The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction Special cases Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf Errors for x \u2208 (0, 5) Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09 Trigonometry Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Sin special cases Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x) Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Cos special cases Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1 Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Tan special cases Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06 ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction ASin special cases Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x) Errors for x \u2208 (-1, 1) Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09 ACos special cases Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09 ATan special cases Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x) Errors for x \u2208 (-5, 5) Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08 Hyperbolic Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2` SinH special cases Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf Errors for x \u2208 (-5, 5) Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08 CosH special cases Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2` Errors for x \u2208 (-5, 5) Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08 TanH special cases Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))` Errors for x \u2208 (-3, 3) Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09 Hyperbolic ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction ArcSin special cases Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf Errors for x \u2208 (-3, 3) Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08 ArcCos special cases Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN Errors for x \u2208 (1, 3) Fixed32 : average: 8.53834e-06 , max: 6.62567e-05 Errors for x \u2208 (1, 5) Fixed64 : average: 2.37609e-09 , max: 2.28507e-08 ArcTan special cases Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Maths functions"},{"location":"ledger/etch-language/maths-functions/#absolute-value","text":"abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = - 1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction","title":"Absolute value"},{"location":"ledger/etch-language/maths-functions/#exponential-function","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction","title":"Exponential function"},{"location":"ledger/etch-language/maths-functions/#range-restrictions","text":"Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range.","title":"Range restrictions"},{"location":"ledger/etch-language/maths-functions/#special-cases","text":"Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x)","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-10-5","text":"Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07","title":"Errors for x \u2208 (-10, 5)"},{"location":"ledger/etch-language/maths-functions/#power","text":"The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));`","title":"Power"},{"location":"ledger/etch-language/maths-functions/#special-cases_1","text":"Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-0-100-y-0-105","text":"Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10","title":"Errors for x \u2208 (0, 100), y \u2208 (0, 10.5)"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-10-10-y-4-4","text":"Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10","title":"Errors for x \u2208 (-10, 10), y \u2208 (-4, 4)"},{"location":"ledger/etch-language/maths-functions/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction","title":"Random (non deterministic)"},{"location":"ledger/etch-language/maths-functions/#square-root","text":"The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction","title":"Square root"},{"location":"ledger/etch-language/maths-functions/#special-cases_2","text":"Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-0-5","text":"Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09","title":"Errors for x \u2208 (0, 5)"},{"location":"ledger/etch-language/maths-functions/#trigonometry","text":"","title":"Trigonometry"},{"location":"ledger/etch-language/maths-functions/#sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction","title":"Sin, Cos, and Tan"},{"location":"ledger/etch-language/maths-functions/#sin-special-cases","text":"Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x)","title":"Sin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger/etch-language/maths-functions/#cos-special-cases","text":"Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1","title":"Cos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2_1","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger/etch-language/maths-functions/#tan-special-cases","text":"Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf","title":"Tan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-pi2-001-pi2-001","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01)"},{"location":"ledger/etch-language/maths-functions/#arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction","title":"ArcSin, ArcCos, and ArcTan"},{"location":"ledger/etch-language/maths-functions/#asin-special-cases","text":"Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x)","title":"ASin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1","text":"Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/maths-functions/#acos-special-cases","text":"Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN","title":"ACos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1_1","text":"Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/maths-functions/#atan-special-cases","text":"Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x)","title":"ATan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5","text":"Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#hyperbolic-sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2`","title":"Hyperbolic Sin, Cos, and Tan"},{"location":"ledger/etch-language/maths-functions/#sinh-special-cases","text":"Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf","title":"SinH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5_1","text":"Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#cosh-special-cases","text":"Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2`","title":"CosH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5_2","text":"Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#tanh-special-cases","text":"Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))`","title":"TanH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-3-3","text":"Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger/etch-language/maths-functions/#hyperbolic-arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Hyperbolic ArcSin, ArcCos, and ArcTan"},{"location":"ledger/etch-language/maths-functions/#arcsin-special-cases","text":"Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf","title":"ArcSin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-3-3_1","text":"Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger/etch-language/maths-functions/#arccos-special-cases","text":"Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN","title":"ArcCos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-3","text":"Fixed32 : average: 8.53834e-06 , max: 6.62567e-05","title":"Errors for x \u2208 (1, 3)"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-5","text":"Fixed64 : average: 2.37609e-09 , max: 2.28507e-08","title":"Errors for x \u2208 (1, 5)"},{"location":"ledger/etch-language/maths-functions/#arctan-special-cases","text":"Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN","title":"ArcTan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1_2","text":"Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/model/","text":"A Model is the simplest way to build, train, and evaluate neural networks in etch . The Model type takes care of the underlying implementation details for Graph , DataLoader , and Optimiser . There are three types of Model . Sequential : trains a computational graph to predict either continuous variables or classes, and allows more control over the layers of the network. Regressor : trains a computational graph to predict continuous variables. For example, what will be the future price of a particular currency? Classifier : trains a computational graph to predict classes. For example, is this a picture of a cat or a dog? Construct a Model Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction Add Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction Compile Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction Read in input data The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Fit With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction Evaluate Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction Predict Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Model"},{"location":"ledger/etch-language/model/#construct-a-model","text":"Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction","title":"Construct a Model"},{"location":"ledger/etch-language/model/#add","text":"Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction","title":"Add"},{"location":"ledger/etch-language/model/#compile","text":"Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction","title":"Compile"},{"location":"ledger/etch-language/model/#read-in-input-data","text":"The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Read in input data"},{"location":"ledger/etch-language/model/#fit","text":"With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction","title":"Fit"},{"location":"ledger/etch-language/model/#evaluate","text":"Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction","title":"Evaluate"},{"location":"ledger/etch-language/model/#predict","text":"Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Predict"},{"location":"ledger/etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"ledger/etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"ledger/etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"ledger/etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"ledger/etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"ledger/etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"ledger/etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"ledger/etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"ledger/etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"ledger/etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"ledger/etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"ledger/etch-language/optimiser/","text":"Use an Optimiser to run the machine learning training on a Graph and a DataLoader . Declare and initialise an Optimiser , giving it the name of the optimisation algorithm you wish to run, the Graph and the DataLoader objects, and the place-holder nodes for the input data, training data, and error data. var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input1\" , \"Input2\" , ...}, \"Label\" , \"Error\" ); To run the Optimiser , call run() with a batch size. Batch size sets the number of samples to train on in an epoch. var loss = optimiser . run ( batch_size ); Adagrad \"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction Adam \"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Momentum \"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... RMSprop \"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... SGD \"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Full optimisation example Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction Reset Graph or DataLoader Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Optimiser"},{"location":"ledger/etch-language/optimiser/#adagrad","text":"\"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction","title":"Adagrad"},{"location":"ledger/etch-language/optimiser/#adam","text":"\"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Adam"},{"location":"ledger/etch-language/optimiser/#momentum","text":"\"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Momentum"},{"location":"ledger/etch-language/optimiser/#rmsprop","text":"\"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"RMSprop"},{"location":"ledger/etch-language/optimiser/#sgd","text":"\"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"SGD"},{"location":"ledger/etch-language/optimiser/#full-optimisation-example","text":"Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction","title":"Full optimisation example"},{"location":"ledger/etch-language/optimiser/#reset-graph-or-dataloader","text":"Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Reset Graph or DataLoader"},{"location":"ledger/etch-language/persistent-globals/","text":"Persistent globals are succinct and ledger efficient persistent variable types that store data on the Fetch.ai Ledger. They are equivalent to State and ShardedState objects and are the primary mechanism for shard management. Five new keywords identify these types: persistent , sharded , use , as , and any . As etch evolves along with the Fetch.ai Ledger, persistent globals will help ensure maximum ledger storage efficiency. Recommendation Use the persistent global syntax instead of State and ShardedState syntax. Syntax Declare all persistent variables the smart contract may use at the top of the file before any function declarations. persistent Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations. sharded Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations. use Import the global persistent variables into smart contract functions with the use keyword. State For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction ShardedState For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects). as Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction any Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction Benefits Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction Limitations You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Persistent globals"},{"location":"ledger/etch-language/persistent-globals/#syntax","text":"Declare all persistent variables the smart contract may use at the top of the file before any function declarations.","title":"Syntax"},{"location":"ledger/etch-language/persistent-globals/#persistent","text":"Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations.","title":"persistent"},{"location":"ledger/etch-language/persistent-globals/#sharded","text":"Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations.","title":"sharded"},{"location":"ledger/etch-language/persistent-globals/#use","text":"Import the global persistent variables into smart contract functions with the use keyword.","title":"use"},{"location":"ledger/etch-language/persistent-globals/#state","text":"For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction","title":"State"},{"location":"ledger/etch-language/persistent-globals/#shardedstate","text":"For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects).","title":"ShardedState"},{"location":"ledger/etch-language/persistent-globals/#as","text":"Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction","title":"as"},{"location":"ledger/etch-language/persistent-globals/#any","text":"Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction","title":"any"},{"location":"ledger/etch-language/persistent-globals/#benefits","text":"Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"Benefits"},{"location":"ledger/etch-language/persistent-globals/#limitations","text":"You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Limitations"},{"location":"ledger/etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"ledger/etch-language/release-notes/","text":"Version v0.9.x Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Release notes"},{"location":"ledger/etch-language/release-notes/#version-v09x","text":"Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Version v0.9.x"},{"location":"ledger/etch-language/sc-annotations/","text":"Smart contract annotations Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment. @action The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction @query Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"Smart contract annotations"},{"location":"ledger/etch-language/sc-annotations/#smart-contract-annotations","text":"Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error.","title":"Smart contract annotations"},{"location":"ledger/etch-language/sc-annotations/#init","text":"The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment.","title":"@init"},{"location":"ledger/etch-language/sc-annotations/#action","text":"The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction","title":"@action"},{"location":"ledger/etch-language/sc-annotations/#query","text":"Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"@query"},{"location":"ledger/etch-language/scaler/","text":"Use a Scaler to normalise data. Declare and initialise a Scaler . function main () var scaler = Scaler (); endfunction Min max The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); Scaler example The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler"},{"location":"ledger/etch-language/scaler/#min-max","text":"The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor );","title":"Min max"},{"location":"ledger/etch-language/scaler/#scaler-example","text":"The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler example"},{"location":"ledger/etch-language/sharded-state/","text":"Warning Use persistent global syntax to build State variables. Introduction to ShardedState variables A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declaration Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Querying with default values Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction ShardedState types with Address references You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState"},{"location":"ledger/etch-language/sharded-state/#introduction-to-shardedstate-variables","text":"A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger.","title":"Introduction to ShardedState variables"},{"location":"ledger/etch-language/sharded-state/#declaration","text":"Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data.","title":"Declaration"},{"location":"ledger/etch-language/sharded-state/#add-keyvalue-pairs","text":"Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction","title":"Add key/value pairs"},{"location":"ledger/etch-language/sharded-state/#querying-with-default-values","text":"Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction","title":"Querying with default values"},{"location":"ledger/etch-language/sharded-state/#shardedstate-types-with-address-references","text":"You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState types with Address references"},{"location":"ledger/etch-language/states/","text":"Warning Use persistent global syntax to build State variables. Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction Default values If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error. Writing State data to the ledger The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"State"},{"location":"ledger/etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction","title":"Introduction to State variables"},{"location":"ledger/etch-language/states/#default-values","text":"If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"ledger/etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership.","title":"Test a State exists"},{"location":"ledger/etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error.","title":"State references and scope"},{"location":"ledger/etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"ledger/etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"ledger/etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction","title":"Passing States around"},{"location":"ledger/etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"Verify an Address"},{"location":"ledger/etch-language/strings/","text":"Strings etch supports ASCII and UTF8 for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction String functions You can use the following utility functions for string manipulation: Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction Substring The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Strings"},{"location":"ledger/etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction","title":"Concatenation"},{"location":"ledger/etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"ledger/etch-language/strings/#string-functions","text":"You can use the following utility functions for string manipulation:","title":"String functions"},{"location":"ledger/etch-language/strings/#find","text":"The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction","title":"Find"},{"location":"ledger/etch-language/strings/#length","text":"The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction","title":"Length"},{"location":"ledger/etch-language/strings/#reverse","text":"The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction","title":"Reverse"},{"location":"ledger/etch-language/strings/#split","text":"The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Split"},{"location":"ledger/etch-language/strings/#substring","text":"The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction","title":"Substring"},{"location":"ledger/etch-language/strings/#trim","text":"The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Trim"},{"location":"ledger/etch-language/syn-annotations/","text":"Etch synergetic contract code includes specific function annotations. These need to be all present or absent, and only one of each type is allowed. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution. You can find an example of a synergetic contract and these annotations here .","title":"Synergetic contract annotations"},{"location":"ledger/etch-language/syntax/","text":"Syntax The etch language integrates with the Fetch.ai Ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Syntax"},{"location":"ledger/etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"ledger/etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"ledger/etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear","title":"Keywords"},{"location":"ledger/etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"ledger/etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Annotations"},{"location":"ledger/etch-language/tensor/","text":"A Tensor is a vector or matrix type having multiple dimensions. In etch it is the n-dimensional matrix type used by the mathematics and machine learning libraries. Declare and initialise Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction toString Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Size Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction fromString Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction Fill Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction Fill Random The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Setters Use setAt() to insert a Fixed64 value at a specific index. 1D The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 2D The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 3D The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction 4D The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction Getters The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension. 1D function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction 2D function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction 3D function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction 4D function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction Reshape The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction Squeeze The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction Serialisation A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Tensor"},{"location":"ledger/etch-language/tensor/#declare-and-initialise","text":"Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction","title":"Declare and initialise"},{"location":"ledger/etch-language/tensor/#tostring","text":"Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"toString"},{"location":"ledger/etch-language/tensor/#size","text":"Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction","title":"Size"},{"location":"ledger/etch-language/tensor/#fromstring","text":"Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction","title":"fromString"},{"location":"ledger/etch-language/tensor/#fill","text":"Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"Fill"},{"location":"ledger/etch-language/tensor/#fill-random","text":"The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"Fill Random"},{"location":"ledger/etch-language/tensor/#setters","text":"Use setAt() to insert a Fixed64 value at a specific index.","title":"Setters"},{"location":"ledger/etch-language/tensor/#1d","text":"The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"1D"},{"location":"ledger/etch-language/tensor/#2d","text":"The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"2D"},{"location":"ledger/etch-language/tensor/#3d","text":"The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction","title":"3D"},{"location":"ledger/etch-language/tensor/#4d","text":"The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction","title":"4D"},{"location":"ledger/etch-language/tensor/#getters","text":"The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension.","title":"Getters"},{"location":"ledger/etch-language/tensor/#1d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction","title":"1D"},{"location":"ledger/etch-language/tensor/#2d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction","title":"2D"},{"location":"ledger/etch-language/tensor/#3d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction","title":"3D"},{"location":"ledger/etch-language/tensor/#4d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction","title":"4D"},{"location":"ledger/etch-language/tensor/#reshape","text":"The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction","title":"Reshape"},{"location":"ledger/etch-language/tensor/#squeeze","text":"The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction","title":"Squeeze"},{"location":"ledger/etch-language/tensor/#serialisation","text":"A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/training-pairs/","text":"TrainingPair is a custom etch class used to load data into a DataLoader . A TrainingPair contains pairs of training data and the corresponding training label coming from two Tensor types. Declare and initialise a TrainingPair . function main () var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction The code below builds two Tensor types, then creates a TrainingPair type with them. function main () var shape = Array < UInt64 > ( 2 ); shape [ 0 ] = 28u64 ; shape [ 1 ] = 28u64 ; var tensor1 = Tensor ( shape ); shape [ 0 ] = 1u64 ; shape [ 1 ] = 10u64 ; var tensor2 = Tensor ( shape ); var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction","title":"Training pairs"},{"location":"ledger/etch-language/transaction/","text":"The Transaction type provides access to data pertaining to a currently invoking transaction on a running smart contract. To access the Transaction type you need a Context . getContext() Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions. digest() The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest (); from() The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from (); transfers() transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers (); getTotalTransferAmount() The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount (); validFrom() The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom (); validUntil() The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil (); chargeRate() The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate (); chargeLimit() The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit (); contractDigest() The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest (); contractAddress() The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress (); action() The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action (); signatories() The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories (); Example Note Coming soon.","title":"Transaction"},{"location":"ledger/etch-language/transaction/#getcontext","text":"Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions.","title":"getContext()"},{"location":"ledger/etch-language/transaction/#digest","text":"The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest ();","title":"digest()"},{"location":"ledger/etch-language/transaction/#from","text":"The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from ();","title":"from()"},{"location":"ledger/etch-language/transaction/#transfers","text":"transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers ();","title":"transfers()"},{"location":"ledger/etch-language/transaction/#gettotaltransferamount","text":"The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount ();","title":"getTotalTransferAmount()"},{"location":"ledger/etch-language/transaction/#validfrom","text":"The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom ();","title":"validFrom()"},{"location":"ledger/etch-language/transaction/#validuntil","text":"The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil ();","title":"validUntil()"},{"location":"ledger/etch-language/transaction/#chargerate","text":"The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate ();","title":"chargeRate()"},{"location":"ledger/etch-language/transaction/#chargelimit","text":"The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit ();","title":"chargeLimit()"},{"location":"ledger/etch-language/transaction/#contractdigest","text":"The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest ();","title":"contractDigest()"},{"location":"ledger/etch-language/transaction/#contractaddress","text":"The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress ();","title":"contractAddress()"},{"location":"ledger/etch-language/transaction/#action","text":"The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action ();","title":"action()"},{"location":"ledger/etch-language/transaction/#signatories","text":"The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories ();","title":"signatories()"},{"location":"ledger/etch-language/transaction/#example","text":"Note Coming soon.","title":"Example"},{"location":"ledger/etch-language/variables/","text":"Variables etch is a statically-typed programming language. The behaviour of value and reference types (primitives and non-primitives in Java) is the same as in other high level languages such as C++, Java, .Net, and Python. Declare a variable with the keyword var . Declare numeric values with literals where possible. Naming Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction 32 byte unsigned integer Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity. Fixed point decimals Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; var fixed128bit = - 128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments . Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type. Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations. StructuredData StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction State A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here . Address The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here . Type casting There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes Scope etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here. Null Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Variables"},{"location":"ledger/etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction","title":"Naming"},{"location":"ledger/etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"ledger/etch-language/variables/#32-byte-unsigned-integer","text":"Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity.","title":"32 byte unsigned integer"},{"location":"ledger/etch-language/variables/#fixed-point-decimals","text":"Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; var fixed128bit = - 128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments .","title":"Fixed point decimals"},{"location":"ledger/etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"ledger/etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"ledger/etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"ledger/etch-language/variables/#buffer","text":"Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type.","title":"Buffer"},{"location":"ledger/etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations.","title":"Maps"},{"location":"ledger/etch-language/variables/#structureddata","text":"StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction","title":"StructuredData"},{"location":"ledger/etch-language/variables/#state","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"State"},{"location":"ledger/etch-language/variables/#shardedstate","text":"Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here .","title":"ShardedState"},{"location":"ledger/etch-language/variables/#address","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here .","title":"Address"},{"location":"ledger/etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here .","title":"Mathematical, ML, and AI"},{"location":"ledger/etch-language/variables/#type-casting","text":"There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"ledger/etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes","title":"Data size"},{"location":"ledger/etch-language/variables/#scope","text":"etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here.","title":"Scope"},{"location":"ledger/etch-language/variables/#null","text":"Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"ledger/etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Default values"},{"location":"ledger/etch-language/examples/dft/","text":"function main () var inreal = Array < Fixed64 > ( 1000 ); var inimag = Array < Fixed64 > ( 1000 ); var outreal = Array < Fixed64 > ( 1000 ); var outimag = Array < Fixed64 > ( 1000 ); for ( i in 0 : inreal . count ()) inreal [ i ] = toFixed64 ( rand ( 0 , 1000 )); inimag [ i ] = toFixed64 ( rand ( 0 , 1000 )); endfor dft ( inreal , inimag , outreal , outimag ); //printLn(inreal); //printLn(inimag); //printLn(outreal); //printLn(outimag); endfunction function dft ( inreal : Array < Fixed64 > , inimag : Array < Fixed64 > , outreal : Array < Fixed64 > , outimag : Array < Fixed64 > ) var n = inreal . count (); var angle = 0.0f p64 ; for ( k in 0 : n ) var sumreal = 0.0f p64 ; var sumimag = 0.0f p64 ; for ( t in 0 : n ) angle = 2.0f p64 * 3.142f p64 * toFixed64 ( t ) * toFixed64 ( k ) / toFixed64 ( n ); sumreal += inreal [ t ] * cos ( angle ) + inimag [ t ] * sin ( angle ); sumimag += - inreal [ t ] * sin ( angle ) + inimag [ t ] * cos ( angle ); endfor outreal [ k ] = sumreal ; outimag [ k ] = sumimag ; endfor endfunction","title":"Discrete Fourier Transformation"},{"location":"ledger/etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"ledger/etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Fixed64 = 32.0f p64 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Fixed64 = toFixed64 ( pixelX ); xLocal = (( xLocal / toFixed64 ( xMax )) * 3.5f p64 ) - 2.5f p64 ; // // Now Y to -1 to 1: var yLocal : Fixed64 = toFixed64 ( pixelY ); yLocal = yLocal / toFixed64 ( yMax ); // // Now let's do the algorithm bit: var x : Fixed64 = 0.0f p64 ; var y : Fixed64 = 0.0f p64 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0f p64 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0f p64 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Fixed64 = ( toFixed64 ( iteration ) / toFixed64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"ledger/etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"ledger/etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"ledger/etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"ledger/etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Sorting algorithms"},{"location":"ledger/etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#quick-sort","text":"function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Quick sort"},{"location":"ledger/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/installation/installation-mac/","text":"Installing and building the ledger on Mac Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"MacOS"},{"location":"ledger/installation/installation-mac/#installing-and-building-the-ledger-on-mac","text":"","title":"Installing and building the ledger on Mac"},{"location":"ledger/installation/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"ledger/installation/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger/installation/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/installation/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"ledger/installation/installation-redhat/","text":"Installing and building the ledger on Linux Redhat Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Redhat"},{"location":"ledger/installation/installation-redhat/#installing-and-building-the-ledger-on-linux-redhat","text":"","title":"Installing and building the ledger on Linux Redhat"},{"location":"ledger/installation/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"ledger/installation/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/installation/installation-ubuntu/","text":"Installing and building the ledger on Linux Ubuntu Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Ubuntu"},{"location":"ledger/installation/installation-ubuntu/#installing-and-building-the-ledger-on-linux-ubuntu","text":"","title":"Installing and building the ledger on Linux Ubuntu"},{"location":"ledger/installation/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger/installation/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/machine-learning/","text":"Machine Learning Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Introduction"},{"location":"ledger/machine-learning/#machine-learning","text":"Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Machine Learning"},{"location":"ledger/machine-learning/basic-etch-example/","text":"AI in Etch The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset. Boston Housing Price Prediction function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look. Setup the etch vm If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here . Input file check First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif Load the input data Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); Set up the model First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Train the model Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluate the model Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate (); Make predictions on the model Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Run the script Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"AI in Etch"},{"location":"ledger/machine-learning/basic-etch-example/#ai-in-etch","text":"The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset.","title":"AI in Etch"},{"location":"ledger/machine-learning/basic-etch-example/#boston-housing-price-prediction","text":"function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look.","title":"Boston Housing Price Prediction"},{"location":"ledger/machine-learning/basic-etch-example/#setup-the-etch-vm","text":"If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here .","title":"Setup the etch vm"},{"location":"ledger/machine-learning/basic-etch-example/#input-file-check","text":"First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif","title":"Input file check"},{"location":"ledger/machine-learning/basic-etch-example/#load-the-input-data","text":"Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 ));","title":"Load the input data"},{"location":"ledger/machine-learning/basic-etch-example/#set-up-the-model","text":"First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Set up the model"},{"location":"ledger/machine-learning/basic-etch-example/#train-the-model","text":"Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size );","title":"Train the model"},{"location":"ledger/machine-learning/basic-etch-example/#evaluate-the-model","text":"Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate ();","title":"Evaluate the model"},{"location":"ledger/machine-learning/basic-etch-example/#make-predictions-on-the-model","text":"Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Make predictions on the model"},{"location":"ledger/machine-learning/basic-etch-example/#run-the-script","text":"Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"Run the script"},{"location":"ledger/machine-learning/getting-started/","text":"Using the machine learning library Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here . Loading input data An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Setting up the model We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Training and evaluating the model Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate (); Making predictions on the model Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Running the script The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Getting started"},{"location":"ledger/machine-learning/getting-started/#using-the-machine-learning-library","text":"Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here .","title":"Using the machine learning library"},{"location":"ledger/machine-learning/getting-started/#loading-input-data","text":"An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Loading input data"},{"location":"ledger/machine-learning/getting-started/#setting-up-the-model","text":"We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Setting up the model"},{"location":"ledger/machine-learning/getting-started/#training-and-evaluating-the-model","text":"Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate ();","title":"Training and evaluating the model"},{"location":"ledger/machine-learning/getting-started/#making-predictions-on-the-model","text":"Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Making predictions on the model"},{"location":"ledger/machine-learning/getting-started/#running-the-script","text":"The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Running the script"},{"location":"ledger/machine-learning/library-architecture/","text":"Machine Learning library architecture The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress. Graph Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal. Ops To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data. Layers Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function. DataLoaders DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders . Integer mathematics The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures. Notes for working with the C++ machine learning library Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Architecture"},{"location":"ledger/machine-learning/library-architecture/#machine-learning-library-architecture","text":"The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress.","title":"Machine Learning library architecture"},{"location":"ledger/machine-learning/library-architecture/#graph","text":"Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal.","title":"Graph"},{"location":"ledger/machine-learning/library-architecture/#ops","text":"To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data.","title":"Ops"},{"location":"ledger/machine-learning/library-architecture/#layers","text":"Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function.","title":"Layers"},{"location":"ledger/machine-learning/library-architecture/#dataloaders","text":"DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders .","title":"DataLoaders"},{"location":"ledger/machine-learning/library-architecture/#integer-mathematics","text":"The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures.","title":"Integer mathematics"},{"location":"ledger/machine-learning/library-architecture/#notes-for-working-with-the-c-machine-learning-library","text":"Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Notes for working with the C++ machine learning library"},{"location":"ledger/machine-learning/smart-contract-example/","text":"AI in Smart Contracts The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators Persistent storage The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here . Separately callable functions In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently. Function decorators Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added. Advanced customisation With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"AI in smart contracts"},{"location":"ledger/machine-learning/smart-contract-example/#ai-in-smart-contracts","text":"The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators","title":"AI in Smart Contracts"},{"location":"ledger/machine-learning/smart-contract-example/#persistent-storage","text":"The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here .","title":"Persistent storage"},{"location":"ledger/machine-learning/smart-contract-example/#separately-callable-functions","text":"In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently.","title":"Separately callable functions"},{"location":"ledger/machine-learning/smart-contract-example/#function-decorators","text":"Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added.","title":"Function decorators"},{"location":"ledger/machine-learning/smart-contract-example/#advanced-customisation","text":"With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"Advanced customisation"},{"location":"ledger/machine-learning/synergetic-contract-example/","text":"AI in Synergetic Contracts The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use. Simple Synergetic Contract Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"AI in synergetic contracts"},{"location":"ledger/machine-learning/synergetic-contract-example/#ai-in-synergetic-contracts","text":"The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use.","title":"AI in Synergetic Contracts"},{"location":"ledger/machine-learning/synergetic-contract-example/#simple-synergetic-contract","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"Simple Synergetic Contract"},{"location":"ledger/python-ledger-api/python-api-install/","text":"Build the Python libraries like this: pip3 install -U fetchai-ledger-api Or, download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.9.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Installation"},{"location":"ledger/python-ledger-api/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block Number"},{"location":"ledger/smart-contracts/etch-smart-contracts/","text":"Etch smart contracts Smart contract code runs on the etch virtual machine. All ledger nodes contain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract addresses etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name. Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Smart contracts in Etch"},{"location":"ledger/smart-contracts/etch-smart-contracts/#smart-contract-addresses","text":"etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name.","title":"Smart contract addresses"},{"location":"ledger/smart-contracts/etch-smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"ledger/smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Public keys Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course. Test network You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#public-keys","text":"Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course.","title":"Public keys"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"ledger/smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code Warning Synergetic contracts are currently an experimental feature. To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = \"\"\" @problem function createProblem(data : Array<StructuredData>) : Int32 var value = 0; for (i in 0:data.count()) value += data[i].getInt32(\"value\"); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : UInt256) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State<Int32>(\"solution\"); result.set(solution); endfunction \"\"\" def main (): # create the API api = LedgerApi ( '127.0.0.1' , 8100 ) # create an entity and provide it some wealth print ( 'Setup...' ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( 'Setup...complete' ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == '__main__' : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic contracts"},{"location":"ledger/smart-contracts/fees/","text":"Fetch.ai charges developers for computation and storage of data on the Fetch.ai Ledger in a manner which incentivises good coding practices. With the best use of Fetch.ai Ledger types such as State and ShardedState , you can limit the fees by distributing data storage over a minimum number of shards. Fees rise in a linear manner per number of shards up to the maximum number of shards. Note The following information details the current implementation which is likely to change. Calculating charge units Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here . Calculating total transaction fee To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Fees"},{"location":"ledger/smart-contracts/fees/#calculating-charge-units","text":"Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here .","title":"Calculating charge units"},{"location":"ledger/smart-contracts/fees/#calculating-total-transaction-fee","text":"To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Calculating total transaction fee"},{"location":"ledger/smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"ledger/smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"ledger/smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Development environment"},{"location":"ledger/smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"ledger/smart-contracts/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"ledger/smart-contracts/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"ledger/smart-contracts/public-keys/","text":"","title":"Public keys"},{"location":"ledger/smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.ai smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the distributed Fetch.ai Ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using persistent global representations of State and ShardedState data structures, and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here . Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Introduction"},{"location":"ledger/smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here .","title":"The Ledger"},{"location":"ledger/smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"ledger/smart-contracts/static-dynamic/","text":"Static contracts A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly. Dynamic contracts A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Static and dynamic contracts"},{"location":"ledger/smart-contracts/static-dynamic/#static-contracts","text":"A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly.","title":"Static contracts"},{"location":"ledger/smart-contracts/static-dynamic/#dynamic-contracts","text":"A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Dynamic contracts"},{"location":"ledger/smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic contracts"},{"location":"ledger/smart-contracts/synergetic/#introduction-to-synergetic-contracts","text":"Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Introduction to synergetic contracts"},{"location":"ledger/walkthrough/","text":"Introduction Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger/walkthrough/#introduction","text":"Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger/walkthrough/creating-addresses/","text":"Creating addresses In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h . Creating a new address You can use any of the following methods to create an address. Using Pocketbook Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts. Using the web testnet wallet For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice. Using the Python Ledger API Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here! Adding an address to Pocketbook We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Listing an address balance You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Creating addresses"},{"location":"ledger/walkthrough/creating-addresses/#creating-addresses","text":"In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h .","title":"Creating addresses"},{"location":"ledger/walkthrough/creating-addresses/#creating-a-new-address","text":"You can use any of the following methods to create an address.","title":"Creating a new address"},{"location":"ledger/walkthrough/creating-addresses/#using-pocketbook","text":"Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts.","title":"Using Pocketbook"},{"location":"ledger/walkthrough/creating-addresses/#using-the-web-testnet-wallet","text":"For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice.","title":"Using the web testnet wallet"},{"location":"ledger/walkthrough/creating-addresses/#using-the-python-ledger-api","text":"Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here!","title":"Using the Python Ledger API"},{"location":"ledger/walkthrough/creating-addresses/#adding-an-address-to-pocketbook","text":"We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Adding an address to Pocketbook"},{"location":"ledger/walkthrough/creating-addresses/#listing-an-address-balance","text":"You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Listing an address balance"},{"location":"ledger/walkthrough/smart-contracts/","text":"Deploying and interacting with smart contracts What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly. Interacting with an already deployed contract There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world Learn more about smart contract development You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Deploying smart contracts"},{"location":"ledger/walkthrough/smart-contracts/#deploying-and-interacting-with-smart-contracts","text":"What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly.","title":"Deploying and interacting with smart contracts"},{"location":"ledger/walkthrough/smart-contracts/#interacting-with-an-already-deployed-contract","text":"There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world","title":"Interacting with an already deployed contract"},{"location":"ledger/walkthrough/smart-contracts/#learn-more-about-smart-contract-development","text":"You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Learn more about smart contract development"},{"location":"ledger/walkthrough/testnet-tokens/","text":"Getting testnet tokens In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet. Using the token tap Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box. Transferring tokens from another account you have It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done! Asking in the developer Slack channel You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Getting testnet tokens"},{"location":"ledger/walkthrough/testnet-tokens/#getting-testnet-tokens","text":"In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet.","title":"Getting testnet tokens"},{"location":"ledger/walkthrough/testnet-tokens/#using-the-token-tap","text":"Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box.","title":"Using the token tap"},{"location":"ledger/walkthrough/testnet-tokens/#transferring-tokens-from-another-account-you-have","text":"It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done!","title":"Transferring tokens from another account you have"},{"location":"ledger/walkthrough/testnet-tokens/#asking-in-the-developer-slack-channel","text":"You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Asking in the developer Slack channel"},{"location":"ledger/walkthrough/transfers-and-balances/","text":"Making transfers In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :) Using Pocketbook You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Using the Python Ledger API Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Making transfers"},{"location":"ledger/walkthrough/transfers-and-balances/#making-transfers","text":"In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :)","title":"Making transfers"},{"location":"ledger/walkthrough/transfers-and-balances/#using-pocketbook","text":"You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Using Pocketbook"},{"location":"ledger/walkthrough/transfers-and-balances/#using-the-python-ledger-api","text":"Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Using the Python Ledger API"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.ai decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.ai blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"Home"},{"location":"oef/advertising/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/java-kotlin-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.7x API.","title":"java kotlin API"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Oef install"},{"location":"oef/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"oef/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"oef/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). You can generate test addresses with the the ledger-api-py (Python SDK) . Check the documentation here . Or... Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) -> str : \"\"\" Returns a 219 character public key in base58 format \"\"\" return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.6x API. Version 0.7x coming soon.","title":"python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register onto the OEF. AsyncioCore thread management The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop () Agent creation Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects. Agent state Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated . Single Agent reacting to arriving messages Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Single Agent doing intermittent work If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Multiple Agent scenarios Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop () Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#asynciocore-thread-management","text":"The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop ()","title":"AsyncioCore thread management"},{"location":"oef/registering/#agent-creation","text":"Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects.","title":"Agent creation"},{"location":"oef/registering/#agent-state","text":"Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated .","title":"Agent state"},{"location":"oef/registering/#single-agent-reacting-to-arriving-messages","text":"Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent reacting to arriving messages"},{"location":"oef/registering/#single-agent-doing-intermittent-work","text":"If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent doing intermittent work"},{"location":"oef/registering/#multiple-agent-scenarios","text":"Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop ()","title":"Multiple Agent scenarios"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Sdk"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 sub-expressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of sub-expressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"tutorials/","text":"Tutorials Smart Contracts and Etch Fungible token generation contract Video tutorials You can also find multiple video tutorials on our YouTube channel .","title":"Index"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#smart-contracts-and-etch","text":"Fungible token generation contract","title":"Smart Contracts and Etch"},{"location":"tutorials/#video-tutorials","text":"You can also find multiple video tutorials on our YouTube channel .","title":"Video tutorials"},{"location":"tutorials/fet1/","text":"Create a token smart contract Most people interact with smart contracts that handle the issuance of tokens, such as the well known Ethereum ERC20 . Most token contracts are either: Non-fungible tokens (NFT): These are like collectables, as they cannot be split; you can't cut a baseball collector's card and have two that are worth 50% of the original. One of the most well-known of these is Cryptokitties . Most non-fungible tokens are ERC721 . Fungible tokens (FT): Fungible can be split, and are used for most token issuance. The circulating supply, the issuance foundation and the list of where the tokens are are held and enforced by a smart contract. Most fungible tokens on Ethereum, including non-native FET tokens, are based on ERC20 . In this tutorial, we are going to develop a fungible token contract. Note As Fetch.ai smart contracts do not have implicit addresses (as in Ethereum), the function signatures are slightly different, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: persistent sharded balance_state : UInt64 ; persistent supply_state : UInt64 ; @init function init ( owner : Address ) use supply_state ; use balance_state [ owner ] ; supply_state . set ( 100000 u64 ); balance_state . set ( owner , 100000 u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing. Queries Functions labeled with @query do not alter state, and they return a value to the caller. There can be many of these in a single contract. In this contract, they are used to return the contract name, total supply, and get the balance of an address. getName simply returns the contract name without further calculations: @query function getName (): String return \"FIP-1 fungible token\" ; endfunction The other two query mechanisms demonstrate two different ways of handling undefined states. totalSupply queries the state variable total_supply and returns it as a result: @query function totalSupply (): UInt64 use supply_state ; return supply_state . get (); endfunction On the other hand, balanceOf uses the sharded state of balance_state and does a dynamic look up based on an address . If the variable does not exist, it returns 0 . @query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ] ; return balance_state . get ( address , 0 u64 ); endfunction Actions The FIP-1 contract defines one function annotated with @action . Actions can alter state and return a value. Like with queries, a contract can contain many of these. The only action in this contract transfers an amount between two different addresses. The source of the transfer has to be the caller of the @action , and the function is responsible for checking that the source address has signed the transaction. @action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif if ( from == to ) return false ; endif use balance_state [ from , to ] ; var from_balance = balance_state . get ( from , 0 u64 ); var to_balance = balance_state . get ( to , 0 u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction You can find the full contract here . Implementing allowance So far, the functions we have seen constitute a basic token contract to create and transfer tokens between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract, that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0 u64 )); endfunction The contract provided here still needs additional functionality for allowance to be truly useful, as we have not implemented any method to actually spend the allowance.","title":"Create FET-1 contract"},{"location":"tutorials/fet1/#create-a-token-smart-contract","text":"Most people interact with smart contracts that handle the issuance of tokens, such as the well known Ethereum ERC20 . Most token contracts are either: Non-fungible tokens (NFT): These are like collectables, as they cannot be split; you can't cut a baseball collector's card and have two that are worth 50% of the original. One of the most well-known of these is Cryptokitties . Most non-fungible tokens are ERC721 . Fungible tokens (FT): Fungible can be split, and are used for most token issuance. The circulating supply, the issuance foundation and the list of where the tokens are are held and enforced by a smart contract. Most fungible tokens on Ethereum, including non-native FET tokens, are based on ERC20 . In this tutorial, we are going to develop a fungible token contract. Note As Fetch.ai smart contracts do not have implicit addresses (as in Ethereum), the function signatures are slightly different, but the overall functionality remains the same.","title":"Create a token smart contract"},{"location":"tutorials/fet1/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: persistent sharded balance_state : UInt64 ; persistent supply_state : UInt64 ; @init function init ( owner : Address ) use supply_state ; use balance_state [ owner ] ; supply_state . set ( 100000 u64 ); balance_state . set ( owner , 100000 u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing.","title":"Initialisation function"},{"location":"tutorials/fet1/#queries","text":"Functions labeled with @query do not alter state, and they return a value to the caller. There can be many of these in a single contract. In this contract, they are used to return the contract name, total supply, and get the balance of an address. getName simply returns the contract name without further calculations: @query function getName (): String return \"FIP-1 fungible token\" ; endfunction The other two query mechanisms demonstrate two different ways of handling undefined states. totalSupply queries the state variable total_supply and returns it as a result: @query function totalSupply (): UInt64 use supply_state ; return supply_state . get (); endfunction On the other hand, balanceOf uses the sharded state of balance_state and does a dynamic look up based on an address . If the variable does not exist, it returns 0 . @query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ] ; return balance_state . get ( address , 0 u64 ); endfunction","title":"Queries"},{"location":"tutorials/fet1/#actions","text":"The FIP-1 contract defines one function annotated with @action . Actions can alter state and return a value. Like with queries, a contract can contain many of these. The only action in this contract transfers an amount between two different addresses. The source of the transfer has to be the caller of the @action , and the function is responsible for checking that the source address has signed the transaction. @action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif if ( from == to ) return false ; endif use balance_state [ from , to ] ; var from_balance = balance_state . get ( from , 0 u64 ); var to_balance = balance_state . get ( to , 0 u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction You can find the full contract here .","title":"Actions"},{"location":"tutorials/fet1/#implementing-allowance","text":"So far, the functions we have seen constitute a basic token contract to create and transfer tokens between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract, that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0 u64 )); endfunction The contract provided here still needs additional functionality for allowance to be truly useful, as we have not implemented any method to actually spend the allowance.","title":"Implementing allowance"}]}