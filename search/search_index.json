{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fetch.ai developer resources. Let's get started. Quickstart If you want to get moving quickly, this is the place. Tutorials Once you're all setup with Fetch.ai, go here to see and build following excellent tutorials. What is Fetch.ai There are billions of devices, processes and pipelines around the world that are desperate for automation and communication. Most blockchains aren't built to handle such a large number of transactions, and none enable their clients to learn from the data generated and exchanged. Fetch.ai is a platform built to bring value to data, by connecting devices and facilitating the creation of new markets based on what they learn from each other. It is the platform where truly autonomous decisions can be made. Some of the technical features that will enable this autonomous world are: Blockchain sharding to increase concurrency and scalability Smart contract language with ML and AI capabilities Framework for rapid development of Autonomous Economic Agents (AEAs) that can be deployed in any device Support for fixed-point arithmetics to guarantee precision and determinism across all operations and transactions Whitepaper > Gentle Introduction > Fetch.ai glossary Collective learning: The act by which autonomous agents, with competitive or complementary interests, increase their understanding of the state and behavior of the decentralized ecosystem they are connected to. Ideally, this will allow them to improve their solutions to a problem. Etch: Our native language in which smart contracts can be written, with support for ML and AI. FET: The cryptocurrency that powers the Fetch.ai ecosystem. Its first version is an ERC-20 token in the Ethereum blockchain, but following versions are native to the Fetch.ai ledger. Synergetic contracts: Type of smart contract that allows anyone to register a problem on the ledger, with miners then using their computational power to solve it and earn a reward. What can you do *now* with Fetch.ai All the components of the Fetch.ai stack and the interfaces to interact with them are open source. Take a look at our SDKs (Python Ledger API, JavaScript Ledger API, Agent Framework and Etch language) so you can start building smart contracts, new agents connected to Fetch.ai, or new ways of interacting with the ledger. And if you want to go even further, you can fork and build any components from the Fetch.ai stack! Versions and release notes As with any software and its documentation, things do change and evolve. We at Fetch.ai try to support backwards compatibility as much as possible, but deprecations will occur. Keep an eye our release notes, as these list all major changes. If you want to view older versions of the documentation, you can select them using the drop down at the bottom of the left hand menu. Updates! November 29th, 2019 Documentation updated for Fetch.ai ledger v0.10.x. See summary details here .","title":"Home"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"summary/","text":"November 29th, 2019 Documentation has been updated for Fetch.ai ledger v0.10.x New style, and new section on Machine Learning on Fetch.ai. We will be continuously updating these docs. Please see github.com/fetchai/docs for latest updates. There have been a number of other minor corrections and updates.","title":"Summary"},{"location":"aea/","text":"Autonomous Economic Agent Framework The AEA framework provides the tools for creating autonomous economic agents. Autonomous Economic Agents (AEAs) work continuously for your benefit without you having to do anything more than write them and start them up. AEAs act independently of constant input and autonomously develop new capabilities. Their goal is to create economic gain for you, their owner. AEAs have a wide range of application areas. Check out the demo section for examples. It is a Python-based development suite which equips you with an efficient and easy to understand set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. The AEA framework attempts to make agent development as straightforward as web development using popular web frameworks. AEAs achieve their goals with the help of the Fetch.ai OEF - a search and discovery platform for agents - and the Fetch.ai blockchain. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/agents-aea).","title":"Introduction"},{"location":"aea/#autonomous-economic-agent-framework","text":"The AEA framework provides the tools for creating autonomous economic agents. Autonomous Economic Agents (AEAs) work continuously for your benefit without you having to do anything more than write them and start them up. AEAs act independently of constant input and autonomously develop new capabilities. Their goal is to create economic gain for you, their owner. AEAs have a wide range of application areas. Check out the demo section for examples. It is a Python-based development suite which equips you with an efficient and easy to understand set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. The AEA framework attempts to make agent development as straightforward as web development using popular web frameworks. AEAs achieve their goals with the help of the Fetch.ai OEF - a search and discovery platform for agents - and the Fetch.ai blockchain. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/agents-aea).","title":"Autonomous Economic Agent Framework"},{"location":"aea/app-areas/","text":"An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. It can represent machines, humans, or data. There are five general application areas for Fetch.ai AEAs. Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. Representative : an agent which represents an individual's activities on the Fetch.ai network. Multi-agent system versus agent-based modelling The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Application areas"},{"location":"aea/app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Multi-agent system versus agent-based modelling"},{"location":"aea/car-park-alt/","text":"Warning Work in progress. Car Park Agent Application The Fetch.ai car park agent application is made up of three components: A Raspberry Pi hardware device with camera module viewing a car park. A car park agent GUI running on the Raspberry Pi that collects data on free spaces and serves it up for purchase on the Fetch.ai network. A remote client agent GUI that connects to the Raspberry Pi and buys data. Hardware Car Park Agent GUI Client Agent GUI Raspberry Pi hardware set up The hardware set up is the most time consuming part of these instructions. We assume the developer has some familiarity with Raspberry Pi and refer them to the manufacturer's instructions. However, we do list any problems we encountered and their solutions below. Note We have used the Raspberry Pi 4. You are welcome to use earlier versions but the set up may change slightly. Follow the manufacturer's instructions to set up the Raspberry Pi 4 hardware device: https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/2 . Install and update the OS Install the Raspbian OS and update it. sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade sudo reboot Enable camera, ssh, and VNC Click on the Raspberry symbol in the top left of the screen. Select Preferences then Raspberry Pi Configuration. Enable the Camera, SSH, and VNC options. Set up camera module Follow the manufacturer's instructions to set up the Raspberry Pi Camera module: https://projects.raspberrypi.org/en/projects/getting-started-with-picamera . Configure and test the camera software: https://www.raspberrypi.org/documentation/configuration/camera.md . Set up your Pi to physically view the car park. We'll leave that to you. Potential issues Make sure you use the first port, HDMI 0 on the Pi for the initial set up monitor. If you install the Pi with a used SD card, you will need to reformat the card with NOOBS: https://www.raspberrypi.org/downloads/noobs/ . Fix the screen resolution issues by editing the configuration. sudo raspi-config Select the 1920X1080 resolution option - number 31. Then update the configuration file as follows. Open it. sudo nano /boot/config.txt And make sure the following three lines are commented out. # Enable DRM VC4 V3D driver on top of the dispmanx display stack # dtoverlay=vc4-fkms-v3d # max_framebuffers=2 Agent server application installation Now we are ready to install the car park agent GUI server application on the Raspberry Pi. Get the code cd ~/Desktop git clone https://github.com/fetchai/carpark_agent.git cd carpark_agent Download datafile This is required for the machine learning algorithms. ./car_detection/weights/download_weights.sh Install the required libraries. sudo apt-get install gcc htop vim mc python3-dev ffmpeg virtualenv libatlas-base-dev libsm6 libxext6 clang libblas3 liblapack3 liblapack-dev libblas-dev cython gfortran build-essential libgdal-dev libopenblas-dev liblapack3 liblapacke liblapacke-dev liblcms2-utils liblcms2-2 libwebpdemux2 python3-scipy python3-numpy python3-matplotlib libjasper-dev libqtgui4 libqt4-test protobuf-compiler python3-opencv gpsd gpsd-clients Activate a virtual environment. pip3 install virtualenv ./run_scripts/create_venv.sh source venv/bin/activate Install the software python setup.py develop Note We recommend that using `develop` as this creates a link to the code and so any changes you make will take immediate effect when you run the code. Run it ./run_scripts/run_carpark_agent.sh You should now see the agent running. Ensure agent start on boot (RPi4 only) Ensure the startup script runs whenever we the Raspberry Pi turns on. crontab -e Pick an editor which will open a text file. Scroll to the bottom and add the following line. @reboot /home/pi/Desktop/carpark_agent/run_scripts/run_carpark_agent.sh Save and reboot. The agent should now start automatically on reboot. Get the Pi's ip address We will need the ip address of the Raspberry Pi to connect remotely. ifconfig Returns something like: ... wlan0: flags = 4163 <UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192 .168.11.9 netmask 255 .255.255.0 broadcast 192 .168.11.255 ... The inet value is the Raspberry Pi's ip address. Connect to the app remotely Download and install the VNC viewer onto your remote laptop: https://www.realvnc.com/en/connect/download/viewer/ . Add the Pi's ip address. You will be prompted for the Raspberry Pi password. The Raspberry Pi's desktop should appear. Get your remote desktop ip Follow the instructions to get your remote ip address. Connect to the Raspberry Pi Start up the agent, if it is not running - but it should be. cd Desktop/carpark_agent ./run_scripts/run_carpark_agent.sh STOPPED HERE - Monday 28th October The Pi server app instructions come next From \"When it starts up and you see the output from the camera, you can move your camera around so it is looking at the area...","title":"Car park alt"},{"location":"aea/car-park-alt/#car-park-agent-application","text":"The Fetch.ai car park agent application is made up of three components: A Raspberry Pi hardware device with camera module viewing a car park. A car park agent GUI running on the Raspberry Pi that collects data on free spaces and serves it up for purchase on the Fetch.ai network. A remote client agent GUI that connects to the Raspberry Pi and buys data. Hardware Car Park Agent GUI Client Agent GUI","title":"Car Park Agent Application"},{"location":"aea/car-park-alt/#raspberry-pi-hardware-set-up","text":"The hardware set up is the most time consuming part of these instructions. We assume the developer has some familiarity with Raspberry Pi and refer them to the manufacturer's instructions. However, we do list any problems we encountered and their solutions below. Note We have used the Raspberry Pi 4. You are welcome to use earlier versions but the set up may change slightly. Follow the manufacturer's instructions to set up the Raspberry Pi 4 hardware device: https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/2 .","title":"Raspberry Pi hardware set up"},{"location":"aea/car-park-alt/#install-and-update-the-os","text":"Install the Raspbian OS and update it. sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade sudo reboot","title":"Install and update the OS"},{"location":"aea/car-park-alt/#enable-camera-ssh-and-vnc","text":"Click on the Raspberry symbol in the top left of the screen. Select Preferences then Raspberry Pi Configuration. Enable the Camera, SSH, and VNC options.","title":"Enable camera, ssh, and VNC"},{"location":"aea/car-park-alt/#set-up-camera-module","text":"Follow the manufacturer's instructions to set up the Raspberry Pi Camera module: https://projects.raspberrypi.org/en/projects/getting-started-with-picamera . Configure and test the camera software: https://www.raspberrypi.org/documentation/configuration/camera.md . Set up your Pi to physically view the car park. We'll leave that to you.","title":"Set up camera module"},{"location":"aea/car-park-alt/#potential-issues","text":"Make sure you use the first port, HDMI 0 on the Pi for the initial set up monitor. If you install the Pi with a used SD card, you will need to reformat the card with NOOBS: https://www.raspberrypi.org/downloads/noobs/ . Fix the screen resolution issues by editing the configuration. sudo raspi-config Select the 1920X1080 resolution option - number 31. Then update the configuration file as follows. Open it. sudo nano /boot/config.txt And make sure the following three lines are commented out. # Enable DRM VC4 V3D driver on top of the dispmanx display stack # dtoverlay=vc4-fkms-v3d # max_framebuffers=2","title":"Potential issues"},{"location":"aea/car-park-alt/#agent-server-application-installation","text":"Now we are ready to install the car park agent GUI server application on the Raspberry Pi.","title":"Agent server application installation"},{"location":"aea/car-park-alt/#get-the-code","text":"cd ~/Desktop git clone https://github.com/fetchai/carpark_agent.git cd carpark_agent","title":"Get the code"},{"location":"aea/car-park-alt/#download-datafile","text":"This is required for the machine learning algorithms. ./car_detection/weights/download_weights.sh Install the required libraries. sudo apt-get install gcc htop vim mc python3-dev ffmpeg virtualenv libatlas-base-dev libsm6 libxext6 clang libblas3 liblapack3 liblapack-dev libblas-dev cython gfortran build-essential libgdal-dev libopenblas-dev liblapack3 liblapacke liblapacke-dev liblcms2-utils liblcms2-2 libwebpdemux2 python3-scipy python3-numpy python3-matplotlib libjasper-dev libqtgui4 libqt4-test protobuf-compiler python3-opencv gpsd gpsd-clients","title":"Download datafile"},{"location":"aea/car-park-alt/#activate-a-virtual-environment","text":"pip3 install virtualenv ./run_scripts/create_venv.sh source venv/bin/activate","title":"Activate a virtual environment."},{"location":"aea/car-park-alt/#install-the-software","text":"python setup.py develop Note We recommend that using `develop` as this creates a link to the code and so any changes you make will take immediate effect when you run the code.","title":"Install the software"},{"location":"aea/car-park-alt/#run-it","text":"./run_scripts/run_carpark_agent.sh You should now see the agent running.","title":"Run it"},{"location":"aea/car-park-alt/#ensure-agent-start-on-boot-rpi4-only","text":"Ensure the startup script runs whenever we the Raspberry Pi turns on. crontab -e Pick an editor which will open a text file. Scroll to the bottom and add the following line. @reboot /home/pi/Desktop/carpark_agent/run_scripts/run_carpark_agent.sh Save and reboot. The agent should now start automatically on reboot.","title":"Ensure agent start on boot (RPi4 only)"},{"location":"aea/car-park-alt/#get-the-pis-ip-address","text":"We will need the ip address of the Raspberry Pi to connect remotely. ifconfig Returns something like: ... wlan0: flags = 4163 <UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192 .168.11.9 netmask 255 .255.255.0 broadcast 192 .168.11.255 ... The inet value is the Raspberry Pi's ip address.","title":"Get the Pi's ip address"},{"location":"aea/car-park-alt/#connect-to-the-app-remotely","text":"Download and install the VNC viewer onto your remote laptop: https://www.realvnc.com/en/connect/download/viewer/ . Add the Pi's ip address. You will be prompted for the Raspberry Pi password. The Raspberry Pi's desktop should appear.","title":"Connect to the app remotely"},{"location":"aea/car-park-alt/#get-your-remote-desktop-ip","text":"Follow the instructions to get your remote ip address.","title":"Get your remote desktop ip"},{"location":"aea/car-park-alt/#connect-to-the-raspberry-pi","text":"Start up the agent, if it is not running - but it should be. cd Desktop/carpark_agent ./run_scripts/run_carpark_agent.sh","title":"Connect to the Raspberry Pi"},{"location":"aea/car-park-alt/#stopped-here-monday-28th-october","text":"","title":"STOPPED HERE - Monday 28th October"},{"location":"aea/car-park-alt/#the-pi-server-app-instructions-come-next","text":"From \"When it starts up and you see the output from the camera, you can move your camera around so it is looking at the area...","title":"The Pi server app instructions come next"},{"location":"aea/car-park/","text":"Car Park Agent Application The Fetch.ai car park agent demo is documented in its own repo here . To test the AEA functionality (without the detection) First, create the carpark detection agent: aea create car_detector cd car_detector aea add skill carpark_detection aea install Then, create the carpark client agent: aea create car_data_buyer cd car_data_buyer aea add skill carpark_client aea install aea generate-key fetchai aea add-key fetchai fet_private_key.txt Add the ledger info to both aea configs: ledger_apis: - ledger_api: ledger: fetchai addr: alpha.fetch-ai.com port: 80 Fund the carpark client agent: cd .. python scripts/fetchai_wealth_generation.py --private-key car_data_buyer/fet_private_key.txt --amount 10000000000 --addr alpha.fetch-ai.com --port 80 Then, in the carpark detection skill settings ( car_detector/skills/carpark_detection/skill.yaml ) of the detection agent comment out database related settings: # db_is_rel_to_cwd: true # db_rel_dir: ../temp_files Then, launch an OEF node instance: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Finally, run both agents with aea run . You can see that the agents find each other, negotiate and eventually trade. When you're finished, delete your agents: cd .. aea delete car_detector aea delete car_data_buyer Communication This diagram shows the communication between the various entities as data is successfully sold by the car park agent to the client. sequenceDiagram participant Search participant Client_AEA participant Car_Park_AEA participant Blockchain activate Client_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Client_AEA: propose Client_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Car park agent"},{"location":"aea/car-park/#car-park-agent-application","text":"The Fetch.ai car park agent demo is documented in its own repo here .","title":"Car Park Agent Application"},{"location":"aea/car-park/#to-test-the-aea-functionality-without-the-detection","text":"First, create the carpark detection agent: aea create car_detector cd car_detector aea add skill carpark_detection aea install Then, create the carpark client agent: aea create car_data_buyer cd car_data_buyer aea add skill carpark_client aea install aea generate-key fetchai aea add-key fetchai fet_private_key.txt Add the ledger info to both aea configs: ledger_apis: - ledger_api: ledger: fetchai addr: alpha.fetch-ai.com port: 80 Fund the carpark client agent: cd .. python scripts/fetchai_wealth_generation.py --private-key car_data_buyer/fet_private_key.txt --amount 10000000000 --addr alpha.fetch-ai.com --port 80 Then, in the carpark detection skill settings ( car_detector/skills/carpark_detection/skill.yaml ) of the detection agent comment out database related settings: # db_is_rel_to_cwd: true # db_rel_dir: ../temp_files Then, launch an OEF node instance: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Finally, run both agents with aea run . You can see that the agents find each other, negotiate and eventually trade. When you're finished, delete your agents: cd .. aea delete car_detector aea delete car_data_buyer","title":"To test the AEA functionality (without the detection)"},{"location":"aea/car-park/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park agent to the client. sequenceDiagram participant Search participant Client_AEA participant Car_Park_AEA participant Blockchain activate Client_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Client_AEA: propose Client_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/cli-commands/","text":"CLI commands Command Description add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. add-key default/fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . delete NAME Delete an aea project. See below for disabling a resource. fetch NAME Fetch an aea project called [name] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key default/fetchai/ethereum/all Generate private keys. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. run {using [connection, ...]} Run the agent on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"Commands"},{"location":"aea/cli-commands/#cli-commands","text":"Command Description add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. add-key default/fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . delete NAME Delete an aea project. See below for disabling a resource. fetch NAME Fetch an aea project called [name] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key default/fetchai/ethereum/all Generate private keys. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. run {using [connection, ...]} Run the agent on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"CLI commands"},{"location":"aea/cli-gui/","text":"You can invoke the AEA Command Line Interface (CLI) from a Graphical User Interface (GUI) accessed from a web browser. These instructions will take you through building an agent, starting an OEF Node, and running the agent - all from the GUI. Preliminaries Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ] Starting the GUI Go to the directory in which you will create new agents. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any agents you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those agents. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your agent. To create a new agent and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_agent agent\". Start an OEF Node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the agent running by clicking on the [start agent] button. You should see the output from the echo agent appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"GUI"},{"location":"aea/cli-gui/#preliminaries","text":"Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ]","title":"Preliminaries"},{"location":"aea/cli-gui/#starting-the-gui","text":"Go to the directory in which you will create new agents. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any agents you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those agents. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your agent. To create a new agent and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_agent agent\". Start an OEF Node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the agent running by clicking on the [start agent] button. You should see the output from the echo agent appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"Starting the GUI"},{"location":"aea/cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ] Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir","title":"CLI tool"},{"location":"aea/cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"Installation"},{"location":"aea/cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir","title":"Troubleshooting"},{"location":"aea/connection/","text":"A Connection is attached to an AEA within the AEA framework. The connection.py module in the connections directory contains a Connection class, which is a wrapper for an SDK or API An AEA can interact with multiple connections at the same time. Configuration The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.ai Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of the Connection dependent on the protocol type. Connection is_established(self) connect(self) disconnect(self) send(self, envelope: Envelope) from_config(cls, public_key: str, connection_configuration: ConnectionConfig) Launching oef connections oef - local node Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection. oef - remote node Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"Connection"},{"location":"aea/connection/#configuration","text":"The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.ai Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of the Connection dependent on the protocol type.","title":"Configuration"},{"location":"aea/connection/#connection","text":"","title":"Connection"},{"location":"aea/connection/#is_establishedself","text":"","title":"is_established(self)"},{"location":"aea/connection/#connectself","text":"","title":"connect(self)"},{"location":"aea/connection/#disconnectself","text":"","title":"disconnect(self)"},{"location":"aea/connection/#sendself-envelope-envelope","text":"","title":"send(self, envelope: Envelope)"},{"location":"aea/connection/#from_configcls-public_key-str-connection_configuration-connectionconfig","text":"","title":"from_config(cls, public_key: str, connection_configuration: ConnectionConfig)"},{"location":"aea/connection/#launching-oef-connections","text":"","title":"Launching oef connections"},{"location":"aea/connection/#oef-local-node","text":"Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection.","title":"oef - local node"},{"location":"aea/connection/#oef-remote-node","text":"Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"oef - remote node"},{"location":"aea/core-components/","text":"InBox and OutBox The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes . Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Connection Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which define a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK. Skill Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent. Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent. Filter Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills. Resource The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"aea/core-components/#inbox-and-outbox","text":"The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes .","title":"InBox and OutBox"},{"location":"aea/core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form.","title":"Envelope"},{"location":"aea/core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"aea/core-components/#connection","text":"Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which define a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK.","title":"Connection"},{"location":"aea/core-components/#skill","text":"Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent.","title":"Skill"},{"location":"aea/core-components/#agent","text":"","title":"Agent"},{"location":"aea/core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them.","title":"Main loop"},{"location":"aea/core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent.","title":"Decision maker"},{"location":"aea/core-components/#filter","text":"Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills.","title":"Filter"},{"location":"aea/core-components/#resource","text":"The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"aea/design-principles/","text":"Eight principles guide AEA framework development: Accessibility : ease of use. Modularity : encourages module creation and sharing and reuse. Openness : easily extensible with third party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"aea/diagram/","text":"Note Work in progress. The framework has two distinctive parts. A core that is developed by the Fetch.ai team as well as external contributors. extensions (also known as packages ) developed by any developer which promotes a modular and scalable framework. Currently, the framework supports three types of packages which can be added to the core as modules. Skills Protocols Connections The following figure illustrates the framework's architecture.","title":"Architectural diagram"},{"location":"aea/file-structure/","text":"The file structure of an agent is fixed. The top level directory has the agent's name. Below is a yaml configuration file, then directories containing the connections, protocols, and skills, and a file containing the private key of the agent. The developer can create new directories where necessary but the core structure must remain the same. The CLI tool provides a way to scaffold out the required directory structure for new agents. See the instructions for that here . agent_name/ aea-config.yaml YAML configuration of the agent private_key.pem The private key file connections/ Directory containing all the supported connections connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all supported protocols protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skill components skill_1/ First skill ... ... skill_k/ kth skill","title":"File structure"},{"location":"aea/fipa-skill/","text":"Note Work in progress. The AEA FIPA skill demonstrates how FIPA negotiation strategies may be embedded into an Autonomous Economic Agent. Configuration The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : '' behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled. Shared classes The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill. Search This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below). Strategy This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not. Dialogue Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between. Transactions This class deals with representing potential transactions between agents. Demo instructions Warning FIPA negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the FIPA agent. aea create my_fipa_agent Add the FIPA skill cd my_fipa_agent aea add skill fipa_negotiation Add the local connection aea add connection local Run the agent with the default connection aea run --connections local Delete the agent When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Fipa skill"},{"location":"aea/fipa-skill/#configuration","text":"The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : '' behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled.","title":"Configuration"},{"location":"aea/fipa-skill/#shared-classes","text":"The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill.","title":"Shared classes"},{"location":"aea/fipa-skill/#search","text":"This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below).","title":"Search"},{"location":"aea/fipa-skill/#strategy","text":"This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not.","title":"Strategy"},{"location":"aea/fipa-skill/#dialogue","text":"Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between.","title":"Dialogue"},{"location":"aea/fipa-skill/#transactions","text":"This class deals with representing potential transactions between agents.","title":"Transactions"},{"location":"aea/fipa-skill/#demo-instructions","text":"Warning FIPA negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"aea/fipa-skill/#create-the-agent","text":"In the root directory, create the FIPA agent. aea create my_fipa_agent","title":"Create the agent"},{"location":"aea/fipa-skill/#add-the-fipa-skill","text":"cd my_fipa_agent aea add skill fipa_negotiation","title":"Add the FIPA skill"},{"location":"aea/fipa-skill/#add-the-local-connection","text":"aea add connection local","title":"Add the local connection"},{"location":"aea/fipa-skill/#run-the-agent-with-the-default-connection","text":"aea run --connections local","title":"Run the agent with the default connection"},{"location":"aea/fipa-skill/#delete-the-agent","text":"When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Delete the agent"},{"location":"aea/gym-plugin/","text":"The gym_ex example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning. There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate environments, potentially owned by different entities. Quick start Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym demo"},{"location":"aea/gym-plugin/#quick-start","text":"","title":"Quick start"},{"location":"aea/gym-plugin/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym","title":"Dependencies"},{"location":"aea/gym-plugin/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"aea/gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an Autonomous Economic Agent. Demo instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Create the agent In the root directory, create the gym agent. aea create my_gym_agent Add the gym skill cd my_gym_agent aea add skill gym Copy the gym environment to the agent directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection gym Update the connection config nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom Install the skill dependencies To install the gym package, a dependency of the gym skill, from Pypi run aea install Run the agent with the gym connection aea run --connections gym You will see the gym training logs. Delete the agent When you're done, you can go up a level and delete the agent. cd .. aea delete my_gym_agent Communication This diagram shows the communication between the agent and the gym environment sequenceDiagram participant Agent participant Environment activate Agent activate Environment Agent->>Environment: reset loop learn Agent->>Environment: act Environment->>Agent: percept end Agent->>Environment: close deactivate Agent deactivate Environment","title":"Gym skill"},{"location":"aea/gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/gym-skill/#create-the-agent","text":"In the root directory, create the gym agent. aea create my_gym_agent","title":"Create the agent"},{"location":"aea/gym-skill/#add-the-gym-skill","text":"cd my_gym_agent aea add skill gym","title":"Add the gym skill"},{"location":"aea/gym-skill/#copy-the-gym-environment-to-the-agent-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the agent directory"},{"location":"aea/gym-skill/#add-a-gym-connection","text":"aea add connection gym","title":"Add a gym connection"},{"location":"aea/gym-skill/#update-the-connection-config","text":"nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom","title":"Update the connection config"},{"location":"aea/gym-skill/#install-the-skill-dependencies","text":"To install the gym package, a dependency of the gym skill, from Pypi run aea install","title":"Install the skill dependencies"},{"location":"aea/gym-skill/#run-the-agent-with-the-gym-connection","text":"aea run --connections gym You will see the gym training logs.","title":"Run the agent with the gym connection"},{"location":"aea/gym-skill/#delete-the-agent","text":"When you're done, you can go up a level and delete the agent. cd .. aea delete my_gym_agent","title":"Delete the agent"},{"location":"aea/gym-skill/#communication","text":"This diagram shows the communication between the agent and the gym environment sequenceDiagram participant Agent participant Environment activate Agent activate Environment Agent->>Environment: reset loop learn Agent->>Environment: act Environment->>Agent: percept end Agent->>Environment: close deactivate Agent deactivate Environment","title":"Communication"},{"location":"aea/hacking-an-agent/","text":"Preliminaries These instructions detail the Python code you need for running an AEA outside the cli tool. Note You have already coded up your agent. See the build your own skill guide for a reminder. Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.mail.base import Envelope from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.registries.base import Resources Initialise the agent Create a private key. python scripts/generate_private_key.py my_key.txt Create a wallet object with a private key. wallet = Wallet ({ 'default' : 'my_key.txt' }) Create a Connection . stub_connection = StubConnection ( input_file_path = 'input.txt' , output_file_path = 'output.txt' ) For ledger APIs, we simply feed the agent an empty dictionary (meaning we do not require any). ledger_apis = LedgerApis ({}) Create the resources pointing to the working directory. resources = Resources ( '' ) Now we have everything we need for initialisation. my_agent = AEA ( \"my_agent\" , stub_connection , wallet , ledger_apis , resources ) Add skills and protocols We can add the echo skill as follows... Note Work in progress. Run the agent Create a thread and add the agent to it. t = Thread ( target = my_agent . start ) Start the agent. t . start () Terminate the agent Finalise the agent thread. my_agent . stop () t . join () t = None","title":"Create an agent programmatically"},{"location":"aea/hacking-an-agent/#preliminaries","text":"These instructions detail the Python code you need for running an AEA outside the cli tool. Note You have already coded up your agent. See the build your own skill guide for a reminder.","title":"Preliminaries"},{"location":"aea/hacking-an-agent/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.mail.base import Envelope from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.registries.base import Resources","title":"Imports"},{"location":"aea/hacking-an-agent/#initialise-the-agent","text":"Create a private key. python scripts/generate_private_key.py my_key.txt Create a wallet object with a private key. wallet = Wallet ({ 'default' : 'my_key.txt' }) Create a Connection . stub_connection = StubConnection ( input_file_path = 'input.txt' , output_file_path = 'output.txt' ) For ledger APIs, we simply feed the agent an empty dictionary (meaning we do not require any). ledger_apis = LedgerApis ({}) Create the resources pointing to the working directory. resources = Resources ( '' ) Now we have everything we need for initialisation. my_agent = AEA ( \"my_agent\" , stub_connection , wallet , ledger_apis , resources )","title":"Initialise the agent"},{"location":"aea/hacking-an-agent/#add-skills-and-protocols","text":"We can add the echo skill as follows... Note Work in progress.","title":"Add skills and protocols"},{"location":"aea/hacking-an-agent/#run-the-agent","text":"Create a thread and add the agent to it. t = Thread ( target = my_agent . start ) Start the agent. t . start ()","title":"Run the agent"},{"location":"aea/hacking-an-agent/#terminate-the-agent","text":"Finalise the agent thread. my_agent . stop () t . join () t = None","title":"Terminate the agent"},{"location":"aea/integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third party ledgers. Fetch.ai Ledger Note Coming soon. Ethereum Ledger Note Coming soon.","title":"Integrate with third parties"},{"location":"aea/integration/#fetchai-ledger","text":"Note Coming soon.","title":"Fetch.ai Ledger"},{"location":"aea/integration/#ethereum-ledger","text":"Note Coming soon.","title":"Ethereum Ledger"},{"location":"aea/logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an agent. First of all, create your agent. aea create my_agent cd my_agent The aea-config.yaml file should look like this. aea_version : 0.1.6 agent_name : my_agent authors : '' connections : - oef default_connection : oef license : '' private_key_pem_path : '' protocols : - default registry_path : ../packages skills : - error url : '' version : v1 logging_config : disable_existing_loggers : false version : 1 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : true This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter.","title":"Logging"},{"location":"aea/oef-ledger/","text":"In the AEA framework universe, agents run alongside OEF search and discovery nodes which are running against the Fetch.ai ledger and external ledger systems.","title":"Oef ledger"},{"location":"aea/protocol/","text":"A Protocol manages message representation, encoding, and serialisation. It also defines the rules to which messages must adhere. An agent can have one or more protocols. The AEA framework supplies three: oef , fipa , and a default protocol. Custom protocol For a custom protocol, the developer must code methods from two classes. Message.check_consistency(self) This method checks the message data for consistency and raises an error if necessary. Todo For example. Serializer.encode(self, msg: Message) This method encodes a message object into bytes for passing around. Todo For example. Serializer.decode(self, obj: bytes) This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit. rules.py Note Coming soon. oef protocol The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc. fipa protocol The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Performative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } } default protocol The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"Protocol"},{"location":"aea/protocol/#custom-protocol","text":"For a custom protocol, the developer must code methods from two classes.","title":"Custom protocol"},{"location":"aea/protocol/#messagecheck_consistencyself","text":"This method checks the message data for consistency and raises an error if necessary. Todo For example.","title":"Message.check_consistency(self)"},{"location":"aea/protocol/#serializerencodeself-msg-message","text":"This method encodes a message object into bytes for passing around. Todo For example.","title":"Serializer.encode(self, msg: Message)"},{"location":"aea/protocol/#serializerdecodeself-obj-bytes","text":"This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit.","title":"Serializer.decode(self, obj: bytes)"},{"location":"aea/protocol/#rulespy","text":"Note Coming soon.","title":"rules.py"},{"location":"aea/protocol/#oef-protocol","text":"The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc.","title":"oef protocol"},{"location":"aea/protocol/#fipa-protocol","text":"The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Performative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } }","title":"fipa protocol"},{"location":"aea/protocol/#default-protocol","text":"The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"default protocol"},{"location":"aea/quickstart/","text":"Preliminaries Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell Installing docker At some point, you will need Docker installed on your machine (e.g. to run an OEF Node). If you don't have it, please check the official documentation here and follow the instructions for your platform. Download the scripts and packages directories svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages You can install the svn command with ( brew install subversion or sudo apt-get install subversion ). Installation Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ] Known issues If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio . Echo skill demo The echo skill is a simple demo that introduces you to the main business logic components of an AEA. Create a new agent First create a new agent project and enter it. aea create my_first_agent cd my_first_agent Add the echo skill aea add skill echo This copies the echo application code for the behaviours, handlers, and tasks into the skill, ready to run. Add a stub connection AEAs use messages for communication. We will add a stub connection to send messages to and receive messages from the AEA. aea add connection stub A stub connection provides an I/O reader/writer. It uses two files for communication: one for the incoming messages and the other for the outgoing messages. Each line contains an encoded envelope. The AEA waits for new messages posted to the file my_first_agent/input_file , and adds a response to the file my_first_agent/output_file . The format of each line is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE For example: recipient_agent,sender_agent,default, { \"type\" : \"bytes\" , \"content\" : \"aGVsbG8=\" } Run the agent Run the agent with the stub connection. aea run --connections stub You will see the echo task running in the terminal window. The framework first calls the setup method on the Handler , Behaviour , and Task code in that order; after which it repeatedly calls the Behaviour and Task methods, act and execute . This is the main agent loop in action. Let's look at the Handler in more depth. Add a message to the input file We send the AEA a message wrapped in an envelope via the input file. echo 'my_first_agent,sender_agent,default,{\"type\": \"bytes\", \"content\": \"aGVsbG8=\"}' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( type = bytes content = b 'hello' ) , sender = sender_agent info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. Stop the agent Stop the agent by pressing CTRL C Delete the agent Delete the agent from the parent directory via cd .. . aea delete my_first_agent","title":"AEA quick start"},{"location":"aea/quickstart/#preliminaries","text":"Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"aea/quickstart/#installing-docker","text":"At some point, you will need Docker installed on your machine (e.g. to run an OEF Node). If you don't have it, please check the official documentation here and follow the instructions for your platform.","title":"Installing docker"},{"location":"aea/quickstart/#download-the-scripts-and-packages-directories","text":"svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages You can install the svn command with ( brew install subversion or sudo apt-get install subversion ).","title":"Download the scripts and packages directories"},{"location":"aea/quickstart/#installation","text":"Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ]","title":"Installation"},{"location":"aea/quickstart/#known-issues","text":"If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio .","title":"Known issues"},{"location":"aea/quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that introduces you to the main business logic components of an AEA.","title":"Echo skill demo"},{"location":"aea/quickstart/#create-a-new-agent","text":"First create a new agent project and enter it. aea create my_first_agent cd my_first_agent","title":"Create a new agent"},{"location":"aea/quickstart/#add-the-echo-skill","text":"aea add skill echo This copies the echo application code for the behaviours, handlers, and tasks into the skill, ready to run.","title":"Add the echo skill"},{"location":"aea/quickstart/#add-a-stub-connection","text":"AEAs use messages for communication. We will add a stub connection to send messages to and receive messages from the AEA. aea add connection stub A stub connection provides an I/O reader/writer. It uses two files for communication: one for the incoming messages and the other for the outgoing messages. Each line contains an encoded envelope. The AEA waits for new messages posted to the file my_first_agent/input_file , and adds a response to the file my_first_agent/output_file . The format of each line is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE For example: recipient_agent,sender_agent,default, { \"type\" : \"bytes\" , \"content\" : \"aGVsbG8=\" }","title":"Add a stub connection"},{"location":"aea/quickstart/#run-the-agent","text":"Run the agent with the stub connection. aea run --connections stub You will see the echo task running in the terminal window. The framework first calls the setup method on the Handler , Behaviour , and Task code in that order; after which it repeatedly calls the Behaviour and Task methods, act and execute . This is the main agent loop in action. Let's look at the Handler in more depth.","title":"Run the agent"},{"location":"aea/quickstart/#add-a-message-to-the-input-file","text":"We send the AEA a message wrapped in an envelope via the input file. echo 'my_first_agent,sender_agent,default,{\"type\": \"bytes\", \"content\": \"aGVsbG8=\"}' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( type = bytes content = b 'hello' ) , sender = sender_agent info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called.","title":"Add a message to the input file"},{"location":"aea/quickstart/#stop-the-agent","text":"Stop the agent by pressing CTRL C","title":"Stop the agent"},{"location":"aea/quickstart/#delete-the-agent","text":"Delete the agent from the parent directory via cd .. . aea delete my_first_agent","title":"Delete the agent"},{"location":"aea/scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml . Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffolding"},{"location":"aea/scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml .","title":"Scaffold generator"},{"location":"aea/scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"aea/scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"aea/scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffold a connection"},{"location":"aea/skill-guide/","text":"The scaffolding tool allows you to create the folder structure required for a skill. Note Before developing your first skill, please read the skill guide . Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Step 1: Setup We will first create an agent and add a scaffold skill, which we call my_search . aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation. We will build a simple skill which lets the agent send a search query to the OEF and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[ {} ]: sending search request to OEF, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and, as such, well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py . Step 3: Develop a Handler So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py . Step 4: Develop a Task We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[ {} ]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py . Step 5: Create the config file Based on our skill components above, we create the following config file. name : my_search authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : '' description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ 'oef' ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml . Step 6: Add the oef protocol Our agent does not have the oef protocol yet so let's add it. aea add protocol oef Step 7: Run the agent We first start an oef node (see the connection section for more details) in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent. aea run Stop the agent with CTRL + C . Now it's your turn We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Build your own skill"},{"location":"aea/skill-guide/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/skill-guide/#step-1-setup","text":"We will first create an agent and add a scaffold skill, which we call my_search . aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation. We will build a simple skill which lets the agent send a search query to the OEF and process the resulting response.","title":"Step 1: Setup"},{"location":"aea/skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[ {} ]: sending search request to OEF, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and, as such, well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py .","title":"Step 2: Develop a Behaviour"},{"location":"aea/skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py .","title":"Step 3: Develop a Handler"},{"location":"aea/skill-guide/#step-4-develop-a-task","text":"We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[ {} ]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[ {} ]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py .","title":"Step 4: Develop a Task"},{"location":"aea/skill-guide/#step-5-create-the-config-file","text":"Based on our skill components above, we create the following config file. name : my_search authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : '' description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ 'oef' ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml .","title":"Step 5: Create the config file"},{"location":"aea/skill-guide/#step-6-add-the-oef-protocol","text":"Our agent does not have the oef protocol yet so let's add it. aea add protocol oef","title":"Step 6: Add the oef protocol"},{"location":"aea/skill-guide/#step-7-run-the-agent","text":"We first start an oef node (see the connection section for more details) in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent. aea run Stop the agent with CTRL + C .","title":"Step 7: Run the agent"},{"location":"aea/skill-guide/#now-its-your-turn","text":"We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Now it's your turn"},{"location":"aea/skill/","text":"An agent developer writes skills that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour, Task , and Handler classes as well as a configuration file skill.yaml . Context The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example. tasks.py Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example. Shared classes The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ] Error skill All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Skill"},{"location":"aea/skill/#context","text":"The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"aea/skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"aea/skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"aea/skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example.","title":"behaviours.py"},{"location":"aea/skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example.","title":"tasks.py"},{"location":"aea/skill/#shared-classes","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class","title":"Shared classes"},{"location":"aea/skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ]","title":"Skill config"},{"location":"aea/skill/#error-skill","text":"All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Error skill"},{"location":"aea/steps/","text":"There are a number of ways to build an agent. We recommended you build an AEA project with the CLI tool as mentioned in the quick start guide. See information on the CLI tool here . [Coming soon!] Using the CLI fetch command, pull in an already built project and run as normal. The last option is to install the AEA without the CLI tool with pip install aea and, from there, import classes directly. See the guide for this here . Set up your skills . Code the protocols . Add the connections . Scaffold any of the above resources with the scaffolding tool . This guide shows you step by step how to develop a skill. Now, build and run your agent using the quick start guide .","title":"Step by step"},{"location":"aea/tac-skills/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of agents: The tac controller which coordinates the game. The participant agents which compete in the game. Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF node In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo 1: no ledger transactions Create the TAC controller AEA In the root directory, create the tac controller AEA. aea create tac_controller Add the tac control skill cd tac_controller aea add skill tac_control Update the game parameters You can change the game parameters in tac_controller/skills/tac_control/skill.yaml under Parameters . You must set the start time to a point in the future start_time: Nov 10 2019 10:40AM . Run the TAC controller AEA aea run Create the TAC participants AEA In a separate terminal, in the root directory, create the tac participant AEA. aea create tac_participant_one aea create tac_participant_two Add the tac participation skill to participant one cd tac_participant_one aea add skill tac_participation aea add skill tac_negotiation Add the tac participation skill to participant two cd tac_participant_two aea add skill tac_participation aea add skill tac_negotiation Run both the TAC participant AEAs aea run Note Currently, the agents cannot settle their trades. Updates coming soon! Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between the two agents and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Searching_Agent participant Seller_Agent participant Controller activate Searching_Agent activate Seller_Agent activate Controller Searching_Agent->>Controller: search Controller-->>Searching_Agent: list_of_agents Searching_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Searching_Agent: proposal Searching_Agent->>Seller_Agent: accept Searching_Agent->>Controller: request_transaction Seller_Agent->>Searching_Agent: match_accept Seller_Agent->>Controller: request_transaction Controller->>Controller: transfer_funds deactivate Searching_Agent deactivate Seller_Agent deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The Searching Agent needs to determine if this is a good deal for them and if so, it accepts. There is an equivilent diagram for agents set up to search for buyers and their interaction with agents which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"TAC skills"},{"location":"aea/tac-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills/#launch-an-oef-node","text":"In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF node"},{"location":"aea/tac-skills/#demo-1-no-ledger-transactions","text":"","title":"Demo 1: no ledger transactions"},{"location":"aea/tac-skills/#create-the-tac-controller-aea","text":"In the root directory, create the tac controller AEA. aea create tac_controller","title":"Create the TAC controller AEA"},{"location":"aea/tac-skills/#add-the-tac-control-skill","text":"cd tac_controller aea add skill tac_control","title":"Add the tac control skill"},{"location":"aea/tac-skills/#update-the-game-parameters","text":"You can change the game parameters in tac_controller/skills/tac_control/skill.yaml under Parameters . You must set the start time to a point in the future start_time: Nov 10 2019 10:40AM .","title":"Update the game parameters"},{"location":"aea/tac-skills/#run-the-tac-controller-aea","text":"aea run","title":"Run the TAC controller AEA"},{"location":"aea/tac-skills/#create-the-tac-participants-aea","text":"In a separate terminal, in the root directory, create the tac participant AEA. aea create tac_participant_one aea create tac_participant_two","title":"Create the TAC participants AEA"},{"location":"aea/tac-skills/#add-the-tac-participation-skill-to-participant-one","text":"cd tac_participant_one aea add skill tac_participation aea add skill tac_negotiation","title":"Add the tac participation skill to participant one"},{"location":"aea/tac-skills/#add-the-tac-participation-skill-to-participant-two","text":"cd tac_participant_two aea add skill tac_participation aea add skill tac_negotiation","title":"Add the tac participation skill to participant two"},{"location":"aea/tac-skills/#run-both-the-tac-participant-aeas","text":"aea run Note Currently, the agents cannot settle their trades. Updates coming soon!","title":"Run both the TAC participant AEAs"},{"location":"aea/tac-skills/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills/#transaction-communication","text":"This diagram shows the communication between the two agents and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Searching_Agent participant Seller_Agent participant Controller activate Searching_Agent activate Seller_Agent activate Controller Searching_Agent->>Controller: search Controller-->>Searching_Agent: list_of_agents Searching_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Searching_Agent: proposal Searching_Agent->>Seller_Agent: accept Searching_Agent->>Controller: request_transaction Seller_Agent->>Searching_Agent: match_accept Seller_Agent->>Controller: request_transaction Controller->>Controller: transfer_funds deactivate Searching_Agent deactivate Seller_Agent deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The Searching Agent needs to determine if this is a good deal for them and if so, it accepts. There is an equivilent diagram for agents set up to search for buyers and their interaction with agents which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac/","text":"TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"aea/tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"aea/tac/#quick-start","text":"Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"aea/tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"aea/tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"aea/tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"aea/trust/","text":"AEA applications operate within different orders of trustlessness. For example, using the AEA weather skills demo without a ledger means that clients must trust that any data the weather station sends is sufficient, including no data at all. Similarly, the weather station must trust the weather clients to send payment via some mechanism. A step up, if you run the weather skills demo with a ledger (Fetch.ai or Ethereum) then the clients must again trust the weather station to send sufficient data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the weather clients as it can observe the transactions taking place on the public ledger. We can expand trustlessness even further by incorporating a third party as an arbitrator or some escrow contract. However, in the weather skills demo there are limits to trustlessness as the station ultimately offers unverifiable data. Finally, in the case of (non-fungible) token transactions where there is an atomic swap, full trustlessness is apparent. This is demonstrated in the TAC.","title":"Trust issues"},{"location":"aea/two-layer/","text":"Todo","title":"Two layer"},{"location":"aea/version/","text":"The current version of the Autonomous Economic Agent framework is 0.1.x . The framework is under rapid development with frequent breaking changes. To check which version you have installed locally, run aea --version","title":"Version"},{"location":"aea/vision/","text":"The AEA framework has two commercial roles. Open source technology We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers. Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Vision"},{"location":"aea/vision/#open-source-technology","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers.","title":"Open source technology"},{"location":"aea/vision/#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Platform for start ups"},{"location":"aea/weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs. The provider of weather data (the weather station). The seller of weather data (the weather client). Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF node In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo 1: no ledger payment The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps. Create the weather station AEA In the root directory, create the weather station AEA. aea create my_weather_station Add the weather station skill cd my_weather_station aea add skill weather_station Run the weather station AEA aea run Create the weather client AEA In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client Add the weather client skill cd my_weather_client aea add skill weather_client Run the weather client AEA aea run Observe the logs of both AEAs To stop an agent use CTRL + C . Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Communication This diagram shows the communication between the various entities as data is successfully sold by the car park agent to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA activate Client_AEA activate Search activate Weather_AEA Weather_AEA->>Search: register_service Client_AEA->>Search: search Search->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Weather_AEA: Inform funds transfered Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA Note that the client informs the weather station that funds have been transfereed, but in this example no funds actually get transfered. Demo 2: Fetch.ai ledger payment A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet . This demo assumes the weather client trusts the weather station to send the weather data upon successful payment. Create the weather station (ledger version) Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger Create the weather client (ledger version) In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt Update the AEA configs Both in my_weather_station/aea-config.yaml and my_weather_client/aea-config.yaml , replace ledger_apis: [] with the following. ledger_apis : - ledger_api : ledger : fetchai addr : alpha.fetch-ai.com port : 80 Fund the weather client AEA Create some wealth for your weather client on the Fetch.ai testnet . (It takes a while). cd .. python scripts/fetchai_wealth_generation.py --private-key my_weather_client/fet_private_key.txt --amount 10000000 --addr alpha.fetch-ai.com --port 80 cd my_weather_client Run the AEAs Run both AEAs from their respective terminals. aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet . Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Demo 3: Ethereum ledger payment A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet . This demo assumes the weather client trusts the weather station to send the weather data upon successful payment. Create the weather station (ledger version) Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger Create the weather client (ledger version) In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_weather_station/aea-config.yaml and my_weather_client/aea-config.yaml , replace ledger_apis: [] with the following. ledger_apis : - ledger_api : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe ledger : ethereum port : 3 Update the skill configs In the weather station skill config ( my_weather_station/skills/weather_station_ledger/skill.yaml ) under strategy, amend the currency_pbk and ledger_id as follows. currency_pbk: 'ETH' ledger_id: 'ethereum' Amend ledgers to the following. ledgers: [ 'ethereum' ] In the weather client skill config ( my_weather_client/skills/weather_client_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id . max_buyer_tx_fee: 20000 currency_pbk: 'ETH' ledger_id: 'ethereum' Amend ledgers to the following. ledgers: ['ethereum'] Fund the weather client AEA Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_weather_client/eth_private_key.txt . Run the AEAs Run both AEAs, from their respective terminals. aea run You will see that the AEAs negotiate and then transact using the Ethereum testnet . Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Communication This diagram shows the communication between the various entities as data is successfully sold by the weather station agent to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Weather skills"},{"location":"aea/weather-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/weather-skills/#launch-an-oef-node","text":"In a separate terminal, launch a local OEF node (for search and discovery). python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF node"},{"location":"aea/weather-skills/#demo-1-no-ledger-payment","text":"The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps.","title":"Demo 1: no ledger payment"},{"location":"aea/weather-skills/#create-the-weather-station-aea","text":"In the root directory, create the weather station AEA. aea create my_weather_station","title":"Create the weather station AEA"},{"location":"aea/weather-skills/#add-the-weather-station-skill","text":"cd my_weather_station aea add skill weather_station","title":"Add the weather station skill"},{"location":"aea/weather-skills/#run-the-weather-station-aea","text":"aea run","title":"Run the weather station AEA"},{"location":"aea/weather-skills/#create-the-weather-client-aea","text":"In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client","title":"Create the weather client AEA"},{"location":"aea/weather-skills/#add-the-weather-client-skill","text":"cd my_weather_client aea add skill weather_client","title":"Add the weather client skill"},{"location":"aea/weather-skills/#run-the-weather-client-aea","text":"aea run","title":"Run the weather client AEA"},{"location":"aea/weather-skills/#observe-the-logs-of-both-aeas","text":"To stop an agent use CTRL + C .","title":"Observe the logs of both AEAs"},{"location":"aea/weather-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/weather-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park agent to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA activate Client_AEA activate Search activate Weather_AEA Weather_AEA->>Search: register_service Client_AEA->>Search: search Search->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Weather_AEA: Inform funds transfered Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA Note that the client informs the weather station that funds have been transfereed, but in this example no funds actually get transfered.","title":"Communication"},{"location":"aea/weather-skills/#demo-2-fetchai-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet . This demo assumes the weather client trusts the weather station to send the weather data upon successful payment.","title":"Demo 2: Fetch.ai ledger payment"},{"location":"aea/weather-skills/#create-the-weather-station-ledger-version","text":"Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger","title":"Create the weather station (ledger version)"},{"location":"aea/weather-skills/#create-the-weather-client-ledger-version","text":"In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt","title":"Create the weather client (ledger version)"},{"location":"aea/weather-skills/#update-the-aea-configs","text":"Both in my_weather_station/aea-config.yaml and my_weather_client/aea-config.yaml , replace ledger_apis: [] with the following. ledger_apis : - ledger_api : ledger : fetchai addr : alpha.fetch-ai.com port : 80","title":"Update the AEA configs"},{"location":"aea/weather-skills/#fund-the-weather-client-aea","text":"Create some wealth for your weather client on the Fetch.ai testnet . (It takes a while). cd .. python scripts/fetchai_wealth_generation.py --private-key my_weather_client/fet_private_key.txt --amount 10000000 --addr alpha.fetch-ai.com --port 80 cd my_weather_client","title":"Fund the weather client AEA"},{"location":"aea/weather-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet .","title":"Run the AEAs"},{"location":"aea/weather-skills/#delete-the-aeas_1","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/weather-skills/#demo-3-ethereum-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet . This demo assumes the weather client trusts the weather station to send the weather data upon successful payment.","title":"Demo 3: Ethereum ledger payment"},{"location":"aea/weather-skills/#create-the-weather-station-ledger-version_1","text":"Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger","title":"Create the weather station (ledger version)"},{"location":"aea/weather-skills/#create-the-weather-client-ledger-version_1","text":"In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the weather client (ledger version)"},{"location":"aea/weather-skills/#update-the-aea-configs_1","text":"Both in my_weather_station/aea-config.yaml and my_weather_client/aea-config.yaml , replace ledger_apis: [] with the following. ledger_apis : - ledger_api : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe ledger : ethereum port : 3","title":"Update the AEA configs"},{"location":"aea/weather-skills/#update-the-skill-configs","text":"In the weather station skill config ( my_weather_station/skills/weather_station_ledger/skill.yaml ) under strategy, amend the currency_pbk and ledger_id as follows. currency_pbk: 'ETH' ledger_id: 'ethereum' Amend ledgers to the following. ledgers: [ 'ethereum' ] In the weather client skill config ( my_weather_client/skills/weather_client_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id . max_buyer_tx_fee: 20000 currency_pbk: 'ETH' ledger_id: 'ethereum' Amend ledgers to the following. ledgers: ['ethereum']","title":"Update the skill configs"},{"location":"aea/weather-skills/#fund-the-weather-client-aea_1","text":"Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_weather_client/eth_private_key.txt .","title":"Fund the weather client AEA"},{"location":"aea/weather-skills/#run-the-aeas_1","text":"Run both AEAs, from their respective terminals. aea run You will see that the AEAs negotiate and then transact using the Ethereum testnet .","title":"Run the AEAs"},{"location":"aea/weather-skills/#delete-the-aeas_2","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/weather-skills/#communication_1","text":"This diagram shows the communication between the various entities as data is successfully sold by the weather station agent to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Communication"},{"location":"etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai Ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.ai Ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Design and test your smart contract code with the etch VM simulator before including it in a Python Ledger API script which takes care of deployment and other details. Find out how to run smart contract code with the Python Ledger API here . Note The `etch` language and the `etch` language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"Introduction"},{"location":"etch-language/addresses/","text":"Address type format The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) . Create an Address function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Type size in detail There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address ) SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready. Print Address Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Address"},{"location":"etch-language/addresses/#address-type-format","text":"The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) .","title":"Address type format"},{"location":"etch-language/addresses/#create-an-address","text":"function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction","title":"Create an Address"},{"location":"etch-language/addresses/#type-size-in-detail","text":"There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address )","title":"Type size in detail"},{"location":"etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"etch-language/addresses/#print-address","text":"Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Print Address"},{"location":"etch-language/arrays/","text":"Arrays One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction Two dimensional arrays Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction Array functions Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction Pop back and front with n Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"etch-language/arrays/#arrays","text":"","title":"Arrays"},{"location":"etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction","title":"One dimensional arrays"},{"location":"etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"etch-language/arrays/#nested-arrays","text":"etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction","title":"Nested arrays"},{"location":"etch-language/arrays/#array-functions","text":"","title":"Array functions"},{"location":"etch-language/arrays/#count","text":"The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction","title":"Count"},{"location":"etch-language/arrays/#append","text":"The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Append"},{"location":"etch-language/arrays/#extend","text":"Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction","title":"Extend"},{"location":"etch-language/arrays/#pop-back-and-pop-front","text":"The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction","title":"Pop back and pop front"},{"location":"etch-language/arrays/#pop-back-and-front-with-n","text":"Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction","title":"Pop back and front with n"},{"location":"etch-language/arrays/#reverse","text":"The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Reverse"},{"location":"etch-language/arrays/#erase","text":"Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Erase"},{"location":"etch-language/balance-transfer/","text":"Like Context , Block , and Transaction , the balance and transfer functions must run against a Fetch.ai Ledger node. balance() The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear transfer(target : Address, amount : UInt64) The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear Example Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here . etch smart contract code The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other. Python Ledger API wrapper code from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Balance and Transfer"},{"location":"etch-language/balance-transfer/#balance","text":"The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear","title":"balance()"},{"location":"etch-language/balance-transfer/#transfertarget-address-amount-uint64","text":"The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear","title":"transfer(target : Address, amount : UInt64)"},{"location":"etch-language/balance-transfer/#example","text":"Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here .","title":"Example"},{"location":"etch-language/balance-transfer/#etch-smart-contract-code","text":"The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other.","title":"etch smart contract code"},{"location":"etch-language/balance-transfer/#python-ledger-api-wrapper-code","text":"from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Python Ledger API wrapper code"},{"location":"etch-language/context/","text":"Context is an etch language type that provides access to currently invoking ledger transaction data - such as block and transaction information - coming from smart contracts running against ledger nodes. Specific annotated functions Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node. Coding with Context Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. getContext() , block() , and blockNumber() To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); Example The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Context"},{"location":"etch-language/context/#specific-annotated-functions","text":"Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node.","title":"Specific annotated functions"},{"location":"etch-language/context/#coding-with-context","text":"Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates.","title":"Coding with Context"},{"location":"etch-language/context/#getcontext-block-and-blocknumber","text":"To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber ();","title":"getContext(), block(), and blockNumber()"},{"location":"etch-language/context/#example","text":"The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Example"},{"location":"etch-language/control-flow/","text":"Control flow Tip Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction","title":"if-else"},{"location":"etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"etch-language/control-flow/#for","text":"function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction","title":"for"},{"location":"etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings and applying them to the SHA256() object. The example then resets the object and repeats the process with three more strings. function main () var my_string_value_1 = \"sdkjfhiuwehfesdfno ; s ; ' mADF ; LK \"; var my_string_value_2 = \"ipoiuwr8934jklnwlkj0892;m\" ; var my_string_value_3 = \"vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548\" ; // create a SHA256() context object var sha256_hash = SHA256 (); // give it your strings sha256_hash . update ( my_string_value_1 ); sha256_hash . update ( my_string_value_2 ); sha256_hash . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 1,2,3 = \" + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hash . reset (); // more strings var my_string_value_4 = \"12345fg\" ; var my_string_value_5 = \"@!#$@#%#\" ; var my_string_value_6 = \"{}:>L$%^:c\" ; // add to context sha256_hash . update ( my_string_value_4 ); sha256_hash . update ( my_string_value_5 ); sha256_hash . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 4,5,6 = \" + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"etch-language/data-loaders/","text":"A DataLoader is an object used by an Optimiser for loading data into a Graph . Usually this data is a pair of Tensor types (data and label). Declare and initialise a DataLoader giving a string parameter which defines the type of input data. The common generic DataLoader takes Tensor objects. function main () var dataLoader = DataLoader ( \"tensor\" ); endfunction There are currently three flavours of DataLoader in etch . Fetch.ai developers have built specific DataLoader types for research and example purposes that take MNIST files, and csv files for a commodity application. Tensor data loader Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction isDone() and getNext() DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction Serialisation A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"DataLoader"},{"location":"etch-language/data-loaders/#tensor-data-loader","text":"Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction","title":"Tensor data loader"},{"location":"etch-language/data-loaders/#isdone-and-getnext","text":"DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction","title":"isDone() and getNext()"},{"location":"etch-language/data-loaders/#serialisation","text":"A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"Serialisation"},{"location":"etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the `etch` compiler will strip out `printLn()` statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"etch-language/debug/#compiling","text":"Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope.","title":"Compiling"},{"location":"etch-language/debug/#system-arguments","text":"System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"System arguments"},{"location":"etch-language/error-checking/","text":"The following functions help with diagnosing bugs and ensuring the correct state of variables and boolean tests. Panic Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction Assert Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"etch-language/error-checking/#panic","text":"Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Panic"},{"location":"etch-language/error-checking/#assert","text":"Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Assert"},{"location":"etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending `etch` in C++.","title":"Extending Etch in C++'"},{"location":"etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv() Type casting toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toFixed32() toFixed64() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFloat32 ( x ); printLn ( g ); var h = toFloat64 ( x ); printLn ( h ); var i = toFixed32 ( x ); printLn ( i ); var j = toFixed64 ( x ); printLn ( j ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here . Getters and setters Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Functions"},{"location":"etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"etch-language/functions/#print","text":"printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards.","title":"Print"},{"location":"etch-language/functions/#sysargs","text":"The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv()","title":"Sysargs"},{"location":"etch-language/functions/#type-casting","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toFixed32() toFixed64() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFloat32 ( x ); printLn ( g ); var h = toFloat64 ( x ); printLn ( h ); var i = toFixed32 ( x ); printLn ( i ); var j = toFixed64 ( x ); printLn ( j ); endfunction","title":"Type casting"},{"location":"etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here .","title":"Annotations"},{"location":"etch-language/functions/#getters-and-setters","text":"Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Getters and setters"},{"location":"etch-language/getstarted/","text":"Getting started Prerequisites To build with Etch, you will need a running node. Installation At the root of your ledger installation directory cd into build folder. Run make etch . Setup At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract. Hello world with Etch Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Compile and run two or more etch files It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch . Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Getting started"},{"location":"etch-language/getstarted/#getting-started","text":"","title":"Getting started"},{"location":"etch-language/getstarted/#prerequisites","text":"To build with Etch, you will need a running node.","title":"Prerequisites"},{"location":"etch-language/getstarted/#installation","text":"At the root of your ledger installation directory cd into build folder. Run make etch .","title":"Installation"},{"location":"etch-language/getstarted/#setup","text":"At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"etch-language/getstarted/#hello-world-with-etch","text":"Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with Etch"},{"location":"etch-language/getstarted/#compile-and-run-two-or-more-etch-files","text":"It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch .","title":"Compile and run two or more etch files"},{"location":"etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"etch-language/graph/","text":"Declare and initialise a Graph . function main () var graph = Graph (); endfunction A Graph is a directed acyclic computational graph used to process data through a sequence of operations. The current primary use case for these is the instantiation of neural networks. Each node in the Graph maintains responsibility for either a single operation or a layer of operations. The preferred method for training a Graph is to use a DataLoader and Optimiser . We describe these two objects in a later section. Placeholders Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction Layers Fully connected Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction 1D convolution The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction Operations Activations ReLU The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction Softmax The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction Dropout The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction Transpose The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction Exp The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction Loss functions Cross entropy loss The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction Mean square error loss The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction Serialisation For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction Serialise to string It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction Deserialise from string Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction Build a Graph example The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction Training a Graph example Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section. 1. Set input Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction 2. Evaluate The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction 3. Back propagate Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction 4. Step Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"Graph"},{"location":"etch-language/graph/#placeholders","text":"Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction","title":"Placeholders"},{"location":"etch-language/graph/#layers","text":"","title":"Layers"},{"location":"etch-language/graph/#fully-connected","text":"Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction","title":"Fully connected"},{"location":"etch-language/graph/#1d-convolution","text":"The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction","title":"1D convolution"},{"location":"etch-language/graph/#operations","text":"","title":"Operations"},{"location":"etch-language/graph/#activations","text":"","title":"Activations"},{"location":"etch-language/graph/#relu","text":"The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction","title":"ReLU"},{"location":"etch-language/graph/#softmax","text":"The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction","title":"Softmax"},{"location":"etch-language/graph/#dropout","text":"The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction","title":"Dropout"},{"location":"etch-language/graph/#transpose","text":"The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction","title":"Transpose"},{"location":"etch-language/graph/#exp","text":"The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction","title":"Exp"},{"location":"etch-language/graph/#loss-functions","text":"","title":"Loss functions"},{"location":"etch-language/graph/#cross-entropy-loss","text":"The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction","title":"Cross entropy loss"},{"location":"etch-language/graph/#mean-square-error-loss","text":"The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction","title":"Mean square error loss"},{"location":"etch-language/graph/#serialisation","text":"For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction","title":"Serialisation"},{"location":"etch-language/graph/#serialise-to-string","text":"It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction","title":"Serialise to string"},{"location":"etch-language/graph/#deserialise-from-string","text":"Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction","title":"Deserialise from string"},{"location":"etch-language/graph/#build-a-graph-example","text":"The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction","title":"Build a Graph example"},{"location":"etch-language/graph/#training-a-graph-example","text":"Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section.","title":"Training a Graph example"},{"location":"etch-language/graph/#1-set-input","text":"Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction","title":"1. Set input"},{"location":"etch-language/graph/#2-evaluate","text":"The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction","title":"2. Evaluate"},{"location":"etch-language/graph/#3-back-propagate","text":"Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction","title":"3. Back propagate"},{"location":"etch-language/graph/#4-step","text":"Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"4. Step"},{"location":"etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Xor Note Coming soon: support for `xor`.","title":"Logical operators"},{"location":"etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction","title":"Equal to"},{"location":"etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction","title":"Not equal to"},{"location":"etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction","title":"Less than"},{"location":"etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction","title":"More than"},{"location":"etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"And"},{"location":"etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"Or"},{"location":"etch-language/logic/#xor","text":"Note Coming soon: support for `xor`.","title":"Xor"},{"location":"etch-language/maths-functions/","text":"Tip `Fixed64` is the default variable data type used by the `etch` mathematics and machine learning libraries. In the current version, and further to the common mathematical operations provided by the etch language already discussed here , the following functions are available. Absolute value abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction Floating point types. function main () // 32 bit floating point var float_32 = 1.0f ; printLn ( toString ( abs ( float_32 ))); var neg_float_32 = - 1.0f ; printLn ( toString ( abs ( neg_float_32 ))); // 64 bit floating point var float_64 = 1.0 ; printLn ( toString ( abs ( float_64 ))); var neg_float_64 = - 1.0 ; printLn ( toString ( abs ( neg_float_64 ))); endfunction And fixed point types. function main () // 32 bit floating point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit floating point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); endfunction Exponential function The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction Range restrictions Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed32 types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range. Special cases Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x) Errors for x \u2208 (-10, 5) Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07 Power The power function returns the value of the first parameter raised to the second. The power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));` Special cases Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x Errors for x \u2208 (0, 100), y \u2208 (0, 10.5) Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10 Errors for x \u2208 (-10, 10), y \u2208 (-4, 4) Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10 Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction Square root The square root of a number is found with the sqrt() function. The square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction Special cases Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf Errors for x \u2208 (0, 5) Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09 Trigonometry Sin , Cos , and Tan function main () var x = 1.0 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Sin special cases Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x) Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Cos special cases Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1 Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Tan special cases Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06 ArcSin , ArcCos , and ArcTan function main () var x = 1.0 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction ASin special cases Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x) Errors for x \u2208 (-1, 1) Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09 ACos special cases Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09 ATan special cases Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x) Errors for x \u2208 (-5, 5) Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08 Hyperbolic Sin , Cos , and Tan function main () var x = 1.0 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2` SinH special cases Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf Errors for x \u2208 (-5, 5) Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08 CosH special cases Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2` Errors for x \u2208 (-5, 5) Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08 TanH special cases Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))` Errors for x \u2208 (-3, 3) Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09 Hyperbolic ArcSin , ArcCos , and ArcTan function main () var x = 1.0 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction ArcSin special cases Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf Errors for x \u2208 (-3, 3) Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08 ArcCos special cases Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN Errors for x \u2208 (1, 3) Fixed32 : average: 8.53834e-06 , max: 6.62567e-05 Errors for x \u2208 (1, 5) Fixed64 : average: 2.37609e-09 , max: 2.28507e-08 ArcTan special cases Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Maths functions"},{"location":"etch-language/maths-functions/#absolute-value","text":"abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction Floating point types. function main () // 32 bit floating point var float_32 = 1.0f ; printLn ( toString ( abs ( float_32 ))); var neg_float_32 = - 1.0f ; printLn ( toString ( abs ( neg_float_32 ))); // 64 bit floating point var float_64 = 1.0 ; printLn ( toString ( abs ( float_64 ))); var neg_float_64 = - 1.0 ; printLn ( toString ( abs ( neg_float_64 ))); endfunction And fixed point types. function main () // 32 bit floating point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit floating point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); endfunction","title":"Absolute value"},{"location":"etch-language/maths-functions/#exponential-function","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction","title":"Exponential function"},{"location":"etch-language/maths-functions/#range-restrictions","text":"Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed32 types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range.","title":"Range restrictions"},{"location":"etch-language/maths-functions/#special-cases","text":"Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x)","title":"Special cases"},{"location":"etch-language/maths-functions/#errors-for-x-10-5","text":"Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07","title":"Errors for x \u2208 (-10, 5)"},{"location":"etch-language/maths-functions/#power","text":"The power function returns the value of the first parameter raised to the second. The power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));`","title":"Power"},{"location":"etch-language/maths-functions/#special-cases_1","text":"Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x","title":"Special cases"},{"location":"etch-language/maths-functions/#errors-for-x-0-100-y-0-105","text":"Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10","title":"Errors for x \u2208 (0, 100), y \u2208 (0, 10.5)"},{"location":"etch-language/maths-functions/#errors-for-x-10-10-y-4-4","text":"Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10","title":"Errors for x \u2208 (-10, 10), y \u2208 (-4, 4)"},{"location":"etch-language/maths-functions/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction","title":"Random (non deterministic)"},{"location":"etch-language/maths-functions/#square-root","text":"The square root of a number is found with the sqrt() function. The square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction","title":"Square root"},{"location":"etch-language/maths-functions/#special-cases_2","text":"Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf","title":"Special cases"},{"location":"etch-language/maths-functions/#errors-for-x-0-5","text":"Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09","title":"Errors for x \u2208 (0, 5)"},{"location":"etch-language/maths-functions/#trigonometry","text":"","title":"Trigonometry"},{"location":"etch-language/maths-functions/#sin-cos-and-tan","text":"function main () var x = 1.0 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction","title":"Sin, Cos, and Tan"},{"location":"etch-language/maths-functions/#sin-special-cases","text":"Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x)","title":"Sin special cases"},{"location":"etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"etch-language/maths-functions/#cos-special-cases","text":"Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1","title":"Cos special cases"},{"location":"etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2_1","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"etch-language/maths-functions/#tan-special-cases","text":"Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf","title":"Tan special cases"},{"location":"etch-language/maths-functions/#errors-for-x-pi2-001-pi2-001","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01)"},{"location":"etch-language/maths-functions/#arcsin-arccos-and-arctan","text":"function main () var x = 1.0 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction","title":"ArcSin, ArcCos, and ArcTan"},{"location":"etch-language/maths-functions/#asin-special-cases","text":"Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x)","title":"ASin special cases"},{"location":"etch-language/maths-functions/#errors-for-x-1-1","text":"Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"etch-language/maths-functions/#acos-special-cases","text":"Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN","title":"ACos special cases"},{"location":"etch-language/maths-functions/#errors-for-x-1-1_1","text":"Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"etch-language/maths-functions/#atan-special-cases","text":"Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x)","title":"ATan special cases"},{"location":"etch-language/maths-functions/#errors-for-x-5-5","text":"Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"etch-language/maths-functions/#hyperbolic-sin-cos-and-tan","text":"function main () var x = 1.0 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2`","title":"Hyperbolic Sin, Cos, and Tan"},{"location":"etch-language/maths-functions/#sinh-special-cases","text":"Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf","title":"SinH special cases"},{"location":"etch-language/maths-functions/#errors-for-x-5-5_1","text":"Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"etch-language/maths-functions/#cosh-special-cases","text":"Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2`","title":"CosH special cases"},{"location":"etch-language/maths-functions/#errors-for-x-5-5_2","text":"Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"etch-language/maths-functions/#tanh-special-cases","text":"Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))`","title":"TanH special cases"},{"location":"etch-language/maths-functions/#errors-for-x-3-3","text":"Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09","title":"Errors for x \u2208 (-3, 3)"},{"location":"etch-language/maths-functions/#hyperbolic-arcsin-arccos-and-arctan","text":"function main () var x = 1.0 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Hyperbolic ArcSin, ArcCos, and ArcTan"},{"location":"etch-language/maths-functions/#arcsin-special-cases","text":"Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf","title":"ArcSin special cases"},{"location":"etch-language/maths-functions/#errors-for-x-3-3_1","text":"Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08","title":"Errors for x \u2208 (-3, 3)"},{"location":"etch-language/maths-functions/#arccos-special-cases","text":"Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN","title":"ArcCos special cases"},{"location":"etch-language/maths-functions/#errors-for-x-1-3","text":"Fixed32 : average: 8.53834e-06 , max: 6.62567e-05","title":"Errors for x \u2208 (1, 3)"},{"location":"etch-language/maths-functions/#errors-for-x-1-5","text":"Fixed64 : average: 2.37609e-09 , max: 2.28507e-08","title":"Errors for x \u2208 (1, 5)"},{"location":"etch-language/maths-functions/#arctan-special-cases","text":"Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN","title":"ArcTan special cases"},{"location":"etch-language/maths-functions/#errors-for-x-1-1_2","text":"Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Errors for x \u2208 (-1, 1)"},{"location":"etch-language/model/","text":"A Model is the simplest way to build, train, and evaluate neural networks in etch . The Model type takes care of the underlying implementation details for Graph , DataLoader , and Optimiser . There are three types of Model . Sequential : trains a computational graph to predict either continuous variables or classes, and allows more control over the layers of the network. Regressor : trains a computational graph to predict continuous variables. For example, what will be the future price of a particular currency? Classifier : trains a computational graph to predict classes. For example, is this a picture of a cat or a dog? Construct a Model Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction Add Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction Compile Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction Read in input data The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Fit With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction Evaluate Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction Predict Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Model"},{"location":"etch-language/model/#construct-a-model","text":"Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction","title":"Construct a Model"},{"location":"etch-language/model/#add","text":"Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction","title":"Add"},{"location":"etch-language/model/#compile","text":"Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction","title":"Compile"},{"location":"etch-language/model/#read-in-input-data","text":"The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Read in input data"},{"location":"etch-language/model/#fit","text":"With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction","title":"Fit"},{"location":"etch-language/model/#evaluate","text":"Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction","title":"Evaluate"},{"location":"etch-language/model/#predict","text":"Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Predict"},{"location":"etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"etch-language/optimiser/","text":"Use an Optimiser to run the machine learning training on a Graph and a DataLoader . Declare and initialise an Optimiser , giving it the name of the optimisation algorithm you wish to run, the Graph and the DataLoader objects, and the place-holder nodes for the input data, training data, and error data. var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input1\" , \"Input2\" , ...}, \"Label\" , \"Error\" ); To run the Optimiser , call run() with a batch size. Batch size sets the number of samples to train on in an epoch. var loss = optimiser . run ( batch_size ); Adagrad \"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction Adam \"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Momentum \"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... RMSprop \"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... SGD \"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Full optimisation example Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction Reset Graph or DataLoader Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Optimiser"},{"location":"etch-language/optimiser/#adagrad","text":"\"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction","title":"Adagrad"},{"location":"etch-language/optimiser/#adam","text":"\"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Adam"},{"location":"etch-language/optimiser/#momentum","text":"\"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Momentum"},{"location":"etch-language/optimiser/#rmsprop","text":"\"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"RMSprop"},{"location":"etch-language/optimiser/#sgd","text":"\"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"SGD"},{"location":"etch-language/optimiser/#full-optimisation-example","text":"Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction","title":"Full optimisation example"},{"location":"etch-language/optimiser/#reset-graph-or-dataloader","text":"Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Reset Graph or DataLoader"},{"location":"etch-language/persistent-globals/","text":"Persistent globals are succinct and ledger efficient persistent variable types that store data on the Fetch.ai Ledger. They are equivalent to State and ShardedState objects and are the primary mechanism for shard management. Five new keywords identify these types: persistent , sharded , use , as , and any . As etch evolves along with the Fetch.ai Ledger, persistent globals will help ensure maximum ledger storage efficiency. Recommendation Use the persistent global syntax instead of State and ShardedState syntax. Syntax Declare all persistent variables the smart contract may use at the top of the file before any function declarations. persistent Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations. sharded Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations. use Import the global persistent variables into smart contract functions with the use keyword. State For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction ShardedState For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects). as Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction any Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction Benefits Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction Limitations You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Persistent globals"},{"location":"etch-language/persistent-globals/#syntax","text":"Declare all persistent variables the smart contract may use at the top of the file before any function declarations.","title":"Syntax"},{"location":"etch-language/persistent-globals/#persistent","text":"Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations.","title":"persistent"},{"location":"etch-language/persistent-globals/#sharded","text":"Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations.","title":"sharded"},{"location":"etch-language/persistent-globals/#use","text":"Import the global persistent variables into smart contract functions with the use keyword.","title":"use"},{"location":"etch-language/persistent-globals/#state","text":"For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction","title":"State"},{"location":"etch-language/persistent-globals/#shardedstate","text":"For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects).","title":"ShardedState"},{"location":"etch-language/persistent-globals/#as","text":"Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction","title":"as"},{"location":"etch-language/persistent-globals/#any","text":"Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction","title":"any"},{"location":"etch-language/persistent-globals/#benefits","text":"Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"Benefits"},{"location":"etch-language/persistent-globals/#limitations","text":"You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Limitations"},{"location":"etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"etch-language/release-notes/","text":"Version v0.9.x Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Release notes"},{"location":"etch-language/release-notes/#version-v09x","text":"Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Version v0.9.x"},{"location":"etch-language/sc-annotations/","text":"Smart contract functions are annotated depending on the activity they perform. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. This happens once and once only at contract deployment. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment. @action The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction In the worst case, the above function needs two shards for data storage. @query Query functions are read-only functions that allow you to view data residing on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"Smart contract annotations"},{"location":"etch-language/sc-annotations/#init","text":"The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. This happens once and once only at contract deployment. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment.","title":"@init"},{"location":"etch-language/sc-annotations/#action","text":"The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction In the worst case, the above function needs two shards for data storage.","title":"@action"},{"location":"etch-language/sc-annotations/#query","text":"Query functions are read-only functions that allow you to view data residing on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"@query"},{"location":"etch-language/scaler/","text":"Use a Scaler to normalise data. Declare and initialise a Scaler . function main () var scaler = Scaler (); endfunction Min max The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); Scaler example The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler"},{"location":"etch-language/scaler/#min-max","text":"The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor );","title":"Min max"},{"location":"etch-language/scaler/#scaler-example","text":"The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler example"},{"location":"etch-language/sharded-state/","text":"Warning Use persistent global syntax to build State variables. Introduction to ShardedState variables A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declaration Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Querying with default values Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction ShardedState types with Address references You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState"},{"location":"etch-language/sharded-state/#introduction-to-shardedstate-variables","text":"A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger.","title":"Introduction to ShardedState variables"},{"location":"etch-language/sharded-state/#declaration","text":"Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data.","title":"Declaration"},{"location":"etch-language/sharded-state/#add-keyvalue-pairs","text":"Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction","title":"Add key/value pairs"},{"location":"etch-language/sharded-state/#querying-with-default-values","text":"Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction","title":"Querying with default values"},{"location":"etch-language/sharded-state/#shardedstate-types-with-address-references","text":"You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState types with Address references"},{"location":"etch-language/states/","text":"Warning Use persistent global syntax to build State variables. Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction Default values If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error. Writing State data to the ledger The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"State"},{"location":"etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction","title":"Introduction to State variables"},{"location":"etch-language/states/#default-values","text":"If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership.","title":"Test a State exists"},{"location":"etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error.","title":"State references and scope"},{"location":"etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction","title":"Passing States around"},{"location":"etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"Verify an Address"},{"location":"etch-language/strings/","text":"Strings etch supports ASCII and UTF8 for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction String functions You can use the following utility functions for string manipulation: Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction Substring The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Strings"},{"location":"etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction","title":"Concatenation"},{"location":"etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"etch-language/strings/#string-functions","text":"You can use the following utility functions for string manipulation:","title":"String functions"},{"location":"etch-language/strings/#find","text":"The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction","title":"Find"},{"location":"etch-language/strings/#length","text":"The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction","title":"Length"},{"location":"etch-language/strings/#reverse","text":"The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction","title":"Reverse"},{"location":"etch-language/strings/#split","text":"The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Split"},{"location":"etch-language/strings/#substring","text":"The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction","title":"Substring"},{"location":"etch-language/strings/#trim","text":"The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Trim"},{"location":"etch-language/syn-annotations/","text":"etch synergetic contract code includes specific annotated functions. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution. Note Detailed explanations of the above annotations, with coded examples, are coming soon.","title":"Synergetic contract annotations"},{"location":"etch-language/syntax/","text":"Syntax The etch language integrates with the Fetch.ai Ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Syntax"},{"location":"etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear","title":"Keywords"},{"location":"etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Annotations"},{"location":"etch-language/tensor/","text":"A Tensor is a vector or matrix type having multiple dimensions. In etch it is the n-dimensional matrix type used by the mathematics and machine learning libraries. Declare and initialise Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction toString Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Size Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction fromString Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction Fill Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction Fill Random The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Setters Use setAt() to insert a Fixed64 value at a specific index. 1D The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 2D The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 3D The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction 4D The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction Getters The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension. 1D function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction 2D function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction 3D function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction 4D function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction Reshape The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction Squeeze The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction Serialisation A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Tensor"},{"location":"etch-language/tensor/#declare-and-initialise","text":"Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction","title":"Declare and initialise"},{"location":"etch-language/tensor/#tostring","text":"Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"toString"},{"location":"etch-language/tensor/#size","text":"Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction","title":"Size"},{"location":"etch-language/tensor/#fromstring","text":"Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction","title":"fromString"},{"location":"etch-language/tensor/#fill","text":"Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"Fill"},{"location":"etch-language/tensor/#fill-random","text":"The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"Fill Random"},{"location":"etch-language/tensor/#setters","text":"Use setAt() to insert a Fixed64 value at a specific index.","title":"Setters"},{"location":"etch-language/tensor/#1d","text":"The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"1D"},{"location":"etch-language/tensor/#2d","text":"The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"2D"},{"location":"etch-language/tensor/#3d","text":"The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction","title":"3D"},{"location":"etch-language/tensor/#4d","text":"The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction","title":"4D"},{"location":"etch-language/tensor/#getters","text":"The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension.","title":"Getters"},{"location":"etch-language/tensor/#1d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction","title":"1D"},{"location":"etch-language/tensor/#2d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction","title":"2D"},{"location":"etch-language/tensor/#3d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction","title":"3D"},{"location":"etch-language/tensor/#4d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction","title":"4D"},{"location":"etch-language/tensor/#reshape","text":"The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction","title":"Reshape"},{"location":"etch-language/tensor/#squeeze","text":"The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction","title":"Squeeze"},{"location":"etch-language/tensor/#serialisation","text":"A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Serialisation"},{"location":"etch-language/training-pairs/","text":"TrainingPair is a custom etch class used to load data into a DataLoader . A TrainingPair contains pairs of training data and the corresponding training label coming from two Tensor types. Declare and initialise a TrainingPair . function main () var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction The code below builds two Tensor types, then creates a TrainingPair type with them. function main () var shape = Array < UInt64 > ( 2 ); shape [ 0 ] = 28u64 ; shape [ 1 ] = 28u64 ; var tensor1 = Tensor ( shape ); shape [ 0 ] = 1u64 ; shape [ 1 ] = 10u64 ; var tensor2 = Tensor ( shape ); var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction","title":"Training pairs"},{"location":"etch-language/transaction/","text":"The Transaction type provides access to data pertaining to a currently invoking transaction on a running smart contract. To access the Transaction type you need a Context . getContext() Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions. digest() The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest (); from() The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from (); transfers() transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers (); getTotalTransferAmount() The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount (); validFrom() The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom (); validUntil() The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil (); chargeRate() The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate (); chargeLimit() The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit (); contractDigest() The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest (); contractAddress() The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress (); action() The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action (); signatories() The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories (); Example Note Coming soon.","title":"Transaction"},{"location":"etch-language/transaction/#getcontext","text":"Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions.","title":"getContext()"},{"location":"etch-language/transaction/#digest","text":"The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest ();","title":"digest()"},{"location":"etch-language/transaction/#from","text":"The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from ();","title":"from()"},{"location":"etch-language/transaction/#transfers","text":"transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers ();","title":"transfers()"},{"location":"etch-language/transaction/#gettotaltransferamount","text":"The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount ();","title":"getTotalTransferAmount()"},{"location":"etch-language/transaction/#validfrom","text":"The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom ();","title":"validFrom()"},{"location":"etch-language/transaction/#validuntil","text":"The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil ();","title":"validUntil()"},{"location":"etch-language/transaction/#chargerate","text":"The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate ();","title":"chargeRate()"},{"location":"etch-language/transaction/#chargelimit","text":"The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit ();","title":"chargeLimit()"},{"location":"etch-language/transaction/#contractdigest","text":"The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest ();","title":"contractDigest()"},{"location":"etch-language/transaction/#contractaddress","text":"The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress ();","title":"contractAddress()"},{"location":"etch-language/transaction/#action","text":"The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action ();","title":"action()"},{"location":"etch-language/transaction/#signatories","text":"The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories ();","title":"signatories()"},{"location":"etch-language/transaction/#example","text":"Note Coming soon.","title":"Example"},{"location":"etch-language/variables/","text":"Variables etch is a statically-typed programming language. The behaviour of value and reference types (primitives and non-primitives in Java) is the same as in other high level languages such as C++, Java, .Net, and Python. Declare a variable with the keyword var . Declare numeric values with literals where possible. Naming Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction 32 byte unsigned integer Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity. Floating point decimals Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Float types are declared as Float32 , Float64 . Unspecified floats default to Float64 . A Float declared with f is a Float32 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = - 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); var float32bit_minus : Float32 = - 32.0f ; printLn ( toString ( float32bit_minus )); endfunction Fixed point decimals Fixed point variables are available as Fixed32 and Fixed64 types. You must declare Fixed Point variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments . Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type. Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations. StructuredData StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction State A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here . Address The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here . Type casting There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // float casting var float64bit = 42.0 ; // cast Float64 to Int32 var intFVariable = toInt32 ( float64bit ); // cast Float64 to Float32 var float32Variable = toFloat32 ( float64bit ); // cast Int32 to Float64 var float64variable = toFloat64 ( int32bit ); // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Fixed32 4 bytes Fixed64 8 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes Scope etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here. Null Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Float32 0 Float64 0 Fixed32 0.0000 Fixed64 0.00000000 Bool false String no default","title":"Variables"},{"location":"etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction","title":"Naming"},{"location":"etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"etch-language/variables/#32-byte-unsigned-integer","text":"Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity.","title":"32 byte unsigned integer"},{"location":"etch-language/variables/#floating-point-decimals","text":"Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Float types are declared as Float32 , Float64 . Unspecified floats default to Float64 . A Float declared with f is a Float32 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = - 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); var float32bit_minus : Float32 = - 32.0f ; printLn ( toString ( float32bit_minus )); endfunction","title":"Floating point decimals"},{"location":"etch-language/variables/#fixed-point-decimals","text":"Fixed point variables are available as Fixed32 and Fixed64 types. You must declare Fixed Point variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments .","title":"Fixed point decimals"},{"location":"etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"etch-language/variables/#buffer","text":"Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type.","title":"Buffer"},{"location":"etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations.","title":"Maps"},{"location":"etch-language/variables/#structureddata","text":"StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction","title":"StructuredData"},{"location":"etch-language/variables/#state","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"State"},{"location":"etch-language/variables/#shardedstate","text":"Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here .","title":"ShardedState"},{"location":"etch-language/variables/#address","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here .","title":"Address"},{"location":"etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here .","title":"Mathematical, ML, and AI"},{"location":"etch-language/variables/#type-casting","text":"There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // float casting var float64bit = 42.0 ; // cast Float64 to Int32 var intFVariable = toInt32 ( float64bit ); // cast Float64 to Float32 var float32Variable = toFloat32 ( float64bit ); // cast Int32 to Float64 var float64variable = toFloat64 ( int32bit ); // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Fixed32 4 bytes Fixed64 8 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes","title":"Data size"},{"location":"etch-language/variables/#scope","text":"etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here.","title":"Scope"},{"location":"etch-language/variables/#null","text":"Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Float32 0 Float64 0 Fixed32 0.0000 Fixed64 0.00000000 Bool false String no default","title":"Default values"},{"location":"etch-language/examples/dft/","text":"function main () var inreal = Array < Fixed64 > ( 1000 ); var inimag = Array < Fixed64 > ( 1000 ); var outreal = Array < Fixed64 > ( 1000 ); var outimag = Array < Fixed64 > ( 1000 ); for ( i in 0 : inreal . count ()) inreal [ i ] = toFixed64 ( rand ( 0 , 1000 )); inimag [ i ] = toFixed64 ( rand ( 0 , 1000 )); endfor dft ( inreal , inimag , outreal , outimag ); //printLn(inreal); //printLn(inimag); //printLn(outreal); //printLn(outimag); endfunction function dft ( inreal : Array < Fixed64 > , inimag : Array < Fixed64 > , outreal : Array < Fixed64 > , outimag : Array < Fixed64 > ) var n = inreal . count (); var angle = 0.0f p64 ; for ( k in 0 : n ) var sumreal = 0.0f p64 ; var sumimag = 0.0f p64 ; for ( t in 0 : n ) angle = 2.0f p64 * 3.142f p64 * toFixed64 ( t ) * toFixed64 ( k ) / toFixed64 ( n ); sumreal += inreal [ t ] * cos ( angle ) + inimag [ t ] * sin ( angle ); sumimag += - inreal [ t ] * sin ( angle ) + inimag [ t ] * cos ( angle ); endfor outreal [ k ] = sumreal ; outimag [ k ] = sumimag ; endfor endfunction","title":"Discrete Fourier Transformation"},{"location":"etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Float64 = 32.0 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Float64 = toFloat64 ( pixelX ); xLocal = (( xLocal / toFloat64 ( xMax )) * 3.5 ) - 2.5 ; // // Now Y to -1 to 1: var yLocal : Float64 = toFloat64 ( pixelY ); yLocal = yLocal / toFloat64 ( yMax ); // // Now let's do the algorithm bit: var x : Float64 = 0.0 ; var y : Float64 = 0.0 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Float64 = ( toFloat64 ( iteration ) / toFloat64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Sorting algorithms"},{"location":"etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"etch-language/examples/sorting-algorithms/#quick-sort","text":"function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Quick sort"},{"location":"getting-started/installation-mac/","text":"Installing and building the ledger on Mac Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"MacOS"},{"location":"getting-started/installation-mac/#installing-and-building-the-ledger-on-mac","text":"","title":"Installing and building the ledger on Mac"},{"location":"getting-started/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"getting-started/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"getting-started/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"getting-started/installation-redhat/","text":"Installing and building the ledger on Linux Redhat Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Redhat"},{"location":"getting-started/installation-redhat/#installing-and-building-the-ledger-on-linux-redhat","text":"","title":"Installing and building the ledger on Linux Redhat"},{"location":"getting-started/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"getting-started/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/installation-ubuntu/","text":"Installing and building the ledger on Linux Ubuntu Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Ubuntu"},{"location":"getting-started/installation-ubuntu/#installing-and-building-the-ledger-on-linux-ubuntu","text":"","title":"Installing and building the ledger on Linux Ubuntu"},{"location":"getting-started/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"getting-started/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Oef install"},{"location":"getting-started/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"getting-started/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"getting-started/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"getting-started/python-api-install/","text":"Build the Python libraries like this: pip3 install -U fetchai-ledger-api Or, download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.9.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Installation"},{"location":"getting-started/quickstart/","text":"Quickstart! Fetch.ai is a decentralised platform where autonomous agents can collaborate, using machine learning supported at all levels, from the consensus design to the smart contracts language Etch . This quickstart quide aims to get you moving as quickly as possible, and it will point you at sections where you can learn more. Let's get started! Running a node locally This is a great way to test locally smart contracts developed in the Fetch.ai native language (called Etch , and to debug a node's behaviour. You can connect to the testnet or just run as a single node. You'll first need to clone the Fetch.ai ledger repo : cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Now let's build the project: ./scripts/quickstart.sh And we can now run the ledger locally: ./build/apps/constellation/constellation -standalone -block-interval 20000 This runs a node with a block interval of 2 seconds. Since it is a standalone node, it is not connected to any network. For more detailed instructions on how to run a node, please check the following: Running a standalone node or connected to a network constellation flags Connecting to the node If you want to create apps that connect directly to the ledger, or to deploy smart contracts, you can use the Python and Javascript Ledger APIs. In this quickstart guide we will focus on the Python API. We recommend you install the latest stable version using pip: pip install fetchai-ledger-api You can also obtain the latest version of the code from the GitHub repository . Once the API is installed, you need to establish a connection via a new LedgerApi object, after which you can generate test tokens for an agent: from fetchai.ledger.crypto import Address , Entity from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) agent1 = Entity () api . sync ( api . tokens . wealth ( agent1 , 200000000 )) You can get the public and private keys of the agent with the following: str ( Address ( agent1 )) agent1 . private_key Deploying a smart contract In order to deploy the simplest contract, we will elaborate on the previous snippet based on the Python Ledger API: from fetchai.ledger.crypto import Address , Entity from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract CONTRACT_TEXT = \"\"\" @query function sayHello() : String return \"Hello\" endfunction \"\"\" api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) agent1 = Entity () api . sync ( api . tokens . wealth ( agent1 , 200000000 )) # Create the smart contract contract = Contract ( CONTRACT_TEXT , agent1 ) fee = 4000 api . sync ( contract . create ( api , agent1 , fee )) # Query the contract contract . query ( api , 'sayHello' ) You can check the following for more interesting smart contract examples: Full smart contract example Synergetic contracts , one of our experimental features Non-fungible generation contract example We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts. Using the machine learning library Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone applicatoin. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here . Loading input data An Etch program needs a main() function as its entry point, and that is where all code in this example will reside. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Setting up the model We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Training and evaluating the model Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate (); Making predictions on the model Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Running the script The script can be run from the root of the ledger folder, passing the input files as arguments with the following: . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file Agents Coming soon. Next steps Coming soon.","title":"Quickstart"},{"location":"getting-started/quickstart/#quickstart","text":"Fetch.ai is a decentralised platform where autonomous agents can collaborate, using machine learning supported at all levels, from the consensus design to the smart contracts language Etch . This quickstart quide aims to get you moving as quickly as possible, and it will point you at sections where you can learn more. Let's get started!","title":"Quickstart!"},{"location":"getting-started/quickstart/#running-a-node-locally","text":"This is a great way to test locally smart contracts developed in the Fetch.ai native language (called Etch , and to debug a node's behaviour. You can connect to the testnet or just run as a single node. You'll first need to clone the Fetch.ai ledger repo : cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Now let's build the project: ./scripts/quickstart.sh And we can now run the ledger locally: ./build/apps/constellation/constellation -standalone -block-interval 20000 This runs a node with a block interval of 2 seconds. Since it is a standalone node, it is not connected to any network. For more detailed instructions on how to run a node, please check the following: Running a standalone node or connected to a network constellation flags","title":"Running a node locally"},{"location":"getting-started/quickstart/#connecting-to-the-node","text":"If you want to create apps that connect directly to the ledger, or to deploy smart contracts, you can use the Python and Javascript Ledger APIs. In this quickstart guide we will focus on the Python API. We recommend you install the latest stable version using pip: pip install fetchai-ledger-api You can also obtain the latest version of the code from the GitHub repository . Once the API is installed, you need to establish a connection via a new LedgerApi object, after which you can generate test tokens for an agent: from fetchai.ledger.crypto import Address , Entity from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) agent1 = Entity () api . sync ( api . tokens . wealth ( agent1 , 200000000 )) You can get the public and private keys of the agent with the following: str ( Address ( agent1 )) agent1 . private_key","title":"Connecting to the node"},{"location":"getting-started/quickstart/#deploying-a-smart-contract","text":"In order to deploy the simplest contract, we will elaborate on the previous snippet based on the Python Ledger API: from fetchai.ledger.crypto import Address , Entity from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract CONTRACT_TEXT = \"\"\" @query function sayHello() : String return \"Hello\" endfunction \"\"\" api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) agent1 = Entity () api . sync ( api . tokens . wealth ( agent1 , 200000000 )) # Create the smart contract contract = Contract ( CONTRACT_TEXT , agent1 ) fee = 4000 api . sync ( contract . create ( api , agent1 , fee )) # Query the contract contract . query ( api , 'sayHello' ) You can check the following for more interesting smart contract examples: Full smart contract example Synergetic contracts , one of our experimental features Non-fungible generation contract example We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Deploying a smart contract"},{"location":"getting-started/quickstart/#using-the-machine-learning-library","text":"Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone applicatoin. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here .","title":"Using the machine learning library"},{"location":"getting-started/quickstart/#loading-input-data","text":"An Etch program needs a main() function as its entry point, and that is where all code in this example will reside. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Loading input data"},{"location":"getting-started/quickstart/#setting-up-the-model","text":"We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Setting up the model"},{"location":"getting-started/quickstart/#training-and-evaluating-the-model","text":"Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate ();","title":"Training and evaluating the model"},{"location":"getting-started/quickstart/#making-predictions-on-the-model","text":"Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Making predictions on the model"},{"location":"getting-started/quickstart/#running-the-script","text":"The script can be run from the root of the ledger folder, passing the input files as arguments with the following: . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"Running the script"},{"location":"getting-started/quickstart/#agents","text":"Coming soon.","title":"Agents"},{"location":"getting-started/quickstart/#next-steps","text":"Coming soon.","title":"Next steps"},{"location":"getting-started/run-a-node/","text":"Local node From the build folder, navigate to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Connect to a node on testnet From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network alpha More info Navigate through to OEF , etch language , smart contracts , and tutorials links where you will find instructions and tutorials.","title":"Run a node"},{"location":"getting-started/run-a-node/#local-node","text":"From the build folder, navigate to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents.","title":"Local node"},{"location":"getting-started/run-a-node/#connect-to-a-node-on-testnet","text":"From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network alpha","title":"Connect to a node on testnet"},{"location":"getting-started/run-a-node/#more-info","text":"Navigate through to OEF , etch language , smart contracts , and tutorials links where you will find instructions and tutorials.","title":"More info"},{"location":"getting-started/versions/","text":"Versions While we continue to work on developing separate applications for the Fetch.ai Ledger, Python Ledger API, and the Fetch.ai Open Economic Framework, it's important to make sure all running versions match up. For example: fetchai / ledger release / v0 .9 . x fetchai / ledger - api - py release / v0 .9 . x fetchai / oef - search - pluto master Against these, follow the documentation in line with the same versions. The documentation you are reading now is version: fetchai / docs release / v0 .9 . x","title":"Versions"},{"location":"ledger/","text":"Fetch.ai ledger The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below. Increased rate of transactions per second The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here . Custom consensus algorithm The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper . Support for on-chain ML and AI operations Coming soon.","title":"Introduction"},{"location":"ledger/#fetchai-ledger","text":"The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below.","title":"Fetch.ai ledger"},{"location":"ledger/#increased-rate-of-transactions-per-second","text":"The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here .","title":"Increased rate of transactions per second"},{"location":"ledger/#custom-consensus-algorithm","text":"The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper .","title":"Custom consensus algorithm"},{"location":"ledger/#support-for-on-chain-ml-and-ai-operations","text":"Coming soon.","title":"Support for on-chain ML and AI operations"},{"location":"ledger/architecture/","text":"Architecture This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct. Sharding In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load. HTTP pages and API Note Coming soon Networking Note Coming soon","title":"Architecture"},{"location":"ledger/architecture/#architecture","text":"This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct.","title":"Architecture"},{"location":"ledger/architecture/#sharding","text":"In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load.","title":"Sharding"},{"location":"ledger/architecture/#http-pages-and-api","text":"Note Coming soon","title":"HTTP pages and API"},{"location":"ledger/architecture/#networking","text":"Note Coming soon","title":"Networking"},{"location":"ledger/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/fetch-token/","text":"In order to implement a static contract, create a new class that inherits from the Contract class and expose the relevant functions. In the following example, we will describe an implementation of the the Fetch token. First, we define the body of the contract as below: class TokenContract : public Contract { public : TokenContract (); ~ TokenContract () = default ; static constexpr char const * LOGGING_NAME = \"TokenContract\" ; private : // transaction handlers Status CreateWealth ( Transaction const & tx ); Status Transfer ( Transaction const & tx ); // queries Status Balance ( Query const & query , Query & response ); };","title":"Fetch token"},{"location":"ledger/maths-lib-overview/","text":"etch mathematics and machine learning operations are supported by a header-only fully-templated C++ library. Detailed developer documentation for the C++ implementation of the maths libraries will be available in the Fetch Ledger section in due course. Developers should be comfortable with SFINAE. Architecture A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress. Tensor A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here . Working with the maths library When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Maths library introduction"},{"location":"ledger/maths-lib-overview/#architecture","text":"A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress.","title":"Architecture"},{"location":"ledger/maths-lib-overview/#tensor","text":"A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here .","title":"Tensor"},{"location":"ledger/maths-lib-overview/#working-with-the-maths-library","text":"When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Working with the maths library"},{"location":"ledger/running-a-constellation/","text":"Local node From the build folder, navigate to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Connect to a node on testnet From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network alpha Compiler flags The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Running a node"},{"location":"ledger/running-a-constellation/#local-node","text":"From the build folder, navigate to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents.","title":"Local node"},{"location":"ledger/running-a-constellation/#connect-to-a-node-on-testnet","text":"From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network alpha","title":"Connect to a node on testnet"},{"location":"ledger/running-a-constellation/#compiler-flags","text":"The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Compiler flags"},{"location":"ledger/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/python-ledger-api/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block Number"},{"location":"machine-learning/","text":"Machine Learning Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Introduction"},{"location":"machine-learning/#machine-learning","text":"Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Machine Learning"},{"location":"machine-learning/basic-etch-example/","text":"AI in Etch The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset. Boston Housing Price Prediction function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look. Setup the etch vm If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here . Input file check First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif Load the input data Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); Set up the model First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Train the model Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluate the model Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate (); Make predictions on the model Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Run the script Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"AI in Etch"},{"location":"machine-learning/basic-etch-example/#ai-in-etch","text":"The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset.","title":"AI in Etch"},{"location":"machine-learning/basic-etch-example/#boston-housing-price-prediction","text":"function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look.","title":"Boston Housing Price Prediction"},{"location":"machine-learning/basic-etch-example/#setup-the-etch-vm","text":"If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here .","title":"Setup the etch vm"},{"location":"machine-learning/basic-etch-example/#input-file-check","text":"First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif","title":"Input file check"},{"location":"machine-learning/basic-etch-example/#load-the-input-data","text":"Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 ));","title":"Load the input data"},{"location":"machine-learning/basic-etch-example/#set-up-the-model","text":"First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Set up the model"},{"location":"machine-learning/basic-etch-example/#train-the-model","text":"Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size );","title":"Train the model"},{"location":"machine-learning/basic-etch-example/#evaluate-the-model","text":"Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate ();","title":"Evaluate the model"},{"location":"machine-learning/basic-etch-example/#make-predictions-on-the-model","text":"Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Make predictions on the model"},{"location":"machine-learning/basic-etch-example/#run-the-script","text":"Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"Run the script"},{"location":"machine-learning/library-architecture/","text":"Machine Learning library architecture The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress. Graph Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal. Ops To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data. Layers Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function. DataLoaders DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders . Integer mathematics The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures. Notes for working with the C++ machine learning library Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Library architecture"},{"location":"machine-learning/library-architecture/#machine-learning-library-architecture","text":"The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress.","title":"Machine Learning library architecture"},{"location":"machine-learning/library-architecture/#graph","text":"Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal.","title":"Graph"},{"location":"machine-learning/library-architecture/#ops","text":"To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data.","title":"Ops"},{"location":"machine-learning/library-architecture/#layers","text":"Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function.","title":"Layers"},{"location":"machine-learning/library-architecture/#dataloaders","text":"DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders .","title":"DataLoaders"},{"location":"machine-learning/library-architecture/#integer-mathematics","text":"The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures.","title":"Integer mathematics"},{"location":"machine-learning/library-architecture/#notes-for-working-with-the-c-machine-learning-library","text":"Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Notes for working with the C++ machine learning library"},{"location":"machine-learning/smart-contract-example/","text":"AI in Smart Contracts The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators Persistent storage The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here . Separately callable functions In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently. Function decorators Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added. Advanced customisation With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"AI in smart contracts"},{"location":"machine-learning/smart-contract-example/#ai-in-smart-contracts","text":"The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators","title":"AI in Smart Contracts"},{"location":"machine-learning/smart-contract-example/#persistent-storage","text":"The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here .","title":"Persistent storage"},{"location":"machine-learning/smart-contract-example/#separately-callable-functions","text":"In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently.","title":"Separately callable functions"},{"location":"machine-learning/smart-contract-example/#function-decorators","text":"Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added.","title":"Function decorators"},{"location":"machine-learning/smart-contract-example/#advanced-customisation","text":"With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"Advanced customisation"},{"location":"machine-learning/synergetic-contract-example/","text":"AI in Synergetic Contracts The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use. Simple Synergetic Contract Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFloat64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"AI in synergetic contracts"},{"location":"machine-learning/synergetic-contract-example/#ai-in-synergetic-contracts","text":"The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use.","title":"AI in Synergetic Contracts"},{"location":"machine-learning/synergetic-contract-example/#simple-synergetic-contract","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFloat64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"Simple Synergetic Contract"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.ai decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.ai blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"Home"},{"location":"oef/advertising/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/java-kotlin-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.7x API.","title":"java kotlin API"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). You can generate test addresses with the the ledger-api-py (Python SDK) . Check the documentation here . Or... Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) -> str : \"\"\" Returns a 219 character public key in base58 format \"\"\" return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.6x API. Version 0.7x coming soon.","title":"python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register onto the OEF. AsyncioCore thread management The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop () Agent creation Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects. Agent state Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated . Single Agent reacting to arriving messages Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Single Agent doing intermittent work If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Multiple Agent scenarios Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop () Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#asynciocore-thread-management","text":"The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop ()","title":"AsyncioCore thread management"},{"location":"oef/registering/#agent-creation","text":"Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects.","title":"Agent creation"},{"location":"oef/registering/#agent-state","text":"Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated .","title":"Agent state"},{"location":"oef/registering/#single-agent-reacting-to-arriving-messages","text":"Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent reacting to arriving messages"},{"location":"oef/registering/#single-agent-doing-intermittent-work","text":"If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent doing intermittent work"},{"location":"oef/registering/#multiple-agent-scenarios","text":"Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop ()","title":"Multiple Agent scenarios"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Sdk"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 sub-expressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of sub-expressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"smart-contracts/etch-smart-contracts/","text":"Etch smart contracts Smart contract code runs on the etch virtual machine. All ledger nodes contain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract addresses etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name. Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Smart contracts in Etch"},{"location":"smart-contracts/etch-smart-contracts/#smart-contract-addresses","text":"etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name.","title":"Smart contract addresses"},{"location":"smart-contracts/etch-smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Public keys Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course. Test network You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"smart-contracts/executing-smart-contract-code/#public-keys","text":"Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course.","title":"Public keys"},{"location":"smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code Warning Synergetic contracts are currently an experimental feature. To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = \"\"\" @problem function createProblem(data : Array<StructuredData>) : Int32 var value = 0; for (i in 0:data.count()) value += data[i].getInt32(\"value\"); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : UInt256) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State<Int32>(\"solution\"); result.set(solution); endfunction \"\"\" def main (): # create the API api = LedgerApi ( '127.0.0.1' , 8100 ) # create an entity and provide it some wealth print ( 'Setup...' ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( 'Setup...complete' ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == '__main__' : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic contracts"},{"location":"smart-contracts/fees/","text":"Fetch.ai charges developers for computation and storage of data on the Fetch.ai Ledger in a manner which incentivises good coding practices. With the best use of Fetch.ai Ledger types such as State and ShardedState , you can limit the fees by distributing data storage over a minimum number of shards. Fees rise in a linear manner per number of shards up to the maximum number of shards. Note The following information details the current implementation which is likely to change. Calculating charge units Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here . Calculating total transaction fee To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Fees"},{"location":"smart-contracts/fees/#calculating-charge-units","text":"Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here .","title":"Calculating charge units"},{"location":"smart-contracts/fees/#calculating-total-transaction-fee","text":"To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Calculating total transaction fee"},{"location":"smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Development environment"},{"location":"smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"smart-contracts/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"smart-contracts/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"smart-contracts/public-keys/","text":"","title":"Public keys"},{"location":"smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.ai smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the distributed Fetch.ai Ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using persistent global representations of State and ShardedState data structures, and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here . Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Introduction"},{"location":"smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here .","title":"The Ledger"},{"location":"smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"smart-contracts/static-dynamic/","text":"Static contracts A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly. Dynamic contracts A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Static and dynamic contracts"},{"location":"smart-contracts/static-dynamic/#static-contracts","text":"A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly.","title":"Static contracts"},{"location":"smart-contracts/static-dynamic/#dynamic-contracts","text":"A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Dynamic contracts"},{"location":"smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic contracts"},{"location":"smart-contracts/synergetic/#introduction-to-synergetic-contracts","text":"Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Introduction to synergetic contracts"},{"location":"smart-contracts/wallets/","text":"Fetch.ai wallet The Fetch.ai wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network. Fetch testnet To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens. Fetch public network Note In development.","title":"Wallets"},{"location":"smart-contracts/wallets/#fetchai-wallet","text":"The Fetch.ai wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network.","title":"Fetch.ai wallet"},{"location":"smart-contracts/wallets/#fetch-testnet","text":"To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens.","title":"Fetch testnet"},{"location":"smart-contracts/wallets/#fetch-public-network","text":"Note In development.","title":"Fetch public network"},{"location":"tutorials/","text":"Tutorials Smart Contracts and Etch Hello world smart contract Deploying an Etch contract with Python Create FIP-1 token generation contract (basic contract, non-fungible)","title":"Introduction"},{"location":"tutorials/fet1/","text":"Create a FIP-1 contract The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here . Requirements The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . We now go ahead and implement most of these functions. Note As Fetch.ai smart contracts do not have implicit addresses, as in Ethereum, the function signatures are slightly different, as will see below, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: @ init function init ( owner : Address ) use supply_state ; use balance_state [ owner ]; supply_state . set ( 92817u64 ); balance_state . set ( owner , 92817u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing. Queries The FIP-1 contract has three query functions: totalSupply(): UInt256 . balanceOf(owner: Address) : UInt256 . transfer(from: Address, to: Address, value: UInt256) : Bool . We will define totalSupply and balanceOf in this section and discuss transfer later on. Both totalSupply and balanceOf are straightforward to implement. totalSupply queries the State variable total_supply and returns it as a result: @ query function totalSupply () : UInt64 use supply_state ; return supply_state . get (); endfunction balanceOf , on the other hand uses the sharded state of balance_state and does a dynamic look up based on the address of address : @ query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ]; return balance_state . get ( address , 0u64 ); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existence. Actions The FIP-1 contract defines one function annotated with @action : transfer(from: Address, to: Address, value: UInt256) : Bool . In transfer , from and to are explicit function arguments and whether these addresses signed the transaction is checked within the @action function. @ action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif use balance_state [ from , to ]; var from_balance = balance_state . get ( from , 0u64 ); var to_balance = balance_state . get ( to , 0u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction The above demonstrates one of the simplest possible token contracts keeping a balance associated with each address and allowing transfers from one address to the other if the address holds sufficient tokens. Implementing allowance So far, the functions we've seen constitute a basic token contract that allows creation of tokens and transfer between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @ action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @ query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0u64 )); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract within here .","title":"Create FET-1 contract"},{"location":"tutorials/fet1/#create-a-fip-1-contract","text":"The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here .","title":"Create a FIP-1 contract"},{"location":"tutorials/fet1/#requirements","text":"The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . We now go ahead and implement most of these functions. Note As Fetch.ai smart contracts do not have implicit addresses, as in Ethereum, the function signatures are slightly different, as will see below, but the overall functionality remains the same.","title":"Requirements"},{"location":"tutorials/fet1/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: @ init function init ( owner : Address ) use supply_state ; use balance_state [ owner ]; supply_state . set ( 92817u64 ); balance_state . set ( owner , 92817u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing.","title":"Initialisation function"},{"location":"tutorials/fet1/#queries","text":"The FIP-1 contract has three query functions: totalSupply(): UInt256 . balanceOf(owner: Address) : UInt256 . transfer(from: Address, to: Address, value: UInt256) : Bool . We will define totalSupply and balanceOf in this section and discuss transfer later on. Both totalSupply and balanceOf are straightforward to implement. totalSupply queries the State variable total_supply and returns it as a result: @ query function totalSupply () : UInt64 use supply_state ; return supply_state . get (); endfunction balanceOf , on the other hand uses the sharded state of balance_state and does a dynamic look up based on the address of address : @ query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ]; return balance_state . get ( address , 0u64 ); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existence.","title":"Queries"},{"location":"tutorials/fet1/#actions","text":"The FIP-1 contract defines one function annotated with @action : transfer(from: Address, to: Address, value: UInt256) : Bool . In transfer , from and to are explicit function arguments and whether these addresses signed the transaction is checked within the @action function. @ action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif use balance_state [ from , to ]; var from_balance = balance_state . get ( from , 0u64 ); var to_balance = balance_state . get ( to , 0u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction The above demonstrates one of the simplest possible token contracts keeping a balance associated with each address and allowing transfers from one address to the other if the address holds sufficient tokens.","title":"Actions"},{"location":"tutorials/fet1/#implementing-allowance","text":"So far, the functions we've seen constitute a basic token contract that allows creation of tokens and transfer between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @ action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @ query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0u64 )); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract within here .","title":"Implementing allowance"},{"location":"tutorials/fet2/","text":"Create an FET-2 contract In this tutorial we are going to implement a subset of the functionality of an FET-2 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens ); Queries In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an FET-2 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array. Actions The standard FET-2 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count ()) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Create an FET-2 contract"},{"location":"tutorials/fet2/#create-an-fet-2-contract","text":"In this tutorial we are going to implement a subset of the functionality of an FET-2 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState .","title":"Create an FET-2 contract"},{"location":"tutorials/fet2/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens );","title":"Initialisation function"},{"location":"tutorials/fet2/#queries","text":"In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an FET-2 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array.","title":"Queries"},{"location":"tutorials/fet2/#actions","text":"The standard FET-2 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count ()) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Actions"},{"location":"tutorials/python-deployment/","text":"Deploying an Etch Contract with the Python Ledger API The following tutorial assumes that you already have a constellation instance running on port 8000 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here . Requirements We're going to keep this simple, and refer to FIP-1, our basic token generation contract. The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . Deploying the contract: We're going to create a new script, let's call it deploy.py Import Let's get the initial things out of the way, let's import: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address from contextlib import contextmanager Connect to network Then, connect to a local running node: api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) Setup accounts Now, we'll read in our etch contract, and create a couple of entities to test with: with open ( 'contract.txt' , 'r' ) as ct : contract_text = ct . read () print ( contract_text ) # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) Create balance To test, we need a balance: api . sync ( api . tokens . wealth ( entity1 , 10000 )) (Note this will functionality will be removed and a faucet will take it's place). Create the smart contract object We create the contract object, and deploy it: contract = Contract ( contract_text , entity1 ) api . sync ( contract . create ( api , entity1 , 4000 )) Query the contract The named argument has to be the exact name of the variable we're accessing in balanceOf for example, if the state had a named var of \"userX\" the below code would be: print (contract.query(api, 'balanceOf', userX=address1)) this is an important note for other functions you might create. print ( contract . query ( api , 'totalSupply' )) print ( contract . query ( api , 'balanceOf' , address = address1 )) Make a transaction Using the two entities we created earlier, and their addressed we transact 200 from entity1 to entity2, then check the balance: # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 160 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) #Query new balance: print ( contract . query ( api , 'balanceOf' , address = address1 )) You can find the source here .","title":"Deploying an Etch contract with Python"},{"location":"tutorials/python-deployment/#deploying-an-etch-contract-with-the-python-ledger-api","text":"The following tutorial assumes that you already have a constellation instance running on port 8000 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here .","title":"Deploying an Etch Contract with the Python Ledger API"},{"location":"tutorials/python-deployment/#requirements","text":"We're going to keep this simple, and refer to FIP-1, our basic token generation contract. The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to .","title":"Requirements"},{"location":"tutorials/python-deployment/#deploying-the-contract","text":"We're going to create a new script, let's call it deploy.py","title":"Deploying the contract:"},{"location":"tutorials/python-deployment/#import","text":"Let's get the initial things out of the way, let's import: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address from contextlib import contextmanager","title":"Import"},{"location":"tutorials/python-deployment/#connect-to-network","text":"Then, connect to a local running node: api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 )","title":"Connect to network"},{"location":"tutorials/python-deployment/#setup-accounts","text":"Now, we'll read in our etch contract, and create a couple of entities to test with: with open ( 'contract.txt' , 'r' ) as ct : contract_text = ct . read () print ( contract_text ) # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 )","title":"Setup accounts"},{"location":"tutorials/python-deployment/#create-balance","text":"To test, we need a balance: api . sync ( api . tokens . wealth ( entity1 , 10000 )) (Note this will functionality will be removed and a faucet will take it's place).","title":"Create balance"},{"location":"tutorials/python-deployment/#create-the-smart-contract-object","text":"We create the contract object, and deploy it: contract = Contract ( contract_text , entity1 ) api . sync ( contract . create ( api , entity1 , 4000 ))","title":"Create the smart contract object"},{"location":"tutorials/python-deployment/#query-the-contract","text":"The named argument has to be the exact name of the variable we're accessing in balanceOf for example, if the state had a named var of \"userX\" the below code would be: print (contract.query(api, 'balanceOf', userX=address1)) this is an important note for other functions you might create. print ( contract . query ( api , 'totalSupply' )) print ( contract . query ( api , 'balanceOf' , address = address1 ))","title":"Query the contract"},{"location":"tutorials/python-deployment/#make-a-transaction","text":"Using the two entities we created earlier, and their addressed we transact 200 from entity1 to entity2, then check the balance: # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 160 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) #Query new balance: print ( contract . query ( api , 'balanceOf' , address = address1 )) You can find the source here .","title":"Make a transaction"}]}