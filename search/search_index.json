{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Fetch.AI documentation. Navigate with the menu buttons above, or click through to: Open Economic Framework Learn how to create agents, interface to the digital world, and get things done. Etch Language Guide Smart contracts on Fetch.AI are written with the Etch programming language. This is the complete reference and language guide.","title":"Welcome to the <a href=\"https://fetch.ai/\" target=_blank>Fetch.AI</a> documentation."},{"location":"#welcome-to-the-fetchai-documentation","text":"Navigate with the menu buttons above, or click through to: Open Economic Framework Learn how to create agents, interface to the digital world, and get things done. Etch Language Guide Smart contracts on Fetch.AI are written with the Etch programming language. This is the complete reference and language guide.","title":"Welcome to the Fetch.AI"},{"location":"etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI Constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.AI ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Please note: The etch language and the etch language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"What's etch?"},{"location":"etch-language/ML-AI/","text":"Machine learning and AI Note Coming soon: machine learning and AI libraries for etch smart contracts. The libraries will support: Tensors. Graphs. Graph operations (MatMul, convolution, etc.). Activations (relu, sigmoid, softmax, etc.). Loss Functions (MeanSquareError, CrossEntropy, KLDivergence, etc.). DataLoaders.","title":"Machine learning and AI"},{"location":"etch-language/addresses/","text":"Address The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK). And then in etch , you can instantiate an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Note When you use a State to represent an Address owner along with their balance, make sure you supply a default value of 0 for the balance. If there is no record of the Address on the ledger, the Address will be considered new. Verification The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedtx (); printLn ( toString ( verified )); // False in v0.3.0 ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Addresses"},{"location":"etch-language/addresses/#verification","text":"The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedtx (); printLn ( toString ( verified )); // False in v0.3.0 ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"etch-language/arrays/","text":"Arrays One dimensional arrays Declare and iterate over an array like this: function main () // var mySizelessArray = Array < String > (); // error: unable to find matching constructor for type/function 'Array<String>' // Failed to compile. var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); // ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction Two dimensional arrays function main () var x = Array < Array < Int32 >> ( 1 ); x [ 0 ] = Array < Int32 > ( 1 ); x [ 0 ][ 0 ] = 13 ; // printLn(toString(x[0])); // error: unable to find matching function for 'toString' printLn ( toString ( x [ 0 ][ 0 ])); endfunction Utility functions You can use the following utility functions to manipulate arrays: append() count() popBack() and popFront() reverse() Append The append() function adds one new item to the end of a one dimensional array, or an array to the end of a two dimensional array. Statically type safe. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 3 ); for ( i in 0 : 2 ) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = toInt32 ( i ) * toInt32 ( j ); endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : 3 ) printLn ( my2dArray [ k ]); endfor endfunction Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Popback and popfront The pop_back() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The pop_front function removes and returns the first item or array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); for ( i in 0 : 2 ) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = toInt32 ( i ) * toInt32 ( j ); endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . pop_back (); var frontArray = my2dArray . pop_front (); printLn ( \"Removed back and front arrays: \" ); printLn ( backArray ); printLn ( frontArray ); endfunction Use pop_back(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array. Use pop-front(n) to remove and return the first n items or arrays. n must be a positive, whole number. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; var backItems = myArray . pop_back ( 2 ); var frontItems = myArray . pop_front ( 1 ); printLn ( \"Items removed from end: \" ); printLn ( backItems ); printLn ( \"Items removed from start: \" ); printLn ( frontItems ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 10 ); for ( i in 0 : 9 ) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = toInt32 ( i ) * toInt32 ( j ); endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . pop_back ( 3 ); var frontArray = my2dArray . pop_front ( 5 ); printLn ( \"Removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor printLn ( \"Removed front arrays: \" ); for ( l in 0 : 4 ) printLn ( frontArray [ l ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); for ( i in 0 : 4 ) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = toInt32 ( i ) * toInt32 ( j ); endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : 4 ) printLn ( my2dArray [ k ]); endfor endfunction","title":"Arrays"},{"location":"etch-language/arrays/#one-dimensional-arrays","text":"Declare and iterate over an array like this: function main () // var mySizelessArray = Array < String > (); // error: unable to find matching constructor for type/function 'Array<String>' // Failed to compile. var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); // ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction","title":"One dimensional arrays"},{"location":"etch-language/arrays/#two-dimensional-arrays","text":"function main () var x = Array < Array < Int32 >> ( 1 ); x [ 0 ] = Array < Int32 > ( 1 ); x [ 0 ][ 0 ] = 13 ; // printLn(toString(x[0])); // error: unable to find matching function for 'toString' printLn ( toString ( x [ 0 ][ 0 ])); endfunction","title":"Two dimensional arrays"},{"location":"etch-language/arrays/#utility-functions","text":"You can use the following utility functions to manipulate arrays: append() count() popBack() and popFront() reverse()","title":"Utility functions"},{"location":"etch-language/control-flow/","text":"Control flow Warning Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"they are equal\" ); elseif ( x > y ) printLn ( \"x is more than y\" ); else if ( x > y ) printLn ( \"x is more than y\" ); else printLn ( \"y is more than x\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"var\" , 3 ); var y = State < Int32 > ( \"var\" , 5 ); if ( x . get () > y . get ()) printLn ( \"object x is greater than object y\" ); else printLn ( \"object x is less than or equal to object y\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for Warning for loop range is inclusive. function main () // ascending printLn ( \"Ascending and inclusive for loop\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( \"Descending and inclusive for loop\" ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( \"Ascending stepwise\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( \"Descending stepwise\" ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"they are equal\" ); elseif ( x > y ) printLn ( \"x is more than y\" ); else if ( x > y ) printLn ( \"x is more than y\" ); else printLn ( \"y is more than x\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"var\" , 3 ); var y = State < Int32 > ( \"var\" , 5 ); if ( x . get () > y . get ()) printLn ( \"object x is greater than object y\" ); else printLn ( \"object x is less than or equal to object y\" ); endif endfunction","title":"if-else"},{"location":"etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"etch-language/control-flow/#for","text":"Warning for loop range is inclusive. function main () // ascending printLn ( \"Ascending and inclusive for loop\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( \"Descending and inclusive for loop\" ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( \"Ascending stepwise\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( \"Descending stepwise\" ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction","title":"for"},{"location":"etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the etch compiler will strip out printLn() statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions - awaiting clarification . Member access support issues with dot operator - awaiting clarification . while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give us access to compiler argument count and values. In the following code, first we print the number of compiler arguments, then we list them. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc () - 1 ) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the vm-lang executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./vm-lang sysargs-examples.etch -- hello You should see the following output: F E \u2571 vm - lang v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / vm - lang 1 = hello etch features like this are useful for playing around with and for debugging in a dev environment. They should not be included in smart contract code. For smart contracts, there are more flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"etch-language/error-checking/","text":"Note Coming soon: support for asserts and error checking.","title":"Error checking"},{"location":"etch-language/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find the details of how to do that here . To run a standalone ledger node listening on port 8000, use the following command: ./apps/constellation/constellation -port 8000 -block-interval 3000 -standalone Next, download the Python Ledger API with: pip install -u fetchai-ledger-api In the examples folder, you will see some scripts. Open the contracts.py script: from typing import List from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" def print_address_balances ( api : LedgerApi , contract : SmartContract , addresses : List [ Address ]): for idx , address in enumerate ( addresses ): print ( 'Address{}: {:<6d} bFET {:<10d} TOK' . format ( idx , api . tokens . balance ( address ), contract . query ( api , 'balance' , address = address ))) print () def main (): # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8000 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) if __name__ == '__main__' : main () The etch smart contract is embedded into Python as a string. This particular example creates a pair of Entity accounts. The first account is the contract owner who receives some tokens in order to create the contract and deploy it to the ledger. Once the contract is deployed to the ledger, the second account receives a transfer of tokens. Test network Note Implementation details for running smart contract code against a test network are coming soon. Public network Note In development.","title":"Executing smart contract code"},{"location":"etch-language/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find the details of how to do that here . To run a standalone ledger node listening on port 8000, use the following command: ./apps/constellation/constellation -port 8000 -block-interval 3000 -standalone Next, download the Python Ledger API with: pip install -u fetchai-ledger-api In the examples folder, you will see some scripts. Open the contracts.py script: from typing import List from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" def print_address_balances ( api : LedgerApi , contract : SmartContract , addresses : List [ Address ]): for idx , address in enumerate ( addresses ): print ( 'Address{}: {:<6d} bFET {:<10d} TOK' . format ( idx , api . tokens . balance ( address ), contract . query ( api , 'balance' , address = address ))) print () def main (): # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8000 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) if __name__ == '__main__' : main () The etch smart contract is embedded into Python as a string. This particular example creates a pair of Entity accounts. The first account is the contract owner who receives some tokens in order to create the contract and deploy it to the ledger. Once the contract is deployed to the ledger, the second account receives a transfer of tokens.","title":"Locally"},{"location":"etch-language/executing-smart-contract-code/#test-network","text":"Note Implementation details for running smart contract code against a test network are coming soon.","title":"Test network"},{"location":"etch-language/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending etch in C++.","title":"Extending etch in C++"},{"location":"etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n <= 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with object types such as Array function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 2 ])); change_value ( myArray ); printLn ( toString ( myArray [ 2 ])); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) var newArray = Array < String > ( 2 ); newArray = myArray ; newArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers and floats. There is one restriction: the beginning value of the range must be less than the end value. function main () // var randUInt8 = Rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' // printLn(toString(randUInt8)); // unpermitted range // var rand_test = Rand(100u16, 0u16); // runtime error: Invalid argument: Rand(a, b) must satisfy a < b var randUInt16 = Rand ( 0u16 , 1000u16 ); // printLn(toString(randUInt16)); var randUInt32 = Rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = Rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = Rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = Rand ( 0 i16 , 1000 i16 ); // printLn(toString(randInt16)); var randInt32 = Rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = Rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = Rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = Rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction Print printLn() is available for printing variables to the console. print() is available without a line break. If the variable is a string, you don't have to cast it before printing, otherwise you should cast it with toString() . Note etch strips out all printLn() statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to vm-lang and their value. System.Argc() System.Argv() Note Coming soon: common utility maths functions such as pow() , exp() , abs() , Sine() , Cosine() , etc. Tip etch also provides utility functions specifically for manipulating strings and arrays . Type casting functions toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toByte ( x ); var z = toInt8 ( x ); var a = toInt16 ( x ); var b = toInt32 ( x ); var c = toInt64 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); // var i = toFixed32(x); // error: unknown symbol 'toFixed32' // var j = toFixed64(x); // error: unknown symbol 'toFixed64' endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. Getters and setters Getters and setters are available for State types. set() get()","title":"Functions"},{"location":"etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n <= 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with object types such as Array function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 2 ])); change_value ( myArray ); printLn ( toString ( myArray [ 2 ])); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) var newArray = Array < String > ( 2 ); newArray = myArray ; newArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"etch-language/functions/#type-casting-functions","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toByte ( x ); var z = toInt8 ( x ); var a = toInt16 ( x ); var b = toInt32 ( x ); var c = toInt64 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); // var i = toFixed32(x); // error: unknown symbol 'toFixed32' // var j = toFixed64(x); // error: unknown symbol 'toFixed64' endfunction","title":"Type casting functions"},{"location":"etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger.","title":"Annotations"},{"location":"etch-language/functions/#getters-and-setters","text":"Getters and setters are available for State types. set() get()","title":"Getters and setters"},{"location":"etch-language/getstarted/","text":"Getting started Prerequisites Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here . Installation cd into build folder. Run make -j 4 vm-lang . Setup cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] <filename> -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract. Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line. Hello world! Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Getting started"},{"location":"etch-language/getstarted/#prerequisites","text":"Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here .","title":"Prerequisites"},{"location":"etch-language/getstarted/#installation","text":"cd into build folder. Run make -j 4 vm-lang .","title":"Installation"},{"location":"etch-language/getstarted/#setup","text":"cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] <filename> -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"etch-language/getstarted/#hello-world","text":"Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Hello world!"},{"location":"etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"equal\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"not equal\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"less than\" ); endif if ( y <= x ) printLn ( \"less than or equal to\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"more than\" ); endif if ( x >= y ) printLn ( \"more than or equal to\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction Xor Note Coming soon: support for xor .","title":"Logical operators"},{"location":"etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"equal\" ); endif endfunction","title":"Equal to"},{"location":"etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"not equal\" ); endif endfunction","title":"Not equal to"},{"location":"etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"less than\" ); endif if ( y <= x ) printLn ( \"less than or equal to\" ); endif endfunction","title":"Less than"},{"location":"etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"more than\" ); endif if ( x >= y ) printLn ( \"more than or equal to\" ); endif endfunction","title":"More than"},{"location":"etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction","title":"And"},{"location":"etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction","title":"Or"},{"location":"etch-language/logic/#xor","text":"Note Coming soon: support for xor .","title":"Xor"},{"location":"etch-language/maths-libs/","text":"Maths libraries and functions Note Coming soon: optimised maths libraries for etch smart contracts. The libraries will support: Tensors. Broadcasting matrix operations. Trigonometry. Distance & correlation measures. Standard element-wise operations (e.g. Abs, Clamp, Min, Max, etc.).","title":"Maths libraries and functions"},{"location":"etch-language/memory/","text":"Memory A State type saves data to the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards, more memory will cost more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. For example, aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State map onto a single shard on the ledger. For example, var myState = State<Int32>(\"balance\", 200); may map to a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which data maps onto the ledger in an inefficient way. For example, given a voting function such as the one below, the code may aggregate the State variables tracking every vote in an inefficient manner: function main () vote (); endfunction function vote () // declare and set politics account var politics = \"nightmare business\" ; var votes_for = State < Int32 > ( politics , 0 ); var votes_against = State < Int32 > ( politics , 0 ); var votes_total = State < Int32 > ( politics , 0 ); var votes_sum = State < Int32 > ( politics , 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new section on the shard. The ledger shards could look something like this after this vote() function runs. This is highly uneconomical. Every aggregate value for a single State accumulates upon a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivize code like the above which can slow the network. The current maximum lanes is configurable. There are better approaches to the voting problem. For example, by encapsulating the data with a Map like this: Note Coming soon: support for Map types. function main () var myMap : Map < String , Int32 > ; // myMap.insert(\"for\", 0); // error: type 'Map<String, Int32>' has no member named 'insert' // myMap.insert(\"against\", 0); // error: type 'Map<String, Int32>' has no member named 'insert' // myMap.insert(\"sum\", 0); // error: type 'Map<String, Int32>' has no member named 'insert' // var myMapState = State<Map<String, Int32>>(myMap, null); // error: unable to find matching constructor for type/function 'State<Map<String, Int32>>' endfunction","title":"Memory"},{"location":"etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z =- 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z =- 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"etch-language/persistent-maps/","text":"PersistentMaps Deprecating in favour of ShardedStates A PersistentMap is a data structure like State but is more flexible. PersistentMap can contain multiple data entries and therefore is a more economical use of the ledger. Declare a PersistentMap with PersistentMap<K, V> where K is a unique key and V is the value associated with the key. function main () // create a PersistentMap // var pm : PersistentMap<String, String>(myPm : String); // error at '<', expected '=' or ';' // create a value // var val : String = \"hello\"; // add the value to the PersistentMap at a specific key name // pm[\"0\"] = val; endfunction To add a State to a PersistentMap , do the following: Note Coming soon: support for PersistentMap . function main () // declare a State and set a value on it var myState = State < Int32 >( \"xyz.balance\" , 0 ); myState . set ( 100 ); // declare a PersistentMap with the same name as the State // var myPm = PersistentMap<String, Int32>(\"xyz\"); // error at ',', expected ';' // Failed to compile. // access a variable in the State using a handle to the PeristentMap // printLn(myPm[\"balance\"]); endfunction In a PersistentMap the key must be a String or an Address type. A PersistentMap can wrap around State types. For example, a common requirement for smart contracts is to facilitate transfers. Below, the from and to variables are Address types representing the two parties to a transaction along with their balances. var from_address = State < UInt64 >( from , 0 u64 ); var to_address = State < UInt64 >( to , 0 u64 ); This is better represented by a PersistentMap where from_address and to_address represent keys, the values of which are set prior to building the data structure. function main () // var transactPm : PersistentMap<Address, String>(tx : Int32); // error at '<', expected '=' or ';' // create transaction account details // var from_address = Address(\"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7DF8+Pw==\"); // var to_address = Address(\"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+Pw==\"); // create values representing the balances of the accounts // var from_balance : String = 1000u64; // var to_balance : String = 0u64; // add the value to the PersistentMap at a specific key name // transactPm[from_address] = from_balance; // transactPm[to_address] = to_balance; endfunction A duplicate key overwrites the previously defined entry.","title":"Persistent maps"},{"location":"etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"etch-language/smart-contract-intro/","text":"Introduction A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.AI smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the Fetch distributed ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using State data structures and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code. Fees Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Introduction"},{"location":"etch-language/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently.","title":"The Ledger"},{"location":"etch-language/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"etch-language/smart-contract-intro/#fees","text":"Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Fees"},{"location":"etch-language/smart-contracts/","text":"Smart contracts Smart contract code runs on the etch VM. All ledger nodes maintain etch VM and smart contract code. Unlike the common cryptographic transactions we have just seen, smart contract code computes more complex functions on the etch VM. The identity of a smart contract is calculated by performing a SHA256 hash of the contract code as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address . On the ledger, the etch VM stores the contract name, the contract source code, and the data resources that are mapped by a data.json file. Taking this contract identity data, the etch VM performs a modulo 16 calculation from which it decides how to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Basic Smart contract Smart contract functions are annotated depending on the activity they perform. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything you like. For example, the following function initialises a contract by creating a State type that represents the owner's account which sets an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( owner , 0u64 ); account . set ( INITIAL_SUPPLY ); endfunction @action The @action annotation signifies a function which deals with transaction details. You cannot create a contract in etch without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from , 0u64 ); var to_balance = State < UInt64 > ( to , 0u64 ); // check if all the conditions are valid var valid = from . signed_tx () && ( from_balance . get () >= amount ); if ( valid ) // update the funds from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endif endfunction In the worst case, the above function needs two shards for data. @query Query functions are read-only functions that allow you to view data on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address , 0u64 ); return account . get (); endfunction Data confirmation If you run an etch contract containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing data details. ./vm-lang *filename* -data data.json data.json may contain the following: { \"var\" : \"0a000000\" } Utility functions getBlockNumber() : returns the number of the current block in UInt64 .","title":"Smart contracts"},{"location":"etch-language/smart-contracts/#basic-smart-contract","text":"Smart contract functions are annotated depending on the activity they perform.","title":"Basic Smart contract"},{"location":"etch-language/smart-contracts/#data-confirmation","text":"If you run an etch contract containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing data details. ./vm-lang *filename* -data data.json data.json may contain the following: { \"var\" : \"0a000000\" }","title":"Data confirmation"},{"location":"etch-language/smart-contracts/#utility-functions","text":"getBlockNumber() : returns the number of the current block in UInt64 .","title":"Utility functions"},{"location":"etch-language/states/","text":"States Smart contracts store data on the Fetch.AI distributed ledger using State . A State is declared as a State<ValueType>(name : String, value : ValueType) like this: var myState = State < Int32 > ( \"balance\" , 0 ); In the above State , the key on the left maps to the Int32 value on the right. The key can be a String or an Address . Wherever referenced, the key gives access to the State , regardless of whether or not the variable name pointing to the State has changed. The value set at declaration is the default value. The following snippet prints 0 . function main () var x : Int32 ; var myState = State < Int32 > ( \"balance\" , x ); var y = myState . get (); print ( toString ( y )); endfunction You can only update the default value using a set() function. Getters and setters Getters and setters are available for State types. function main () var myAccount = State < Int32 > ( \"balance\" , 0 ); printLn ( \"My balance = \" + toString ( myAccount . get ())); myAccount . set ( 10 ); printLn ( \"My balance = \" + toString ( myAccount . get ())); endfunction Currently, State getters and setters support primitive types only. State behaviour Currently State behaviour is fairly trivial. The code below gives a number of examples. First, we see that we can happily print the value of a state after declaration // 1. . In // 2. it is possible to change the State value within the same method with set() . In the function change_state() we can assign our State object to a new name and reset the value to 100 which main() prints at // 3. , even though we also create a new State using the same \"balance\" key and reset the value to 42 . The second statement has no effect on the original State object. The query() function (no connection to @query ) also references the original State by using the \"balance\" key and declares the default value as 0 . However, this time we do get access to the original State and the value returned is 100 again. There is an option in //5. to uncomment and test the set() function. function main () var myState = State < Int32 > ( \"contract_owner_balance\" , 0 ); // 1. print empty state print ( \"1: \" ); printLn ( toString ( myState . get ())); // PRINTS 0 // 2. change state inside main myState . set ( 33 ); print ( \"2: \" ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); // 3. print state after change_state call print ( \"3: \" ); printLn ( toString ( myState . get ())); // PRINTS 100 var result = query (); // 4. print state after query call - notice how query function doesn't change state of the original print ( \"4: \" ); printLn ( toString ( result )); // PRINTS 100 // 5. alter comments in query method to see that state value is not alterable even though // accessible from another function // print(\"5: \"); // printLn(toString(result)); // printLn(toString(myState.get())); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 100 ); // this has no effect on the original State var anotherState = State < Int32 > ( \"balance\" , 42 ); endfunction function query () : Int32 // this gives a default value var myState = State < Int32 > ( \"balance\" , 0 ); // 4. this returns 100 return myState . get (); // 5. // If you set a new variable into the state, it will return the new variable // myState.set(55); // return myState.get(); endfunction Non-primitive types A common use for the State type is to represent account owner Address types with their respective balances. To this end, you can declare a State where the first parameter is an Address type. In the code below we first create an Address type. We can then define the transaction sender account wrapped in a State type where the first parameter from is the Address we just created and the second parameter is the account balance in UInt64 : function main () var from = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var from_account = State < UInt64 > ( from , 0u64 ); endfunction","title":"States"},{"location":"etch-language/states/#getters-and-setters","text":"Getters and setters are available for State types. function main () var myAccount = State < Int32 > ( \"balance\" , 0 ); printLn ( \"My balance = \" + toString ( myAccount . get ())); myAccount . set ( 10 ); printLn ( \"My balance = \" + toString ( myAccount . get ())); endfunction Currently, State getters and setters support primitive types only.","title":"Getters and setters"},{"location":"etch-language/states/#state-behaviour","text":"Currently State behaviour is fairly trivial. The code below gives a number of examples. First, we see that we can happily print the value of a state after declaration // 1. . In // 2. it is possible to change the State value within the same method with set() . In the function change_state() we can assign our State object to a new name and reset the value to 100 which main() prints at // 3. , even though we also create a new State using the same \"balance\" key and reset the value to 42 . The second statement has no effect on the original State object. The query() function (no connection to @query ) also references the original State by using the \"balance\" key and declares the default value as 0 . However, this time we do get access to the original State and the value returned is 100 again. There is an option in //5. to uncomment and test the set() function. function main () var myState = State < Int32 > ( \"contract_owner_balance\" , 0 ); // 1. print empty state print ( \"1: \" ); printLn ( toString ( myState . get ())); // PRINTS 0 // 2. change state inside main myState . set ( 33 ); print ( \"2: \" ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); // 3. print state after change_state call print ( \"3: \" ); printLn ( toString ( myState . get ())); // PRINTS 100 var result = query (); // 4. print state after query call - notice how query function doesn't change state of the original print ( \"4: \" ); printLn ( toString ( result )); // PRINTS 100 // 5. alter comments in query method to see that state value is not alterable even though // accessible from another function // print(\"5: \"); // printLn(toString(result)); // printLn(toString(myState.get())); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 100 ); // this has no effect on the original State var anotherState = State < Int32 > ( \"balance\" , 42 ); endfunction function query () : Int32 // this gives a default value var myState = State < Int32 > ( \"balance\" , 0 ); // 4. this returns 100 return myState . get (); // 5. // If you set a new variable into the state, it will return the new variable // myState.set(55); // return myState.get(); endfunction","title":"State behaviour"},{"location":"etch-language/states/#non-primitive-types","text":"A common use for the State type is to represent account owner Address types with their respective balances. To this end, you can declare a State where the first parameter is an Address type. In the code below we first create an Address type. We can then define the transaction sender account wrapped in a State type where the first parameter from is the Address we just created and the second parameter is the account balance in UInt64 : function main () var from = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var from_account = State < UInt64 > ( from , 0u64 ); endfunction","title":"Non-primitive types"},{"location":"etch-language/strings/","text":"Strings etch supports ASCII for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' // myString2[0]; // error: operand does not support index operator endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction Utility functions You can use the following utility functions to manipulate strings: find() length() reverse() substr() trim() Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Substr The substr() function extracts a substring from a string, based on specified starting and ending indexes (but excluding the final character): string.substr(start, end) The first character in the string occurs at index 0. The final character is excluded from the substring. Returns an empty string if start and end are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Strings"},{"location":"etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' // myString2[0]; // error: operand does not support index operator endfunction","title":"Concatenation"},{"location":"etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"etch-language/strings/#utility-functions","text":"You can use the following utility functions to manipulate strings: find() length() reverse() substr() trim()","title":"Utility functions"},{"location":"etch-language/synergetic/","text":"Synergetic contracts Synergetic contracts are a new type of smart contract which allow miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating from a random seed generated from a public key. Registered miners begin to solve the problem at the same time and the miner who solves the problem first wins the bounty associated with the problem. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic"},{"location":"etch-language/syntax/","text":"Syntax The etch language was initially integrated with the Fetch.AI C++ ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on Smart Contracts .","title":"Syntax"},{"location":"etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return","title":"Keywords"},{"location":"etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on Smart Contracts .","title":"Annotations"},{"location":"etch-language/transactions/","text":"Transactions Smart contracts are user-defined transactions. A transaction takes place between two or more parties and the data exchange is recorded on the ledger. etch supports a number of transactions commonly supported by cryptographic ledgers. Currently, these are built-in transaction types executed in Python which have relatively fixed data storage requirements. For example: Transaction Deed Wealth Note Coming soon: support for smart contract transaction types.","title":"Transactions"},{"location":"etch-language/variables/","text":"Variables etch is a statically-typed programming language. For good coding practice, you should explicitly declare all variable types. Declare a variable with the keyword var . Declare numeric values with literals where possible. You can also use an explicit type cast operation. See below for explicit type declaration rules. Any numerical variable not explicitly initialised receives a default value, such as 0 for integers and 0.0 for floats. Warning The toString function does not yet support all variable types. Naming Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits. They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt16 , UInt32 , UInt64 . Int32 is the compiler default so you don't need to explicitly declare this type. Initialise an 8 bit unsigned integer with a Byte type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; // printLn(toString(int8a)); // error: unable to find matching function for 'toString' var int8b : Int8 = - 0 i8 ; // printLn(toString(int8b)); // error: unable to find matching function for 'toString' var int16a = 0 i16 ; // printLn(toString(int16a)); // error: unable to find matching function for 'toString' var int16b : Int16 = - 1 i16 ; // printLn(toString(int16b)); // error: unable to find matching function for 'toString' endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; // printLn(toString(uint8a)); // error: unable to find matching function for 'toString' // var uint8b : UInt8 = 1u16; // error: unknown type 'UInt8' var uint16a = 0u16 ; // printLn(toString(uint16a)); // error: unable to find matching function for 'toString' var uint16b : UInt16 = 1u16 ; // printLn(toString(uint16b)); // error: unable to find matching function for 'toString' endfunction function main () var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction Floats Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation. Note Fixed point variables Fixed32 and Fixed64 are coming soon. Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); // fixed point types - wip // var fixed32bit : Fixed32 = 32.1; // error: unknown type 'Fixed32' // var fixed64bit : Fixed64 = 64.1; // error: unknown type 'Fixed64' endfunction Byte - deprecating in favour of UInt8 Declare and initialise an 8 bit unsigned integer with the Byte type. function main () // unsigned 8 bit integer type // var uint8bit : Byte = 42u8 ; // error: internal error at '42u8' // printLn(toString(uint8bit)); // error: unable to find matching function for 'toString' endfunction Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' endfunction Find out more about etch Strings here . Arrays Note Coming soon: common Array operations. You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor endfunction Find out more about etch Arrays here . Maps Note Coming soon: common Map operations. Declare the dictionary Map type with Map<KeyType, ValueType> . function main () var myMap : Map < String , Int32 > ; // myMap[\"balance1\"] = 1000; // runtime error: line 5: null reference // myMap[\"balance2\"] = 2000; // runtime error: line 6: null reference // myMap[\"balance3\"] = 3000; // runtime error: line 7: null reference // TODO: // var myMapState = State<Map<String, Int32>>(myMap, null); // error: unable to find matching constructor for type/function 'State<Map<String, Int32>>' endfunction Matrices Note Coming soon: Matrix type with common matrix operations. Declare the Matrix type with Matrix<ElementType>(Rows, Cols) . function main () // var myMatrix : Matrix < Int32 > ( 5 , 5 ); // error at '(', expected '=' or ';' // Failed to compile. endfunction States A State is a data structure used by etch Smart Contracts for storing and querying data on the ledger. The data stored by a State is held on shards on the ledger. Declare and initialise a State type with State<ValueType> where values are mapped to a key: var myState = State<Int32>(\"var\", 200); Getters and setters are available for State types. function main () var myState = State < Int32 > ( \"var\" , 200 ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Currently, the State type supports primitive types only. Find out more about etch States here . PersistentMap - deprecating in favour of ShardedState Note Coming soon: PersistentMap full implementation. The PersistentMap type is similar to State but more flexible. Declare a PersistentMap with PersistentMap<K, V> where K is the key and V is the value. Note that K must be a String or an Address type. function main () // var myPm : PersistentMap < String , Int32 > ; // error at '<', expected '=' or ';' // Failed to compile. endfunction Find out more about etch PersistentMaps here . Addresses The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key . Declare and initialise an Address like this: function main () var myAddress = Address ( \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+Pw==\" ); endfunction Find out more about etch Addresses here . Mathematical, ML, and AI Note Coming soon: full implementation of mathematical, machine learning, and AI libraries. etch has powerful mathematical, machine learning, and AI specific data types and processes. For example, etch provides a number of powerful data types such as Graph , Tensor , TrainingPair , and CrossEntropy . We will look at these more complex data structures in a later section. Type casting If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name to type cast. There is no implicit type casting in etch . Warning toString is not currently universal. function main () // signed 32 bit integer type var int32bit = 42 ; // cast to byte var byteVariable = toByte ( int32bit ); // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 // var uint8Variable = toUInt8(int32bit); // error: unknown symbol 'toUInt8' // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); //cast to Byte var mybyte = toByte ( 5 ); // float casting var float64bit = 42.0 ; // cast to byte var byteFVariable = toByte ( float64bit ); // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( mybyte ); // cast to Float64 var float64variable = toFloat64 ( mybyte ); // cast to string var stringVariable = toString ( int32bit ); endfunction Constants Note Coming soon: support for constants. Data measures In the table below, we detail the exact memory size of each data type when added to the network. Data type Memory etched upon the ledger Int8 Int16 Int32 Int64 Byte UInt16 UInt32 UInt64 Float32 Float64 Bool String Array Map Matrix State PersistentMap Address Null etc. Note Coming soon: details on memory used on the ledger per variable type plus relative cost. Scope etch has no global variables. Null Non-primitives can be set to null. Note You cannot print a null value. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; // printLn(myString); // Segmentation fault: 11 endfunction","title":"Variables"},{"location":"etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction","title":"Naming"},{"location":"etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits. They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt16 , UInt32 , UInt64 . Int32 is the compiler default so you don't need to explicitly declare this type. Initialise an 8 bit unsigned integer with a Byte type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; // printLn(toString(int8a)); // error: unable to find matching function for 'toString' var int8b : Int8 = - 0 i8 ; // printLn(toString(int8b)); // error: unable to find matching function for 'toString' var int16a = 0 i16 ; // printLn(toString(int16a)); // error: unable to find matching function for 'toString' var int16b : Int16 = - 1 i16 ; // printLn(toString(int16b)); // error: unable to find matching function for 'toString' endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; // printLn(toString(uint8a)); // error: unable to find matching function for 'toString' // var uint8b : UInt8 = 1u16; // error: unknown type 'UInt8' var uint16a = 0u16 ; // printLn(toString(uint16a)); // error: unable to find matching function for 'toString' var uint16b : UInt16 = 1u16 ; // printLn(toString(uint16b)); // error: unable to find matching function for 'toString' endfunction function main () var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"etch-language/variables/#floats","text":"Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation. Note Fixed point variables Fixed32 and Fixed64 are coming soon. Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); // fixed point types - wip // var fixed32bit : Fixed32 = 32.1; // error: unknown type 'Fixed32' // var fixed64bit : Fixed64 = 64.1; // error: unknown type 'Fixed64' endfunction","title":"Floats"},{"location":"etch-language/variables/#byte-deprecating-in-favour-of-uint8","text":"Declare and initialise an 8 bit unsigned integer with the Byte type. function main () // unsigned 8 bit integer type // var uint8bit : Byte = 42u8 ; // error: internal error at '42u8' // printLn(toString(uint8bit)); // error: unable to find matching function for 'toString' endfunction","title":"Byte - deprecating in favour of UInt8"},{"location":"etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"etch-language/variables/#arrays","text":"Note Coming soon: common Array operations. You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"etch-language/variables/#maps","text":"Note Coming soon: common Map operations. Declare the dictionary Map type with Map<KeyType, ValueType> . function main () var myMap : Map < String , Int32 > ; // myMap[\"balance1\"] = 1000; // runtime error: line 5: null reference // myMap[\"balance2\"] = 2000; // runtime error: line 6: null reference // myMap[\"balance3\"] = 3000; // runtime error: line 7: null reference // TODO: // var myMapState = State<Map<String, Int32>>(myMap, null); // error: unable to find matching constructor for type/function 'State<Map<String, Int32>>' endfunction","title":"Maps"},{"location":"etch-language/variables/#matrices","text":"Note Coming soon: Matrix type with common matrix operations. Declare the Matrix type with Matrix<ElementType>(Rows, Cols) . function main () // var myMatrix : Matrix < Int32 > ( 5 , 5 ); // error at '(', expected '=' or ';' // Failed to compile. endfunction","title":"Matrices"},{"location":"etch-language/variables/#states","text":"A State is a data structure used by etch Smart Contracts for storing and querying data on the ledger. The data stored by a State is held on shards on the ledger. Declare and initialise a State type with State<ValueType> where values are mapped to a key: var myState = State<Int32>(\"var\", 200); Getters and setters are available for State types. function main () var myState = State < Int32 > ( \"var\" , 200 ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Currently, the State type supports primitive types only. Find out more about etch States here .","title":"States"},{"location":"etch-language/variables/#persistentmap-deprecating-in-favour-of-shardedstate","text":"Note Coming soon: PersistentMap full implementation. The PersistentMap type is similar to State but more flexible. Declare a PersistentMap with PersistentMap<K, V> where K is the key and V is the value. Note that K must be a String or an Address type. function main () // var myPm : PersistentMap < String , Int32 > ; // error at '<', expected '=' or ';' // Failed to compile. endfunction Find out more about etch PersistentMaps here .","title":"PersistentMap - deprecating in favour of ShardedState"},{"location":"etch-language/variables/#addresses","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key . Declare and initialise an Address like this: function main () var myAddress = Address ( \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+Pw==\" ); endfunction Find out more about etch Addresses here .","title":"Addresses"},{"location":"etch-language/variables/#mathematical-ml-and-ai","text":"Note Coming soon: full implementation of mathematical, machine learning, and AI libraries. etch has powerful mathematical, machine learning, and AI specific data types and processes. For example, etch provides a number of powerful data types such as Graph , Tensor , TrainingPair , and CrossEntropy . We will look at these more complex data structures in a later section.","title":"Mathematical, ML, and AI"},{"location":"etch-language/variables/#type-casting","text":"If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name to type cast. There is no implicit type casting in etch . Warning toString is not currently universal. function main () // signed 32 bit integer type var int32bit = 42 ; // cast to byte var byteVariable = toByte ( int32bit ); // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 // var uint8Variable = toUInt8(int32bit); // error: unknown symbol 'toUInt8' // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); //cast to Byte var mybyte = toByte ( 5 ); // float casting var float64bit = 42.0 ; // cast to byte var byteFVariable = toByte ( float64bit ); // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( mybyte ); // cast to Float64 var float64variable = toFloat64 ( mybyte ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"etch-language/variables/#constants","text":"Note Coming soon: support for constants.","title":"Constants"},{"location":"etch-language/variables/#data-measures","text":"In the table below, we detail the exact memory size of each data type when added to the network. Data type Memory etched upon the ledger Int8 Int16 Int32 Int64 Byte UInt16 UInt32 UInt64 Float32 Float64 Bool String Array Map Matrix State PersistentMap Address Null etc. Note Coming soon: details on memory used on the ledger per variable type plus relative cost.","title":"Data measures"},{"location":"etch-language/variables/#scope","text":"etch has no global variables.","title":"Scope"},{"location":"etch-language/variables/#null","text":"Non-primitives can be set to null. Note You cannot print a null value. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; // printLn(myString); // Segmentation fault: 11 endfunction","title":"Null"},{"location":"etch-language/examples/2d-array/","text":"Creating a 2D array // create a 2dArray function create_2dArray ( i : Int32 , j : Int32 ) : Array < Array < Int32 > > var x = Array < Array < Int32 > >( i ); for ( k in 0 : i - 1 ) x [ k ] = Array < Int32 >( j ); endfor return x ; endfunction // call and build the create_2dArray function from main function main () var x : Array < Array < Int32 > > = create_2dArray ( 10 , 15 ); for ( i in 0 : 9 ) for ( j in 0 : 14 ) x [ i ][ j ] = toInt32 ( i ) * toInt32 ( j ); endfor endfor printLn ( \"\" ); for ( i in 0 : 9 ) for ( j in 0 : 14 ) print ( toString ( x [ i ][ j ]) + \" \" ); endfor endfor endfunction","title":"2D array"},{"location":"etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Float64 = 32.0 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Float64 = toFloat64 ( pixelX ); xLocal = (( xLocal / toFloat64 ( xMax )) * 3.5 ) - 2.5 ; // // Now Y to -1 to 1: var yLocal : Float64 = toFloat64 ( pixelY ); yLocal = yLocal / toFloat64 ( yMax ); // // Now let's do the algorithm bit: var x : Float64 = 0.0 ; var y : Float64 = 0.0 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Float64 = ( toFloat64 ( iteration ) / toFloat64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 >) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count ()- 2 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 >) for ( index in 1 : an_array . count ()- 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) // this should be position > 0 in first operand an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort Note Coming soon. Quick sort Note Coming soon.","title":"Sorting algorithms"},{"location":"etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 >) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count ()- 2 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()- 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 >) for ( index in 1 : an_array . count ()- 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) // this should be position > 0 in first operand an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"etch-language/examples/sorting-algorithms/#merge-sort","text":"Note Coming soon.","title":"Merge sort"},{"location":"etch-language/examples/sorting-algorithms/#quick-sort","text":"Note Coming soon.","title":"Quick sort"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.AI decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.AI blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"What is the OEF?"},{"location":"oef/advertising/","text":"Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Warning Need to tell them where this code is. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ): return self . _public_key The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Get a public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the API.","title":"Python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register to the OEF. Agents are created with a name and public key and they connect to the OEF with an OEF host and port number. On attempting to connect to the OEF, the public key is verified. Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Get the SDK"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 subexpressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of subexpressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"smart-ledger/placeholder/","text":"","title":"Placeholder"}]}