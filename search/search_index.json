{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Fetch.AI documentation. Navigate with the menu buttons above, or click through to: Open Economic Framework Learn how to create agents, interface to the digital world, and get things done. etch Language Guide Smart contracts on Fetch.AI are written in the etch programming language. This is the complete reference and language guide to writing smart contracts.","title":"Welcome to the <a href=\"https://fetch.ai/\" target=_blank>Fetch.AI</a> documentation."},{"location":"#welcome-to-the-fetchai-documentation","text":"Navigate with the menu buttons above, or click through to: Open Economic Framework Learn how to create agents, interface to the digital world, and get things done. etch Language Guide Smart contracts on Fetch.AI are written in the etch programming language. This is the complete reference and language guide to writing smart contracts.","title":"Welcome to the Fetch.AI"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI Constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.AI ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Please note: The etch language and the etch language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"What's etch?"},{"location":"etch-language/ML-AI/","text":"Machine learning and AI Note Coming soon: Tensors. Graphs. Graph operations (MatMul, convolution, etc.). Activations (relu, sigmoid, softmax, etc.). Loss Functions (MeanSquareError, CrossEntropy, KLDivergence, etc.). DataLoaders.","title":"Machine learning and AI"},{"location":"etch-language/arrays/","text":"Arrays Warning Array ranges are wholly inclusive in etch . One dimensional arrays Declare, access by index, and iterate over an array like this: function main () // var mySizelessArray = Array < String > (); // error: unable to find matching constructor for type/function 'Array<String>' // Failed to compile. var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print one element of the array printLn ( toString ( myArray [ 3 ])); // print ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // print descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction Two dimensional arrays Declare a 4x4 2d array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : 3 ) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : 3 ) for ( column in 0 : 3 ) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Utility functions You can use the following utility functions to manipulate arrays: count() append() extend() popBack() and popFront() reverse() Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : 2 ) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : 3 ) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : 2 ) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count () - 1 ) printLn ( my2dArray [ row ]); endfor endfunction Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a positive, whole number. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"Items removed from end: \" ); printLn ( backItems ); printLn ( \"Items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : 4 ) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); var frontArray = my2dArray . popFront ( 2 ); printLn ( \"Removed back arrays: \" ); for ( k in 0 : 1 ) printLn ( backArray [ k ]); endfor printLn ( \"Removed front arrays: \" ); for ( l in 0 : 1 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 0 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : 4 ) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : 4 ) printLn ( my2dArray [ k ]); endfor endfunction","title":"Arrays"},{"location":"etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () // var mySizelessArray = Array < String > (); // error: unable to find matching constructor for type/function 'Array<String>' // Failed to compile. var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print one element of the array printLn ( toString ( myArray [ 3 ])); // print ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // print descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction","title":"One dimensional arrays"},{"location":"etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 2d array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : 3 ) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : 3 ) for ( column in 0 : 3 ) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"etch-language/arrays/#utility-functions","text":"You can use the following utility functions to manipulate arrays: count() append() extend() popBack() and popFront() reverse()","title":"Utility functions"},{"location":"etch-language/control-flow/","text":"Control flow Warning Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"they are equal\" ); elseif ( x > y ) printLn ( \"x is more than y\" ); else if ( x > y ) printLn ( \"x is more than y\" ); else printLn ( \"y is more than x\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"object x is greater than object y\" ); else printLn ( \"object x is less than or equal to object y\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for Warning for loop range is inclusive. function main () // ascending printLn ( \"Ascending and inclusive for loop\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( \"Descending and inclusive for loop\" ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( \"Ascending and inclusive stepwise\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( \"Descending and inclusive stepwise\" ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"they are equal\" ); elseif ( x > y ) printLn ( \"x is more than y\" ); else if ( x > y ) printLn ( \"x is more than y\" ); else printLn ( \"y is more than x\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"object x is greater than object y\" ); else printLn ( \"object x is less than or equal to object y\" ); endif endfunction","title":"if-else"},{"location":"etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"etch-language/control-flow/#for","text":"Warning for loop range is inclusive. function main () // ascending printLn ( \"Ascending and inclusive for loop\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( \"Descending and inclusive for loop\" ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( \"Ascending and inclusive stepwise\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( \"Descending and inclusive stepwise\" ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction","title":"for"},{"location":"etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"etch-language/crypto/","text":"SHA256 etch supports a SHA256 object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var byteArray = Buffer ( 8 ); s . update ( byteArray ); // finalise the object s . final (); // reset the object s . reset (); endfunction","title":"Cryptographic functions"},{"location":"etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the etch compiler will strip out printLn() statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions - awaiting clarification . Member access support issues with dot operator - awaiting clarification . while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give us access to compiler argument count and values. In the following code, first we print the number of compiler arguments, then we list them. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc () - 1 ) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the vm-lang executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./vm-lang sysargs-examples.etch -- hello You should see the following output: F E \u2571 vm - lang v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / vm - lang 1 = hello etch features like this are useful for experimentation and debugging in a dev environment. For example, you can use these system arguments to load machine learning training data. System arguments should not be included in smart contract code. For smart contracts, there are more flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"etch-language/error-checking/","text":"Forcing runtime errors You can force runtime errors with panic() . Use panic for unrecoverable states. It terminates the progam immediately and provides optional feedback. For example: function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"this is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"etch-language/etch-addresses/","text":"Address The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK). And in etch , you can instantiate an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction SHA256 etch currently supports the SHA256 encryption algorithm . Verification The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); // False in v0.4.x ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Addresses"},{"location":"etch-language/etch-addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm .","title":"SHA256"},{"location":"etch-language/etch-addresses/#verification","text":"The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); // False in v0.4.x ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending etch in C++.","title":"Extending etch in C++"},{"location":"etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n <= 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with accessing the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) var newArray = Array < String > ( 2 ); newArray = myArray ; newArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Often, if the variable is a string, you don't have to cast it before printing, otherwise you should cast it with toString() . Note etch strips out all printLn() statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to vm-lang and their value. These functions are only useful on the etch simulator outside of smart contract development. System.Argc() System.Argv() Tip etch also provides utility functions specifically for manipulating strings and arrays . Type casting functions toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toInt8 ( x ); var z = toInt16 ( x ); var a = toInt32 ( x ); var b = toInt64 ( x ); var c = toUInt8 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); // var i = toFixed32(x); // error: unknown symbol 'toFixed32' // var j = toFixed64(x); // error: unknown symbol 'toFixed64' endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. Getters and setters Getters and setters are available for State types. set() get()","title":"Functions"},{"location":"etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n <= 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with accessing the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) var newArray = Array < String > ( 2 ); newArray = myArray ; newArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"etch-language/functions/#type-casting-functions","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toInt8 ( x ); var z = toInt16 ( x ); var a = toInt32 ( x ); var b = toInt64 ( x ); var c = toUInt8 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); // var i = toFixed32(x); // error: unknown symbol 'toFixed32' // var j = toFixed64(x); // error: unknown symbol 'toFixed64' endfunction","title":"Type casting functions"},{"location":"etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger.","title":"Annotations"},{"location":"etch-language/functions/#getters-and-setters","text":"Getters and setters are available for State types. set() get()","title":"Getters and setters"},{"location":"etch-language/getstarted/","text":"Getting started Prerequisites Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here . Installation cd into build folder. Run make vm-lang . Setup cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] <filename> -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract. Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line. Hello world! Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Getting started"},{"location":"etch-language/getstarted/#prerequisites","text":"Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here .","title":"Prerequisites"},{"location":"etch-language/getstarted/#installation","text":"cd into build folder. Run make vm-lang .","title":"Installation"},{"location":"etch-language/getstarted/#setup","text":"cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] <filename> -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"etch-language/getstarted/#hello-world","text":"Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Hello world!"},{"location":"etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"equal\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"not equal\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"less than\" ); endif if ( y <= x ) printLn ( \"less than or equal to\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"more than\" ); endif if ( x >= y ) printLn ( \"more than or equal to\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction Xor Note Coming soon: support for xor . Short circuiting Currently, we don't short circuit. This may cause unexpected results. function foo () : Bool printLn ( '1' ); return true ; endfunction function bar () : Bool printLn ( '2' ); return false ; endfunction function main () if ( foo () || bar ()) printLn ( '3' ); endif endfunction","title":"Logical operators"},{"location":"etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"equal\" ); endif endfunction","title":"Equal to"},{"location":"etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"not equal\" ); endif endfunction","title":"Not equal to"},{"location":"etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"less than\" ); endif if ( y <= x ) printLn ( \"less than or equal to\" ); endif endfunction","title":"Less than"},{"location":"etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"more than\" ); endif if ( x >= y ) printLn ( \"more than or equal to\" ); endif endfunction","title":"More than"},{"location":"etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction","title":"And"},{"location":"etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"true\" ); else printLn ( \"false\" ); endif endfunction","title":"Or"},{"location":"etch-language/logic/#xor","text":"Note Coming soon: support for xor .","title":"Xor"},{"location":"etch-language/logic/#short-circuiting","text":"Currently, we don't short circuit. This may cause unexpected results. function foo () : Bool printLn ( '1' ); return true ; endfunction function bar () : Bool printLn ( '2' ); return false ; endfunction function main () if ( foo () || bar ()) printLn ( '3' ); endif endfunction","title":"Short circuiting"},{"location":"etch-language/maths-libs/","text":"Maths libraries and functions In the current version, release/v0.4.x , the following maths functions are available: Logarithm Natural log values are currently available for UInt256 types only. function main () var int32 = 32 ; // var logI = int32.logValue(); // error: primitive type 'Int32' does not support member-access operator var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); // prints -inf endfunction In a future release, log values will be available for all types as well as in base 2 and 10. Absolute value Abs() returns the absolute value of an Int32 or a Float64 . function do_abs ( value : Int32 ) printLn ( \"Abs of \" + toString ( value ) + \": \" ); printLn ( toString ( Abs ( value ))); endfunction function do_abs ( value : Float64 ) printLn ( \"Abs of \" + toString ( value ) + \": \" ); printLn ( toString ( Abs ( value ))); endfunction function main () // positive int 32 var x_int = 1 ; do_abs ( x_int ); // negative int 32 x_int = - 1 ; do_abs ( x_int ); // positive float 64 var x_float = 0.1123 ; do_abs ( x_float ); // negative float 64 x_float = - 7.151 ; do_abs ( x_float ); endfunction Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = Rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' // printLn(toString(randUInt8)); // unpermitted range // var rand_test = Rand(100u16, 0u16); // runtime error: Invalid argument: Rand(a, b) must satisfy a < b var randUInt16 = Rand ( 0u16 , 1000u16 ); // printLn(toString(randUInt16)); var randUInt32 = Rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = Rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = Rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = Rand ( 0 i16 , 1000 i16 ); // printLn(toString(randInt16)); var randInt32 = Rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = Rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = Rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = Rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction Exponent exp - next release. Square root sqrt - next release. Trig trig functions - next release.","title":"Maths libraries and functions"},{"location":"etch-language/maths-libs/#logarithm","text":"Natural log values are currently available for UInt256 types only. function main () var int32 = 32 ; // var logI = int32.logValue(); // error: primitive type 'Int32' does not support member-access operator var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); // prints -inf endfunction In a future release, log values will be available for all types as well as in base 2 and 10.","title":"Logarithm"},{"location":"etch-language/maths-libs/#absolute-value","text":"Abs() returns the absolute value of an Int32 or a Float64 . function do_abs ( value : Int32 ) printLn ( \"Abs of \" + toString ( value ) + \": \" ); printLn ( toString ( Abs ( value ))); endfunction function do_abs ( value : Float64 ) printLn ( \"Abs of \" + toString ( value ) + \": \" ); printLn ( toString ( Abs ( value ))); endfunction function main () // positive int 32 var x_int = 1 ; do_abs ( x_int ); // negative int 32 x_int = - 1 ; do_abs ( x_int ); // positive float 64 var x_float = 0.1123 ; do_abs ( x_float ); // negative float 64 x_float = - 7.151 ; do_abs ( x_float ); endfunction","title":"Absolute value"},{"location":"etch-language/maths-libs/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = Rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' // printLn(toString(randUInt8)); // unpermitted range // var rand_test = Rand(100u16, 0u16); // runtime error: Invalid argument: Rand(a, b) must satisfy a < b var randUInt16 = Rand ( 0u16 , 1000u16 ); // printLn(toString(randUInt16)); var randUInt32 = Rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = Rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = Rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = Rand ( 0 i16 , 1000 i16 ); // printLn(toString(randInt16)); var randInt32 = Rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = Rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = Rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = Rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction","title":"Random (non deterministic)"},{"location":"etch-language/maths-libs/#exponent","text":"exp - next release.","title":"Exponent"},{"location":"etch-language/maths-libs/#square-root","text":"sqrt - next release.","title":"Square root"},{"location":"etch-language/maths-libs/#trig","text":"trig functions - next release.","title":"Trig"},{"location":"etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"etch-language/release-notes/","text":"Version 0.5.x Significant changes in this version of the etch virtual machine include the following: ...","title":"Release notes"},{"location":"etch-language/release-notes/#version-05x","text":"Significant changes in this version of the etch virtual machine include the following: ...","title":"Version 0.5.x"},{"location":"etch-language/sharded-state/","text":"Sharded States A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declare a ShardedState in the same way you declare a State : function main () var state = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs to the ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction You can of course create ShardedState types using Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction Writing ShardedState data to the ledger Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState < Int32 > ( \"account1\" ); var y = ShardedState < Int32 > ( \"account1\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My state value = \" + toString ( x . get ( \"balance\" ))); endfunction Because ShardedState uses anonymous State types to write data as soon as it is created, we can access values with keys using any var identifier. This makes the ShardedState type much more powerful than a State type.","title":"Sharded State"},{"location":"etch-language/sharded-state/#writing-shardedstate-data-to-the-ledger","text":"Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState < Int32 > ( \"account1\" ); var y = ShardedState < Int32 > ( \"account1\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My state value = \" + toString ( x . get ( \"balance\" ))); endfunction Because ShardedState uses anonymous State types to write data as soon as it is created, we can access values with keys using any var identifier. This makes the ShardedState type much more powerful than a State type.","title":"Writing ShardedState data to the ledger"},{"location":"etch-language/states/","text":"States Smart contracts store data on the Fetch.AI distributed ledger using State and ShardedState data structures. A State is declared as a State<ValueType>(name : String) where name is the unique memory location identifier for data residing on the ledger, like this: var myState = State < Int32 > ( \"account\" ); Now we can set a value on the State with set() : myState . set ( 100 ); And retrieve the value with get() : myState . get (); The State constructor value inside the parentheses is a pointer to a memory location on the ledger. It takes a string, as above, or an Address type. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = State < Int32 > ( account ); myState . set ( 100 ); printLn ( \"My state value = \" + toString ( myState . get ())); endfunction In smart contract code, any number of var identifiers can point to the same State object on the ledger. In the example below, ownerState and contractState point to the same memory location and therefore reference the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. //The value has not been assigned and/or it does not exist in data storage. endfunction Attempting to print the value of the second State object generates an error. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and this generates a runtime error. Writing State data to the ledger The following is true for State variables with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of scope and the destructor() function has been called behind the scenes. While identifiable State variables remain in function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which do not explicitly call set() . Once control reaches the end of the function, data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var name performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up on immediate write anonymouse State types behind the scenes. Default values Although it is possible to declare a State without a value, attempting to get() from such a State results in a runtime error. function main () State < Int32 > ( \"myNumber\" ); // printLn(State<Int32>(\"myNumber\").get()); // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. var x = State < Int32 > ( \"myNumber2\" ); // printLn(x.get()); // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Similarly, you cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Common use A common use for the State type is to represent account owner Address types with their respective balances. To this end, you can declare a State where the first parameter is an Address type. In the code below we first create an Address type. We can then define the transaction sender account wrapped in a State type where the first parameter from is the Address we just created and the second parameter is the account balance in UInt64 : function main () var from = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var from_account = State < UInt64 > ( from ); from_account . set ( 100u64 ); endfunction","title":"States"},{"location":"etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State variables with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of scope and the destructor() function has been called behind the scenes. While identifiable State variables remain in function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which do not explicitly call set() . Once control reaches the end of the function, data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var name performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up on immediate write anonymouse State types behind the scenes.","title":"Anonymous State types"},{"location":"etch-language/states/#default-values","text":"Although it is possible to declare a State without a value, attempting to get() from such a State results in a runtime error. function main () State < Int32 > ( \"myNumber\" ); // printLn(State<Int32>(\"myNumber\").get()); // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. var x = State < Int32 > ( \"myNumber2\" ); // printLn(x.get()); // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction","title":"Default values"},{"location":"etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Similarly, you cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction","title":"Passing States around"},{"location":"etch-language/states/#common-use","text":"A common use for the State type is to represent account owner Address types with their respective balances. To this end, you can declare a State where the first parameter is an Address type. In the code below we first create an Address type. We can then define the transaction sender account wrapped in a State type where the first parameter from is the Address we just created and the second parameter is the account balance in UInt64 : function main () var from = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var from_account = State < UInt64 > ( from ); from_account . set ( 100u64 ); endfunction","title":"Common use"},{"location":"etch-language/strings/","text":"Strings etch supports ASCII for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' // var y = myString[0]; // error: unable to find matching index operator for type 'String' endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction Utility functions You can use the following utility functions for string manipulation: find() length() reverse() substr() trim() split() Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Substr The substr() function extracts a substring from a string, based on specified starting and ending indexes (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indexes are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence to split on and returns an array of strings that does not include the split character(s). Returns a one element array if there is no tokenizer within it or if the input string is empty. Returns an empty string if more than one tokenizer is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a tokenizer. Returns an empty string as the last element in the output array if the last element of the input is a tokenizer. The following code takes a string and splits it on the tokenizer -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Strings"},{"location":"etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(toString(x)); // error: unable to find matching function for 'toString' // var y = myString[0]; // error: unable to find matching index operator for type 'String' endfunction","title":"Concatenation"},{"location":"etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"etch-language/strings/#utility-functions","text":"You can use the following utility functions for string manipulation: find() length() reverse() substr() trim() split()","title":"Utility functions"},{"location":"etch-language/syntax/","text":"Syntax The etch language was initially integrated with the Fetch.AI C++ ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on smart contracts .","title":"Syntax"},{"location":"etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return","title":"Keywords"},{"location":"etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on smart contracts .","title":"Annotations"},{"location":"etch-language/variables/","text":"Variables etch is a statically-typed programming language. For good coding practice, you should explicitly declare all variable types. Declare a variable with the keyword var . Declare numeric values with literals where possible. You can also use an explicit type cast operation. See below for explicit type declaration rules. Warning The toString function does not yet support all variable types. Naming Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits. They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; // printLn(toString(int8a)); // error: unable to find matching function for 'toString' var int8b : Int8 = - 0 i8 ; // printLn(toString(int8b)); // error: unable to find matching function for 'toString' var int16a = 0 i16 ; // printLn(toString(int16a)); // error: unable to find matching function for 'toString' var int16b : Int16 = - 1 i16 ; // printLn(toString(int16b)); // error: unable to find matching function for 'toString' endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; // printLn(toString(uint8a)); // error: unable to find matching function for 'toString' var uint8b : UInt8 = 1u8 ; // printLn(toString(uint8b)); // error: unable to find matching function for 'toString' var uint16a = 0u16 ; // printLn(toString(uint16a)); // error: unable to find matching function for 'toString' var uint16b : UInt16 = 1u16 ; // printLn(toString(uint16b)); // error: unable to find matching function for 'toString' endfunction function main () var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction In the current version, UInt256 is built from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction Floats Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation. Note Fixed point variables Fixed32 and Fixed64 will be available in version release/0.5.x. Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); // fixed point types - wip // var fixed32bit : Fixed32 = 32.1; // error: unknown type 'Fixed32' // var fixed64bit : Fixed64 = 64.1; // error: unknown type 'Fixed64' endfunction Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this: var myBuffer = Buffer ( 8 ); Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); endfunction Note Coming soon: common Map operations. States A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI ledger shards. Unique identifiers for ledger data are created at State construction time. Declare and initialise a State type with State<ValueType> where values set with set() are mapped to the unique ledger identifier account : var myState = State<Int32> ( \"account\" ) ; Getters and setters are available for State types. function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState A ShardedState is also used for reading and writing data to the Fetch.AI ledger. However, it is much more efficient and powerful. ShardedState uses State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with keys and values. In the following code, we create a ShardedState , set() a key/value pair on it, and finally we print the value using get() on a key with a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedStates here . Addresses The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about etch Addresses here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. In the current version, release/v0.4.x , the following maths functions are available: Log values. Absolute values. Exponents. Square roots. Random generator. Trigonometry functions such as sin , cos , tan , asin , sinh , asinh , etc. For more details on the mathematical computation functions above, please check the section on maths libraries and functions . The following types and functions commonly used for machine learning are also available: Graphs. Tensors. Cross entropy. Mean square error. For more details on the machine learning implementations, please check the section on machine learning and artificial intelligence . Type casting If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name to type cast. There is no implicit type casting in etch . Warning toString is not currently universal. function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // float casting var float64bit = 42.0 ; // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( float64bit ); // cast to Float64 var float64variable = toFloat64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the exact memory size of each data type, and when etched onto the network. Type Memory size Size on ledger Int8 8 byte tbc Int16 16 byte tbc Int32 32 byte tbc Int64 64 byte tbc UInt8 8 byte tbc UInt16 16 byte tbc UInt32 32 byte tbc UInt64 64 byte tbc UInt256 256 byte tbc Float32 32 byte tbc Float64 64 byte tbc Bool tbc tbc String tbc tbc Array tbc tbc Map tbc tbc State tbc tbc ShardedState tbc tbc Address tbc tbc null tbc tbc Note Coming soon: relative cost. Scope etch has no global variables. Null Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Variables"},{"location":"etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction","title":"Naming"},{"location":"etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits. They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; // printLn(toString(int8a)); // error: unable to find matching function for 'toString' var int8b : Int8 = - 0 i8 ; // printLn(toString(int8b)); // error: unable to find matching function for 'toString' var int16a = 0 i16 ; // printLn(toString(int16a)); // error: unable to find matching function for 'toString' var int16b : Int16 = - 1 i16 ; // printLn(toString(int16b)); // error: unable to find matching function for 'toString' endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; // printLn(toString(uint8a)); // error: unable to find matching function for 'toString' var uint8b : UInt8 = 1u8 ; // printLn(toString(uint8b)); // error: unable to find matching function for 'toString' var uint16a = 0u16 ; // printLn(toString(uint16a)); // error: unable to find matching function for 'toString' var uint16b : UInt16 = 1u16 ; // printLn(toString(uint16b)); // error: unable to find matching function for 'toString' endfunction function main () var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction In the current version, UInt256 is built from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction","title":"Integers"},{"location":"etch-language/variables/#floats","text":"Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation. Note Fixed point variables Fixed32 and Fixed64 will be available in version release/0.5.x. Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); // fixed point types - wip // var fixed32bit : Fixed32 = 32.1; // error: unknown type 'Fixed32' // var fixed64bit : Fixed64 = 64.1; // error: unknown type 'Fixed64' endfunction","title":"Floats"},{"location":"etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"etch-language/variables/#buffer","text":"Create a Buffer byte array type like this: var myBuffer = Buffer ( 8 );","title":"Buffer"},{"location":"etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); endfunction Note Coming soon: common Map operations.","title":"Maps"},{"location":"etch-language/variables/#states","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI ledger shards. Unique identifiers for ledger data are created at State construction time. Declare and initialise a State type with State<ValueType> where values set with set() are mapped to the unique ledger identifier account : var myState = State<Int32> ( \"account\" ) ; Getters and setters are available for State types. function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"States"},{"location":"etch-language/variables/#shardedstate","text":"A ShardedState is also used for reading and writing data to the Fetch.AI ledger. However, it is much more efficient and powerful. ShardedState uses State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with keys and values. In the following code, we create a ShardedState , set() a key/value pair on it, and finally we print the value using get() on a key with a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedStates here .","title":"ShardedState"},{"location":"etch-language/variables/#addresses","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about etch Addresses here .","title":"Addresses"},{"location":"etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. In the current version, release/v0.4.x , the following maths functions are available: Log values. Absolute values. Exponents. Square roots. Random generator. Trigonometry functions such as sin , cos , tan , asin , sinh , asinh , etc. For more details on the mathematical computation functions above, please check the section on maths libraries and functions . The following types and functions commonly used for machine learning are also available: Graphs. Tensors. Cross entropy. Mean square error. For more details on the machine learning implementations, please check the section on machine learning and artificial intelligence .","title":"Mathematical, ML, and AI"},{"location":"etch-language/variables/#type-casting","text":"If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name to type cast. There is no implicit type casting in etch . Warning toString is not currently universal. function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // float casting var float64bit = 42.0 ; // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( float64bit ); // cast to Float64 var float64variable = toFloat64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"etch-language/variables/#data-size","text":"In the table below, we detail the exact memory size of each data type, and when etched onto the network. Type Memory size Size on ledger Int8 8 byte tbc Int16 16 byte tbc Int32 32 byte tbc Int64 64 byte tbc UInt8 8 byte tbc UInt16 16 byte tbc UInt32 32 byte tbc UInt64 64 byte tbc UInt256 256 byte tbc Float32 32 byte tbc Float64 64 byte tbc Bool tbc tbc String tbc tbc Array tbc tbc Map tbc tbc State tbc tbc ShardedState tbc tbc Address tbc tbc null tbc tbc Note Coming soon: relative cost.","title":"Data size"},{"location":"etch-language/variables/#scope","text":"etch has no global variables.","title":"Scope"},{"location":"etch-language/variables/#null","text":"Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Default values"},{"location":"etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Float64 = 32.0 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Float64 = toFloat64 ( pixelX ); xLocal = (( xLocal / toFloat64 ( xMax )) * 3.5 ) - 2.5 ; // // Now Y to -1 to 1: var yLocal : Float64 = toFloat64 ( pixelY ); yLocal = yLocal / toFloat64 ( yMax ); // // Now let's do the algorithm bit: var x : Float64 = 0.0 ; var y : Float64 = 0.0 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Float64 = ( toFloat64 ( iteration ) / toFloat64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 2 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count () - 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count () - 1 ) a_list [ i ] = Rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( a_list . count () - mid ); for ( x in 0 : mid - 1 ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count () - 1 ) right_half [ y - mid ] = a_list [ y ]; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort Note Coming soon.","title":"Sorting algorithms"},{"location":"etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 2 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count () - 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count () - 1 ) a_list [ i ] = Rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( a_list . count () - mid ); for ( x in 0 : mid - 1 ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count () - 1 ) right_half [ y - mid ] = a_list [ y ]; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"etch-language/examples/sorting-algorithms/#quick-sort","text":"Note Coming soon.","title":"Quick sort"},{"location":"getting-started/erc20/","text":"Making an ERC20 contract The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Requirements The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State< UInt256 >(\"total_supply\"); supply_state.set(supply); var balance_state = State< UInt256 >(owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract. Queries The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State< UInt256 >(\"total_supply\"); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State< UInt256 >(owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance. Actions The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State< UInt256 >(from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance < value) return false; endif var to_state = State< UInt256 >(to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens. Implementing allowance The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState< UInt256 >(spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState< UInt256 >(spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here https://github.com/fetchai/etch-examples/blob/master/02_erc20/contract.etch.","title":"Making an ERC20 contract"},{"location":"getting-started/erc20/#making-an-erc20-contract","text":"The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API.","title":"Making an ERC20 contract"},{"location":"getting-started/erc20/#requirements","text":"The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same.","title":"Requirements"},{"location":"getting-started/erc20/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State< UInt256 >(\"total_supply\"); supply_state.set(supply); var balance_state = State< UInt256 >(owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract.","title":"Initialisation function"},{"location":"getting-started/erc20/#queries","text":"The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State< UInt256 >(\"total_supply\"); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State< UInt256 >(owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance.","title":"Queries"},{"location":"getting-started/erc20/#actions","text":"The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State< UInt256 >(from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance < value) return false; endif var to_state = State< UInt256 >(to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens.","title":"Actions"},{"location":"getting-started/erc20/#implementing-allowance","text":"The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState< UInt256 >(spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState< UInt256 >(spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here https://github.com/fetchai/etch-examples/blob/master/02_erc20/contract.etch.","title":"Implementing allowance"},{"location":"getting-started/erc721/","text":"Making an ERC721 contract In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256(\"hello world\"); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState< Address >(\"tokens.owner\"); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State< Array< UInt256 > >(owner); // Storing the tokens on the owners address objects_state.set(tokens); Queries In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State< Array< UInt256 > >(owner); var tokens = objects_state.get( Array< UInt256 >(0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState< Address >(\"tokens.owner\"); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array. Actions The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic(\"Invalid signature from owner.\"); endif var owner_state = ShardedState< Address >(\"tokens.owner\"); var owner = owner_state.get(toString(token_id)); if(owner != from) panic(\"Owner does not actually own the token\"); endif var from_state = State< Array< UInt256 > >(from); var from_objects = from_state.get( Array< UInt256 >(0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic(\"Contract broken - token is only supposed be represented once.\"); endif found = true; position = i; break; endif endfor if(!found) panic(\"Contract is fundamentally broken - owner has not been updated correctly\"); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State< Array< UInt256 > >(to); var to_objects = to_state.get( Array< UInt256 >(0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here: https://github.com/fetchai/etch-examples/blob/master/03_erc721/contract.etch.","title":"Making an ERC721 contract"},{"location":"getting-started/erc721/#making-an-erc721-contract","text":"In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState .","title":"Making an ERC721 contract"},{"location":"getting-started/erc721/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256(\"hello world\"); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState< Address >(\"tokens.owner\"); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State< Array< UInt256 > >(owner); // Storing the tokens on the owners address objects_state.set(tokens);","title":"Initialisation function"},{"location":"getting-started/erc721/#queries","text":"In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State< Array< UInt256 > >(owner); var tokens = objects_state.get( Array< UInt256 >(0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState< Address >(\"tokens.owner\"); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array.","title":"Queries"},{"location":"getting-started/erc721/#actions","text":"The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic(\"Invalid signature from owner.\"); endif var owner_state = ShardedState< Address >(\"tokens.owner\"); var owner = owner_state.get(toString(token_id)); if(owner != from) panic(\"Owner does not actually own the token\"); endif var from_state = State< Array< UInt256 > >(from); var from_objects = from_state.get( Array< UInt256 >(0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic(\"Contract broken - token is only supposed be represented once.\"); endif found = true; position = i; break; endif endfor if(!found) panic(\"Contract is fundamentally broken - owner has not been updated correctly\"); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State< Array< UInt256 > >(to); var to_objects = to_state.get( Array< UInt256 >(0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here: https://github.com/fetchai/etch-examples/blob/master/03_erc721/contract.etch.","title":"Actions"},{"location":"getting-started/installation-mac/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"MacOS"},{"location":"getting-started/installation-mac/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"getting-started/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Initial setup"},{"location":"getting-started/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Build the ledger"},{"location":"getting-started/installation-mac/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"Run a local node"},{"location":"getting-started/installation-redhat/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Redhat is not currently supported. Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"Redhat"},{"location":"getting-started/installation-redhat/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-redhat/#supported-platforms","text":"Redhat is not currently supported.","title":"Supported platforms"},{"location":"getting-started/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"getting-started/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Build the ledger"},{"location":"getting-started/installation-redhat/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"Run a local node"},{"location":"getting-started/installation-ubuntu/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Ubuntu 18.04 (x86_64) Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Building the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"Ubuntu"},{"location":"getting-started/installation-ubuntu/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-ubuntu/#supported-platforms","text":"Ubuntu 18.04 (x86_64)","title":"Supported platforms"},{"location":"getting-started/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"getting-started/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.4.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-ubuntu/#building-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Building the ledger"},{"location":"getting-started/installation-ubuntu/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) Once you see the message: [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete you are ready to start exploring the ledger functionality.","title":"Run a local node"},{"location":"getting-started/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Open Economic Framework"},{"location":"getting-started/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"getting-started/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"getting-started/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"getting-started/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"getting-started/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"getting-started/python-api-install/","text":"Download and install the Python library which interacts with the running ledger node: git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.4.x Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Python API"},{"location":"getting-started/submitting_contract/","text":"Developing smart contracts Let's develop a simple Hello world contract and submit it to a running local ledger node. Hello world with vm-lang Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Submitting the contract to the ledger To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Developing smart contracts"},{"location":"getting-started/submitting_contract/#developing-smart-contracts","text":"Let's develop a simple Hello world contract and submit it to a running local ledger node.","title":"Developing smart contracts"},{"location":"getting-started/submitting_contract/#hello-world-with-vm-lang","text":"Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with vm-lang"},{"location":"getting-started/submitting_contract/#submitting-the-contract-to-the-ledger","text":"To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Submitting the contract to the ledger"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.AI decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.AI blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"What is the OEF?"},{"location":"oef/advertising/","text":"Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) -> str : \"\"\" Returns a 219 character public key in base58 format \"\"\" return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Get a public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the API.","title":"Python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register to the OEF. Agents are created with a name and public key and they connect to the OEF with an OEF host and port number. On attempting to connect to the OEF, the public key is verified. Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Get the SDK"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 subexpressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of subexpressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"smart-contracts/addresses/","text":"Address The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK). And in etch , you can instantiate an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction SHA256 etch currently supports the SHA256 encryption algorithm . Verification The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); // False in v0.4.x ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Addresses"},{"location":"smart-contracts/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm .","title":"SHA256"},{"location":"smart-contracts/addresses/#verification","text":"The Address type has a function signed_tx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); // False in v0.4.x ledger code endfunction The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"smart-contracts/erc20/","text":"Making an ERC20 contract The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Requirements The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State< UInt256 >(\"total_supply\"); supply_state.set(supply); var balance_state = State< UInt256 >(owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract. Queries The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State< UInt256 >(\"total_supply\"); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State< UInt256 >(owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance. Actions The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State< UInt256 >(from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance < value) return false; endif var to_state = State< UInt256 >(to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens. Implementing allowance The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState< UInt256 >(spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState< UInt256 >(spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here https://github.com/fetchai/etch-examples/blob/master/02_erc20/contract.etch.","title":"Creating FET-20 contract"},{"location":"smart-contracts/erc20/#making-an-erc20-contract","text":"The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API.","title":"Making an ERC20 contract"},{"location":"smart-contracts/erc20/#requirements","text":"The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same.","title":"Requirements"},{"location":"smart-contracts/erc20/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State< UInt256 >(\"total_supply\"); supply_state.set(supply); var balance_state = State< UInt256 >(owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract.","title":"Initialisation function"},{"location":"smart-contracts/erc20/#queries","text":"The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State< UInt256 >(\"total_supply\"); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State< UInt256 >(owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance.","title":"Queries"},{"location":"smart-contracts/erc20/#actions","text":"The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State< UInt256 >(from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance < value) return false; endif var to_state = State< UInt256 >(to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens.","title":"Actions"},{"location":"smart-contracts/erc20/#implementing-allowance","text":"The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState< UInt256 >(spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState< UInt256 >(spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here https://github.com/fetchai/etch-examples/blob/master/02_erc20/contract.etch.","title":"Implementing allowance"},{"location":"smart-contracts/erc721/","text":"Making an ERC721 contract In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256(\"hello world\"); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState< Address >(\"tokens.owner\"); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State< Array< UInt256 > >(owner); // Storing the tokens on the owners address objects_state.set(tokens); Queries In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State< Array< UInt256 > >(owner); var tokens = objects_state.get( Array< UInt256 >(0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState< Address >(\"tokens.owner\"); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array. Actions The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic(\"Invalid signature from owner.\"); endif var owner_state = ShardedState< Address >(\"tokens.owner\"); var owner = owner_state.get(toString(token_id)); if(owner != from) panic(\"Owner does not actually own the token\"); endif var from_state = State< Array< UInt256 > >(from); var from_objects = from_state.get( Array< UInt256 >(0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic(\"Contract broken - token is only supposed be represented once.\"); endif found = true; position = i; break; endif endfor if(!found) panic(\"Contract is fundamentally broken - owner has not been updated correctly\"); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State< Array< UInt256 > >(to); var to_objects = to_state.get( Array< UInt256 >(0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here: https://github.com/fetchai/etch-examples/blob/master/03_erc721/contract.etch.","title":"Creating FET-721 contract"},{"location":"smart-contracts/erc721/#making-an-erc721-contract","text":"In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState .","title":"Making an ERC721 contract"},{"location":"smart-contracts/erc721/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256(\"hello world\"); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState< Address >(\"tokens.owner\"); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State< Array< UInt256 > >(owner); // Storing the tokens on the owners address objects_state.set(tokens);","title":"Initialisation function"},{"location":"smart-contracts/erc721/#queries","text":"In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State< Array< UInt256 > >(owner); var tokens = objects_state.get( Array< UInt256 >(0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState< Address >(\"tokens.owner\"); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array.","title":"Queries"},{"location":"smart-contracts/erc721/#actions","text":"The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic(\"Invalid signature from owner.\"); endif var owner_state = ShardedState< Address >(\"tokens.owner\"); var owner = owner_state.get(toString(token_id)); if(owner != from) panic(\"Owner does not actually own the token\"); endif var from_state = State< Array< UInt256 > >(from); var from_objects = from_state.get( Array< UInt256 >(0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic(\"Contract broken - token is only supposed be represented once.\"); endif found = true; position = i; break; endif endfor if(!found) panic(\"Contract is fundamentally broken - owner has not been updated correctly\"); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State< Array< UInt256 > >(to); var to_objects = to_state.get( Array< UInt256 >(0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here: https://github.com/fetchai/etch-examples/blob/master/03_erc721/contract.etch.","title":"Actions"},{"location":"smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find the full details of how to do that here . For this version of documentation alone, run git checkout master before building the ledger and running a node. If you have been running constellation nodes previously, you should remove the databases as they will be incompatible with a fresh node: rm *.db For example, to run a standalone ledger node listening on port 8000 from the build directory, use the following command: ./apps/constellation/constellation -port 8000 -block-interval 3000 -standalone Build the Python API libraries like this: pip3 install -U fetchai-ledger-api The API will install to tbc . Running a smart contract example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install Open the contracts.py script in the examples directory: from typing import List from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" def print_address_balances ( api : LedgerApi , contract : SmartContract , addresses : List [ Address ]): for idx , address in enumerate ( addresses ): print ( 'Address{}: {:<6d} bFET {:<10d} TOK' . format ( idx , api . tokens . balance ( address ), contract . query ( api , 'balance' , address = address ))) print () def main (): # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8000 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) print ( '-- AFTER --' ) print_address_balances ( api , contract , [ address1 , address2 ]) if __name__ == '__main__' : main () The etch smart contract is embedded into Python as a string. This particular example creates a pair of Entity accounts. The first account is the contract owner who receives some tokens in order to create the contract and deploy it to the ledger. Once the contract is deployed to the ledger, the second account receives a transfer of tokens. Test network Note Implementation details for running smart contract code against a test network are coming soon. Public network Note In development.","title":"Executing smart contract code"},{"location":"smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find the full details of how to do that here . For this version of documentation alone, run git checkout master before building the ledger and running a node. If you have been running constellation nodes previously, you should remove the databases as they will be incompatible with a fresh node: rm *.db For example, to run a standalone ledger node listening on port 8000 from the build directory, use the following command: ./apps/constellation/constellation -port 8000 -block-interval 3000 -standalone Build the Python API libraries like this: pip3 install -U fetchai-ledger-api The API will install to tbc .","title":"Locally"},{"location":"smart-contracts/executing-smart-contract-code/#running-a-smart-contract-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install Open the contracts.py script in the examples directory: from typing import List from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" def print_address_balances ( api : LedgerApi , contract : SmartContract , addresses : List [ Address ]): for idx , address in enumerate ( addresses ): print ( 'Address{}: {:<6d} bFET {:<10d} TOK' . format ( idx , api . tokens . balance ( address ), contract . query ( api , 'balance' , address = address ))) print () def main (): # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8000 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ address1 , address2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) print ( '-- AFTER --' ) print_address_balances ( api , contract , [ address1 , address2 ]) if __name__ == '__main__' : main () The etch smart contract is embedded into Python as a string. This particular example creates a pair of Entity accounts. The first account is the contract owner who receives some tokens in order to create the contract and deploy it to the ledger. Once the contract is deployed to the ledger, the second account receives a transfer of tokens.","title":"Running a smart contract example in Python"},{"location":"smart-contracts/executing-smart-contract-code/#test-network","text":"Note Implementation details for running smart contract code against a test network are coming soon.","title":"Test network"},{"location":"smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"smart-contracts/memory/","text":"Memory State and a ShardedState save data onto the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. For example, aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, State<Int32>(\"balance\").set(200); may map to a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. For example, given a vote() function such as the one below, the code may aggregate the State variables tracking every vote in an inefficient manner: function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up new memory space on the shard. The ledger shards could look something like this after this vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State accumulates upon a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivize code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState like this: function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.AI smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the Fetch distributed ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using State data structures and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code. Fees Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Introduction"},{"location":"smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently.","title":"The Ledger"},{"location":"smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"smart-contracts/smart-contract-intro/#fees","text":"Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Fees"},{"location":"smart-contracts/smart-contracts/","text":"Smart contracts Smart contract code runs on the etch VM. All ledger nodes maintain etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash of the contract code as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address . On the ledger, the etch VM stores the contract name, the contract source code, and the data resources that are mapped by a data.json file. Taking this contract identity data, the etch VM performs a modulo 16 calculation from which it decides how to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Basic Smart contract Smart contract functions are annotated depending on the activity they perform. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything you like. For example, the following function initialises a contract by creating a State type that represents the owner's account which sets an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction @action The @action annotation signifies a function which performs a transaction. You cannot create a contract in etch without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction In the worst case, the above function needs two shards for data. @query Query functions are read-only functions that allow you to view data on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var x = balance ( owner ); printLn ( x ); endfunction Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing data details. ./vm-lang *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" } Utility functions getBlockNumber() : returns the number of the current block in UInt64 .","title":"Smart contracts"},{"location":"smart-contracts/smart-contracts/#basic-smart-contract","text":"Smart contract functions are annotated depending on the activity they perform.","title":"Basic Smart contract"},{"location":"smart-contracts/smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing data details. ./vm-lang *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"smart-contracts/smart-contracts/#utility-functions","text":"getBlockNumber() : returns the number of the current block in UInt64 .","title":"Utility functions"},{"location":"smart-contracts/submitting_contract/","text":"Developing smart contracts Let's develop a simple Hello world contract and submit it to a running local ledger node. Hello world with vm-lang Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Submitting the contract to the ledger To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Hello world"},{"location":"smart-contracts/submitting_contract/#developing-smart-contracts","text":"Let's develop a simple Hello world contract and submit it to a running local ledger node.","title":"Developing smart contracts"},{"location":"smart-contracts/submitting_contract/#hello-world-with-vm-lang","text":"Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with vm-lang"},{"location":"smart-contracts/submitting_contract/#submitting-the-contract-to-the-ledger","text":"To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Submitting the contract to the ledger"},{"location":"smart-contracts/synergetic/","text":"Synergetic contracts Synergetic contracts are a new type of smart contract which allow miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating from a random seed generated from a public key. Registered miners begin to solve the problem at the same time and the miner who solves the problem first wins the bounty associated with the problem. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic"},{"location":"smart-contracts/transactions/","text":"Transactions Smart contracts are user-defined transactions. A transaction takes place between two or more parties and the data exchange is recorded on the ledger. etch supports a number of transactions commonly supported by cryptographic ledgers. Currently, these are built-in transaction types executed in Python which have relatively fixed data storage requirements. For example: Transaction Deed Wealth Note Coming soon: support for smart contract transaction types.","title":"Transactions"}]}