{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fetch.ai developer resources. Let's get started. Fetch.ai Incentivized testnets are running now Over a MILLION FET in rewards over the testnet phases! You can learn more about this journey here . The current running testnet is Security themed, and you can get part of a substantial reward pool over the coming weeks: up to a quarter of a MILLION FET in rewards for taking part . Each themed testnet divides its focus up into different pieces, so there's something for everyone. Get started now ! Incentivized Testnet - Beacon World 1 Earn tokens while contributing to the governance and security of our network Developing agents Speed up the development of Autonomous Economic Agents using our framework Getting Ready for mainnet v2 Learn how to use our ledger technologies as we prepare for mainnet v2 Here to build agents? Learn about the agent framework's architecture . Learn about the concepts . Build your first agent. What is Fetch.ai There are billions of devices, processes and pipelines around the world that are desperate for automation and communication. Most blockchains aren't built to handle such a large number of transactions, and none enable their clients to learn from the data generated and exchanged. Fetch.ai is a platform built to bring value to data, by connecting devices and facilitating the creation of new markets based on what they learn from each other. It is the platform where truly autonomous decisions can be made. Some of the technical features that will enable this autonomous world are: Blockchain sharding to increase concurrency and scalability Smart contract language with ML and AI capabilities Framework for rapid development of Autonomous Economic Agents (AEAs) that can be deployed in any device Support for fixed-point arithmetics to guarantee precision and determinism across all operations and transactions Versions and release notes As with any software and its documentation, things do change and evolve. We at Fetch.ai try to support backwards compatibility as much as possible, but deprecations will occur. Keep an eye our release notes, as these list all major changes. Updates! Documentation last updated on December 9th, 2020","title":"Home"},{"location":"aea/","text":"The AEA framework provides the tools for creating Autonomous Economic Agents (AEA). What are AEAs? We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. AEAs act independently of constant input from their owner and autonomously execute actions to achieve their prescribed goal. Their goal is to create economic value for you, their owner, in a clearly defined domain. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs' purpose is to generate economic value in a multi-stakeholder environment with competing incentives between agents. The represent humans, organisations or things. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic. What is the AEA Framework? The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. It attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. AEAs achieve their goals with the help of the Open Economic Framework (OEF) - a decentralized communication and search & discovery system for agents - and using Fetch.ai's blockchain as a financial settlement and commitment layer. Third-party blockchains, such as Ethereum , may also allow AEA integration. Why build with the AEA Framework? The AEA framework provides the developer with a number of features which cannot be found in this combination anywhere else: the peer-to-peer agent communication network allows your AEAs to interact with all other AEAs over the public internet the search and discovery system sOEF allows your AEAs to find other agents the AEA registry enables code sharing and re-use the framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains reusability of code for interacting with blockchains is enabled via the contract packages Next steps To get started developing your own AEA, check out the getting started section. To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . If you would like to develop an AEA in a language different to Python then check out our language agnostic AEA definition . If you would run a demo, check out the demo guides . Help us improve Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Slack channel .","title":"Introduction"},{"location":"aea/#what-are-aeas","text":"We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. AEAs act independently of constant input from their owner and autonomously execute actions to achieve their prescribed goal. Their goal is to create economic value for you, their owner, in a clearly defined domain. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs' purpose is to generate economic value in a multi-stakeholder environment with competing incentives between agents. The represent humans, organisations or things. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic.","title":"What are AEAs?"},{"location":"aea/#what-is-the-aea-framework","text":"The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. It attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. AEAs achieve their goals with the help of the Open Economic Framework (OEF) - a decentralized communication and search & discovery system for agents - and using Fetch.ai's blockchain as a financial settlement and commitment layer. Third-party blockchains, such as Ethereum , may also allow AEA integration.","title":"What is the AEA Framework?"},{"location":"aea/#why-build-with-the-aea-framework","text":"The AEA framework provides the developer with a number of features which cannot be found in this combination anywhere else: the peer-to-peer agent communication network allows your AEAs to interact with all other AEAs over the public internet the search and discovery system sOEF allows your AEAs to find other agents the AEA registry enables code sharing and re-use the framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains reusability of code for interacting with blockchains is enabled via the contract packages","title":"Why build with the AEA Framework?"},{"location":"aea/#next-steps","text":"To get started developing your own AEA, check out the getting started section. To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . If you would like to develop an AEA in a language different to Python then check out our language agnostic AEA definition . If you would run a demo, check out the demo guides .","title":"Next steps"},{"location":"aea/#help-us-improve","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Slack channel .","title":"Help us improve"},{"location":"aea/acn/","text":"The agent communication network (ACN) provides a system for agents to find each other and communicate, solely based on their wallet addresses. It addresses the message delivery problem. Message delivery problem Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like to have are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agents framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints. Peers The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system. Distributed hash table At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer. N-tier architecture To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The `p2p_libp2p_mailbox` connection is not available yet. Trust and security An agent can choose which connection to use depending on the resource and trust requirements: p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Agent Communication Network"},{"location":"aea/acn/#message-delivery-problem","text":"Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like to have are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agents framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints.","title":"Message delivery problem"},{"location":"aea/acn/#peers","text":"The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system.","title":"Peers"},{"location":"aea/acn/#distributed-hash-table","text":"At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer.","title":"Distributed hash table"},{"location":"aea/acn/#n-tier-architecture","text":"To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The `p2p_libp2p_mailbox` connection is not available yet.","title":"N-tier architecture"},{"location":"aea/acn/#trust-and-security","text":"An agent can choose which connection to use depending on the resource and trust requirements: p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Trust and security"},{"location":"aea/aea-vs-mvc/","text":"The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails . MVC Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling Comparison to AEA framework The AEA framework is based on asynchronous messaging . Hence, there is not a direct 1-1 relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make progress in the AEA framework in particular, the development of Skills , quickly: Handler : receive the messages for the protocol they are registered against and are supposed to handle these messages. They are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates pro-active components of the agent. Since web apps do not have any goals or intentions they do not pro-actively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours can but do not have to send messages. Task : are meant to deal with long running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : implement business logic and data representation, as such they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services. Next steps We recommend you continue with the next step in the 'Getting Started' series: Build a skill for an AEA","title":"AEA and web frameworks"},{"location":"aea/aea-vs-mvc/#mvc","text":"Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling","title":"MVC"},{"location":"aea/aea-vs-mvc/#comparison-to-aea-framework","text":"The AEA framework is based on asynchronous messaging . Hence, there is not a direct 1-1 relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make progress in the AEA framework in particular, the development of Skills , quickly: Handler : receive the messages for the protocol they are registered against and are supposed to handle these messages. They are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates pro-active components of the agent. Since web apps do not have any goals or intentions they do not pro-actively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours can but do not have to send messages. Task : are meant to deal with long running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : implement business logic and data representation, as such they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services.","title":"Comparison to AEA framework"},{"location":"aea/aea-vs-mvc/#next-steps","text":"We recommend you continue with the next step in the 'Getting Started' series: Build a skill for an AEA","title":"Next steps"},{"location":"aea/agent-oriented-development/","text":"Agent-oriented development In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems. Decentralisation Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is of an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on a third party acting as an intermediary or match-maker. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. The conventional client-server model is an example of a centralized architecture where clients interact with one another regarding specific services (e.g. communication, commerce) only through a server. This is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the ' commanding reliance on middlemen ' that MAS rejects. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of the peers that create the infrastructure. Therefore, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. A notable characteristic of cryptocurrencies is the absence of central trusted entities (e.g. banks). But this in turn means that most security precautions related to the handling of digital assets and the execution of transactions are the responsibility of individuals. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do also tend to be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google or Microsoft's cloud infrastructure are examples of this, where their components are distributed across the globe yet designed to work together harmoniously and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of central authorities between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for. Conflicting Environment As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise. Asynchronisation The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks. Time Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour. Complex, Incomplete, Inconsistent and Uncertain The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment. Further Reading Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#agent-oriented-development","text":"In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#decentralisation","text":"Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is of an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on a third party acting as an intermediary or match-maker. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. The conventional client-server model is an example of a centralized architecture where clients interact with one another regarding specific services (e.g. communication, commerce) only through a server. This is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the ' commanding reliance on middlemen ' that MAS rejects. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of the peers that create the infrastructure. Therefore, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. A notable characteristic of cryptocurrencies is the absence of central trusted entities (e.g. banks). But this in turn means that most security precautions related to the handling of digital assets and the execution of transactions are the responsibility of individuals. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do also tend to be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google or Microsoft's cloud infrastructure are examples of this, where their components are distributed across the globe yet designed to work together harmoniously and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of central authorities between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.","title":"Decentralisation"},{"location":"aea/agent-oriented-development/#conflicting-environment","text":"As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise.","title":"Conflicting Environment"},{"location":"aea/agent-oriented-development/#asynchronisation","text":"The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks.","title":"Asynchronisation"},{"location":"aea/agent-oriented-development/#time","text":"Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour.","title":"Time"},{"location":"aea/agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","text":"The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Complex, Incomplete, Inconsistent and Uncertain"},{"location":"aea/agent-oriented-development/#further-reading","text":"Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Further Reading"},{"location":"aea/agent-vs-aea/","text":"AEAs are more than just agents. In this guide we show some of the differences in terms of code. The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the Agent class programmatically as well. First, import the python and application specific libraries. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage Unlike an AEA , an Agent does not require a Wallet , LedgerApis or Resources module. However, we need to implement 4 abstract methods: - setup() - act() - handle_envelope() - teardown() When we run an agent, start() calls setup() and then the main agent loop. The main agent loop calls act() , react() and update() on each tick. When the agent is stopped via stop() then teardown() is called. Such a lightweight agent can be used to implement simple logic. Code an Agent We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" pass def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if envelope is not None and envelope . protocol_id == DefaultMessage . protocol_id : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" pass Instantiate an Agent # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) Start the agent We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:0.11.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) Shutdown Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join () Your turn Now it is your turn to develop a simple agent with the Agent class. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" pass def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if envelope is not None and envelope . protocol_id == DefaultMessage . protocol_id : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" pass def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:0.11.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"AEAs vs agents"},{"location":"aea/agent-vs-aea/#code-an-agent","text":"We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" pass def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if envelope is not None and envelope . protocol_id == DefaultMessage . protocol_id : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" pass","title":"Code an Agent"},{"location":"aea/agent-vs-aea/#instantiate-an-agent","text":"# Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ])","title":"Instantiate an Agent"},{"location":"aea/agent-vs-aea/#start-the-agent","text":"We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the agent"},{"location":"aea/agent-vs-aea/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:0.11.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" ))","title":"Send and receive an envelope"},{"location":"aea/agent-vs-aea/#shutdown","text":"Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join ()","title":"Shutdown"},{"location":"aea/agent-vs-aea/#your-turn","text":"Now it is your turn to develop a simple agent with the Agent class.","title":"Your turn"},{"location":"aea/agent-vs-aea/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" pass def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if envelope is not None and envelope . protocol_id == DefaultMessage . protocol_id : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" pass def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:0.11.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/app-areas/","text":"An AEA is an intelligent agent whose goal is generating economic value for its owner. It can represent machines, humans (individuals or organisations), or data. General application areas As described in the guide on agent-oriented development , AEAs are designed to operate in an environment with: multiple stakeholders, which are represented by AEAs, that interact autonomously and communicate via a peer-to-peer network. There are at least five general application areas for AEAs: Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. An example is the thermometer agent that can be found here . Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. An example is the http skill in this agent. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. An example can be found here . Representative : an agent which represents an individual's activities on the Fetch.ai network. An example can be found here . Likely short-term applications In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well defined processes in supply chain, transport and finance. Micro transactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify the interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user. Multi-agent system versus agent-based modelling The Fetch.ai multi-agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also supported.","title":"Application areas"},{"location":"aea/app-areas/#general-application-areas","text":"As described in the guide on agent-oriented development , AEAs are designed to operate in an environment with: multiple stakeholders, which are represented by AEAs, that interact autonomously and communicate via a peer-to-peer network. There are at least five general application areas for AEAs: Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. An example is the thermometer agent that can be found here . Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. An example is the http skill in this agent. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. An example can be found here . Representative : an agent which represents an individual's activities on the Fetch.ai network. An example can be found here .","title":"General application areas"},{"location":"aea/app-areas/#likely-short-term-applications","text":"In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well defined processes in supply chain, transport and finance. Micro transactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify the interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user.","title":"Likely short-term applications"},{"location":"aea/app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The Fetch.ai multi-agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also supported.","title":"Multi-agent system versus agent-based modelling"},{"location":"aea/aries-cloud-agent-demo/","text":"Note This demo is incomplete and will soon be updated. Demonstrating an entire decentralised identity scenario involving AEAs and instances of Aries Cloud Agents (ACAs). Discussion This demo corresponds with the one here from Aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows P2P ID faea->>faca: Request status? faca->>faea: status faea->>faca: Register schema faca->>faea: schema_id faea->>faca: Register credential definition faca->>faea: credential_definition_id faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its P2P address in the terminal and waits for an invitation detail from Faber_AEA . Alice_AEA : registers itself on the SOEF. Faber_AEA : starts Faber_AEA : searches the SOEF and finds Alice_AEA . Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : registers a DID on the ledger. Faber_AEA : request Faber_ACA to register a schema on the ledger. Faber_ACA : responds by sending back the schema_id . Faber_AEA : request Faber_ACA to register a credential definition on the ledger. Faber_ACA : responds by sending back the credential_definition_id . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the P2P communication network accessed via the p2p_libp2p connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential. Preparation Instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent This demo has been successfully tested with aca-py version 0.4.5 . This demo requires an instance of von network running in docker locally (for more info see here ) This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number ad1f84f64d4f4c106a81462f5fbff496c5fbf10e ). Terminals Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo. VON Network In the first terminal move to the von-network directory and run an instance of von-network locally in docker. This tutorial has information on starting (and stopping) the network locally. ./manage build ./manage start --logs Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to http://localhost:9000 . Alice and Faber ACAs To learn about the command for starting an ACA and its various options: aca-py start --help Faber_ACA In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications. Alice_ACA In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032 Alice and Faber AEAs Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively. Alice_AEA In the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.19.0 cd aries_alice Alternatively, create from scratch. The following steps create **Alice_AEA** from scratch: aea create aries_alice cd aries_alice aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/webhook:0.12.0 aea add skill fetchai/aries_alice:0.15.0 Configure the aries_alice skill: (configuration file: alice/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.models.strategy.args.admin_port 8031 Configure the webhook connection: (configuration file: alice/vendor/fetchai/connections/webhook/connection.yaml ). First ensure the value of webhook_port matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure the p2p_libp2p connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11000\", \"entry_peers\": [], \"local_uri\": \"127.0.0.1:7000\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7000\" }' Install the Dependencies and Run Alice_AEA: Now install all the dependencies: aea install aea build Finally run Alice_AEA : aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) We will refer to this as Alice_AEA's P2P address . Faber_AEA In the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.19.0 cd aries_faber Alternatively, create from scratch. The following steps create **Faber_AEA** from scratch: aea create aries_faber cd aries_faber aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/webhook:0.12.0 aea add skill fetchai/aries_faber:0.14.0 Configure the aries_faber skill: (configuration file: faber/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with those you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.models.strategy.args.admin_port 8021 Configure the webhook connection: (configuration file: faber/vendor/fetchai/connections/webhook/connection.yaml ). First, ensure the value of webhook_port matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure the p2p_libp2p connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:7001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7001\" }' where SOME_ADDRESS is Alice_AEA's P2P address as displayed in the third terminal. Install the Dependencies and Run Faber_AEA: Now install all the dependencies: aea install aea build Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved. Terminate and Delete the Agents You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice Further developments In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Aries Cloud Agents Demo"},{"location":"aea/aries-cloud-agent-demo/#discussion","text":"This demo corresponds with the one here from Aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows P2P ID faea->>faca: Request status? faca->>faea: status faea->>faca: Register schema faca->>faea: schema_id faea->>faca: Register credential definition faca->>faea: credential_definition_id faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its P2P address in the terminal and waits for an invitation detail from Faber_AEA . Alice_AEA : registers itself on the SOEF. Faber_AEA : starts Faber_AEA : searches the SOEF and finds Alice_AEA . Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : registers a DID on the ledger. Faber_AEA : request Faber_ACA to register a schema on the ledger. Faber_ACA : responds by sending back the schema_id . Faber_AEA : request Faber_ACA to register a credential definition on the ledger. Faber_ACA : responds by sending back the credential_definition_id . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the P2P communication network accessed via the p2p_libp2p connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential.","title":"Discussion"},{"location":"aea/aries-cloud-agent-demo/#preparation-instructions","text":"","title":"Preparation Instructions"},{"location":"aea/aries-cloud-agent-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent This demo has been successfully tested with aca-py version 0.4.5 . This demo requires an instance of von network running in docker locally (for more info see here ) This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number ad1f84f64d4f4c106a81462f5fbff496c5fbf10e ).","title":"Dependencies"},{"location":"aea/aries-cloud-agent-demo/#terminals","text":"Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo.","title":"Terminals"},{"location":"aea/aries-cloud-agent-demo/#von-network","text":"In the first terminal move to the von-network directory and run an instance of von-network locally in docker. This tutorial has information on starting (and stopping) the network locally. ./manage build ./manage start --logs Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to http://localhost:9000 .","title":"VON Network"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-acas","text":"To learn about the command for starting an ACA and its various options: aca-py start --help","title":"Alice and Faber ACAs"},{"location":"aea/aries-cloud-agent-demo/#faber_aca","text":"In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications.","title":"Faber_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice_aca","text":"In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032","title":"Alice_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-aeas","text":"Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively.","title":"Alice and Faber AEAs"},{"location":"aea/aries-cloud-agent-demo/#alice_aea","text":"In the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.19.0 cd aries_alice Alternatively, create from scratch. The following steps create **Alice_AEA** from scratch: aea create aries_alice cd aries_alice aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/webhook:0.12.0 aea add skill fetchai/aries_alice:0.15.0","title":"Alice_AEA"},{"location":"aea/aries-cloud-agent-demo/#configure-the-aries_alice-skill","text":"(configuration file: alice/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.models.strategy.args.admin_port 8031","title":"Configure the aries_alice skill:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-webhook-connection","text":"(configuration file: alice/vendor/fetchai/connections/webhook/connection.yaml ). First ensure the value of webhook_port matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the webhook connection:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection","text":"aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11000\", \"entry_peers\": [], \"local_uri\": \"127.0.0.1:7000\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7000\" }'","title":"Configure the p2p_libp2p connection:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-alice_aea","text":"Now install all the dependencies: aea install aea build Finally run Alice_AEA : aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) We will refer to this as Alice_AEA's P2P address .","title":"Install the Dependencies and Run Alice_AEA:"},{"location":"aea/aries-cloud-agent-demo/#faber_aea","text":"In the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.19.0 cd aries_faber Alternatively, create from scratch. The following steps create **Faber_AEA** from scratch: aea create aries_faber cd aries_faber aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/webhook:0.12.0 aea add skill fetchai/aries_faber:0.14.0","title":"Faber_AEA"},{"location":"aea/aries-cloud-agent-demo/#configure-the-aries_faber-skill","text":"(configuration file: faber/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with those you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.models.strategy.args.admin_port 8021","title":"Configure the aries_faber skill:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-webhook-connection_1","text":"(configuration file: faber/vendor/fetchai/connections/webhook/connection.yaml ). First, ensure the value of webhook_port matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the webhook connection:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection_1","text":"aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:7001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7001\" }' where SOME_ADDRESS is Alice_AEA's P2P address as displayed in the third terminal.","title":"Configure the p2p_libp2p connection:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-faber_aea","text":"Now install all the dependencies: aea install aea build Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved.","title":"Install the Dependencies and Run Faber_AEA:"},{"location":"aea/aries-cloud-agent-demo/#terminate-and-delete-the-agents","text":"You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice","title":"Terminate and Delete the Agents"},{"location":"aea/aries-cloud-agent-demo/#further-developments","text":"In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Further developments"},{"location":"aea/build-aea-programmatically/","text":"These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. Preparation Get the packages directory from the AEA repository: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) Create a private key We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Clearing the input and output files We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) Initialise the AEA We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:0.11.0 protocol, the fetchai/stub:0.15.0 connection and the fetchai/error:0.11.0 skill. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build () Start the AEA We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) Send and receive an envelope We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:0.11.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) Shutdown Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None Running the AEA If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.11.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:0.11.0,...\\x05hello Entire code listing If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:0.11.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Build an AEA programmatically"},{"location":"aea/build-aea-programmatically/#preparation","text":"Get the packages directory from the AEA repository: svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Preparation"},{"location":"aea/build-aea-programmatically/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier )","title":"Imports"},{"location":"aea/build-aea-programmatically/#create-a-private-key","text":"We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE )","title":"Create a private key"},{"location":"aea/build-aea-programmatically/#clearing-the-input-and-output-files","text":"We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE )","title":"Clearing the input and output files"},{"location":"aea/build-aea-programmatically/#initialise-the-aea","text":"We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:0.11.0 protocol, the fetchai/stub:0.15.0 connection and the fetchai/error:0.11.0 skill. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build ()","title":"Initialise the AEA"},{"location":"aea/build-aea-programmatically/#start-the-aea","text":"We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 )","title":"Start the AEA"},{"location":"aea/build-aea-programmatically/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:0.11.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/build-aea-programmatically/#shutdown","text":"Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None","title":"Shutdown"},{"location":"aea/build-aea-programmatically/#running-the-aea","text":"If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.11.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:0.11.0,...\\x05hello","title":"Running the AEA"},{"location":"aea/build-aea-programmatically/#entire-code-listing","text":"If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:0.11.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/build-aea-step-by-step/","text":"Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first): Set up your AEA project with the CLI: `aea create my_aea && cd my_aea` Look at, then add the right connections for your use case: `aea search connections`, then `aea add connection [public_id]` Look for, then add or generate the protocols you require: `aea search protocols`, then `aea add protocol [public_id]` or `aea generate protocol [path_to_specification]` Look for, then add or code the skills you need: `aea search skills`, then `aea add skill [public_id]`. This guide shows you step by step how to develop a skill. Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator . Now, run your AEA: `aea run --connections [public_id]` See information on the CLI tool here for all the available commands.","title":"Build an AEA with the CLI"},{"location":"aea/car-park-skills/","text":"The AEA car-park skills demonstrate an interaction between two AEAs. The carpark_detection AEA provides information on the number of car parking spaces available in a given vicinity. The carpark_client AEA is interested in purchasing information on available car parking spaces in the same vicinity. Discussion The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information. Communication This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create car detector AEA First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.20.0 cd car_detector aea install aea build Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/carpark_detection:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Create car data buyer AEA Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.21.0 cd car_data_buyer aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/carpark_client:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Add keys for the car data seller AEA First, create the private key for the car data seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the car data buyer AEA The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the AEAs Run both AEAs from their respective terminals. First, run the car data seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the car data seller. Then, in the car data buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the car data buyer to connect to the same local agent communication network as the car data seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Cleaning up When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Car park skills"},{"location":"aea/car-park-skills/#discussion","text":"The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information.","title":"Discussion"},{"location":"aea/car-park-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/car-park-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/car-park-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/car-park-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/car-park-skills/#create-car-detector-aea","text":"First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.20.0 cd car_detector aea install aea build Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/carpark_detection:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create car detector AEA"},{"location":"aea/car-park-skills/#create-car-data-buyer-aea","text":"Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.21.0 cd car_data_buyer aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/carpark_client:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create car data buyer AEA"},{"location":"aea/car-park-skills/#add-keys-for-the-car-data-seller-aea","text":"First, create the private key for the car data seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the car data seller AEA"},{"location":"aea/car-park-skills/#add-keys-and-generate-wealth-for-the-car-data-buyer-aea","text":"The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the car data buyer AEA"},{"location":"aea/car-park-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. First, run the car data seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the car data seller. Then, in the car data buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the car data buyer to connect to the same local agent communication network as the car data seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/car-park-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Cleaning up"},{"location":"aea/cli-commands/","text":"CLI commands Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-wealth [ledger_id] Get the wealth associated with the private key. gui Run the GUI. init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) interact Interact with a running AEA via the stub connection. issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag `--skip-consistency-check`. E.g. `aea --skip-consistency-check run` will bypass the fingerprint checks.","title":"Commands"},{"location":"aea/cli-commands/#cli-commands","text":"Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-wealth [ledger_id] Get the wealth associated with the private key. gui Run the GUI. init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) interact Interact with a running AEA via the stub connection. issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag `--skip-consistency-check`. E.g. `aea --skip-consistency-check run` will bypass the fingerprint checks.","title":"CLI commands"},{"location":"aea/cli-gui/","text":"You can invoke the AEA Command Line Interface (CLI) from a Graphical User Interface (GUI) accessed from a web browser. These instructions will take you through building an AEA and running the AEA - all from the GUI. Preliminaries Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ] Starting the GUI Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . It is important to start the GUI not from within an agent project but its parent directory instead. Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea . Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"GUI"},{"location":"aea/cli-gui/#preliminaries","text":"Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ]","title":"Preliminaries"},{"location":"aea/cli-gui/#starting-the-gui","text":"Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . It is important to start the GUI not from within an agent project but its parent directory instead. Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea . Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"Starting the GUI"},{"location":"aea/cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool. Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Installation"},{"location":"aea/cli-how-to/#installation","text":"The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool.","title":"Installation"},{"location":"aea/cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Troubleshooting"},{"location":"aea/cli-vs-programmatic-aeas/","text":"The AEA framework enables us to create agents either from the CLI tool or programmatically. The following demo demonstrates an interaction between two AEAs. The provider of weather data (managed with the CLI). The buyer of weather data (managed programmatically). Discussion The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction. Get required packages Copy the packages directory into your local working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Demo instructions If you want to create the weather station AEA step by step you can follow this guide here Create the weather station AEA Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.20.0 cd weather_station Update the AEA configurations In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Add keys Add a private key for the weather station. aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the weather station AEA aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. Create the weather client AEA Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea.aea import AEA from aea.aea_builder import AEABuilder from aea.configurations.base import ConnectionConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import ( PRIVATE_KEY_PATH_SCHEMA , create_private_key , make_certificate , ) from aea.crypto.wallet import Wallet from aea.helpers.base import CertRequest from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill import packages.fetchai.connections.p2p_libp2p.connection from packages.fetchai.connections.ledger.connection import LedgerConnection from packages.fetchai.connections.p2p_libp2p.connection import P2PLibp2pConnection from packages.fetchai.connections.soef.connection import SOEFConnection from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.weather_client.strategy import Strategy API_KEY = \"TwiCIriSl0mLahw17pyqoA\" SOEF_ADDR = \"soef.fetch.ai\" SOEF_PORT = 9002 ENTRY_PEER_ADDRESS = ( \"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAmLBCAqHL8SuFosyDhAKYsLKXBZBWXBsB9oFw2qU4Kckun\" ) FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) FETCHAI_PRIVATE_KEY_FILE_CONNECTION = PRIVATE_KEY_PATH_SCHEMA . format ( \"fetchai_connection\" ) ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_CONNECTION ) # Set up the wallet, identity and (empty) resources wallet = Wallet ( private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }, connection_private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_CONNECTION }, ) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ) ) resources = Resources () # specify the default routing for some protocols default_routing = { LedgerApiMessage . protocol_id : LedgerConnection . connection_id , OefSearchMessage . protocol_id : SOEFConnection . connection_id , } default_connection = P2PLibp2pConnection . connection_id # create the AEA my_aea = AEA ( identity , wallet , resources , default_connection = default_connection , default_routing = default_routing , ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"default\" ) ) resources . add_protocol ( default_protocol ) # Add the signing protocol (which is part of the AEA distribution) signing_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"signing\" ) ) resources . add_protocol ( signing_protocol ) # Add the ledger_api protocol ledger_api_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"ledger_api\" ,) ) resources . add_protocol ( ledger_api_protocol ) # Add the oef_search protocol oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the LedgerAPI connection configuration = ConnectionConfig ( connection_id = LedgerConnection . connection_id ) ledger_api_connection = LedgerConnection ( configuration = configuration , identity = identity ) resources . add_connection ( ledger_api_connection ) # Add the P2P connection cert_path = \".certs/conn_cert.txt\" cert_request = CertRequest ( identifier = \"acn\" , ledger_id = FetchAICrypto . identifier , not_after = \"2022-01-01\" , not_before = \"2021-01-01\" , public_key = \"fetchai\" , save_path = cert_path , ) public_key = wallet . connection_cryptos . public_keys . get ( FetchAICrypto . identifier ) message = cert_request . get_message ( public_key ) make_certificate ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE , message , cert_path ) configuration = ConnectionConfig ( connection_id = P2PLibp2pConnection . connection_id , delegate_uri = \"127.0.0.1:11001\" , entry_peers = [ ENTRY_PEER_ADDRESS ], local_uri = \"127.0.0.1:9001\" , log_file = \"libp2p_node.log\" , public_uri = \"127.0.0.1:9001\" , build_directory = os . getcwd (), build_entrypoint = \"check_dependencies.py\" , cert_requests = [ cert_request ], ) configuration . directory = os . path . dirname ( packages . fetchai . connections . p2p_libp2p . connection . __file__ ) AEABuilder . run_build_for_component_configuration ( configuration ) p2p_connection = P2PLibp2pConnection ( configuration = configuration , identity = identity , crypto_store = wallet . connection_cryptos , ) resources . add_connection ( p2p_connection ) # Add the SOEF connection configuration = ConnectionConfig ( api_key = API_KEY , soef_addr = SOEF_ADDR , soef_port = SOEF_PORT , restricted_to_protocols = { OefSearchMessage . protocol_id }, connection_id = SOEFConnection . connection_id , ) soef_connection = SOEFConnection ( configuration = configuration , identity = identity ) resources . add_connection ( soef_connection ) # Add the error and weather_client skills error_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"error\" ), agent_context = my_aea . context , ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), agent_context = my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . _is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Run the AEA try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () Now replace ENTRY_PEER_ADDRESS with the peer address ( SOME_ADDRESS ) noted above. For more details on how to create an agent programmatically follow this guide here . Run the weather station AEA In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"CLI vs programmatic AEAs"},{"location":"aea/cli-vs-programmatic-aeas/#discussion","text":"The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction.","title":"Discussion"},{"location":"aea/cli-vs-programmatic-aeas/#get-required-packages","text":"Copy the packages directory into your local working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Get required packages"},{"location":"aea/cli-vs-programmatic-aeas/#demo-instructions","text":"If you want to create the weather station AEA step by step you can follow this guide here","title":"Demo instructions"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-station-aea","text":"Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.20.0 cd weather_station","title":"Create the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#update-the-aea-configurations","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configurations"},{"location":"aea/cli-vs-programmatic-aeas/#add-keys","text":"Add a private key for the weather station. aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea","text":"aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address.","title":"Run the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-client-aea","text":"Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea.aea import AEA from aea.aea_builder import AEABuilder from aea.configurations.base import ConnectionConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import ( PRIVATE_KEY_PATH_SCHEMA , create_private_key , make_certificate , ) from aea.crypto.wallet import Wallet from aea.helpers.base import CertRequest from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill import packages.fetchai.connections.p2p_libp2p.connection from packages.fetchai.connections.ledger.connection import LedgerConnection from packages.fetchai.connections.p2p_libp2p.connection import P2PLibp2pConnection from packages.fetchai.connections.soef.connection import SOEFConnection from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.weather_client.strategy import Strategy API_KEY = \"TwiCIriSl0mLahw17pyqoA\" SOEF_ADDR = \"soef.fetch.ai\" SOEF_PORT = 9002 ENTRY_PEER_ADDRESS = ( \"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAmLBCAqHL8SuFosyDhAKYsLKXBZBWXBsB9oFw2qU4Kckun\" ) FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) FETCHAI_PRIVATE_KEY_FILE_CONNECTION = PRIVATE_KEY_PATH_SCHEMA . format ( \"fetchai_connection\" ) ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_CONNECTION ) # Set up the wallet, identity and (empty) resources wallet = Wallet ( private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }, connection_private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_CONNECTION }, ) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ) ) resources = Resources () # specify the default routing for some protocols default_routing = { LedgerApiMessage . protocol_id : LedgerConnection . connection_id , OefSearchMessage . protocol_id : SOEFConnection . connection_id , } default_connection = P2PLibp2pConnection . connection_id # create the AEA my_aea = AEA ( identity , wallet , resources , default_connection = default_connection , default_routing = default_routing , ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"default\" ) ) resources . add_protocol ( default_protocol ) # Add the signing protocol (which is part of the AEA distribution) signing_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"signing\" ) ) resources . add_protocol ( signing_protocol ) # Add the ledger_api protocol ledger_api_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"ledger_api\" ,) ) resources . add_protocol ( ledger_api_protocol ) # Add the oef_search protocol oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the LedgerAPI connection configuration = ConnectionConfig ( connection_id = LedgerConnection . connection_id ) ledger_api_connection = LedgerConnection ( configuration = configuration , identity = identity ) resources . add_connection ( ledger_api_connection ) # Add the P2P connection cert_path = \".certs/conn_cert.txt\" cert_request = CertRequest ( identifier = \"acn\" , ledger_id = FetchAICrypto . identifier , not_after = \"2022-01-01\" , not_before = \"2021-01-01\" , public_key = \"fetchai\" , save_path = cert_path , ) public_key = wallet . connection_cryptos . public_keys . get ( FetchAICrypto . identifier ) message = cert_request . get_message ( public_key ) make_certificate ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE , message , cert_path ) configuration = ConnectionConfig ( connection_id = P2PLibp2pConnection . connection_id , delegate_uri = \"127.0.0.1:11001\" , entry_peers = [ ENTRY_PEER_ADDRESS ], local_uri = \"127.0.0.1:9001\" , log_file = \"libp2p_node.log\" , public_uri = \"127.0.0.1:9001\" , build_directory = os . getcwd (), build_entrypoint = \"check_dependencies.py\" , cert_requests = [ cert_request ], ) configuration . directory = os . path . dirname ( packages . fetchai . connections . p2p_libp2p . connection . __file__ ) AEABuilder . run_build_for_component_configuration ( configuration ) p2p_connection = P2PLibp2pConnection ( configuration = configuration , identity = identity , crypto_store = wallet . connection_cryptos , ) resources . add_connection ( p2p_connection ) # Add the SOEF connection configuration = ConnectionConfig ( api_key = API_KEY , soef_addr = SOEF_ADDR , soef_port = SOEF_PORT , restricted_to_protocols = { OefSearchMessage . protocol_id }, connection_id = SOEFConnection . connection_id , ) soef_connection = SOEFConnection ( configuration = configuration , identity = identity ) resources . add_connection ( soef_connection ) # Add the error and weather_client skills error_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"error\" ), agent_context = my_aea . context , ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), agent_context = my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . _is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Run the AEA try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () Now replace ENTRY_PEER_ADDRESS with the peer address ( SOME_ADDRESS ) noted above. For more details on how to create an agent programmatically follow this guide here .","title":"Create the weather client AEA"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea_1","text":"In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"Run the weather station AEA"},{"location":"aea/config/","text":"This document describes the configuration files of the different packages. AEA configuration YAML The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.15.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:0.11.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.11.0 default_connection : fetchai/p2p_libp2p:0.14.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 registry_path : ../packages # The path to the local package registry (must be a directory path and point to a directory called `packages`) The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar Connection configuration YAML The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. is_abstract : false # An optional boolean that if `true` makes the connection Contract configuration YAML The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. Protocol configuration YAML The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. Skill configuration YAML The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on.","title":"Configurations"},{"location":"aea/config/#aea-configuration-yaml","text":"The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.15.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:0.11.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.11.0 default_connection : fetchai/p2p_libp2p:0.14.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 registry_path : ../packages # The path to the local package registry (must be a directory path and point to a directory called `packages`) The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar","title":"AEA configuration YAML"},{"location":"aea/config/#connection-configuration-yaml","text":"The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. is_abstract : false # An optional boolean that if `true` makes the connection","title":"Connection configuration YAML"},{"location":"aea/config/#contract-configuration-yaml","text":"The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on.","title":"Contract configuration YAML"},{"location":"aea/config/#protocol-configuration-yaml","text":"The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on.","title":"Protocol configuration YAML"},{"location":"aea/config/#skill-configuration-yaml","text":"The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=0.9.0, <0.10.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on.","title":"Skill configuration YAML"},{"location":"aea/connect-a-frontend/","text":"This demo discusses the options we have to connect a front-end to the AEA. The following diagram illustrates the two options we are going to discuss. Case 1 The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Server Connection package. The rest API should send CRUD requests to the HTTP Server Connection ( fetchai/http_server:0.15.0 ) which translates these into Envelopes to be consumed by the correct skill. Case 2 The other option we have is to create a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.14.0 ). In this scenario, the front-end needs to incorporate a Multiplexer with an P2P Connection. Then the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Front-end intergration"},{"location":"aea/connect-a-frontend/#case-1","text":"The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Server Connection package. The rest API should send CRUD requests to the HTTP Server Connection ( fetchai/http_server:0.15.0 ) which translates these into Envelopes to be consumed by the correct skill.","title":"Case 1"},{"location":"aea/connect-a-frontend/#case-2","text":"The other option we have is to create a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.14.0 ). In this scenario, the front-end needs to incorporate a Multiplexer with an P2P Connection. Then the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Case 2"},{"location":"aea/connection/","text":"A Connection wraps an SDK or API and provides an interface to network, ledgers and other services. As such a connection is concerned with I/O bound and continuously connected operations. Where necessary, a connection is responsible for translating between the framework specific protocol (an Envelope with its contained Message ) and the external service or third-party protocol (e.g. HTTP ). The messages constructed or received by a connection are eventually processed by one or several skills which deal with handling and generating messages related to a specific business objective. The framework provides one default connection, called stub . It implements an I/O reader and writer to send messages to the agent from a local file. Additional connections can be added as packages. An AEA can interact with multiple connections at the same time via the Multiplexer . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing envelopes and their contained messages. Configuration The connection.yaml file of a connection package contains meta information on the connection as well as all the required configuration details. For more details have a look here Developing your own The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py , containing the scaffolded connection class connection.yaml , containing the scaffolded configuration file Primary methods to develop The scaffolded connection.py file contains a single class inherited from the Connection base class. The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time when the Multiplexer handles an outgoing envelope specified to be handled by the connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent and if necessary its translation into a relevant protocol. When developing your own connection you might benefit from inspecting the fetchai/http_server:0.15.0 and fetchai/http_client:0.16.0 connections to gain more familiarity and inspiration. Configuration options The connection.yaml files contains a number of fields required to be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is available in the constructor of the connection excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Connections"},{"location":"aea/connection/#configuration","text":"The connection.yaml file of a connection package contains meta information on the connection as well as all the required configuration details. For more details have a look here","title":"Configuration"},{"location":"aea/connection/#developing-your-own","text":"The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py , containing the scaffolded connection class connection.yaml , containing the scaffolded configuration file","title":"Developing your own"},{"location":"aea/connection/#primary-methods-to-develop","text":"The scaffolded connection.py file contains a single class inherited from the Connection base class. The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time when the Multiplexer handles an outgoing envelope specified to be handled by the connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent and if necessary its translation into a relevant protocol. When developing your own connection you might benefit from inspecting the fetchai/http_server:0.15.0 and fetchai/http_client:0.16.0 connections to gain more familiarity and inspiration.","title":"Primary methods to develop"},{"location":"aea/connection/#configuration-options","text":"The connection.yaml files contains a number of fields required to be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is available in the constructor of the connection excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Configuration options"},{"location":"aea/contract/","text":"Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract and its byte code. They implement a translation between framework messages (in the fetchai/contract_api:0.10.0 protocol) and the implementation specifics of the ABI. Contracts usually implement four types of methods: a method to create a smart contract deployment transaction, methods to create transactions to modify state in the deployed smart contract, methods to create contract calls to execute static methods on the deployed smart contract, and methods to query the state of the deployed smart contract. Contracts can be added as packages which means they become reusable across AEA projects. The smart contract wrapped in a AEA contract package might be a third-party smart contract or your own smart contract potentially interacting with a third-party contract on-chain. Interacting with contracts from skills Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.12.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.12.0 connection via the fetchai/contract_api:0.10.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the `store` and `init` messages use the `ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION` performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an `init` transaction requires the keyword arguments `code_id` (integer), `label` (string), `amount` (integer) and `init_msg` (JSON). For an example look at the `fetchai/erc1155:0.15.0` package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. In this case, signing is not required. Developing your own The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . getTransactionCount ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.12.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.15.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.21.0 , for inspiration and guidance.","title":"Contracts"},{"location":"aea/contract/#interacting-with-contracts-from-skills","text":"Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.12.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.12.0 connection via the fetchai/contract_api:0.10.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the `store` and `init` messages use the `ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION` performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an `init` transaction requires the keyword arguments `code_id` (integer), `label` (string), `amount` (integer) and `init_msg` (JSON). For an example look at the `fetchai/erc1155:0.15.0` package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.15.0 package, we send the following message to the fetchai/ledger:0.12.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.15.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.12.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.15.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.12.0 connection using the fetchai/ledger_api:0.9.0 protocol. In this case, signing is not required.","title":"Interacting with contracts from skills"},{"location":"aea/contract/#developing-your-own","text":"The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . getTransactionCount ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.12.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.15.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.21.0 , for inspiration and guidance.","title":"Developing your own"},{"location":"aea/core-components-1/","text":"The AEA framework consists of several core elements, some of which are required to run an AEA and others which are optional. The following sections discuss the use of the AEA framework, in particular its dominant usage where the framework is in charge of calling the code in custom packages (see inversion of control ). Whilst it is in principle possible to use parts of the framework as a library, we do not recommend it. The elements each AEA uses AEAs communicate asynchronously via Envelopes . Envelope An Envelope is the core object with which agents communicate. It is a vehicle for Messages with five attributes: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol . Protocol Protocols define agent-to-agent as well as component-to-component interactions within agents. As such, they include: Messages , which define the representation; serialization logic, which define how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called default (current version fetchai/default:0.11.0 ). This Protocol provides a bare-bones implementation for an AEA Protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional Protocols - i.e. a new type of interaction - can be added as packages and generated with the protocol generator . For more details on Protocols also read the Protocol guide here . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections . Connection A Connection wraps an SDK or API and provides an interface to network, ledgers and other services. Where necessary, a Connection is responsible for translating between the framework specific Envelope with its contained Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.15.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections also read the Connection guide here . An AEA can run Connections via a Multiplexer . Multiplexer The Multiplexer is responsible for maintaining potentially multiple Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills . Skill Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has none, one or more Handler objects, each responsible for the registered messaging Protocol . Handlers implement AEAs' reactive behaviour. If the AEA understands the Protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding Message . Each Handler is responsible for only one Protocol . Behaviour : none, one or more Behaviours encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.). Model : none, one or more Models that inherit from the Model can be accessed via the SkillContext . Task : none, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) the state of the the AEA (as summarised in the AgentContext ), and suggest actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each Skill corresponds to a different trading strategy. The Skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) or complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills also read the Skill guide here . Main loop The main AgentLoop performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . update() : this function dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill . Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Core components - Part 1"},{"location":"aea/core-components-1/#the-elements-each-aea-uses","text":"AEAs communicate asynchronously via Envelopes .","title":"The elements each AEA uses"},{"location":"aea/core-components-1/#envelope","text":"An Envelope is the core object with which agents communicate. It is a vehicle for Messages with five attributes: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol .","title":"Envelope"},{"location":"aea/core-components-1/#protocol","text":"Protocols define agent-to-agent as well as component-to-component interactions within agents. As such, they include: Messages , which define the representation; serialization logic, which define how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called default (current version fetchai/default:0.11.0 ). This Protocol provides a bare-bones implementation for an AEA Protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional Protocols - i.e. a new type of interaction - can be added as packages and generated with the protocol generator . For more details on Protocols also read the Protocol guide here . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections .","title":"Protocol"},{"location":"aea/core-components-1/#connection","text":"A Connection wraps an SDK or API and provides an interface to network, ledgers and other services. Where necessary, a Connection is responsible for translating between the framework specific Envelope with its contained Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.15.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections also read the Connection guide here . An AEA can run Connections via a Multiplexer .","title":"Connection"},{"location":"aea/core-components-1/#multiplexer","text":"The Multiplexer is responsible for maintaining potentially multiple Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills .","title":"Multiplexer"},{"location":"aea/core-components-1/#skill","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has none, one or more Handler objects, each responsible for the registered messaging Protocol . Handlers implement AEAs' reactive behaviour. If the AEA understands the Protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding Message . Each Handler is responsible for only one Protocol . Behaviour : none, one or more Behaviours encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.). Model : none, one or more Models that inherit from the Model can be accessed via the SkillContext . Task : none, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) the state of the the AEA (as summarised in the AgentContext ), and suggest actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each Skill corresponds to a different trading strategy. The Skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) or complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills also read the Skill guide here .","title":"Skill"},{"location":"aea/core-components-1/#main-loop","text":"The main AgentLoop performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . update() : this function dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill .","title":"Main loop"},{"location":"aea/core-components-1/#next-steps","text":"","title":"Next steps"},{"location":"aea/core-components-1/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks","title":"Recommended"},{"location":"aea/core-components-1/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"aea/core-components-2/","text":"The AEA framework consists of several core elements, some of which are required to run an AEA and others which are optional. The advanced elements AEAs use In Core Components - Part 1 we discussed the elements each AEA uses. We will now look at some of the advanced elements each AEA uses. Decision Maker The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the Wallet 's private keys. You can learn more about the decision maker here . In the simplest form, it acts like a Handler with a Wallet . Wallet The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. Identity The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext . Optional elements AEAs use Contracts Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions. Contracts can be added as packages. For more details on Contracts also read the Contract guide here . Putting it together Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA: Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols Relevant deep-dives Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other aims. You can learn more about the Contracts agents use in the following section: Contracts","title":"Core components - Part 2"},{"location":"aea/core-components-2/#the-advanced-elements-aeas-use","text":"In Core Components - Part 1 we discussed the elements each AEA uses. We will now look at some of the advanced elements each AEA uses.","title":"The advanced elements AEAs use"},{"location":"aea/core-components-2/#decision-maker","text":"The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the Wallet 's private keys. You can learn more about the decision maker here . In the simplest form, it acts like a Handler with a Wallet .","title":"Decision Maker"},{"location":"aea/core-components-2/#wallet","text":"The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does.","title":"Wallet"},{"location":"aea/core-components-2/#identity","text":"The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext .","title":"Identity"},{"location":"aea/core-components-2/#optional-elements-aeas-use","text":"","title":"Optional elements AEAs use"},{"location":"aea/core-components-2/#contracts","text":"Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions. Contracts can be added as packages. For more details on Contracts also read the Contract guide here .","title":"Contracts"},{"location":"aea/core-components-2/#putting-it-together","text":"Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA:","title":"Putting it together"},{"location":"aea/core-components-2/#next-steps","text":"","title":"Next steps"},{"location":"aea/core-components-2/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols","title":"Recommended"},{"location":"aea/core-components-2/#relevant-deep-dives","text":"Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other aims. You can learn more about the Contracts agents use in the following section: Contracts","title":"Relevant deep-dives"},{"location":"aea/debug/","text":"There are multiple ways in which to configure your AEA for debugging during development. We focus on the standard Python approach here. Using pdb stdlib You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation . Using an IDE: For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV_PACKAGES/aea/cli/__main__.py\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV_PACKAGES should be replaced with the path to the virtual environment's packages and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Debugging"},{"location":"aea/debug/#using-pdb-stdlib","text":"You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation .","title":"Using pdb stdlib"},{"location":"aea/debug/#using-an-ide","text":"For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV_PACKAGES/aea/cli/__main__.py\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV_PACKAGES should be replaced with the path to the virtual environment's packages and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Using an IDE:"},{"location":"aea/decision-maker-transaction/","text":"This guide can be considered as a part 2 of the the stand-alone transaction demo . The main difference is that now we are going to use the decision-maker to sign the transaction. First, import the libraries and the set the constant values. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create a private key and an AEA To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () Add a simple skill Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) Create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) Create the signing message Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) Run the agent Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction. More details To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"Create decision-maker transaction"},{"location":"aea/decision-maker-transaction/#create-a-private-key-and-an-aea","text":"To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build ()","title":"Create a private key and an AEA"},{"location":"aea/decision-maker-transaction/#add-a-simple-skill","text":"Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill )","title":"Add a simple skill"},{"location":"aea/decision-maker-transaction/#create-a-second-identity","text":"create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , )","title":"Create a second identity"},{"location":"aea/decision-maker-transaction/#create-the-signing-message","text":"Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg )","title":"Create the signing message"},{"location":"aea/decision-maker-transaction/#run-the-agent","text":"Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction.","title":"Run the agent"},{"location":"aea/decision-maker-transaction/#more-details","text":"To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"More details"},{"location":"aea/decision-maker/","text":"The DecisionMaker can be thought of like a wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the wallet's private keys. Interaction with skills Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. StateUpdateMessage : it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message Custom DecisionMaker The framework implements a default DecisionMakerHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change.","title":"Decision Maker"},{"location":"aea/decision-maker/#interaction-with-skills","text":"Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. StateUpdateMessage : it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message","title":"Interaction with skills"},{"location":"aea/decision-maker/#custom-decisionmaker","text":"The framework implements a default DecisionMakerHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change.","title":"Custom DecisionMaker"},{"location":"aea/defining-data-models/","text":"In this section, we explain how to define data models , an important component of the OEF Search & Discovery. It allows agents to describe themselves and to discover the services/resources they are interested in. In a sentence, a DataModel is a set of attributes , and a Description of a service/resource is an assignment of those attributes. All you need to specify data models and descriptions (that is, instances of the data model) can be found in the aea.helpers.search module. Attributes At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search.models import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute. Data models A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search.models import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model. Description A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from aea.helpers.search.models import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Defining Data Models"},{"location":"aea/defining-data-models/#attributes","text":"At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search.models import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute.","title":"Attributes"},{"location":"aea/defining-data-models/#data-models","text":"A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search.models import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model.","title":"Data models"},{"location":"aea/defining-data-models/#description","text":"A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from aea.helpers.search.models import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Description"},{"location":"aea/demos/","text":"We provide demo guides for multiple use-cases, each one involving several AEAs interacting in a different scenario. These demos serve to highlight the concept of AEAs as well as provide inspiration for developers. Demos should not be taken as production ready software, although every care is taken to fix bugs when reported. Demos are alphabetically sorted, we recommend you start with the weather skills demo .","title":"Demos"},{"location":"aea/deployment/","text":"The easiest way to run an AEA is using your development environment. If you would like to run an AEA from a browser you can use Google Colab . This gist can be opened in Colab and implements the quick start . For deployment, we recommend you use Docker . Building a Docker Image First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/fetchai/agents-aea/branches/master/deploy-image cd deploy-image rm -rf scripts svn export https://github.com/fetchai/docker-images/branches/master/scripts cd .. Next, we build the image: ./deploy-image/scripts/docker-build-img.sh -t aea-deploy:latest -- Running a Docker Image Finally, we run it: docker run -it aea-deploy:latest This will run the fetchai/my_first_aea:0.18.0 demo project. You can edit entrypoint.sh to run whatever project you would like. Deployment Note This section is incomplete and will soon be updated.","title":"Deployment"},{"location":"aea/deployment/#building-a-docker-image","text":"First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/fetchai/agents-aea/branches/master/deploy-image cd deploy-image rm -rf scripts svn export https://github.com/fetchai/docker-images/branches/master/scripts cd .. Next, we build the image: ./deploy-image/scripts/docker-build-img.sh -t aea-deploy:latest --","title":"Building a Docker Image"},{"location":"aea/deployment/#running-a-docker-image","text":"Finally, we run it: docker run -it aea-deploy:latest This will run the fetchai/my_first_aea:0.18.0 demo project. You can edit entrypoint.sh to run whatever project you would like.","title":"Running a Docker Image"},{"location":"aea/deployment/#deployment","text":"Note This section is incomplete and will soon be updated.","title":"Deployment"},{"location":"aea/design-principles/","text":"Eight principles guide AEA framework development: Accessibility : ease of use. Modularity : encourages module creation, sharing and reuse. Openness : easily extensible with third-party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal-alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"aea/development-setup/","text":"An AEA consists of many packages . When developing, it helps to be able to save packages in a local package registry, rather than pushing them to remote registry . This guide helps setting up a local package registry and configuring the working directory for development. There are two ways to write code for an AEA: independent of a concrete AEA project, write individual packages from within an AEA project, write packages for that AEA Approach 1 To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side-effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.) Approach 2 It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are a purely for your IDE. In your project, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. General advice This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local (see here ) or --remote to only point to remote registry. When working on an AEA it can help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages .","title":"Development setup"},{"location":"aea/development-setup/#approach-1","text":"To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side-effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.)","title":"Approach 1"},{"location":"aea/development-setup/#approach-2","text":"It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are a purely for your IDE. In your project, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect.","title":"Approach 2"},{"location":"aea/development-setup/#general-advice","text":"This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local (see here ) or --remote to only point to remote registry. When working on an AEA it can help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages .","title":"General advice"},{"location":"aea/diagram/","text":"The framework has two distinctive parts. A core that is developed by the Fetch.ai team as well as external contributors. Extensions (also known as packages ) developed by any developer. Currently, the framework supports four types of packages which can be added to the core as modules: Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. Protocols define agent-to-agent as well as component-to-component interactions (messages and dialogues) within agents. Connections wrap SDKs or APIs and provide an interface to network, ledgers and other services. Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers. The following figure illustrates the framework's architecture: The execution is broken down in more detail below: The agent operation breaks down into three parts: Setup: calls the setup() method of all registered resources Operation: Main loop (Thread 1 - Synchronous): react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function on the Handler(s) responsible for them. As such it consumes and potentially produces Messages . act() : this function calls the act() function of all registered Behaviours. As such it potentially produces Messages . update() : this function enqueues scheduled tasks for execution with the TaskManager and executes the decision maker. Task loop (Thread 2- Synchronous): executes available tasks Decision maker loop (Thread 3- Synchronous): processes internal messages Multiplexer (Thread 4 - Asynchronous event loop): the multiplexer has an event loop which processes incoming and outgoing messages across several connections asynchronously. Teardown: calls the teardown() method of all registered resources To prevent a developer from blocking the main loop with custom skill code, an execution time limit is applied to every Behaviour.act and Handler.handle call. By default, the execution limit is set to 0 seconds, which disables the feature. You can set the limit to a strictly positive value (e.g. 0.1 seconds) to test your AEA for production readiness. If the act or handle time exceed this limit, the call will be terminated. An appropriate message is added to the logs in the case of some code execution being terminated.","title":"Architectural diagram"},{"location":"aea/erc1155-skills/","text":"The AEA erc1155_deploy and erc1155_client skills demonstrate an interaction between two AEAs with the usage of a smart contract. The erc1155_deploy skill deploys the smart contract, creates and mints items. The erc1155_client skill signs a transaction to complete a trustless trade with the counterparty. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Discussion The scope of the specific demo is to demonstrate how to deploy a smart contract and interact with it. For the specific use-case, we create two AEAs one that deploys and creates tokens inside the smart contract and the other that signs a transaction so we can complete an atomic swap. The smart contract we are using is an ERC1155 smart contract with a one-step atomic swap functionality. That means the trade between the two AEAs can be trustless. Note This demo serves demonstrative purposes only. Since the AEA deploying the contract also has the ability to mint tokens, in reality the transfer of tokens from the AEA signing the transaction is worthless. Demo Create the deployer AEA Fetch the AEA that will deploy the contract. aea fetch fetchai/erc1155_deployer:0.22.0 cd erc1155_deployer aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/erc1155_deploy:0.21.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the deployer AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt And one for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Create the client AEA In another terminal, fetch the AEA that will get some tokens from the deployer. aea fetch fetchai/erc1155_client:0.22.0 cd erc1155_client aea install aea build Alternatively, create from scratch. Create the AEA that will get some tokens from the deployer. aea create erc1155_client cd erc1155_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/erc1155_client:0.20.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt And one for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run Ganache Run the following command docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat erc1155_deployer/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat erc1155_client/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum You should get 1000000000000000000000 . Note If no wealth appears after a while, then try funding the private key directly using a web faucet. Update SOEF configurations for both AEAs To update the SOEF configuration, run in each AEA project: aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum Run the AEAs First, run the deployer AEA. aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. It will perform the following steps: - deploy the smart contract - create a batch of items in the smart contract - mint a batch of items in the smart contract At some point you should see the log output: registering service on SOEF. Then, update the configuration of the client AEA's P2P connection by appending the following YAML text at the end of the aea-config.yaml file: --- public_id : fetchai/p2p_libp2p:0.14.0 type : connection config : delegate_uri : 127.0.0.1:11001 entry_peers : - SOME_ADDRESS local_uri : 127.0.0.1:9001 log_file : libp2p_node.log public_uri : 127.0.0.1:9001 where SOME_ADDRESS is the output of aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri) in the erc1155_deployer project. The output will be something like /dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm2JPsUX1Su59YVDXJQizYkNSe8JCusqRpLeeTbvY76fE5 . Or, run these commands (replace SOME_ADDRESS as above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then, in the separate terminal run the client AEA. aea run You will see that upon discovery the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client Communication This diagram shows the communication between the various entities as data is successfully trustless trade. sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Deployer_AEA activate Search activate Client_AEA activate Erc1155_contract activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Deployer_AEA deactivate Search deactivate Client_AEA deactivate ERC1155_contract deactivate Blockchain","title":"Contract deploy and interact"},{"location":"aea/erc1155-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/erc1155-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/erc1155-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to deploy a smart contract and interact with it. For the specific use-case, we create two AEAs one that deploys and creates tokens inside the smart contract and the other that signs a transaction so we can complete an atomic swap. The smart contract we are using is an ERC1155 smart contract with a one-step atomic swap functionality. That means the trade between the two AEAs can be trustless. Note This demo serves demonstrative purposes only. Since the AEA deploying the contract also has the ability to mint tokens, in reality the transfer of tokens from the AEA signing the transaction is worthless.","title":"Discussion"},{"location":"aea/erc1155-skills/#demo","text":"","title":"Demo"},{"location":"aea/erc1155-skills/#create-the-deployer-aea","text":"Fetch the AEA that will deploy the contract. aea fetch fetchai/erc1155_deployer:0.22.0 cd erc1155_deployer aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/erc1155_deploy:0.21.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the deployer AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt And one for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create the deployer AEA"},{"location":"aea/erc1155-skills/#create-the-client-aea","text":"In another terminal, fetch the AEA that will get some tokens from the deployer. aea fetch fetchai/erc1155_client:0.22.0 cd erc1155_client aea install aea build Alternatively, create from scratch. Create the AEA that will get some tokens from the deployer. aea create erc1155_client cd erc1155_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/erc1155_client:0.20.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt And one for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create the client AEA"},{"location":"aea/erc1155-skills/#run-ganache","text":"Run the following command docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat erc1155_deployer/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat erc1155_client/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth use (after some time for the wealth creation to be mined on Ropsten): aea get-wealth ethereum You should get 1000000000000000000000 . Note If no wealth appears after a while, then try funding the private key directly using a web faucet.","title":"Run Ganache"},{"location":"aea/erc1155-skills/#update-soef-configurations-for-both-aeas","text":"To update the SOEF configuration, run in each AEA project: aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum","title":"Update SOEF configurations for both AEAs"},{"location":"aea/erc1155-skills/#run-the-aeas","text":"First, run the deployer AEA. aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. It will perform the following steps: - deploy the smart contract - create a batch of items in the smart contract - mint a batch of items in the smart contract At some point you should see the log output: registering service on SOEF. Then, update the configuration of the client AEA's P2P connection by appending the following YAML text at the end of the aea-config.yaml file: --- public_id : fetchai/p2p_libp2p:0.14.0 type : connection config : delegate_uri : 127.0.0.1:11001 entry_peers : - SOME_ADDRESS local_uri : 127.0.0.1:9001 log_file : libp2p_node.log public_uri : 127.0.0.1:9001 where SOME_ADDRESS is the output of aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri) in the erc1155_deployer project. The output will be something like /dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm2JPsUX1Su59YVDXJQizYkNSe8JCusqRpLeeTbvY76fE5 . Or, run these commands (replace SOME_ADDRESS as above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then, in the separate terminal run the client AEA. aea run You will see that upon discovery the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored.","title":"Run the AEAs"},{"location":"aea/erc1155-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client","title":"Delete the AEAs"},{"location":"aea/erc1155-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully trustless trade. sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Deployer_AEA activate Search activate Client_AEA activate Erc1155_contract activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Deployer_AEA deactivate Search deactivate Client_AEA deactivate ERC1155_contract deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills-step-by-step/","text":"This guide is a step-by-step introduction to building an AEA that represents static, and dynamic data to be advertised on the Open Economic Framework . If you simply want to run the resulting AEAs go here . Dependencies (Required) Follow the Preliminaries and Installation sections from the AEA quick start. Reference (Optional) This step-by-step guide recreates two AEAs already developed by Fetch.ai. You can get the finished AEAs to compare your code against by following the next steps: aea fetch fetchai/generic_seller:0.17.0 cd generic_seller aea eject skill fetchai/generic_seller:0.19.0 cd .. aea fetch fetchai/generic_buyer:0.18.0 cd generic_buyer aea eject skill fetchai/generic_buyer:0.19.0 cd .. Simplification step To keep file paths consistent with the reference code, we suggest you initialize your local author as fetchai for the purpose of this demo only: aea init --reset --local --author fetchai Generic Seller AEA Step 1: Create the AEA Create a new AEA by typing the following command in the terminal: aea create my_generic_seller cd my_generic_seller Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of data. Type the following command: aea scaffold skill generic_seller This command will create the correct structure for a new skill inside our AEA project. You can locate the newly created skill inside the skills folder ( my_generic_seller/skills/generic_seller/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml Step 2: Create the behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py file ( my_generic_seller/skills/generic_seller/behaviours.py ) and add the following code (replacing the stub code already present in the file): from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy DEFAULT_SERVICES_INTERVAL = 60.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) self . _register_agent () self . _register_service_personality_classification () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" pass def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering agent on SOEF.\" ) def _register_service_personality_classification ( self ) -> None : \"\"\" Register the agent's service, personality and classification. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) descriptions = [ strategy . get_register_service_description (), strategy . get_register_personality_description (), strategy . get_register_classification_description (), ] oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) for description in descriptions : oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering service on SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) This TickerBehaviour registers and de-register our AEA\u2019s service on the SOEF search node at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to possible clients. The act method unregisters and registers the AEA to the SOEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances. At setup we are sending a message to the ledger connection to check the account balance for the AEA's address on the configured ledger. Step 3: Create the handler So far, we have tasked the AEA with sending register/unregister requests to the SOEF search node . However, we have at present no way of handling the responses sent to the AEA by the SOEF search node or messages sent from any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a buyer_AEA . sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Get raw transaction from ledger api end loop Once with DecisionMaker Buyer_AEA->>Buyer_AEA: Get signed transaction from decision maker end loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Send transaction and get digest from ledger api Buyer_AEA->>Blockchain: transfer_funds end Buyer_AEA->>Seller_AEA: send_transaction_digest Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In the context of our generic use-case, the my_generic_seller AEA is the seller. Let us now implement a Handler to deal with the incoming messages. Open the handlers.py file ( my_generic_seller/skills/generic_seller/handlers.py ) and add the following code (replacing the stub code already present in the file): from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.helpers.transaction.base import TransactionDigest from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling FipaMessages received by the my_generic_seller AEA. We use FipaDialogues (more on this below in this section) to keep track of the dialogue state between the my_generic_seller AEA and the my_generic_buyer AEA. First, we check if the message is registered to an existing dialogue or if we have to create a new dialogue. The second part matches messages with their handler based on the message's performative. We are going to implement each case in a different function. Below the unused teardown function, we continue by adding the following code: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles the CFP message, paste the code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_matching_supply ( fipa_msg . query ): proposal , terms , data_for_sale = strategy . generate_proposal_terms_and_data ( fipa_msg . query , fipa_msg . sender ) fipa_dialogue . data_for_sale = data_for_sale fipa_dialogue . terms = terms self . context . logger . info ( \"sending a PROPOSE with proposal= {} to sender= {} \" . format ( proposal . values , fipa_msg . sender [ - 5 :] ) ) proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = fipa_msg , proposal = proposal , ) self . context . outbox . put_message ( message = proposal_msg ) else : self . context . logger . info ( \"declined the CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) The above code will respond with a PROPOSE message to the buyer if the CFP matches the supplied services and our strategy otherwise it will respond with a DECLINE message. The next code-block handles the decline message we receive from the buyer. Add the following code below the _handle_cfp function: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_PROPOSE , fipa_dialogue . is_self_initiated ) If we receive a decline message from the buyer we close the dialogue and terminate this conversation with the my_generic_buyer . Alternatively, we might receive an ACCEPT message. In order to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received ACCEPT from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) info = { \"address\" : fipa_dialogue . terms . sender_address } match_accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , target_message = fipa_msg , info = info , ) self . context . logger . info ( \"sending MATCH_ACCEPT_W_INFORM to sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], info , ) ) self . context . outbox . put_message ( message = match_accept_msg ) When the my_generic_buyer accepts the Proposal we send it, and therefore sends us an ACCEPT message, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to inform the buyer about the address we would like it to send the funds to. Lastly, we handle the INFORM message, which the buyer uses to inform us that it has sent the funds to the provided address. Add the following code: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the data, otherwise do nothing. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx and \"transaction_digest\" in fipa_msg . info . keys (): self . context . logger . info ( \"checking whether transaction= {} has been received ...\" . format ( fipa_msg . info [ \"transaction_digest\" ] ) ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , transaction_digest = TransactionDigest ( fipa_dialogue . terms . ledger_id , fipa_msg . info [ \"transaction_digest\" ] ), ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . context . outbox . put_message ( message = ledger_api_msg ) elif strategy . is_ledger_tx : self . context . logger . warning ( \"did not receive transaction digest from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) elif not strategy . is_ledger_tx and \"Done\" in fipa_msg . info . keys (): inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , fipa_msg . sender [ - 5 :], ) ) else : self . context . logger . warning ( \"did not receive transaction confirmation from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the buyer accepted. If the transaction is valid and we received the funds then we send the data to the buyer. Otherwise we do not send the data. The remaining handlers are as follows: def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message \"\"\" self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( ledger_api_msg . ledger_id , ledger_api_msg . balance , ) ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) is_valid = LedgerApis . is_transaction_valid ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . transaction , fipa_dialogue . terms . sender_address , fipa_dialogue . terms . counterparty_address , fipa_dialogue . terms . nonce , fipa_dialogue . terms . counterparty_payable_amount , ) if is_settled and is_valid : last_message = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if last_message is None : raise ValueError ( \"Cannot retrieve last fipa message.\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = last_message , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , last_message . sender [ - 5 :], ) ) else : self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The GenericLedgerApiHandler deals with LedgerApiMessages from the ledger connection. The GenericOefSearchHandler handles OefSearchMessages from the SOEF connection. Step 4: Create the strategy Next, we are going to create the strategy that we want our my_generic_seller AEA to follow. Rename the my_model.py file ( my_generic_seller/skills/generic_seller/my_model.py ) to strategy.py and copy and paste the following code (replacing the stub code already present in the file): import uuid from typing import Any , Dict , Optional , Tuple from aea.common import Address from aea.crypto.ledger_apis import LedgerApis from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , SIMPLE_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location , Query from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_UNIT_PRICE = 4 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } DEFAULT_HAS_DATA_SOURCE = False DEFAULT_DATA_FOR_SALE = { \"some_generic_data_key\" : \"some_generic_data_value\" } # type: Optional[Dict[str, Any]] class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _unit_price = kwargs . pop ( \"unit_price\" , DEFAULT_UNIT_PRICE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} self . _simple_service_data = { self . _set_service_data [ \"key\" ]: self . _set_service_data [ \"value\" ] } self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) data_for_sale_ordered = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) data_for_sale = { str ( key ): str ( value ) for key , value in data_for_sale_ordered . items () } super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id enforce ( self . context . agent_addresses . get ( self . _ledger_id , None ) is not None , \"Wallet does not contain cryptos for provided ledger id.\" , ) self . _data_for_sale = data_for_sale We initialise the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following properties and methods deal with different aspects of the strategy. Add them under the initialization of the class: @property def data_for_sale ( self ) -> Dict [ str , str ]: \"\"\"Get the data for sale.\"\"\" if self . _has_data_source : return self . collect_from_data_source () # pragma: nocover return self . _data_for_sale @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_service_description ( self ) -> Description : \"\"\" Get the simple service description. :return: a description of the offered services \"\"\" description = Description ( self . _simple_service_data , data_model = SIMPLE_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indiciating whether matches or not \"\"\" return query . check ( self . get_service_description ()) def generate_proposal_terms_and_data ( # pylint: disable=unused-argument self , query : Query , counterparty_address : Address ) -> Tuple [ Description , Terms , Dict [ str , str ]]: \"\"\" Generate a proposal matching the query. :param query: the query :param counterparty_address: the counterparty of the proposal. :return: a tuple of proposal, terms and the weather data \"\"\" data_for_sale = self . data_for_sale sale_quantity = len ( data_for_sale ) seller_address = self . context . agent_addresses [ self . ledger_id ] total_price = sale_quantity * self . _unit_price if self . is_ledger_tx : tx_nonce = LedgerApis . generate_tx_nonce ( identifier = self . ledger_id , seller = seller_address , client = counterparty_address , ) else : tx_nonce = uuid . uuid4 () . hex # pragma: nocover proposal = Description ( { \"ledger_id\" : self . ledger_id , \"price\" : total_price , \"currency_id\" : self . _currency_id , \"service_id\" : self . _service_id , \"quantity\" : sale_quantity , \"tx_nonce\" : tx_nonce , } ) terms = Terms ( ledger_id = self . ledger_id , sender_address = seller_address , counterparty_address = counterparty_address , amount_by_currency_id = { self . _currency_id : total_price }, quantities_by_good_id = { self . _service_id : - sale_quantity }, is_sender_payable_tx_fee = False , nonce = tx_nonce , fee_by_currency_id = { self . _currency_id : 0 }, ) return proposal , terms , data_for_sale def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to communicate with the sensor.\"\"\" raise NotImplementedError Before the creation of the actual proposal, we have to check if the sale generates value for us or a loss. If it is a loss, we abort and warn the developer. The helper private function collect_from_data_source , is where we read data from our sensor or in case we do not have a sensor use some default data provided. Step 5: Create the dialogues When we are negotiating with other AEAs we would like to keep track of the state of these negotiations. To this end we create a new file in the skill folder ( my_generic_seller/skills/generic_seller/ ) and name it dialogues.py . Inside this file add the following code: from typing import Dict , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . data_for_sale = None # type: Optional[Dict[str, str]] self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) The FipaDialogues class stores dialogue with each my_generic_buyer (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to a dialogue, access previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA. It also keeps track of the data that we offer for sale during the proposal phase. The FipaDialogues class extends BaseFipaDialogues , which itself derives from the base Dialogues class. Similarly, the FipaDialogue class extends BaseFipaDialogue , which itself derives from the base Dialogue class. To learn more about dialogues have a look here . Step 6: Update the YAML files Since we made so many changes to our AEA we have to update the skill.yaml (at my_generic_seller/skills/generic_seller/skill.yaml ). Make sure you update your skill.yaml with the following configuration: name : generic_seller author : fetchai version : 0.1.0 type : skill description : The weather station skill implements the functionality to sell weather data. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : README.md : QmPb5kHYZyhUN87EKmuahyGqDGgqVdGPyfC1KpGC3xfmcP __init__.py : QmTSEedzQySy2nzRCY3F66CBSX52f8s3pWHZTejX4hKC9h behaviours.py : QmS9sPCv2yBnhWsmHeaCptpApMtYZipbR39TXixeGK64Ks dialogues.py : QmdTW8q1xQ7ajFVsWmuV62ypoT5J2b6Hkyz52LFaWuMEtd handlers.py : QmQnQhSaHPUYaJut8bMe2LHEqiZqokMSVfCthVaqrvPbdi strategy.py : QmYTUsfv64eRQDevCfMUDQPx2GCtiMLFdacN4sS1E4Fdfx fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.12.0 contracts : [] protocols : - fetchai/default:0.11.0 - fetchai/fipa:0.12.0 - fetchai/ledger_api:0.9.0 - fetchai/oef_search:0.12.0 skills : [] behaviours : service_registration : args : services_interval : 20 class_name : GenericServiceRegistrationBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : data_for_sale : generic : data has_data_source : false is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy dependencies : {} We must pay attention to the models and in particular the strategy\u2019s variables. Here we can change the price we would like to sell each reading for or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_seller:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Generic Buyer AEA Step 1: Create the AEA In a new terminal, create a new AEA by typing the following command in the terminal: aea create my_generic_buyer cd my_generic_buyer Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the purchase of the data. Type the following command: aea scaffold skill generic_buyer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder ( my_generic_buyer/skills/generic_buyer/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml Step 2: Create the behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_generic_buyer/skills/generic_buyer/behaviours.py ) and add the following code (replacing the stub code already present in the file): from typing import List , Optional , Set , cast from aea.protocols.dialogue.base import DialogueLabel from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_buyer.dialogues import ( FipaDialogue , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy DEFAULT_MAX_PROCESSING = 120 DEFAULT_TX_INTERVAL = 2.0 DEFAULT_SEARCH_INTERVAL = 5.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericSearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) else : strategy . is_searching = True def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_location_and_service_query () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = query , ) self . context . outbox . put_message ( message = oef_search_msg ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" pass class GenericTransactionBehaviour ( TickerBehaviour ): \"\"\"A behaviour to sequentially submit transactions to the blockchain.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the transaction behaviour.\"\"\" tx_interval = cast ( float , kwargs . pop ( \"transaction_interval\" , DEFAULT_TX_INTERVAL ) ) self . max_processing = cast ( float , kwargs . pop ( \"max_processing\" , DEFAULT_MAX_PROCESSING ) ) self . processing_time = 0.0 self . waiting : List [ FipaDialogue ] = [] self . processing : Optional [ LedgerApiDialogue ] = None self . timedout : Set [ DialogueLabel ] = set () super () . __init__ ( tick_interval = tx_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Setup behaviour.\"\"\" pass def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" if self . processing is not None : if self . processing_time <= self . max_processing : # already processing self . processing_time += self . tick_interval return self . _timeout_processing () if len ( self . waiting ) == 0 : # nothing to process return self . _start_processing () def _start_processing ( self ) -> None : \"\"\"Process the next transaction.\"\"\" fipa_dialogue = self . waiting . pop ( 0 ) self . context . logger . info ( f \"Processing transaction, { len ( self . waiting ) } transactions remaining\" ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_RAW_TRANSACTION , terms = fipa_dialogue . terms , ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . processing_time = 0.0 self . processing = ledger_api_dialogue self . context . logger . info ( f \"requesting transfer transaction from ledger api for message= { ledger_api_msg } ...\" ) self . context . outbox . put_message ( message = ledger_api_msg ) def teardown ( self ) -> None : \"\"\"Teardown behaviour.\"\"\" pass def _timeout_processing ( self ) -> None : \"\"\"Timeout processing.\"\"\" if self . processing is None : return self . timedout . add ( self . processing . dialogue_label ) self . waiting . append ( self . processing . associated_fipa_dialogue ) self . processing_time = 0.0 self . processing = None def finish_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Finish processing. :param ledger_api_dialogue: the ledger api dialogue \"\"\" if self . processing == ledger_api_dialogue : self . processing_time = 0.0 self . processing = None return if ledger_api_dialogue . dialogue_label not in self . timedout : raise ValueError ( f \"Non-matching dialogues in transaction behaviour: { self . processing } and { ledger_api_dialogue } \" ) self . timedout . remove ( ledger_api_dialogue . dialogue_label ) self . context . logger . debug ( f \"Timeout dialogue in transaction processing: { ledger_api_dialogue } \" ) # don't reset, as another might be processing def failed_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Failed processing. Currently, we retry processing indefinitely. :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . finish_processing ( ledger_api_dialogue ) self . waiting . append ( ledger_api_dialogue . associated_fipa_dialogue ) This TickerBehaviour will search on the SOEF search node with a specific query at regular tick intervals. Step 3: Create the handler So far, we have tasked the AEA with sending search queries to the SOEF search node . However, we have at present no way of handling the responses sent to the AEA by the SOEF search node or messages sent by other agent. Let us now implement a Handler to deal with the incoming messages. Open the handlers.py file ( my_generic_buyer/skills/generic_buyer/handlers.py ) and add the following code (replacing the stub code already present in the file): import pprint from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.signing.message import SigningMessage from packages.fetchai.skills.generic_buyer.behaviours import GenericTransactionBehaviour from packages.fetchai.skills.generic_buyer.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , SigningDialogue , SigningDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue , fipa_dialogues ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic to the generic_seller when we develop the generic_buyer \u2019s side of the negotiation. First, we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the PROPOSE message that we receive from the my_generic_seller AEA: def _handle_propose ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the propose. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received proposal= {} from sender= {} \" . format ( fipa_msg . proposal . values , fipa_msg . sender [ - 5 :], ) ) strategy = cast ( GenericStrategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( fipa_msg . proposal ) affordable = strategy . is_affordable_proposal ( fipa_msg . proposal ) if acceptable and affordable : self . context . logger . info ( \"accepting the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) terms = strategy . terms_from_proposal ( fipa_msg . proposal , fipa_msg . sender ) fipa_dialogue . terms = terms accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . ACCEPT , target_message = fipa_msg , ) self . context . outbox . put_message ( message = accept_msg ) else : self . context . logger . info ( \"declining the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a DECLINE message. Otherwise, we send an ACCEPT message to the seller. The next code-block handles the DECLINE message that we may receive from the buyer on our CFP message or our ACCEPT message: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the decline. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues :return: None \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if fipa_msg . target == 1 : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_CFP , fipa_dialogue . is_self_initiated ) elif fipa_msg . target == 3 : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_ACCEPT , fipa_dialogue . is_self_initiated ) The above code terminates each dialogue with the specific AEA and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case we do not receive any DECLINE message that means that the my_generic_seller AEA want to move on with the sale, in that case, it will send a MATCH_ACCEPT message. In order to handle this we add the following code: def _handle_match_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the match accept. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received MATCH_ACCEPT_W_INFORM from sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], fipa_msg . info ) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : transfer_address = fipa_msg . info . get ( \"address\" , None ) if transfer_address is not None and isinstance ( transfer_address , str ): fipa_dialogue . terms . counterparty_address = ( # pragma: nocover transfer_address ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . waiting . append ( fipa_dialogue ) else : inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"informing counterparty= {} of payment.\" . format ( fipa_msg . sender [ - 5 :]) ) The first thing we are checking is if we enabled our AEA to transact with a ledger. If we can transact with a ledger we generate a LedgerApiMessage of performative GET_RAW_TRANSACTION and send it to the ledger connection. The ledger connection will construct a raw transaction for us, using the relevant ledger API. Lastly, we need to handle the INFORM message. This is the message that will have our data: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the match inform. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues :return: None \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if len ( fipa_msg . info . keys ()) >= 1 : data = fipa_msg . info self . context . logger . info ( \"received the following data= {} \" . format ( pprint . pformat ( data )) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) strategy = cast ( GenericStrategy , self . context . strategy ) strategy . successful_trade_with_counterparty ( fipa_msg . sender , data ) else : self . context . logger . info ( \"received no data from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) The main difference between the generic_buyer and the generic_seller skill handlers.py file is that in this one we create more than one handler. The reason is that we receive messages not only from the my_generic_seller AEA but also from the DecisionMaker and the SOEF search node . We need one handler for each type of protocol we use. To handle the messages in the oef_search protocol used by the SOEF search node we add the following code in the same file ( my_generic_buyer/skills/generic_buyer/handlers.py ): class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( oef_search_msg . agents ) == 0 : self . context . logger . info ( f \"found no agents in dialogue= { oef_search_dialogue } , continue searching.\" ) return strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_stop_searching_on_result : self . context . logger . info ( \"found agents= {} , stopping search.\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) strategy . is_searching = False # stopping search else : self . context . logger . info ( \"found agents= {} .\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) query = strategy . get_service_query () fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) counterparties = strategy . get_acceptable_counterparties ( oef_search_msg . agents ) for counterparty in counterparties : cfp_msg , _ = fipa_dialogues . create ( counterparty = counterparty , performative = FipaMessage . Performative . CFP , query = query , ) self . context . outbox . put_message ( message = cfp_msg ) self . context . logger . info ( \"sending CFP to agent= {} \" . format ( counterparty [ - 5 :]) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) When we receive a message from the SOEF search node of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the relevant handler method. In the _handle_search function we are checking that the response contains some agents and we stop the search if it does. We pick our first agent and we send a CFP message. The last handlers we need are the GenericSigningHandler and the GenericLedgerApiHandler . This handler will handle the SigningMessages that we receive from the DecisionMaker . The GenericLedgerApiHandler will handle the LedgerApiMessages that we receive from the ledger connection. class GenericSigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue last_ledger_api_msg = ledger_api_dialogue . last_incoming_message if last_ledger_api_msg is None : raise ValueError ( \"Could not retrieve last message in ledger api dialogue\" ) ledger_api_msg = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . SEND_SIGNED_TRANSACTION , target_message = last_ledger_api_msg , signed_transaction = signing_msg . signed_transaction , ) self . context . outbox . put_message ( message = ledger_api_msg ) self . context . logger . info ( \"sending transaction to ledger.\" ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) signing_msg_ = cast ( Optional [ SigningMessage ], signing_dialogue . last_outgoing_message ) if ( signing_msg_ is not None and signing_msg_ . performative == SigningMessage . Performative . SIGN_TRANSACTION ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . RAW_TRANSACTION ): self . _handle_raw_transaction ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_DIGEST ): self . _handle_transaction_digest ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if ledger_api_msg . balance > 0 : self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( strategy . ledger_id , ledger_api_msg . balance , ) ) strategy . balance = ledger_api_msg . balance strategy . is_searching = True else : self . context . logger . warning ( \"you have no starting balance on {} ledger!\" . format ( strategy . ledger_id ) ) self . context . is_active = False def _handle_raw_transaction ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of raw_transaction performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received raw transaction= {} \" . format ( ledger_api_msg )) signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_msg , signing_dialogue = signing_dialogues . create ( counterparty = self . context . decision_maker_address , performative = SigningMessage . Performative . SIGN_TRANSACTION , raw_transaction = ledger_api_msg . raw_transaction , terms = ledger_api_dialogue . associated_fipa_dialogue . terms , ) signing_dialogue = cast ( SigningDialogue , signing_dialogue ) signing_dialogue . associated_ledger_api_dialogue = ledger_api_dialogue self . context . decision_maker_message_queue . put_nowait ( signing_msg ) self . context . logger . info ( \"proposing the transaction to the decision maker. Waiting for confirmation ...\" ) def _handle_transaction_digest ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of transaction_digest performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"transaction was successfully submitted. Transaction digest= {} \" . format ( ledger_api_msg . transaction_digest ) ) ledger_api_msg_ = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , target_message = ledger_api_msg , transaction_digest = ledger_api_msg . transaction_digest , ) self . context . logger . info ( \"checking transaction is settled.\" ) self . context . outbox . put_message ( message = ledger_api_msg_ ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) if is_settled : tx_behaviour . finish_processing ( ledger_api_dialogue ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ledger_api_msg_ is None : raise ValueError ( # pragma: nocover \"Could not retrieve last ledger_api message\" ) fipa_msg = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if fipa_msg is None : raise ValueError ( \"Could not retrieve last fipa message\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"transaction_digest\" : ledger_api_msg_ . transaction_digest . body }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"transaction confirmed, informing counterparty= {} of transaction digest.\" . format ( fipa_dialogue . dialogue_label . dialogue_opponent_addr [ - 5 :], ) ) else : tx_behaviour . failed_processing ( ledger_api_dialogue ) self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ( ledger_api_msg_ is not None and ledger_api_msg_ . performative != LedgerApiMessage . Performative . GET_BALANCE ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) Step 4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file (in my_generic_buyer/skills/generic_buyer/ ) to strategy.py and paste the following code (replacing the stub code already present in the file): from aea.common import Address from aea.exceptions import enforce from aea.helpers.search.generic import SIMPLE_SERVICE_MODEL from aea.helpers.search.models import ( Constraint , ConstraintType , Description , Location , Query , ) from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_MAX_UNIT_PRICE = 5 DEFAULT_MAX_TX_FEE = 2 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_MIN_QUANTITY = 1 DEFAULT_MAX_QUANTITY = 100 DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 DEFAULT_MAX_NEGOTIATIONS = 2 class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _max_unit_price = kwargs . pop ( \"max_unit_price\" , DEFAULT_MAX_UNIT_PRICE ) self . _min_quantity = kwargs . pop ( \"min_quantity\" , DEFAULT_MIN_QUANTITY ) self . _max_quantity = kwargs . pop ( \"max_quantity\" , DEFAULT_MAX_QUANTITY ) self . _max_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) self . _search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) self . _radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) self . _max_negotiations = kwargs . pop ( \"max_negotiations\" , DEFAULT_MAX_NEGOTIATIONS ) self . _is_stop_searching_on_result = kwargs . pop ( \"stop_searching_on_result\" , True ) super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id self . _is_searching = False self . _balance = 0 We initialize the strategy class by trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two methods are related to the OEF search service, add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx @property def is_stop_searching_on_result ( self ) -> bool : \"\"\"Check if search is stopped on result.\"\"\" return self . _is_stop_searching_on_result @property def is_searching ( self ) -> bool : \"\"\"Check if the agent is searching.\"\"\" return self . _is_searching @is_searching . setter def is_searching ( self , is_searching : bool ) -> None : \"\"\"Check if the agent is searching.\"\"\" enforce ( isinstance ( is_searching , bool ), \"Can only set bool on is_searching!\" ) self . _is_searching = is_searching @property def balance ( self ) -> int : \"\"\"Get the balance.\"\"\" return self . _balance @balance . setter def balance ( self , balance : int ) -> None : \"\"\"Set the balance.\"\"\" self . _balance = balance @property def max_negotiations ( self ) -> int : \"\"\"Get the maximum number of negotiations the agent can start.\"\"\" return self . _max_negotiations def get_location_and_service_query ( self ) -> Query : \"\"\" Get the location and service query of the agent. :return: the query \"\"\" close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( self . _agent_location , self . _radius )) ) service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ close_to_my_service , service_key_filter ],) return query def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ service_key_filter ], model = SIMPLE_SERVICE_MODEL ) return query The following code block checks if the proposal that we received is acceptable based on the strategy: def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( all ( [ key in proposal . values for key in [ \"ledger_id\" , \"currency_id\" , \"price\" , \"service_id\" , \"quantity\" , \"tx_nonce\" , ] ] ) and proposal . values [ \"ledger_id\" ] == self . ledger_id and proposal . values [ \"price\" ] > 0 and proposal . values [ \"quantity\" ] >= self . _min_quantity and proposal . values [ \"quantity\" ] <= self . _max_quantity and proposal . values [ \"price\" ] <= proposal . values [ \"quantity\" ] * self . _max_unit_price and proposal . values [ \"currency_id\" ] == self . _currency_id and proposal . values [ \"service_id\" ] == self . _service_id and isinstance ( proposal . values [ \"tx_nonce\" ], str ) and proposal . values [ \"tx_nonce\" ] != \"\" ) return result The is_affordable_proposal method checks if we can afford the transaction based on the funds we have in our wallet on the ledger. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values . get ( \"price\" , 0 ) + self . _max_tx_fee result = self . balance >= payable else : result = True return result def get_acceptable_counterparties ( self , counterparties : Tuple [ str , ... ] ) -> Tuple [ str , ... ]: \"\"\" Process counterparties and drop unacceptable ones. :return: list of counterparties \"\"\" valid_counterparties : List [ str ] = [] for idx , counterparty in enumerate ( counterparties ): if idx < self . max_negotiations : valid_counterparties . append ( counterparty ) return tuple ( valid_counterparties ) def terms_from_proposal ( self , proposal : Description , counterparty_address : Address ) -> Terms : \"\"\" Get the terms from a proposal. :param proposal: the proposal :return: terms \"\"\" buyer_address = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ]] terms = Terms ( ledger_id = proposal . values [ \"ledger_id\" ], sender_address = buyer_address , counterparty_address = counterparty_address , amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, quantities_by_good_id = { proposal . values [ \"service_id\" ]: proposal . values [ \"quantity\" ] }, is_sender_payable_tx_fee = True , nonce = proposal . values [ \"tx_nonce\" ], fee_by_currency_id = { proposal . values [ \"currency_id\" ]: self . _max_tx_fee }, ) return terms def successful_trade_with_counterparty ( self , counterparty : str , data : Dict [ str , str ] ) -> None : \"\"\" Do something on successful trade. :param counterparty: the counterparty address :param data: the data :return: False \"\"\" pass Step 5: Create the dialogues As mentioned, when we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py (in my_generic_buyer/skills/generic_buyer/ ). Inside this file add the following code: from typing import Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogue as BaseSigningDialogue , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class SigningDialogue ( BaseSigningDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseSigningDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_ledger_api_dialogue = None # type: Optional[LedgerApiDialogue] @property def associated_ledger_api_dialogue ( self ) -> LedgerApiDialogue : \"\"\"Get associated_ledger_api_dialogue.\"\"\" if self . _associated_ledger_api_dialogue is None : raise AEAEnforceError ( \"LedgerApiDialogue not set!\" ) return self . _associated_ledger_api_dialogue @associated_ledger_api_dialogue . setter def associated_ledger_api_dialogue ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\"Set associated_ledger_api_dialogue\"\"\" enforce ( self . _associated_ledger_api_dialogue is None , \"LedgerApiDialogue already set!\" , ) self . _associated_ledger_api_dialogue = ledger_api_dialogue class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseSigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = SigningDialogue , ) The dialogues class stores dialogue with each AEA and other AEA components so we can have access to previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA. Step 6: Update the YAML files Since we made so many changes to our AEA we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. First, we update the skill.yaml . Make sure you update your skill.yaml with the following configuration: name : generic_buyer author : fetchai version : 0.1.0 type : skill description : The weather client skill implements the skill to purchase weather data. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : README.md : QmTR91jm7WfJpmabisy74NR5mc35YXjDU1zQAUKZeHRw8L __init__.py : QmU5vrC8FipyjfS5biNa6qDWdp4aeH5h4YTtbFDmCg8Chj behaviours.py : QmNwvSjEz4kzM3gWtnKbZVFJc2Z85Nb748CWAK4C4Sa4nT dialogues.py : QmNen91qQDWy4bNBKrB3LabAP5iRf29B8iwYss4NB13iNU handlers.py : QmZfudXXbdiREiViuwPZDXoQQyXT2ySQHdF7psQsohZXQy strategy.py : QmcrwaEWvKHDCNti8QjRhB4utJBJn5L8GpD27Uy9zHwKhY fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.12.0 contracts : [] protocols : - fetchai/default:0.11.0 - fetchai/fipa:0.12.0 - fetchai/ledger_api:0.9.0 - fetchai/oef_search:0.12.0 - fetchai/signing:0.9.0 skills : [] behaviours : search : args : search_interval : 5 class_name : GenericSearchBehaviour transaction : args : max_processing : 420 transaction_interval : 2 class_name : GenericTransactionBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler signing : args : {} class_name : GenericSigningHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues signing_dialogues : args : {} class_name : SigningDialogues strategy : args : is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 min_quantity : 1 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service stop_searching_on_result : true class_name : GenericStrategy dependencies : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading at or the currency we would like to transact with. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_buyer:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Run the AEAs Create private keys For each AEA, create the private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the AEA configurations In both AEAs run: aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Fund the buyer AEA Create some wealth for your buyer on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai --sync Run seller AEA Add the remaining packages for the seller AEA, then run it: aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add protocol fetchai/fipa:0.12.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. Run buyer AEA Add the remaining packages for the buyer AEA: aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add protocol fetchai/fipa:0.12.0 aea add protocol fetchai/signing:0.9.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 Then, update the configuration of the buyer AEA's P2P connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' where SOME_ADDRESS is replaced accordingly. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Agentland testnet. Delete the AEAs When you are done, go up a level and delete the AEAs. cd .. aea delete my_generic_seller aea delete my_generic_buyer Next steps You have completed the \"Getting Started\" series. Congratulations! Recommended We recommend you build your own AEA next. There are many helpful guides on here and a developer community on Slack . Speak to you there!","title":"Trade between two AEAs"},{"location":"aea/generic-skills-step-by-step/#dependencies-required","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies (Required)"},{"location":"aea/generic-skills-step-by-step/#reference-optional","text":"This step-by-step guide recreates two AEAs already developed by Fetch.ai. You can get the finished AEAs to compare your code against by following the next steps: aea fetch fetchai/generic_seller:0.17.0 cd generic_seller aea eject skill fetchai/generic_seller:0.19.0 cd .. aea fetch fetchai/generic_buyer:0.18.0 cd generic_buyer aea eject skill fetchai/generic_buyer:0.19.0 cd ..","title":"Reference (Optional)"},{"location":"aea/generic-skills-step-by-step/#simplification-step","text":"To keep file paths consistent with the reference code, we suggest you initialize your local author as fetchai for the purpose of this demo only: aea init --reset --local --author fetchai","title":"Simplification step"},{"location":"aea/generic-skills-step-by-step/#generic-seller-aea","text":"","title":"Generic Seller AEA"},{"location":"aea/generic-skills-step-by-step/#step-1-create-the-aea","text":"Create a new AEA by typing the following command in the terminal: aea create my_generic_seller cd my_generic_seller Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of data. Type the following command: aea scaffold skill generic_seller This command will create the correct structure for a new skill inside our AEA project. You can locate the newly created skill inside the skills folder ( my_generic_seller/skills/generic_seller/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml","title":"Step 1: Create the AEA"},{"location":"aea/generic-skills-step-by-step/#step-2-create-the-behaviour","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py file ( my_generic_seller/skills/generic_seller/behaviours.py ) and add the following code (replacing the stub code already present in the file): from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy DEFAULT_SERVICES_INTERVAL = 60.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) self . _register_agent () self . _register_service_personality_classification () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" pass def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering agent on SOEF.\" ) def _register_service_personality_classification ( self ) -> None : \"\"\" Register the agent's service, personality and classification. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) descriptions = [ strategy . get_register_service_description (), strategy . get_register_personality_description (), strategy . get_register_classification_description (), ] oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) for description in descriptions : oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering service on SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) This TickerBehaviour registers and de-register our AEA\u2019s service on the SOEF search node at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to possible clients. The act method unregisters and registers the AEA to the SOEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances. At setup we are sending a message to the ledger connection to check the account balance for the AEA's address on the configured ledger.","title":"Step 2: Create the behaviour"},{"location":"aea/generic-skills-step-by-step/#step-3-create-the-handler","text":"So far, we have tasked the AEA with sending register/unregister requests to the SOEF search node . However, we have at present no way of handling the responses sent to the AEA by the SOEF search node or messages sent from any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a buyer_AEA . sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Get raw transaction from ledger api end loop Once with DecisionMaker Buyer_AEA->>Buyer_AEA: Get signed transaction from decision maker end loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Send transaction and get digest from ledger api Buyer_AEA->>Blockchain: transfer_funds end Buyer_AEA->>Seller_AEA: send_transaction_digest Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In the context of our generic use-case, the my_generic_seller AEA is the seller. Let us now implement a Handler to deal with the incoming messages. Open the handlers.py file ( my_generic_seller/skills/generic_seller/handlers.py ) and add the following code (replacing the stub code already present in the file): from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.helpers.transaction.base import TransactionDigest from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling FipaMessages received by the my_generic_seller AEA. We use FipaDialogues (more on this below in this section) to keep track of the dialogue state between the my_generic_seller AEA and the my_generic_buyer AEA. First, we check if the message is registered to an existing dialogue or if we have to create a new dialogue. The second part matches messages with their handler based on the message's performative. We are going to implement each case in a different function. Below the unused teardown function, we continue by adding the following code: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles the CFP message, paste the code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_matching_supply ( fipa_msg . query ): proposal , terms , data_for_sale = strategy . generate_proposal_terms_and_data ( fipa_msg . query , fipa_msg . sender ) fipa_dialogue . data_for_sale = data_for_sale fipa_dialogue . terms = terms self . context . logger . info ( \"sending a PROPOSE with proposal= {} to sender= {} \" . format ( proposal . values , fipa_msg . sender [ - 5 :] ) ) proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = fipa_msg , proposal = proposal , ) self . context . outbox . put_message ( message = proposal_msg ) else : self . context . logger . info ( \"declined the CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) The above code will respond with a PROPOSE message to the buyer if the CFP matches the supplied services and our strategy otherwise it will respond with a DECLINE message. The next code-block handles the decline message we receive from the buyer. Add the following code below the _handle_cfp function: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_PROPOSE , fipa_dialogue . is_self_initiated ) If we receive a decline message from the buyer we close the dialogue and terminate this conversation with the my_generic_buyer . Alternatively, we might receive an ACCEPT message. In order to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received ACCEPT from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) info = { \"address\" : fipa_dialogue . terms . sender_address } match_accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , target_message = fipa_msg , info = info , ) self . context . logger . info ( \"sending MATCH_ACCEPT_W_INFORM to sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], info , ) ) self . context . outbox . put_message ( message = match_accept_msg ) When the my_generic_buyer accepts the Proposal we send it, and therefore sends us an ACCEPT message, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to inform the buyer about the address we would like it to send the funds to. Lastly, we handle the INFORM message, which the buyer uses to inform us that it has sent the funds to the provided address. Add the following code: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the data, otherwise do nothing. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx and \"transaction_digest\" in fipa_msg . info . keys (): self . context . logger . info ( \"checking whether transaction= {} has been received ...\" . format ( fipa_msg . info [ \"transaction_digest\" ] ) ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , transaction_digest = TransactionDigest ( fipa_dialogue . terms . ledger_id , fipa_msg . info [ \"transaction_digest\" ] ), ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . context . outbox . put_message ( message = ledger_api_msg ) elif strategy . is_ledger_tx : self . context . logger . warning ( \"did not receive transaction digest from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) elif not strategy . is_ledger_tx and \"Done\" in fipa_msg . info . keys (): inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , fipa_msg . sender [ - 5 :], ) ) else : self . context . logger . warning ( \"did not receive transaction confirmation from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the buyer accepted. If the transaction is valid and we received the funds then we send the data to the buyer. Otherwise we do not send the data. The remaining handlers are as follows: def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message \"\"\" self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( ledger_api_msg . ledger_id , ledger_api_msg . balance , ) ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) is_valid = LedgerApis . is_transaction_valid ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . transaction , fipa_dialogue . terms . sender_address , fipa_dialogue . terms . counterparty_address , fipa_dialogue . terms . nonce , fipa_dialogue . terms . counterparty_payable_amount , ) if is_settled and is_valid : last_message = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if last_message is None : raise ValueError ( \"Cannot retrieve last fipa message.\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = last_message , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , last_message . sender [ - 5 :], ) ) else : self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The GenericLedgerApiHandler deals with LedgerApiMessages from the ledger connection. The GenericOefSearchHandler handles OefSearchMessages from the SOEF connection.","title":"Step 3: Create the handler"},{"location":"aea/generic-skills-step-by-step/#step-4-create-the-strategy","text":"Next, we are going to create the strategy that we want our my_generic_seller AEA to follow. Rename the my_model.py file ( my_generic_seller/skills/generic_seller/my_model.py ) to strategy.py and copy and paste the following code (replacing the stub code already present in the file): import uuid from typing import Any , Dict , Optional , Tuple from aea.common import Address from aea.crypto.ledger_apis import LedgerApis from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , SIMPLE_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location , Query from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_UNIT_PRICE = 4 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } DEFAULT_HAS_DATA_SOURCE = False DEFAULT_DATA_FOR_SALE = { \"some_generic_data_key\" : \"some_generic_data_value\" } # type: Optional[Dict[str, Any]] class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _unit_price = kwargs . pop ( \"unit_price\" , DEFAULT_UNIT_PRICE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} self . _simple_service_data = { self . _set_service_data [ \"key\" ]: self . _set_service_data [ \"value\" ] } self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) data_for_sale_ordered = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) data_for_sale = { str ( key ): str ( value ) for key , value in data_for_sale_ordered . items () } super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id enforce ( self . context . agent_addresses . get ( self . _ledger_id , None ) is not None , \"Wallet does not contain cryptos for provided ledger id.\" , ) self . _data_for_sale = data_for_sale We initialise the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following properties and methods deal with different aspects of the strategy. Add them under the initialization of the class: @property def data_for_sale ( self ) -> Dict [ str , str ]: \"\"\"Get the data for sale.\"\"\" if self . _has_data_source : return self . collect_from_data_source () # pragma: nocover return self . _data_for_sale @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_service_description ( self ) -> Description : \"\"\" Get the simple service description. :return: a description of the offered services \"\"\" description = Description ( self . _simple_service_data , data_model = SIMPLE_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indiciating whether matches or not \"\"\" return query . check ( self . get_service_description ()) def generate_proposal_terms_and_data ( # pylint: disable=unused-argument self , query : Query , counterparty_address : Address ) -> Tuple [ Description , Terms , Dict [ str , str ]]: \"\"\" Generate a proposal matching the query. :param query: the query :param counterparty_address: the counterparty of the proposal. :return: a tuple of proposal, terms and the weather data \"\"\" data_for_sale = self . data_for_sale sale_quantity = len ( data_for_sale ) seller_address = self . context . agent_addresses [ self . ledger_id ] total_price = sale_quantity * self . _unit_price if self . is_ledger_tx : tx_nonce = LedgerApis . generate_tx_nonce ( identifier = self . ledger_id , seller = seller_address , client = counterparty_address , ) else : tx_nonce = uuid . uuid4 () . hex # pragma: nocover proposal = Description ( { \"ledger_id\" : self . ledger_id , \"price\" : total_price , \"currency_id\" : self . _currency_id , \"service_id\" : self . _service_id , \"quantity\" : sale_quantity , \"tx_nonce\" : tx_nonce , } ) terms = Terms ( ledger_id = self . ledger_id , sender_address = seller_address , counterparty_address = counterparty_address , amount_by_currency_id = { self . _currency_id : total_price }, quantities_by_good_id = { self . _service_id : - sale_quantity }, is_sender_payable_tx_fee = False , nonce = tx_nonce , fee_by_currency_id = { self . _currency_id : 0 }, ) return proposal , terms , data_for_sale def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to communicate with the sensor.\"\"\" raise NotImplementedError Before the creation of the actual proposal, we have to check if the sale generates value for us or a loss. If it is a loss, we abort and warn the developer. The helper private function collect_from_data_source , is where we read data from our sensor or in case we do not have a sensor use some default data provided.","title":"Step 4: Create the strategy"},{"location":"aea/generic-skills-step-by-step/#step-5-create-the-dialogues","text":"When we are negotiating with other AEAs we would like to keep track of the state of these negotiations. To this end we create a new file in the skill folder ( my_generic_seller/skills/generic_seller/ ) and name it dialogues.py . Inside this file add the following code: from typing import Dict , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . data_for_sale = None # type: Optional[Dict[str, str]] self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) The FipaDialogues class stores dialogue with each my_generic_buyer (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to a dialogue, access previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA. It also keeps track of the data that we offer for sale during the proposal phase. The FipaDialogues class extends BaseFipaDialogues , which itself derives from the base Dialogues class. Similarly, the FipaDialogue class extends BaseFipaDialogue , which itself derives from the base Dialogue class. To learn more about dialogues have a look here .","title":"Step 5: Create the dialogues"},{"location":"aea/generic-skills-step-by-step/#step-6-update-the-yaml-files","text":"Since we made so many changes to our AEA we have to update the skill.yaml (at my_generic_seller/skills/generic_seller/skill.yaml ). Make sure you update your skill.yaml with the following configuration: name : generic_seller author : fetchai version : 0.1.0 type : skill description : The weather station skill implements the functionality to sell weather data. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : README.md : QmPb5kHYZyhUN87EKmuahyGqDGgqVdGPyfC1KpGC3xfmcP __init__.py : QmTSEedzQySy2nzRCY3F66CBSX52f8s3pWHZTejX4hKC9h behaviours.py : QmS9sPCv2yBnhWsmHeaCptpApMtYZipbR39TXixeGK64Ks dialogues.py : QmdTW8q1xQ7ajFVsWmuV62ypoT5J2b6Hkyz52LFaWuMEtd handlers.py : QmQnQhSaHPUYaJut8bMe2LHEqiZqokMSVfCthVaqrvPbdi strategy.py : QmYTUsfv64eRQDevCfMUDQPx2GCtiMLFdacN4sS1E4Fdfx fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.12.0 contracts : [] protocols : - fetchai/default:0.11.0 - fetchai/fipa:0.12.0 - fetchai/ledger_api:0.9.0 - fetchai/oef_search:0.12.0 skills : [] behaviours : service_registration : args : services_interval : 20 class_name : GenericServiceRegistrationBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : data_for_sale : generic : data has_data_source : false is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy dependencies : {} We must pay attention to the models and in particular the strategy\u2019s variables. Here we can change the price we would like to sell each reading for or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_seller:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 6: Update the YAML files"},{"location":"aea/generic-skills-step-by-step/#generic-buyer-aea","text":"","title":"Generic Buyer AEA"},{"location":"aea/generic-skills-step-by-step/#step-1-create-the-aea_1","text":"In a new terminal, create a new AEA by typing the following command in the terminal: aea create my_generic_buyer cd my_generic_buyer Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the purchase of the data. Type the following command: aea scaffold skill generic_buyer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder ( my_generic_buyer/skills/generic_buyer/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml","title":"Step 1: Create the AEA"},{"location":"aea/generic-skills-step-by-step/#step-2-create-the-behaviour_1","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. Open the behaviours.py ( my_generic_buyer/skills/generic_buyer/behaviours.py ) and add the following code (replacing the stub code already present in the file): from typing import List , Optional , Set , cast from aea.protocols.dialogue.base import DialogueLabel from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_buyer.dialogues import ( FipaDialogue , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy DEFAULT_MAX_PROCESSING = 120 DEFAULT_TX_INTERVAL = 2.0 DEFAULT_SEARCH_INTERVAL = 5.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericSearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) else : strategy . is_searching = True def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_location_and_service_query () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = query , ) self . context . outbox . put_message ( message = oef_search_msg ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" pass class GenericTransactionBehaviour ( TickerBehaviour ): \"\"\"A behaviour to sequentially submit transactions to the blockchain.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the transaction behaviour.\"\"\" tx_interval = cast ( float , kwargs . pop ( \"transaction_interval\" , DEFAULT_TX_INTERVAL ) ) self . max_processing = cast ( float , kwargs . pop ( \"max_processing\" , DEFAULT_MAX_PROCESSING ) ) self . processing_time = 0.0 self . waiting : List [ FipaDialogue ] = [] self . processing : Optional [ LedgerApiDialogue ] = None self . timedout : Set [ DialogueLabel ] = set () super () . __init__ ( tick_interval = tx_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Setup behaviour.\"\"\" pass def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" if self . processing is not None : if self . processing_time <= self . max_processing : # already processing self . processing_time += self . tick_interval return self . _timeout_processing () if len ( self . waiting ) == 0 : # nothing to process return self . _start_processing () def _start_processing ( self ) -> None : \"\"\"Process the next transaction.\"\"\" fipa_dialogue = self . waiting . pop ( 0 ) self . context . logger . info ( f \"Processing transaction, { len ( self . waiting ) } transactions remaining\" ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_RAW_TRANSACTION , terms = fipa_dialogue . terms , ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . processing_time = 0.0 self . processing = ledger_api_dialogue self . context . logger . info ( f \"requesting transfer transaction from ledger api for message= { ledger_api_msg } ...\" ) self . context . outbox . put_message ( message = ledger_api_msg ) def teardown ( self ) -> None : \"\"\"Teardown behaviour.\"\"\" pass def _timeout_processing ( self ) -> None : \"\"\"Timeout processing.\"\"\" if self . processing is None : return self . timedout . add ( self . processing . dialogue_label ) self . waiting . append ( self . processing . associated_fipa_dialogue ) self . processing_time = 0.0 self . processing = None def finish_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Finish processing. :param ledger_api_dialogue: the ledger api dialogue \"\"\" if self . processing == ledger_api_dialogue : self . processing_time = 0.0 self . processing = None return if ledger_api_dialogue . dialogue_label not in self . timedout : raise ValueError ( f \"Non-matching dialogues in transaction behaviour: { self . processing } and { ledger_api_dialogue } \" ) self . timedout . remove ( ledger_api_dialogue . dialogue_label ) self . context . logger . debug ( f \"Timeout dialogue in transaction processing: { ledger_api_dialogue } \" ) # don't reset, as another might be processing def failed_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Failed processing. Currently, we retry processing indefinitely. :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . finish_processing ( ledger_api_dialogue ) self . waiting . append ( ledger_api_dialogue . associated_fipa_dialogue ) This TickerBehaviour will search on the SOEF search node with a specific query at regular tick intervals.","title":"Step 2: Create the behaviour"},{"location":"aea/generic-skills-step-by-step/#step-3-create-the-handler_1","text":"So far, we have tasked the AEA with sending search queries to the SOEF search node . However, we have at present no way of handling the responses sent to the AEA by the SOEF search node or messages sent by other agent. Let us now implement a Handler to deal with the incoming messages. Open the handlers.py file ( my_generic_buyer/skills/generic_buyer/handlers.py ) and add the following code (replacing the stub code already present in the file): import pprint from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.signing.message import SigningMessage from packages.fetchai.skills.generic_buyer.behaviours import GenericTransactionBehaviour from packages.fetchai.skills.generic_buyer.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , SigningDialogue , SigningDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue , fipa_dialogues ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic to the generic_seller when we develop the generic_buyer \u2019s side of the negotiation. First, we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the PROPOSE message that we receive from the my_generic_seller AEA: def _handle_propose ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the propose. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received proposal= {} from sender= {} \" . format ( fipa_msg . proposal . values , fipa_msg . sender [ - 5 :], ) ) strategy = cast ( GenericStrategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( fipa_msg . proposal ) affordable = strategy . is_affordable_proposal ( fipa_msg . proposal ) if acceptable and affordable : self . context . logger . info ( \"accepting the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) terms = strategy . terms_from_proposal ( fipa_msg . proposal , fipa_msg . sender ) fipa_dialogue . terms = terms accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . ACCEPT , target_message = fipa_msg , ) self . context . outbox . put_message ( message = accept_msg ) else : self . context . logger . info ( \"declining the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a DECLINE message. Otherwise, we send an ACCEPT message to the seller. The next code-block handles the DECLINE message that we may receive from the buyer on our CFP message or our ACCEPT message: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the decline. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues :return: None \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if fipa_msg . target == 1 : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_CFP , fipa_dialogue . is_self_initiated ) elif fipa_msg . target == 3 : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_ACCEPT , fipa_dialogue . is_self_initiated ) The above code terminates each dialogue with the specific AEA and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case we do not receive any DECLINE message that means that the my_generic_seller AEA want to move on with the sale, in that case, it will send a MATCH_ACCEPT message. In order to handle this we add the following code: def _handle_match_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the match accept. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"received MATCH_ACCEPT_W_INFORM from sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], fipa_msg . info ) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : transfer_address = fipa_msg . info . get ( \"address\" , None ) if transfer_address is not None and isinstance ( transfer_address , str ): fipa_dialogue . terms . counterparty_address = ( # pragma: nocover transfer_address ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . waiting . append ( fipa_dialogue ) else : inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"informing counterparty= {} of payment.\" . format ( fipa_msg . sender [ - 5 :]) ) The first thing we are checking is if we enabled our AEA to transact with a ledger. If we can transact with a ledger we generate a LedgerApiMessage of performative GET_RAW_TRANSACTION and send it to the ledger connection. The ledger connection will construct a raw transaction for us, using the relevant ledger API. Lastly, we need to handle the INFORM message. This is the message that will have our data: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the match inform. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues :return: None \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if len ( fipa_msg . info . keys ()) >= 1 : data = fipa_msg . info self . context . logger . info ( \"received the following data= {} \" . format ( pprint . pformat ( data )) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) strategy = cast ( GenericStrategy , self . context . strategy ) strategy . successful_trade_with_counterparty ( fipa_msg . sender , data ) else : self . context . logger . info ( \"received no data from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) The main difference between the generic_buyer and the generic_seller skill handlers.py file is that in this one we create more than one handler. The reason is that we receive messages not only from the my_generic_seller AEA but also from the DecisionMaker and the SOEF search node . We need one handler for each type of protocol we use. To handle the messages in the oef_search protocol used by the SOEF search node we add the following code in the same file ( my_generic_buyer/skills/generic_buyer/handlers.py ): class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( oef_search_msg . agents ) == 0 : self . context . logger . info ( f \"found no agents in dialogue= { oef_search_dialogue } , continue searching.\" ) return strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_stop_searching_on_result : self . context . logger . info ( \"found agents= {} , stopping search.\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) strategy . is_searching = False # stopping search else : self . context . logger . info ( \"found agents= {} .\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) query = strategy . get_service_query () fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) counterparties = strategy . get_acceptable_counterparties ( oef_search_msg . agents ) for counterparty in counterparties : cfp_msg , _ = fipa_dialogues . create ( counterparty = counterparty , performative = FipaMessage . Performative . CFP , query = query , ) self . context . outbox . put_message ( message = cfp_msg ) self . context . logger . info ( \"sending CFP to agent= {} \" . format ( counterparty [ - 5 :]) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) When we receive a message from the SOEF search node of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the relevant handler method. In the _handle_search function we are checking that the response contains some agents and we stop the search if it does. We pick our first agent and we send a CFP message. The last handlers we need are the GenericSigningHandler and the GenericLedgerApiHandler . This handler will handle the SigningMessages that we receive from the DecisionMaker . The GenericLedgerApiHandler will handle the LedgerApiMessages that we receive from the ledger connection. class GenericSigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue last_ledger_api_msg = ledger_api_dialogue . last_incoming_message if last_ledger_api_msg is None : raise ValueError ( \"Could not retrieve last message in ledger api dialogue\" ) ledger_api_msg = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . SEND_SIGNED_TRANSACTION , target_message = last_ledger_api_msg , signed_transaction = signing_msg . signed_transaction , ) self . context . outbox . put_message ( message = ledger_api_msg ) self . context . logger . info ( \"sending transaction to ledger.\" ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) signing_msg_ = cast ( Optional [ SigningMessage ], signing_dialogue . last_outgoing_message ) if ( signing_msg_ is not None and signing_msg_ . performative == SigningMessage . Performative . SIGN_TRANSACTION ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . RAW_TRANSACTION ): self . _handle_raw_transaction ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_DIGEST ): self . _handle_transaction_digest ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if ledger_api_msg . balance > 0 : self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( strategy . ledger_id , ledger_api_msg . balance , ) ) strategy . balance = ledger_api_msg . balance strategy . is_searching = True else : self . context . logger . warning ( \"you have no starting balance on {} ledger!\" . format ( strategy . ledger_id ) ) self . context . is_active = False def _handle_raw_transaction ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of raw_transaction performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received raw transaction= {} \" . format ( ledger_api_msg )) signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_msg , signing_dialogue = signing_dialogues . create ( counterparty = self . context . decision_maker_address , performative = SigningMessage . Performative . SIGN_TRANSACTION , raw_transaction = ledger_api_msg . raw_transaction , terms = ledger_api_dialogue . associated_fipa_dialogue . terms , ) signing_dialogue = cast ( SigningDialogue , signing_dialogue ) signing_dialogue . associated_ledger_api_dialogue = ledger_api_dialogue self . context . decision_maker_message_queue . put_nowait ( signing_msg ) self . context . logger . info ( \"proposing the transaction to the decision maker. Waiting for confirmation ...\" ) def _handle_transaction_digest ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of transaction_digest performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"transaction was successfully submitted. Transaction digest= {} \" . format ( ledger_api_msg . transaction_digest ) ) ledger_api_msg_ = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , target_message = ledger_api_msg , transaction_digest = ledger_api_msg . transaction_digest , ) self . context . logger . info ( \"checking transaction is settled.\" ) self . context . outbox . put_message ( message = ledger_api_msg_ ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) if is_settled : tx_behaviour . finish_processing ( ledger_api_dialogue ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ledger_api_msg_ is None : raise ValueError ( # pragma: nocover \"Could not retrieve last ledger_api message\" ) fipa_msg = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if fipa_msg is None : raise ValueError ( \"Could not retrieve last fipa message\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"transaction_digest\" : ledger_api_msg_ . transaction_digest . body }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"transaction confirmed, informing counterparty= {} of transaction digest.\" . format ( fipa_dialogue . dialogue_label . dialogue_opponent_addr [ - 5 :], ) ) else : tx_behaviour . failed_processing ( ledger_api_dialogue ) self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ( ledger_api_msg_ is not None and ledger_api_msg_ . performative != LedgerApiMessage . Performative . GET_BALANCE ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_message: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) )","title":"Step 3: Create the handler"},{"location":"aea/generic-skills-step-by-step/#step-4-create-the-strategy_1","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file (in my_generic_buyer/skills/generic_buyer/ ) to strategy.py and paste the following code (replacing the stub code already present in the file): from aea.common import Address from aea.exceptions import enforce from aea.helpers.search.generic import SIMPLE_SERVICE_MODEL from aea.helpers.search.models import ( Constraint , ConstraintType , Description , Location , Query , ) from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_MAX_UNIT_PRICE = 5 DEFAULT_MAX_TX_FEE = 2 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_MIN_QUANTITY = 1 DEFAULT_MAX_QUANTITY = 100 DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 DEFAULT_MAX_NEGOTIATIONS = 2 class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _max_unit_price = kwargs . pop ( \"max_unit_price\" , DEFAULT_MAX_UNIT_PRICE ) self . _min_quantity = kwargs . pop ( \"min_quantity\" , DEFAULT_MIN_QUANTITY ) self . _max_quantity = kwargs . pop ( \"max_quantity\" , DEFAULT_MAX_QUANTITY ) self . _max_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) self . _search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) self . _radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) self . _max_negotiations = kwargs . pop ( \"max_negotiations\" , DEFAULT_MAX_NEGOTIATIONS ) self . _is_stop_searching_on_result = kwargs . pop ( \"stop_searching_on_result\" , True ) super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id self . _is_searching = False self . _balance = 0 We initialize the strategy class by trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two methods are related to the OEF search service, add them under the initialization of the class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx @property def is_stop_searching_on_result ( self ) -> bool : \"\"\"Check if search is stopped on result.\"\"\" return self . _is_stop_searching_on_result @property def is_searching ( self ) -> bool : \"\"\"Check if the agent is searching.\"\"\" return self . _is_searching @is_searching . setter def is_searching ( self , is_searching : bool ) -> None : \"\"\"Check if the agent is searching.\"\"\" enforce ( isinstance ( is_searching , bool ), \"Can only set bool on is_searching!\" ) self . _is_searching = is_searching @property def balance ( self ) -> int : \"\"\"Get the balance.\"\"\" return self . _balance @balance . setter def balance ( self , balance : int ) -> None : \"\"\"Set the balance.\"\"\" self . _balance = balance @property def max_negotiations ( self ) -> int : \"\"\"Get the maximum number of negotiations the agent can start.\"\"\" return self . _max_negotiations def get_location_and_service_query ( self ) -> Query : \"\"\" Get the location and service query of the agent. :return: the query \"\"\" close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( self . _agent_location , self . _radius )) ) service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ close_to_my_service , service_key_filter ],) return query def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ service_key_filter ], model = SIMPLE_SERVICE_MODEL ) return query The following code block checks if the proposal that we received is acceptable based on the strategy: def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( all ( [ key in proposal . values for key in [ \"ledger_id\" , \"currency_id\" , \"price\" , \"service_id\" , \"quantity\" , \"tx_nonce\" , ] ] ) and proposal . values [ \"ledger_id\" ] == self . ledger_id and proposal . values [ \"price\" ] > 0 and proposal . values [ \"quantity\" ] >= self . _min_quantity and proposal . values [ \"quantity\" ] <= self . _max_quantity and proposal . values [ \"price\" ] <= proposal . values [ \"quantity\" ] * self . _max_unit_price and proposal . values [ \"currency_id\" ] == self . _currency_id and proposal . values [ \"service_id\" ] == self . _service_id and isinstance ( proposal . values [ \"tx_nonce\" ], str ) and proposal . values [ \"tx_nonce\" ] != \"\" ) return result The is_affordable_proposal method checks if we can afford the transaction based on the funds we have in our wallet on the ledger. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values . get ( \"price\" , 0 ) + self . _max_tx_fee result = self . balance >= payable else : result = True return result def get_acceptable_counterparties ( self , counterparties : Tuple [ str , ... ] ) -> Tuple [ str , ... ]: \"\"\" Process counterparties and drop unacceptable ones. :return: list of counterparties \"\"\" valid_counterparties : List [ str ] = [] for idx , counterparty in enumerate ( counterparties ): if idx < self . max_negotiations : valid_counterparties . append ( counterparty ) return tuple ( valid_counterparties ) def terms_from_proposal ( self , proposal : Description , counterparty_address : Address ) -> Terms : \"\"\" Get the terms from a proposal. :param proposal: the proposal :return: terms \"\"\" buyer_address = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ]] terms = Terms ( ledger_id = proposal . values [ \"ledger_id\" ], sender_address = buyer_address , counterparty_address = counterparty_address , amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, quantities_by_good_id = { proposal . values [ \"service_id\" ]: proposal . values [ \"quantity\" ] }, is_sender_payable_tx_fee = True , nonce = proposal . values [ \"tx_nonce\" ], fee_by_currency_id = { proposal . values [ \"currency_id\" ]: self . _max_tx_fee }, ) return terms def successful_trade_with_counterparty ( self , counterparty : str , data : Dict [ str , str ] ) -> None : \"\"\" Do something on successful trade. :param counterparty: the counterparty address :param data: the data :return: False \"\"\" pass","title":"Step 4: Create the strategy"},{"location":"aea/generic-skills-step-by-step/#step-5-create-the-dialogues_1","text":"As mentioned, when we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py (in my_generic_buyer/skills/generic_buyer/ ). Inside this file add the following code: from typing import Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogue as BaseSigningDialogue , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class SigningDialogue ( BaseSigningDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" BaseSigningDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_ledger_api_dialogue = None # type: Optional[LedgerApiDialogue] @property def associated_ledger_api_dialogue ( self ) -> LedgerApiDialogue : \"\"\"Get associated_ledger_api_dialogue.\"\"\" if self . _associated_ledger_api_dialogue is None : raise AEAEnforceError ( \"LedgerApiDialogue not set!\" ) return self . _associated_ledger_api_dialogue @associated_ledger_api_dialogue . setter def associated_ledger_api_dialogue ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\"Set associated_ledger_api_dialogue\"\"\" enforce ( self . _associated_ledger_api_dialogue is None , \"LedgerApiDialogue already set!\" , ) self . _associated_ledger_api_dialogue = ledger_api_dialogue class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseSigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = SigningDialogue , ) The dialogues class stores dialogue with each AEA and other AEA components so we can have access to previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA.","title":"Step 5: Create the dialogues"},{"location":"aea/generic-skills-step-by-step/#step-6-update-the-yaml-files_1","text":"Since we made so many changes to our AEA we have to update the skill.yaml to contain our newly created scripts and the details that will be used from the strategy. First, we update the skill.yaml . Make sure you update your skill.yaml with the following configuration: name : generic_buyer author : fetchai version : 0.1.0 type : skill description : The weather client skill implements the skill to purchase weather data. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : README.md : QmTR91jm7WfJpmabisy74NR5mc35YXjDU1zQAUKZeHRw8L __init__.py : QmU5vrC8FipyjfS5biNa6qDWdp4aeH5h4YTtbFDmCg8Chj behaviours.py : QmNwvSjEz4kzM3gWtnKbZVFJc2Z85Nb748CWAK4C4Sa4nT dialogues.py : QmNen91qQDWy4bNBKrB3LabAP5iRf29B8iwYss4NB13iNU handlers.py : QmZfudXXbdiREiViuwPZDXoQQyXT2ySQHdF7psQsohZXQy strategy.py : QmcrwaEWvKHDCNti8QjRhB4utJBJn5L8GpD27Uy9zHwKhY fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.12.0 contracts : [] protocols : - fetchai/default:0.11.0 - fetchai/fipa:0.12.0 - fetchai/ledger_api:0.9.0 - fetchai/oef_search:0.12.0 - fetchai/signing:0.9.0 skills : [] behaviours : search : args : search_interval : 5 class_name : GenericSearchBehaviour transaction : args : max_processing : 420 transaction_interval : 2 class_name : GenericTransactionBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler signing : args : {} class_name : GenericSigningHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues signing_dialogues : args : {} class_name : SigningDialogues strategy : args : is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 min_quantity : 1 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service stop_searching_on_result : true class_name : GenericStrategy dependencies : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading at or the currency we would like to transact with. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_buyer:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 6: Update the YAML files"},{"location":"aea/generic-skills-step-by-step/#run-the-aeas","text":"","title":"Run the AEAs"},{"location":"aea/generic-skills-step-by-step/#create-private-keys","text":"For each AEA, create the private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create private keys"},{"location":"aea/generic-skills-step-by-step/#update-the-aea-configurations","text":"In both AEAs run: aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Update the AEA configurations"},{"location":"aea/generic-skills-step-by-step/#fund-the-buyer-aea","text":"Create some wealth for your buyer on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai --sync","title":"Fund the buyer AEA"},{"location":"aea/generic-skills-step-by-step/#run-seller-aea","text":"Add the remaining packages for the seller AEA, then run it: aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add protocol fetchai/fipa:0.12.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address.","title":"Run seller AEA"},{"location":"aea/generic-skills-step-by-step/#run-buyer-aea","text":"Add the remaining packages for the buyer AEA: aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add protocol fetchai/fipa:0.12.0 aea add protocol fetchai/signing:0.9.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 Then, update the configuration of the buyer AEA's P2P connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' where SOME_ADDRESS is replaced accordingly. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Agentland testnet.","title":"Run buyer AEA"},{"location":"aea/generic-skills-step-by-step/#delete-the-aeas","text":"When you are done, go up a level and delete the AEAs. cd .. aea delete my_generic_seller aea delete my_generic_buyer","title":"Delete the AEAs"},{"location":"aea/generic-skills-step-by-step/#next-steps","text":"You have completed the \"Getting Started\" series. Congratulations!","title":"Next steps"},{"location":"aea/generic-skills-step-by-step/#recommended","text":"We recommend you build your own AEA next. There are many helpful guides on here and a developer community on Slack . Speak to you there!","title":"Recommended"},{"location":"aea/generic-skills/","text":"The AEA generic buyer and seller skills demonstrate an interaction between two AEAs. The provider of a service in the form of data for sale. The buyer of a service. Discussion The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True . Then you have to implement the method collect_from_data_source(self) inside the strategy.py file. Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search_agents Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the seller AEA First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.17.0 --alias my_seller_aea cd my_seller_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/generic_seller:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Create the buyer AEA Then, fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.18.0 --alias my_buyer_aea cd my_buyer_aea aea install aea build Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/generic_buyer:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Add keys for the seller AEA First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the buyer AEA The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the skill configurations The default skill configurations assume that the transaction is settled against the Fetch.ai ledger. In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml the data_for_sale is the data the seller AEA is offering for sale. models : ... strategy : args : currency_id : FET data_for_sale : generic : data has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy The data_model , data_model_name and the service_data are used to register the service in the SOEF search node and make your agent discoverable. The name of each data_model attribute must be a key in the service_data dictionary. In the generic buyer skill configuration ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) defines the search_query , which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service class_name : GenericStrategy Update the skill configurations Both skills are abstract skills, make them instantiable: cd my_seller_aea aea config set vendor.fetchai.skills.generic_seller.is_abstract false --type bool cd my_buyer_aea aea config set vendor.fetchai.skills.generic_buyer.is_abstract false --type bool Run the AEAs Run both AEAs from their respective terminals. First, run the seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the seller. Then, in the buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the buyer to connect to the same local agent communication network as the seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Generic skills"},{"location":"aea/generic-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True . Then you have to implement the method collect_from_data_source(self) inside the strategy.py file.","title":"Discussion"},{"location":"aea/generic-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search_agents Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/generic-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/generic-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/generic-skills/#create-the-seller-aea","text":"First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.17.0 --alias my_seller_aea cd my_seller_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/generic_seller:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the seller AEA"},{"location":"aea/generic-skills/#create-the-buyer-aea","text":"Then, fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.18.0 --alias my_buyer_aea cd my_buyer_aea aea install aea build Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/generic_buyer:0.19.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the buyer AEA"},{"location":"aea/generic-skills/#add-keys-for-the-seller-aea","text":"First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the seller AEA"},{"location":"aea/generic-skills/#add-keys-and-generate-wealth-for-the-buyer-aea","text":"The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the buyer AEA"},{"location":"aea/generic-skills/#update-the-skill-configurations","text":"The default skill configurations assume that the transaction is settled against the Fetch.ai ledger. In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml the data_for_sale is the data the seller AEA is offering for sale. models : ... strategy : args : currency_id : FET data_for_sale : generic : data has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy The data_model , data_model_name and the service_data are used to register the service in the SOEF search node and make your agent discoverable. The name of each data_model attribute must be a key in the service_data dictionary. In the generic buyer skill configuration ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) defines the search_query , which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service class_name : GenericStrategy","title":"Update the skill configurations"},{"location":"aea/generic-skills/#update-the-skill-configurations_1","text":"Both skills are abstract skills, make them instantiable: cd my_seller_aea aea config set vendor.fetchai.skills.generic_seller.is_abstract false --type bool cd my_buyer_aea aea config set vendor.fetchai.skills.generic_buyer.is_abstract false --type bool","title":"Update the skill configurations"},{"location":"aea/generic-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. First, run the seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the seller. Then, in the buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the buyer to connect to the same local agent communication network as the seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/generic-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/generic-storage/","text":"The AEA generic storage: description and usage. AEA Generic Storage AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style. Configuration Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage. Dialogues and Storage integration One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature. Keep terminal state dialogues The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example: Dialogues dump/restore on agent restart If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start. Offload terminal state dialogues If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured. Manual usage with skill components Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Generic Storage"},{"location":"aea/generic-storage/#aea-generic-storage","text":"AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style.","title":"AEA Generic Storage"},{"location":"aea/generic-storage/#configuration","text":"Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage.","title":"Configuration"},{"location":"aea/generic-storage/#dialogues-and-storage-integration","text":"One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature.","title":"Dialogues and Storage integration"},{"location":"aea/generic-storage/#keep-terminal-state-dialogues","text":"The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example:","title":"Keep terminal state dialogues"},{"location":"aea/generic-storage/#dialogues-dumprestore-on-agent-restart","text":"If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start.","title":"Dialogues dump/restore on agent restart"},{"location":"aea/generic-storage/#offload-terminal-state-dialogues","text":"If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured.","title":"Offload terminal state dialogues"},{"location":"aea/generic-storage/#manual-usage-with-skill-components","text":"Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Manual usage with skill components"},{"location":"aea/glossary/","text":"This glossary defines a number of common terms used throughout the documentation. For the definition of framework components consult the API docs. AEA: an Autonomous Economic Agent (AEA) is a \"an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner\". AEAs are a special type of agent. [ more ] (Software) Agent: a software agent is a computer program that acts on behalf of an entity (e.g. individual, organisation, business). [ more ] sOEF (Simple-OEF): The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents. [ more ]","title":"Glossary"},{"location":"aea/gym-example/","text":"The gym example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's gym framework. Discussion There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Download the necessary directories into your working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Install the gym and numpy library. pip install numpy gym Demo instructions Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym example"},{"location":"aea/gym-example/#discussion","text":"There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-example/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-example/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Download the necessary directories into your working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Install the gym and numpy library. pip install numpy gym","title":"Dependencies"},{"location":"aea/gym-example/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-example/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"aea/gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection. Discussion The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the AEA First, fetch the gym AEA: aea fetch fetchai/gym_aea:0.16.0 --alias my_gym_aea cd my_gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.13.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.11.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install Set up the training environment Copy the gym environment to the AEA directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Update the connection configuration aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom' Run the AEA with the gym connection aea run You will see the gym training logs. Delete the AEA When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea Communication This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment Skill Architecture The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Gym skill"},{"location":"aea/gym-skill/#discussion","text":"The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-skill/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-skill/#create-the-aea","text":"First, fetch the gym AEA: aea fetch fetchai/gym_aea:0.16.0 --alias my_gym_aea cd my_gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.13.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.11.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install","title":"Create the AEA"},{"location":"aea/gym-skill/#set-up-the-training-environment","text":"","title":"Set up the training environment"},{"location":"aea/gym-skill/#copy-the-gym-environment-to-the-aea-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the AEA directory"},{"location":"aea/gym-skill/#update-the-connection-configuration","text":"aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'","title":"Update the connection configuration"},{"location":"aea/gym-skill/#run-the-aea-with-the-gym-connection","text":"aea run You will see the gym training logs.","title":"Run the AEA with the gym connection"},{"location":"aea/gym-skill/#delete-the-aea","text":"When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea","title":"Delete the AEA"},{"location":"aea/gym-skill/#communication","text":"This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment","title":"Communication"},{"location":"aea/gym-skill/#skill-architecture","text":"The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Skill Architecture"},{"location":"aea/http-connection-and-skill/","text":"Description The HTTP server connection allows you to run a server inside a connection which accepts requests from clients. The HTTP server connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client. Steps Create a new AEA: aea create my_aea cd my_aea Add the http server connection package aea add connection fetchai/http_server:0.15.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.15.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We will implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, we delete the my_model.py and behaviour.py (in my_aea/skills/http_echo/ ). The server will be purely reactive, so we only require the handlers.py file. We update the skill.yaml accordingly, so set models: {} and behaviours: {} . Next we implement a basic handler which prints the received envelopes and responds: import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.http.message import HttpMessage class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message :return: None \"\"\" http_msg = cast ( HttpMessage , message ) if http_msg . performative == HttpMessage . Performative . REQUEST : self . context . logger . info ( \"received http request with method= {} , url= {} and body= {} \" . format ( http_msg . method , http_msg . url , http_msg . bodyy , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg ) else : self . context . logger . info ( \"received response ( {} ) unexpectedly!\" . format ( http_msg ) ) def _handle_get ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response ) ) http_response . counterparty = http_msg . counterparty self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = b \"\" , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response ) ) http_response . counterparty = http_msg . counterparty self . context . outbox . put_message ( message = http_response ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass We also need to update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler Finally, we run the fingerprinter: aea fingerprint skill fetchai/http_echo:0.13.0 Note, you will have to replace the author name with your author handle. We can now run the AEA: aea run In a separate terminal, we can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Connection"},{"location":"aea/http-connection-and-skill/#description","text":"The HTTP server connection allows you to run a server inside a connection which accepts requests from clients. The HTTP server connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client.","title":"Description"},{"location":"aea/http-connection-and-skill/#steps","text":"Create a new AEA: aea create my_aea cd my_aea Add the http server connection package aea add connection fetchai/http_server:0.15.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.15.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We will implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, we delete the my_model.py and behaviour.py (in my_aea/skills/http_echo/ ). The server will be purely reactive, so we only require the handlers.py file. We update the skill.yaml accordingly, so set models: {} and behaviours: {} . Next we implement a basic handler which prints the received envelopes and responds: import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.http.message import HttpMessage class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message :return: None \"\"\" http_msg = cast ( HttpMessage , message ) if http_msg . performative == HttpMessage . Performative . REQUEST : self . context . logger . info ( \"received http request with method= {} , url= {} and body= {} \" . format ( http_msg . method , http_msg . url , http_msg . bodyy , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg ) else : self . context . logger . info ( \"received response ( {} ) unexpectedly!\" . format ( http_msg ) ) def _handle_get ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response ) ) http_response . counterparty = http_msg . counterparty self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :return: None \"\"\" http_response = HttpMessage ( dialogue_reference = http_msg . dialogue_reference , target = http_msg . message_id , message_id = http_msg . message_id + 1 , performative = HttpMessage . Performative . RESPONSE , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , bodyy = b \"\" , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response ) ) http_response . counterparty = http_msg . counterparty self . context . outbox . put_message ( message = http_response ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass We also need to update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler Finally, we run the fingerprinter: aea fingerprint skill fetchai/http_echo:0.13.0 Note, you will have to replace the author name with your author handle. We can now run the AEA: aea run In a separate terminal, we can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"Steps"},{"location":"aea/identity/","text":"Note This section is incomplete and will soon be updated. The AEAs currently use the addresses associated with their private-public key pairs to identify themselves. To learn how to generate a private-public key pair check out the CLI section . To learn more about public-key cryptography check out Wikipedia . AEAs can provide attestations of their identity using third-party solutions. We have implemented a demo using Aries Hyperledger Cloud Agent which is available here .","title":"Identity"},{"location":"aea/interaction-protocol/","text":"Interaction protocols are possible communication scenarios between agents or agent components (specifically, skills and connections). There are multiple types of interactions an AEA can have: AEA to AEA interactions, as for instance demonstrated in the demo sections . AEA internal interactions, between components of the framework. Usually, an interaction involves three types of framework packages: skills , protocols and connections . Example 1: negotiation In the generic buyer/seller skills the protocol fetchai/fipa is used for maintaining the negotiation dialogue between two AEAs. The skills fetchai/generic_buyer and fetchai/generic_seller are used to implement the handling and generating of individual messages and associated logic. The connection fetchai/p2p_libp2p is used for connecting to the agent communication network . Example 2: AEA <> web client In the http connection and skill guide we demo how a skill ( fetchai/http_echo ) can be used to process http requests received by a http server connection ( fetchai/http_server ). The fetchai/http protocol is used for communication between the connection and skill. Example 3 : AEA <> 3rd party server The fetchai/http_client connection can be used to make requests to third party servers. Alternatively, a third party SDK can be wrapped in a connection and shared with other developers as a package. Often, the developer will also create a custom protocol to enforce the type of interactions permitted with the SDK wrapped in such a connection. Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: Trade between two AEAs Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"How AEAs talk to each other - interaction protocols"},{"location":"aea/interaction-protocol/#example-1-negotiation","text":"In the generic buyer/seller skills the protocol fetchai/fipa is used for maintaining the negotiation dialogue between two AEAs. The skills fetchai/generic_buyer and fetchai/generic_seller are used to implement the handling and generating of individual messages and associated logic. The connection fetchai/p2p_libp2p is used for connecting to the agent communication network .","title":"Example 1: negotiation"},{"location":"aea/interaction-protocol/#example-2-aea-web-client","text":"In the http connection and skill guide we demo how a skill ( fetchai/http_echo ) can be used to process http requests received by a http server connection ( fetchai/http_server ). The fetchai/http protocol is used for communication between the connection and skill.","title":"Example 2: AEA &lt;&gt; web client"},{"location":"aea/interaction-protocol/#example-3-aea-3rd-party-server","text":"The fetchai/http_client connection can be used to make requests to third party servers. Alternatively, a third party SDK can be wrapped in a connection and shared with other developers as a package. Often, the developer will also create a custom protocol to enforce the type of interactions permitted with the SDK wrapped in such a connection.","title":"Example 3 : AEA &lt;&gt; 3rd party server"},{"location":"aea/interaction-protocol/#next-steps","text":"","title":"Next steps"},{"location":"aea/interaction-protocol/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: Trade between two AEAs","title":"Recommended"},{"location":"aea/interaction-protocol/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"aea/known-limits/","text":"The AEA framework makes a multitude of tradeoffs. Here we present an incomplete list of known limitations: The AEABuilder checks the consistency of packages at the add stage. However, it does not currently check the consistency again at the load stage. This means, if a package is tampered with after it is added to the AEABuilder then these inconsistencies might not be detected by the AEABuilder . The AEABuilder assumes that packages with public ids of identical author and package name have a matching version. As a result, if a developer uses a package with matching author and package name but different version in the public id, then the AEABuilder will not detect this and simply use the last loaded package. The order in which setup and teardown are called on the skills, and act is called on the behaviours, is not guaranteed. Skills should be designed to work independently. Where skills use the shared_context to exchange information they must do so safely.","title":"Known limitations"},{"location":"aea/language-agnostic-definition/","text":"An Autonomous Economic Agent is, in technical terms, defined by the following characteristics: It MUST be capable of receiving and sending Envelopes which satisfy the following protobuf schema: syntax = \"proto3\" ; package aea ; message Envelope { string to = 1 ; string sender = 2 ; string protocol_id = 3 ; bytes message = 4 ; string uri = 5 ; } The format for the above fields, except message , is specified below. to and sender : an address derived from the private key of a secp256k1 -compatible elliptic curve protocol_id : this must match a defined regular expression (see below) message : a bytes string representing a serialized message in the specified protocol URI : this syntax It MUST implement each protocol's message with the required meta-fields: import \"google/protobuf/struct.proto\" ; message DialogueMessage { int32 message_id = 1 ; string dialogue_starter_reference = 2 ; string dialogue_responder_reference = 3 ; int32 target = 4 ; bytes content = 5 ; } message Message { oneof message { google.protobuf.Struct body = 1 ; DialogueMessage dialogue_message = 2 ; } } where content is replaced with the protocol specific content (see here for details). It MUST implement protocols according to their specification (see here for details). It SHOULD implement the fetchai/default:0.11.0 protocol which satisfies the following protobuf schema: syntax = \"proto3\" ; package aea . fetchai.default ; message DefaultMessage { // Custom Types message ErrorCode { enum ErrorCodeEnum { UNSUPPORTED_PROTOCOL = 0 ; DECODING_ERROR = 1 ; INVALID_MESSAGE = 2 ; UNSUPPORTED_SKILL = 3 ; INVALID_DIALOGUE = 4 ; } ErrorCodeEnum error_code = 1 ; } // Performatives and contents message Bytes_Performative { bytes content = 1 ; } message Error_Performative { ErrorCode error_code = 1 ; string error_msg = 2 ; map < string , bytes > error_data = 3 ; } message End_Performative {} oneof performative { Bytes_Performative bytes = 5 ; End_Performative end = 6 ; Error_Performative error = 7 ; } } The protocol id MUST match the following regular expression: ^([a-zA-Z_][a-zA-Z0-9_]{0,127})/([a-zA-Z_][a-zA-Z0-9_]{0,127})(:((any|latest|((0|[1-9]\\d*))\\.((0|[1-9]\\d*))\\.((0|[1-9]\\d*))(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)))?$ It is recommended that it processes Envelopes asynchronously. Note, the specification regarding the processing of messages does not impose any particular implementation, and the AEA can be designed to process envelopes either synchronously and asynchronously. However, asynchronous message handling enables the agent to be more responsive and scalable in maintaining many concurrent dialogues with its peers. It MUST have an identity in the form of, at a minimum, an address derived from a public key and its associated private key (where the elliptic curve must be of type SECP256k1 ). It SHOULD implement handling of errors using the fetchai/default:0.11.0 protocol. The protobuf schema is given above. It MUST implement the following principles when handling messages: It MUST ALWAYS handle incoming envelopes/messages and NEVER raise an exception when decoding and validating the message. This ensures another AEA cannot cause the agent to fail by sending a malicious envelope/message. It MUST NEVER handle outgoing messages and ALWAYS raise an exception when validating the message. An exception implies that the handler is resolving a bug in the implementation. Note Additional constraints will be added soon!","title":"Language Agnostic Definition"},{"location":"aea/ledger-integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers. The framework currently natively supports two ledgers: Fetch.ai Ethereum Cosmos However, support for additional ledgers can be added to the framework at runtime. For a ledger to be considered supported in the framework, three abstract base classes need to be implemented: the LedgerApi class wraps the API to talk to the ledger and its helper methods the Crypto class wraps the API to perform cryptographic operations for the relevant ledger the FaucetApi class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed: Examples of how to interact with the crypto registry: from aea.crypto.registries import crypto_registry , make_crypto , register_crypto # by default we can use the native cryptos fetchai_crypto = make_crypto ( \"fetchai\" ) # we can check what cryptos are registered crypto_registry . supported_ids # we can also add a new crypto to the registry register_crypto ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerCrypto\" ) # and then make it anywhere my_ledger_crypto = make_crypto ( \"my_ledger_id\" ) Examples of how to interact with the ledger API registry: from aea.crypto.registries import ledger_apis_registry , make_ledger_api , register_ledger_api # by default we can use the native ledger apis CONFIG = { \"network\" : \"testnet\" } fetchai_ledger_api = make_ledger_api ( \"fetchai\" , ** CONFIG ) # we can check what ledger apis are registered ledger_apis_registry . supported_ids # we can also add a new ledger api to the registry register_ledger_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerApi\" ) # and then make it anywhere my_ledger_api = make_ledger_api ( \"my_ledger_id\" ) Examples of how to interact with the faucet API registry: from aea.crypto.registries import faucet_apis_registry , make_faucet_api , register_faucet_api # by default we can use the native faucet apis CONFIG = dict ( poll_interval = 1.0 ) fetchai_faucet_api = make_faucet_api ( \"fetchai\" , ** CONFIG ) # we can check what faucet apis are registered faucet_apis_registry . supported_ids # we can also add a new faucet api to the registry register_faucet_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerFaucetApi\" ) # and then make it anywhere my_faucet_api = make_faucet_api ( \"my_ledger_id\" ) The framework wraps all LedgerApi classes and exposes them in the LedgerApis classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the Wallet . The separation between the Crypto and LedgerApi is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's Wallet whilst LedgerApis are accessible by all skills. CosmWasm supporting chains The Fetch.ai networks use CosmWasm for smart contract support. Currently, to use the smart contract functionality of the Fetch.ai network you have to install a CLI tool which is used by the AEA framework to perform some necessary actions for the smart contract functionality on-chain. Install Rust using the following command: curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Update the configuration for Rust: rustup default stable cargo version # If this is lower than 1.44.1+, update with: # rustup update stable rustup target list --installed rustup target add wasm32-unknown-unknown Install fetchd : git clone https://github.com/fetchai/fetchd.git cd fetchd git checkout release/v0.2.x make install # Check if wasmcli is properly installed wasmcli version # Version should be >=0.2.5 Configure wasmcli : wasmcli config chain-id agent-land wasmcli config trust-node false wasmcli config node https://rpc-agent-land.fetch.ai:443 wasmcli config output json wasmcli config indent true wasmcli config broadcast-mode block Now wasmcli will be ready for use on your system.","title":"Ledger & Crypto APIs"},{"location":"aea/ledger-integration/#cosmwasm-supporting-chains","text":"The Fetch.ai networks use CosmWasm for smart contract support. Currently, to use the smart contract functionality of the Fetch.ai network you have to install a CLI tool which is used by the AEA framework to perform some necessary actions for the smart contract functionality on-chain. Install Rust using the following command: curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh Update the configuration for Rust: rustup default stable cargo version # If this is lower than 1.44.1+, update with: # rustup update stable rustup target list --installed rustup target add wasm32-unknown-unknown Install fetchd : git clone https://github.com/fetchai/fetchd.git cd fetchd git checkout release/v0.2.x make install # Check if wasmcli is properly installed wasmcli version # Version should be >=0.2.5 Configure wasmcli : wasmcli config chain-id agent-land wasmcli config trust-node false wasmcli config node https://rpc-agent-land.fetch.ai:443 wasmcli config output json wasmcli config indent true wasmcli config broadcast-mode block Now wasmcli will be ready for use on your system.","title":"CosmWasm supporting chains"},{"location":"aea/logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an AEA. First of all, create your AEA. aea create my_aea cd my_aea The aea-config.yaml file should look like this. agent_name : my_aea author : fetchai version : 0.1.0 description : '' license : Apache-2.0 aea_version : 0.6.0 fingerprint : {} fingerprint_ignore_patterns : [] connections : - fetchai/stub:0.15.0 contracts : [] protocols : - fetchai/default:0.11.0 skills : - fetchai/error:0.11.0 default_connection : fetchai/stub:0.15.0 default_ledger : fetchai logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} registry_path : ../packages By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : False formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : False This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter.","title":"Logging"},{"location":"aea/message-routing/","text":"Message routing can be split up into the routing of incoming and outgoing Messages . Incoming Messages Connections receive Envelopes which they deposit in InBox AgentLoop 's react picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the error Skill Messages are dispatched to all relevant Handlers . To limit dispatch to a specific Handler in a specific Skill the EnvelopeContext can be used to reference a unique skill id . Outgoing Messages Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on three rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can encode envelopes where necessary or pass them on for transport to another agent Address fields in Envelopes / Messages Addresses can reference agents or components within an agent. If the address references an agent then it must follow the address standard of agents. If the address references a component then it must be a public id.","title":"Message routing"},{"location":"aea/message-routing/#incoming-messages","text":"Connections receive Envelopes which they deposit in InBox AgentLoop 's react picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the error Skill Messages are dispatched to all relevant Handlers . To limit dispatch to a specific Handler in a specific Skill the EnvelopeContext can be used to reference a unique skill id .","title":"Incoming Messages"},{"location":"aea/message-routing/#outgoing-messages","text":"Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on three rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can encode envelopes where necessary or pass them on for transport to another agent","title":"Outgoing Messages"},{"location":"aea/message-routing/#address-fields-in-envelopesmessages","text":"Addresses can reference agents or components within an agent. If the address references an agent then it must follow the address standard of agents. If the address references a component then it must be a public id.","title":"Address fields in Envelopes/Messages"},{"location":"aea/ml-skills/","text":"The AEA ML (machine learning) skills demonstrate an interaction between two AEAs trading data. There are two types of AEAs: The ml_data_provider which sells training data. The ml_model_trainer which trains a model Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. Communication This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create data provider AEA First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.20.0 cd ml_data_provider aea install aea build Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/ml_data_provider:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Create model trainer AEA Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.21.0 cd ml_model_trainer aea install aea build Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/ml_train:0.19.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Add keys for the data provider AEA First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the model trainer AEA The model trainer needs to have some wealth to purchase the data from the data provider. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run both AEAs Run both AEAs from their respective terminals. First, run the data provider AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the ML data provider. Then, in the ML model trainer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the model trainer to connect to the same local agent communication network as the data provider. Then run the model trainer AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"ML skills"},{"location":"aea/ml-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/ml-skills/#communication","text":"This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger","title":"Communication"},{"location":"aea/ml-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/ml-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/ml-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/ml-skills/#create-data-provider-aea","text":"First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.20.0 cd ml_data_provider aea install aea build Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/ml_data_provider:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build","title":"Create data provider AEA"},{"location":"aea/ml-skills/#create-model-trainer-aea","text":"Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.21.0 cd ml_model_trainer aea install aea build Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/ml_train:0.19.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build","title":"Create model trainer AEA"},{"location":"aea/ml-skills/#add-keys-for-the-data-provider-aea","text":"First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the data provider AEA"},{"location":"aea/ml-skills/#add-keys-and-generate-wealth-for-the-model-trainer-aea","text":"The model trainer needs to have some wealth to purchase the data from the data provider. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the model trainer AEA"},{"location":"aea/ml-skills/#run-both-aeas","text":"Run both AEAs from their respective terminals. First, run the data provider AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the ML data provider. Then, in the ML model trainer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the model trainer to connect to the same local agent communication network as the data provider. Then run the model trainer AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/ml-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"Cleaning up"},{"location":"aea/modes/","text":"We can run an AEA in multiple modes thanks to the configurable design of the framework. The AEA contains two runnable parts, the AgentLoop , which operates the skills, and the Multiplexer, which operates the connections. The AgentLoop can be configured to run in async or sync mode. The Multiplexer by default runs in async mode. The AEA itself, can be configured to run in async mode, if both the Multiplexer and AgentLoop have the same mode, or in threaded mode. The latter ensures that AgentLoop and Multiplexer are run in separate threads.","title":"Modes of running an AEA"},{"location":"aea/multi-agent-manager/","text":"The MultiAgentManager allows managing multiple agent projects programmatically. Setup We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager () Adding projects We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.20.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.21.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name Adding agent instances Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . keys_dir , f \"fetchai_private_key_ { weather_station_name } .txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . keys_dir , f \"fetchai_connection_private_key_ { weather_station_name } .txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) CERT_PATH_STATION = Path ( manager . certs_dir , f \"conn_cert_ { weather_station_name } .txt\" ) . absolute () SOEF_STORAGE_PATH_STATION = Path ( manager . keys_dir , f \"soef_token_ { weather_station_name } .txt\" ) . absolute () FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . keys_dir , f \"fetchai_private_key_ { weather_client_name } .txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . keys_dir , f \"fetchai_connection_private_key_ { weather_client_name } .txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT ) CERT_PATH_CLIENT = Path ( manager . certs_dir , f \"conn_cert_ { weather_client_name } .txt\" ) . absolute () SOEF_STORAGE_PATH_CLIENT = Path ( manager . keys_dir , f \"soef_token_ { weather_client_name } .txt\" ) . absolute () Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : str ( FET_PRIVATE_KEY_PATH_STATION )}, \"connection_private_key_paths\" : { \"fetchai\" : str ( FET_CONNECTION_PRIVATE_KEY_PATH_STATION )} } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.14.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.15.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"save_path\" : str ( CERT_PATH_STATION ) }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : str ( SOEF_STORAGE_PATH_STATION ) } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : str ( FET_PRIVATE_KEY_PATH_CLIENT )}, \"connection_private_key_paths\" : { \"fetchai\" : str ( FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT )} } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"save_path\" : str ( CERT_PATH_CLIENT ) }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : str ( SOEF_STORAGE_PATH_CLIENT ) } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) Running the agents: import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 ) Stopping the agents: manager . stop_all_agents () Cleaning up manager . stop_manager ()","title":"Multi agent manager"},{"location":"aea/multi-agent-manager/#setup","text":"We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager ()","title":"Setup"},{"location":"aea/multi-agent-manager/#adding-projects","text":"We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.20.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.21.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name","title":"Adding projects"},{"location":"aea/multi-agent-manager/#adding-agent-instances","text":"Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . keys_dir , f \"fetchai_private_key_ { weather_station_name } .txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . keys_dir , f \"fetchai_connection_private_key_ { weather_station_name } .txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) CERT_PATH_STATION = Path ( manager . certs_dir , f \"conn_cert_ { weather_station_name } .txt\" ) . absolute () SOEF_STORAGE_PATH_STATION = Path ( manager . keys_dir , f \"soef_token_ { weather_station_name } .txt\" ) . absolute () FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . keys_dir , f \"fetchai_private_key_ { weather_client_name } .txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . keys_dir , f \"fetchai_connection_private_key_ { weather_client_name } .txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT ) CERT_PATH_CLIENT = Path ( manager . certs_dir , f \"conn_cert_ { weather_client_name } .txt\" ) . absolute () SOEF_STORAGE_PATH_CLIENT = Path ( manager . keys_dir , f \"soef_token_ { weather_client_name } .txt\" ) . absolute () Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : str ( FET_PRIVATE_KEY_PATH_STATION )}, \"connection_private_key_paths\" : { \"fetchai\" : str ( FET_CONNECTION_PRIVATE_KEY_PATH_STATION )} } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.14.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.15.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"save_path\" : str ( CERT_PATH_STATION ) }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : str ( SOEF_STORAGE_PATH_STATION ) } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : str ( FET_PRIVATE_KEY_PATH_CLIENT )}, \"connection_private_key_paths\" : { \"fetchai\" : str ( FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT )} } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"save_path\" : str ( CERT_PATH_CLIENT ) }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : str ( SOEF_STORAGE_PATH_CLIENT ) } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides )","title":"Adding agent instances"},{"location":"aea/multi-agent-manager/#running-the-agents","text":"import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 )","title":"Running the agents:"},{"location":"aea/multi-agent-manager/#stopping-the-agents","text":"manager . stop_all_agents ()","title":"Stopping the agents:"},{"location":"aea/multi-agent-manager/#cleaning-up","text":"manager . stop_manager ()","title":"Cleaning up"},{"location":"aea/multiplexer-standalone/","text":"The Multiplexer can be used stand-alone. This way a developer can utilise the protocols and connections independent of the Agent or AEA classes. First, import the Python and application specific libraries and set the static variables. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Instantiate a Multiplexer A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = Identity ( \"some_agent\" , \"some_address\" ) ) multiplexer = Multiplexer ([ stub_connection ]) Start the Multiplexer We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.11.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) Shutdown Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join () Your turn Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = Identity ( \"some_agent\" , \"some_address\" ) ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.11.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Use multiplexer stand-alone"},{"location":"aea/multiplexer-standalone/#instantiate-a-multiplexer","text":"A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = Identity ( \"some_agent\" , \"some_address\" ) ) multiplexer = Multiplexer ([ stub_connection ])","title":"Instantiate a Multiplexer"},{"location":"aea/multiplexer-standalone/#start-the-multiplexer","text":"We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the Multiplexer"},{"location":"aea/multiplexer-standalone/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.11.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/multiplexer-standalone/#shutdown","text":"Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join ()","title":"Shutdown"},{"location":"aea/multiplexer-standalone/#your-turn","text":"Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes.","title":"Your turn"},{"location":"aea/multiplexer-standalone/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , identity = Identity ( \"some_agent\" , \"some_address\" ) ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.11.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/oef-ledger/","text":"The Open Economic Framework (OEF) and Decentralized Ledger Technologies (DLTs) allow AEAs to create value through their interaction with other AEAs. The following diagram illustrates the relation of AEAs to the OEF and DLTs. Open Economic Framework (OEF) The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. As such the OEF defines the decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF's capabilities are fulfilled by two components: a permissionless, public peer to peer (agent to agent) communication network, called the Agent Communication Network ; a set of agent interaction protocols ; and a centralized search and discovery system . The latter will be decentralized over time. Agent Communication Network (ACN) The agent communication network is a peer-to-peer communication network for agents . It allows agents, in particular AEAs, to send and receive envelopes between each other. The implementation builds on the open-source libp2p library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses. Agents can receive messages from other agents if they are both connected to the ACN (see here for an example). Centralized search and discovery A simple OEF (SOEF) search node allows agents to search and discover each other. In particular, agents can register themselves and their services as well as send search requests. For two agents to be able to find each other, at least one must register themselves and the other must query the SOEF search node for it. Detailed documentation is provided here . Ledgers Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. They optionally ensure the truth and integrity of agent to agent interactions. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain. The Python version of the AEA Framework currently integrates with three ledgers: Fetch.ai ledger Ethereum ledger Cosmos ledger However, the framework makes it straightforward for further ledgers to be added by any developer. AEAs as second layer technology The following presentation discusses how AEAs can be seen as second layer technology to ledgers.","title":"Relation to OEF and Ledger"},{"location":"aea/oef-ledger/#open-economic-framework-oef","text":"The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. As such the OEF defines the decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF's capabilities are fulfilled by two components: a permissionless, public peer to peer (agent to agent) communication network, called the Agent Communication Network ; a set of agent interaction protocols ; and a centralized search and discovery system . The latter will be decentralized over time.","title":"Open Economic Framework (OEF)"},{"location":"aea/oef-ledger/#agent-communication-network-acn","text":"The agent communication network is a peer-to-peer communication network for agents . It allows agents, in particular AEAs, to send and receive envelopes between each other. The implementation builds on the open-source libp2p library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses. Agents can receive messages from other agents if they are both connected to the ACN (see here for an example).","title":"Agent Communication Network (ACN)"},{"location":"aea/oef-ledger/#centralized-search-and-discovery","text":"A simple OEF (SOEF) search node allows agents to search and discover each other. In particular, agents can register themselves and their services as well as send search requests. For two agents to be able to find each other, at least one must register themselves and the other must query the SOEF search node for it. Detailed documentation is provided here .","title":"Centralized search and discovery"},{"location":"aea/oef-ledger/#ledgers","text":"Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. They optionally ensure the truth and integrity of agent to agent interactions. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain. The Python version of the AEA Framework currently integrates with three ledgers: Fetch.ai ledger Ethereum ledger Cosmos ledger However, the framework makes it straightforward for further ledgers to be added by any developer.","title":"Ledgers"},{"location":"aea/oef-ledger/#aeas-as-second-layer-technology","text":"The following presentation discusses how AEAs can be seen as second layer technology to ledgers.","title":"AEAs as second layer technology"},{"location":"aea/oracle-demo/","text":"This demo shows how an AEA can be used to maintain an oracle and how another AEA can request the oracle value. Discussion Oracle agents are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities. This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo Create the oracle AEA Fetch the AEA that will deploy and update the oracle contract. aea fetch fetchai/coin_price_oracle:0.4.0 cd coin_price_oracle aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/ledger:0.12.0 aea add connection fetchai/p2p_libp2p:0.14.0 aea add skill fetchai/coin_price:0.3.0 aea add skill fetchai/simple_oracle:0.3.0 aea install aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 Then update the agent configuration with the default routing and cert requests: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/http:0.11.0\": \"fetchai/http_client:0.16.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the oracle AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Create the oracle client AEA From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract. aea fetch fetchai/coin_price_oracle_client:0.1.0 cd coin_price_oracle_client aea install Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/simple_oracle_client:0.2.0 aea install aea config set agent.default_connection fetchai/ledger:0.12.0 Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/http:0.11.0\": \"fetchai/http_client:0.16.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\" }' Change the default ledger: aea config set agent.default_ledger ethereum Create the private key for the oracle client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum The oracle AEAs require either a locally running test node or a connection to a remote testnet. Setting up with a local Ganache node The easiest way to test the oracle agents is to set up a local Ethereum test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat coin_price_oracle/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat coin_price_oracle_client/ethereum_private_key.txt ) ,1000000000000000000000\" Run the enclosed Python script (with web3 installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent. import json import os from web3 import Web3 FILE_DIR = os . path . dirname ( os . path . realpath ( __file__ )) CONTRACT_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/vendor/fetchai/contracts/fet_erc20/build/FetERC20Mock.json\" ) ORACLE_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle/ethereum_private_key.txt\" ) CLIENT_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/ethereum_private_key.txt\" ) # Solidity source code with open ( CONTRACT_PATH ) as file : compiled_sol = json . load ( file ) # web3.py instance w3 = Web3 ( Web3 . HTTPProvider ( 'http://127.0.0.1:8545' )) # Import oracle account from private key and set to default account with open ( ORACLE_PRIVATE_KEY_PATH ) as file : private_key = file . read () oracle_account = w3 . eth . account . privateKeyToAccount ( private_key ) w3 . eth . defaultAccount = oracle_account . address # Import client account from private key with open ( CLIENT_PRIVATE_KEY_PATH ) as file : private_key = file . read () client_account = w3 . eth . account . privateKeyToAccount ( private_key ) # Deploy mock Fetch ERC20 contract FetERC20Mock = w3 . eth . contract ( abi = compiled_sol [ 'abi' ], bytecode = compiled_sol [ 'bytecode' ]) # Submit the transaction that deploys the contract tx_hash = FetERC20Mock . constructor ( name = \"FetERC20Mock\" , symbol = \"MFET\" , initialSupply = int ( 1e23 ), decimals_ = 18 ) . transact () # Wait for the transaction to be mined, and get the transaction receipt tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) # Print out the contract address print ( \"FetERC20Mock contract deployed at:\" , tx_receipt . contractAddress ) # Get deployed contract fet_erc20_mock = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = compiled_sol [ 'abi' ]) # Transfer some test FET to oracle client account tx_hash = fet_erc20_mock . functions . transfer ( client_account . address , int ( 1e20 )) . transact () tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) Set the ERC20 contract address for the oracle AEA: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.erc20_address ERC20_ADDRESS where ERC20_ADDRESS is in the output of the script above. Run the oracle AEA Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle ] Oracle contract successfully deployed! ... info: [ coin_price_oracle ] Oracle role successfully granted! ... info: [ coin_price_oracle ] Oracle value successfully updated! The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds). Set the ERC20 and oracle contract addresses for the oracle client AEA: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.erc20_address ERC20_ADDRESS aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.oracle_contract_address ORACLE_ADDRESS where ORACLE_ADDRESS appears in the contractAddress field of the contract deployment transaction. Run the oracle client AEA Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle_client ] Oracle client contract successfully deployed! ... info: [ coin_price_oracle_client ] Oracle client transactions approved! ... info: [ coin_price_oracle_client ] Oracle value successfully requested! The AEA will continue to request the latest coin price at the default time interval (every 15 seconds).","title":"Oracle skills"},{"location":"aea/oracle-demo/#discussion","text":"Oracle agents are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities. This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract.","title":"Discussion"},{"location":"aea/oracle-demo/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/oracle-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/oracle-demo/#demo","text":"","title":"Demo"},{"location":"aea/oracle-demo/#create-the-oracle-aea","text":"Fetch the AEA that will deploy and update the oracle contract. aea fetch fetchai/coin_price_oracle:0.4.0 cd coin_price_oracle aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/ledger:0.12.0 aea add connection fetchai/p2p_libp2p:0.14.0 aea add skill fetchai/coin_price:0.3.0 aea add skill fetchai/simple_oracle:0.3.0 aea install aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 Then update the agent configuration with the default routing and cert requests: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/http:0.11.0\": \"fetchai/http_client:0.16.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' And change the default ledger: aea config set agent.default_ledger ethereum Additionally, create the private key for the oracle AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create the oracle AEA"},{"location":"aea/oracle-demo/#create-the-oracle-client-aea","text":"From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract. aea fetch fetchai/coin_price_oracle_client:0.1.0 cd coin_price_oracle_client aea install Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.16.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/simple_oracle_client:0.2.0 aea install aea config set agent.default_connection fetchai/ledger:0.12.0 Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/http:0.11.0\": \"fetchai/http_client:0.16.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\" }' Change the default ledger: aea config set agent.default_ledger ethereum Create the private key for the oracle client AEA. Generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum The oracle AEAs require either a locally running test node or a connection to a remote testnet.","title":"Create the oracle client AEA"},{"location":"aea/oracle-demo/#setting-up-with-a-local-ganache-node","text":"The easiest way to test the oracle agents is to set up a local Ethereum test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat coin_price_oracle/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat coin_price_oracle_client/ethereum_private_key.txt ) ,1000000000000000000000\" Run the enclosed Python script (with web3 installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent. import json import os from web3 import Web3 FILE_DIR = os . path . dirname ( os . path . realpath ( __file__ )) CONTRACT_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/vendor/fetchai/contracts/fet_erc20/build/FetERC20Mock.json\" ) ORACLE_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle/ethereum_private_key.txt\" ) CLIENT_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/ethereum_private_key.txt\" ) # Solidity source code with open ( CONTRACT_PATH ) as file : compiled_sol = json . load ( file ) # web3.py instance w3 = Web3 ( Web3 . HTTPProvider ( 'http://127.0.0.1:8545' )) # Import oracle account from private key and set to default account with open ( ORACLE_PRIVATE_KEY_PATH ) as file : private_key = file . read () oracle_account = w3 . eth . account . privateKeyToAccount ( private_key ) w3 . eth . defaultAccount = oracle_account . address # Import client account from private key with open ( CLIENT_PRIVATE_KEY_PATH ) as file : private_key = file . read () client_account = w3 . eth . account . privateKeyToAccount ( private_key ) # Deploy mock Fetch ERC20 contract FetERC20Mock = w3 . eth . contract ( abi = compiled_sol [ 'abi' ], bytecode = compiled_sol [ 'bytecode' ]) # Submit the transaction that deploys the contract tx_hash = FetERC20Mock . constructor ( name = \"FetERC20Mock\" , symbol = \"MFET\" , initialSupply = int ( 1e23 ), decimals_ = 18 ) . transact () # Wait for the transaction to be mined, and get the transaction receipt tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) # Print out the contract address print ( \"FetERC20Mock contract deployed at:\" , tx_receipt . contractAddress ) # Get deployed contract fet_erc20_mock = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = compiled_sol [ 'abi' ]) # Transfer some test FET to oracle client account tx_hash = fet_erc20_mock . functions . transfer ( client_account . address , int ( 1e20 )) . transact () tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash )","title":"Setting up with a local Ganache node"},{"location":"aea/oracle-demo/#set-the-erc20-contract-address-for-the-oracle-aea","text":"aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.erc20_address ERC20_ADDRESS where ERC20_ADDRESS is in the output of the script above.","title":"Set the ERC20 contract address for the oracle AEA:"},{"location":"aea/oracle-demo/#run-the-oracle-aea","text":"Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle ] Oracle contract successfully deployed! ... info: [ coin_price_oracle ] Oracle role successfully granted! ... info: [ coin_price_oracle ] Oracle value successfully updated! The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds).","title":"Run the oracle AEA"},{"location":"aea/oracle-demo/#set-the-erc20-and-oracle-contract-addresses-for-the-oracle-client-aea","text":"aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.erc20_address ERC20_ADDRESS aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.oracle_contract_address ORACLE_ADDRESS where ORACLE_ADDRESS appears in the contractAddress field of the contract deployment transaction.","title":"Set the ERC20 and oracle contract addresses for the oracle client AEA:"},{"location":"aea/oracle-demo/#run-the-oracle-client-aea","text":"Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle_client ] Oracle client contract successfully deployed! ... info: [ coin_price_oracle_client ] Oracle client transactions approved! ... info: [ coin_price_oracle_client ] Oracle value successfully requested! The AEA will continue to request the latest coin price at the default time interval (every 15 seconds).","title":"Run the oracle client AEA"},{"location":"aea/orm-integration/","text":"This guide demonstrates how to configure an AEA to interact with a database using python-sql objects. Discussion Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. We assume, that you followed the guide for the thermometer-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database (although you can follow the guide without having access to a sensor). Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file. Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the seller AEA First, fetch the seller AEA, which will provide data: aea fetch fetchai/thermometer_aea:0.18.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Create the buyer client In another terminal, fetch the AEA that will query the seller AEA. aea fetch fetchai/thermometer_client:0.19.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Add keys for the thermometer AEA First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the thermometer client AEA The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-key fetchai Update the seller and buyer AEA skill configurations In my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml , replace the data_for_sale with your data: models : ... strategy : args : currency_id : FET data_for_sale : temperature : 26 has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : thermometer_data service_id : thermometer_data unit_price : 10 class_name : Strategy dependencies : SQLAlchemy : {} The data_model and the service_data are used to register the service in the SOEF search node and make your agent discoverable. The name of each attribute must be a key in the service_data dictionary. In my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) ensure you have matching data. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : thermometer_data search_radius : 5.0 service_id : thermometer_data class_name : Strategy After changing the skill configuration files you should run the following command for both agents to install each dependency: aea install Modify the seller's strategy Before being able to modify a package we need to eject it from vendor: aea eject skill fetchai/thermometer:0.18.0 This will move the package to your skills directory and reset the version to 0.1.0 and the author to your author handle. Open the strategy.py (in my_thermometer_aea/skills/thermometer/strategy.py ) with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: class Strategy ( GenericStrategy ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () super () . __init__ ( ** kwargs ) At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query ) After modifying the skill we need to fingerprint it: aea fingerprint skill { YOUR_AUTHOR_HANDLE } /thermometer:0.1.0 Run both AEAs Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer. Then run the thermometer client AEA: aea run You will see that the AEAs negotiate and then transact using the configured testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"ORM integration"},{"location":"aea/orm-integration/#discussion","text":"Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. We assume, that you followed the guide for the thermometer-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database (although you can follow the guide without having access to a sensor). Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/orm-integration/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/orm-integration/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/orm-integration/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/orm-integration/#demo-instructions","text":"A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions"},{"location":"aea/orm-integration/#create-the-seller-aea","text":"First, fetch the seller AEA, which will provide data: aea fetch fetchai/thermometer_aea:0.18.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the seller AEA"},{"location":"aea/orm-integration/#create-the-buyer-client","text":"In another terminal, fetch the AEA that will query the seller AEA. aea fetch fetchai/thermometer_client:0.19.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the buyer client"},{"location":"aea/orm-integration/#add-keys-for-the-thermometer-aea","text":"First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the thermometer AEA"},{"location":"aea/orm-integration/#add-keys-and-generate-wealth-for-the-thermometer-client-aea","text":"The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-key fetchai","title":"Add keys and generate wealth for the thermometer client AEA"},{"location":"aea/orm-integration/#update-the-seller-and-buyer-aea-skill-configurations","text":"In my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml , replace the data_for_sale with your data: models : ... strategy : args : currency_id : FET data_for_sale : temperature : 26 has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : thermometer_data service_id : thermometer_data unit_price : 10 class_name : Strategy dependencies : SQLAlchemy : {} The data_model and the service_data are used to register the service in the SOEF search node and make your agent discoverable. The name of each attribute must be a key in the service_data dictionary. In my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) ensure you have matching data. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : thermometer_data search_radius : 5.0 service_id : thermometer_data class_name : Strategy After changing the skill configuration files you should run the following command for both agents to install each dependency: aea install","title":"Update the seller and buyer AEA skill configurations"},{"location":"aea/orm-integration/#modify-the-sellers-strategy","text":"Before being able to modify a package we need to eject it from vendor: aea eject skill fetchai/thermometer:0.18.0 This will move the package to your skills directory and reset the version to 0.1.0 and the author to your author handle. Open the strategy.py (in my_thermometer_aea/skills/thermometer/strategy.py ) with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: class Strategy ( GenericStrategy ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () super () . __init__ ( ** kwargs ) At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query ) After modifying the skill we need to fingerprint it: aea fingerprint skill { YOUR_AUTHOR_HANDLE } /thermometer:0.1.0","title":"Modify the seller's strategy"},{"location":"aea/orm-integration/#run-both-aeas","text":"Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer. Then run the thermometer client AEA: aea run You will see that the AEAs negotiate and then transact using the configured testnet.","title":"Run both AEAs"},{"location":"aea/orm-integration/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Delete the AEAs"},{"location":"aea/p2p-connection/","text":"The fetchai/p2p_libp2p:0.14.0 connection allows AEAs to create a peer-to-peer communication network. In particular, the connection creates an overlay network which maps agents' public keys to IP addresses. Local demo Create and run the genesis AEA Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections fetchai/p2p_libp2p:0.14.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA. Create and run another AEA Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here SOME_ADDRESS needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.14.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently `p2p_libp2p` connection limits the message total size to 3 MB. Local demo with skills Explore the demo section for further examples. Deployed agent communication network You can connect to the deployed public test network by adding one or multiple of the following addresses as the libp2p_entry_peers : /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW In particular, by modifying the configuration by specifying an override in aea-config.yaml such that: --- public_id : fetchai/p2p_libp2p:0.14.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx , /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all of the agents which are attempting to communicate via the Agent Communication Network, i.e. BOTH Agent_A and Agent_B will require the above modifications to their aea-config.yaml file, however different ports need to be specified in the local_uri. This will allow both of these agents to default to this communication network, without the added overhead of opening/specifying ports/hosts on the individual host machines running the agents. Configuring the connection.yaml entries: To learn more about how to configure your fetchai/p2p_libp2p:0.14.0 connection consult the README.md supplied with the connection package. Running Go peer standalone You can run the peer node in standalone mode, that is, as a Go process with no dependency to the agents framework. To facilitate the deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally svn export https://github.com/fetchai/agents-aea.git/trunk/packages/fetchai/connections/p2p_libp2p cd p2p_libp2p go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is reachable publicly AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of entry Multiaddresses for the peer to bootstrap, comma-separated ( , ) The script allows different methods to pass these values to the node: as environment variables exported in format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry python3 run_acn_node_standalone.py libp2p_node --config-from-env using an environment file containing the entries and their values in format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one per line python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config using command line arguments as follow python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under name .acn_config within current working directory. This can be handy to ensure exact same configuration for future runs of the node.","title":"P2P Connection"},{"location":"aea/p2p-connection/#local-demo","text":"","title":"Local demo"},{"location":"aea/p2p-connection/#create-and-run-the-genesis-aea","text":"Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections fetchai/p2p_libp2p:0.14.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA.","title":"Create and run the genesis AEA"},{"location":"aea/p2p-connection/#create-and-run-another-aea","text":"Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here SOME_ADDRESS needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.14.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently `p2p_libp2p` connection limits the message total size to 3 MB.","title":"Create and run another AEA"},{"location":"aea/p2p-connection/#local-demo-with-skills","text":"Explore the demo section for further examples.","title":"Local demo with skills"},{"location":"aea/p2p-connection/#deployed-agent-communication-network","text":"You can connect to the deployed public test network by adding one or multiple of the following addresses as the libp2p_entry_peers : /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW In particular, by modifying the configuration by specifying an override in aea-config.yaml such that: --- public_id : fetchai/p2p_libp2p:0.14.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx , /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all of the agents which are attempting to communicate via the Agent Communication Network, i.e. BOTH Agent_A and Agent_B will require the above modifications to their aea-config.yaml file, however different ports need to be specified in the local_uri. This will allow both of these agents to default to this communication network, without the added overhead of opening/specifying ports/hosts on the individual host machines running the agents.","title":"Deployed agent communication network"},{"location":"aea/p2p-connection/#configuring-the-connectionyaml-entries","text":"To learn more about how to configure your fetchai/p2p_libp2p:0.14.0 connection consult the README.md supplied with the connection package.","title":"Configuring the connection.yaml entries:"},{"location":"aea/p2p-connection/#running-go-peer-standalone","text":"You can run the peer node in standalone mode, that is, as a Go process with no dependency to the agents framework. To facilitate the deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally svn export https://github.com/fetchai/agents-aea.git/trunk/packages/fetchai/connections/p2p_libp2p cd p2p_libp2p go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is reachable publicly AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of entry Multiaddresses for the peer to bootstrap, comma-separated ( , ) The script allows different methods to pass these values to the node: as environment variables exported in format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry python3 run_acn_node_standalone.py libp2p_node --config-from-env using an environment file containing the entries and their values in format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one per line python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config using command line arguments as follow python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under name .acn_config within current working directory. This can be handy to ensure exact same configuration for future runs of the node.","title":"Running Go peer standalone"},{"location":"aea/package-imports/","text":"An agent that is generated using the AEA framework is a modular system with different connections, contracts, protocols and skills. File structure The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry are located in vendor and sorted by author. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same. AEA Configuration YAML The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.15.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package. Vendor and package directories The vendor folder contains the packages from the registry which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder. Importing modules from packages The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem. Python dependencies of packages Python dependencies of packages are specified in their respective configuration files under dependencies . Create a package If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). Use published packages from the registry If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local . Package versioning By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 .","title":"File structure"},{"location":"aea/package-imports/#file-structure","text":"The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry are located in vendor and sorted by author. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same.","title":"File structure"},{"location":"aea/package-imports/#aea-configuration-yaml","text":"The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.15.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package.","title":"AEA Configuration YAML"},{"location":"aea/package-imports/#vendor-and-package-directories","text":"The vendor folder contains the packages from the registry which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder.","title":"Vendor and package directories"},{"location":"aea/package-imports/#importing-modules-from-packages","text":"The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem.","title":"Importing modules from packages"},{"location":"aea/package-imports/#python-dependencies-of-packages","text":"Python dependencies of packages are specified in their respective configuration files under dependencies .","title":"Python dependencies of packages"},{"location":"aea/package-imports/#create-a-package","text":"If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ).","title":"Create a package"},{"location":"aea/package-imports/#use-published-packages-from-the-registry","text":"If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local .","title":"Use published packages from the registry"},{"location":"aea/package-imports/#package-versioning","text":"By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 .","title":"Package versioning"},{"location":"aea/performance-benchmark/","text":"Test AEA framework performance. What is it? The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results. How does it work? The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results. How to use Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results. Simple example cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution. Requirements for tested function The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while. Execution options To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values. Limitations Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually. Testing AEA: handlers example Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Performance benchmark"},{"location":"aea/performance-benchmark/#what-is-it","text":"The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results.","title":"What is it?"},{"location":"aea/performance-benchmark/#how-does-it-work","text":"The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results.","title":"How does it work?"},{"location":"aea/performance-benchmark/#how-to-use","text":"Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results.","title":"How to use"},{"location":"aea/performance-benchmark/#simple-example","text":"cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution.","title":"Simple example"},{"location":"aea/performance-benchmark/#requirements-for-tested-function","text":"The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while.","title":"Requirements for tested function"},{"location":"aea/performance-benchmark/#execution-options","text":"To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values.","title":"Execution options"},{"location":"aea/performance-benchmark/#limitations","text":"Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually.","title":"Limitations"},{"location":"aea/performance-benchmark/#testing-aea-handlers-example","text":"Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Testing AEA: handlers example"},{"location":"aea/por/","text":"An AEA can use several key pairs. In particular, it can use different keys for securing its communication and for engaging in exchange. In the ACN we make use of this fact. To be able to signal to other agents that the address derived from one key pair is allowed to represent the agent controlling the other key pair, the key pair which is being represented must sign a message to prove that the other key pair is allowed to represent it. The aea issue-certificates command allows to create this association. The proof of representation feature is used in the context of the fetchai/p2p_libp2p and fetchai/p2p_libp2p_client connection. In the former connection, the configuration YAML specifies a cert_requests field: cert_requests : - identifier : acn ledger_id : fetchai not_after : '2022-01-01' not_before : '2021-01-01' public_key : fetchai save_path : .certs/conn_cert.txt The identifier refers to the environment for which the signature is generated, here acn . The ledger_id refers to the key pair to be used from the private_key_paths specified in aea-config.yaml for signing. The not_after and not_before fields specify constraints on the validity of the signature. The public_key can specify either the identifier of the key pair in connection_private_key_paths of which the public key is signed or it can contain the to be signed public key in plain text. The save_path specifies the path where the certificate is to be saved at. In the above example, the connection requests a certificate which is a signature of the fetchai public key in connection_private_key_paths with the fetchai key pair in private_key_paths . The validity of the signature will be constrained to the year 2021 for the environment acn .","title":"Proof of Representation"},{"location":"aea/prometheus/","text":"AEAs can create and update prometheus metrics for remote monitoring by sending messages to the prometheus connection fetchai/prometheus:0.2.0 . To see this working in an agent, fetch and run the coin_price_feed agent and check localhost:9090/metrics to see the latest values of the metrics num_retrievals and num_requests : aea fetch fetchai/coin_price_feed:0.4.0 cd coin_price_feed aea install aea build aea run You can then instruct a prometheus server running on the same computing cluster as a deployed agent to scrape these metrics for remote monitoring and visualisation with the Prometheus/Grafana toolset. To use this connection, add a model prometheus_dialogues to your skill to handle the metrics configuration and messages to the prometheus connection. Click here for example class PrometheusDialogues ( Model , BasePrometheusDialogues ): \"\"\"The dialogues class keeps track of all prometheus dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" self . enabled = kwargs . pop ( \"enabled\" , False ) self . metrics = kwargs . pop ( \"metrics\" , []) Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return PrometheusDialogue . Role . AGENT BasePrometheusDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) Then configure your metrics in the skill.yaml file. For example (from the coin_price skill): models : prometheus_dialogues : args : enabled : true metrics : - name : num_retrievals type : Gauge description : Number of price quotes retrieved labels : {} - name : num_requests type : Gauge description : Number of price quote requests served labels : {} class_name : PrometheusDialogues Add a metric metric_name of type metric_type { Gauge , Counter , ...} and description description by sending a message with performative ADD_METRIC to the prometheus connection: def add_prometheus_metric ( self , metric_name : str , metric_type : str , description : str , labels : Dict [ str , str ], ) -> None : \"\"\" Add a prometheus metric. :param metric_name: the name of the metric to add. :param type: the type of the metric. :param description: a description of the metric. :param labels: the metric labels. :return: None \"\"\" # context prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) # prometheus update message message , _ = prom_dialogues . create ( counterparty = str ( PROM_CONNECTION_ID ), performative = PrometheusMessage . Performative . ADD_METRIC , type = metric_type , title = metric_name , description = description , labels = labels , ) # send message envelope_context = EnvelopeContext ( skill_id = self . context . skill_id , connection_id = PROM_CONNECTION_ID ) self . context . outbox . put_message ( message = message , context = envelope_context ) where PROM_CONNECTION_ID should be imported to your skill as follows: from packages.fetchai.connections.prometheus.connection import ( PUBLIC_ID as PROM_CONNECTION_ID , ) Update metric metric_name with update function update_func { inc , set , observe , ...} and value value by sending a message with performative UPDATE_METRIC to the prometheus connection: def update_prometheus_metric ( self , metric_name : str , update_func : str , value : float , labels : Dict [ str , str ], ) -> None : \"\"\" Update a prometheus metric. :param metric_name: the name of the metric. :param update_func: the name of the update function (e.g. inc, dec, set, ...). :param value: the value to provide to the update function. :param labels: the metric labels. :return: None \"\"\" # context prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) # prometheus update message message , _ = prom_dialogues . create ( counterparty = str ( PROM_CONNECTION_ID ), performative = PrometheusMessage . Performative . UPDATE_METRIC , title = metric_name , callable = update_func , value = value , labels = labels , ) # send message envelope_context = EnvelopeContext ( skill_id = self . context . skill_id , connection_id = PROM_CONNECTION_ID ) self . context . outbox . put_message ( message = message , context = envelope_context ) Initialize the metrics from the configuration file in the behaviour setup: def setup ( self ) -> None : \"\"\"Implement the setup of the behaviour\"\"\" prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) if prom_dialogues . enabled : for metric in prom_dialogues . metrics : self . context . logger . info ( \"Adding Prometheus metric: \" + metric [ \"name\" ]) self . add_prometheus_metric ( metric [ \"name\" ], metric [ \"type\" ], metric [ \"description\" ], dict ( metric [ \"labels\" ]), Then call the update_prometheus_metric function from the appropriate places. For example, the following code in handlers.py for the coin_price skill updates the number of http requests served: if self . context . prometheus_dialogues . enabled : self . context . behaviours . coin_price_behaviour . update_prometheus_metric ( \"num_requests\" , \"inc\" , 1.0 , {} ) Finally, you can add a PrometheusHandler to your skill to process response messages from the prometheus connection. Click here for example class PrometheusHandler ( Handler ): \"\"\"This class handles responses from the prometheus server.\"\"\" SUPPORTED_PROTOCOL = PrometheusMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . handled_message = None def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" if self . context . prometheus_dialogues . enabled : self . context . logger . info ( \"setting up PrometheusHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" message = cast ( PrometheusMessage , message ) # recover dialogue prometheus_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) prometheus_dialogue = cast ( PrometheusDialogue , prometheus_dialogues . update ( message ) ) if prometheus_dialogue is None : self . _handle_unidentified_dialogue ( message ) return self . handled_message = message if message . performative == PrometheusMessage . Performative . RESPONSE : self . context . logger . debug ( f \"Prometheus response ( { message . code } ): { message . message } \" ) else : self . context . logger . debug ( f \"got unexpected prometheus message: Performative = { PrometheusMessage . Performative } \" ) def _handle_unidentified_dialogue ( self , msg : Message ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the unidentified message to be handled :return: None \"\"\" self . context . logger . info ( \"received invalid message= {} , unidentified dialogue.\" . format ( msg ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" pass","title":"Prometheus monitoring"},{"location":"aea/protocol-generator/","text":"Note This is currently an experimental feature. To try it follow this guide. How to run First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types) Protocol Specification A protocol can be described in a YAML file. As such, it needs to follow the YAML format . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification YAML file must have a minimum of one, and a maximum of three YAML documents (each YAML document is enclosed within --- and ...). Basic Protocol Detail and Messages Syntax The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query . Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here . Protocol Buffer Schema Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification. Dialogues You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or dismiss a terminated dialogue. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded. Design Guidelines initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act). Notes Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents. Demo instructions First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Generating protocols"},{"location":"aea/protocol-generator/#how-to-run","text":"First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types)","title":"How to run"},{"location":"aea/protocol-generator/#protocol-specification","text":"A protocol can be described in a YAML file. As such, it needs to follow the YAML format . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification YAML file must have a minimum of one, and a maximum of three YAML documents (each YAML document is enclosed within --- and ...).","title":"Protocol Specification"},{"location":"aea/protocol-generator/#basic-protocol-detail-and-messages-syntax","text":"The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query .","title":"Basic Protocol Detail and Messages Syntax"},{"location":"aea/protocol-generator/#types","text":"The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here .","title":"Types"},{"location":"aea/protocol-generator/#protocol-buffer-schema","text":"Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification.","title":"Protocol Buffer Schema"},{"location":"aea/protocol-generator/#dialogues","text":"You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or dismiss a terminated dialogue. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded.","title":"Dialogues"},{"location":"aea/protocol-generator/#design-guidelines","text":"initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act).","title":"Design Guidelines"},{"location":"aea/protocol-generator/#notes","text":"Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents.","title":"Notes"},{"location":"aea/protocol-generator/#demo-instructions","text":"First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Demo instructions"},{"location":"aea/protocol/","text":"Protocols define agent to agent interactions, which include: messages, which define the representation; serialization logic, which define how a message is encoded for transport; and, optionally dialogues, which define rules over message sequences. The framework provides one default protocol, called default and introduced below. This protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional protocols - i.e. a new type of interaction - can be added as packages or generated with the protocol generator . We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator! Components of a protocol A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains * dialogues.py , which defines rules of the message exchange * custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services. Metadata Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. * dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. is_incoming: bool , a boolean specifying whether the message is outgoing (from the agent), or incoming (from the other agent). The default value is False . counterparty: Address , the address of the counterparty of this agent; the other agent, this agent is communicating with. The default values for the above fields assume the message is the first message by the agent in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue, target is 0 since the first message is the only message that does not reply to any other, and is_incoming is False indicating the message is by the agent itself. By default, the values of dialogue_reference , message_id , target , is_incoming , counterparty are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with a another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one. Contents Each message may optionally have any number of contents of varying types. Dialogue rules Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single dialogue, respectively all dialogues, associated with the protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes. Custom protocol The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator! fetchai/default:0.11.0 protocol The fetchai/default:0.11.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" END = \"end\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.11.0 skill utilises the fetchai/default:0.11.0 protocol for error handling. fetchai/oef_search:0.12.0 protocol The fetchai/oef_search:0.12.0 protocol is used by AEAs to interact with an SOEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.12.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" SUCCESS = \"success\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The SOEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the P2P agent communication network and any protocol other than fetchai/oef_search:0.12.0 . If the SOEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000 fetchai/fipa:0.12.0 protocol This protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. The fetchai/fipa:0.12.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" END = \"end\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:0.12.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:0.12.0 protocol check out the generic skills step by step guide . Fipa dialogue Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of FipaDialogue and FipaDialogues for the buyer and seller: from aea.common import Address from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage class BuyerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class BuyerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class SellerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class SellerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: buyer_address = \"buyer_address_stub\" seller_address = \"seller_address_stub\" buyer_dialogues = BuyerDialogues ( buyer_address ) seller_dialogues = SellerDialogues ( seller_address ) First, the buyer creates a message destined for the seller and updates the dialogues: cfp_msg = FipaMessage ( message_id = 1 , dialogue_reference = buyer_dialogues . new_self_initiated_dialogue_reference (), target = 0 , performative = FipaMessage . Performative . CFP , query = Query ([ Constraint ( \"something\" , ConstraintType ( \">\" , 1 ))]), ) cfp_msg . counterparty = seller_addr # Extends the outgoing list of messages. buyer_dialogue = buyer_dialogues . update ( cfp_msg ) If the message has been correctly constructed, the buyer_dialogue will be returned, otherwise it will be None . In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=cfp_msg) However, here we simply continue with the seller: # change the incoming message field & counterparty cfp_msg . is_incoming = True cfp_msg . counterparty = buyer_address In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: # Creates a new dialogue for the seller side based on the income message. seller_dialogue = seller_dialogues . update ( cfp_msg ) Next, the seller can generate a proposal: # Generate a proposal message to send to the buyer. proposal = Description ({ \"foo1\" : 1 , \"bar1\" : 2 }) message_id = cfp_msg . message_id + 1 target = cfp_msg . message_id proposal_msg = FipaMessage ( message_id = message_id , dialogue_reference = seller_dialogue . dialogue_label . dialogue_reference , target = target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = cfp_msg . counterparty # Then we update the dialogue seller_dialogue . update ( proposal_msg ) In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=proposal_msg) The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following: retrieved_dialogue = seller_dialogues . get_dialogue ( cfp_msg )","title":"Protocols"},{"location":"aea/protocol/#components-of-a-protocol","text":"A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains * dialogues.py , which defines rules of the message exchange * custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services.","title":"Components of a protocol"},{"location":"aea/protocol/#metadata","text":"Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. * dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. is_incoming: bool , a boolean specifying whether the message is outgoing (from the agent), or incoming (from the other agent). The default value is False . counterparty: Address , the address of the counterparty of this agent; the other agent, this agent is communicating with. The default values for the above fields assume the message is the first message by the agent in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue, target is 0 since the first message is the only message that does not reply to any other, and is_incoming is False indicating the message is by the agent itself. By default, the values of dialogue_reference , message_id , target , is_incoming , counterparty are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with a another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one.","title":"Metadata"},{"location":"aea/protocol/#contents","text":"Each message may optionally have any number of contents of varying types.","title":"Contents"},{"location":"aea/protocol/#dialogue-rules","text":"Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single dialogue, respectively all dialogues, associated with the protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes.","title":"Dialogue rules"},{"location":"aea/protocol/#custom-protocol","text":"The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator!","title":"Custom protocol"},{"location":"aea/protocol/#fetchaidefault0110-protocol","text":"The fetchai/default:0.11.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" END = \"end\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.11.0 skill utilises the fetchai/default:0.11.0 protocol for error handling.","title":"fetchai/default:0.11.0 protocol"},{"location":"aea/protocol/#fetchaioef_search0120-protocol","text":"The fetchai/oef_search:0.12.0 protocol is used by AEAs to interact with an SOEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.12.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" SUCCESS = \"success\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The SOEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the P2P agent communication network and any protocol other than fetchai/oef_search:0.12.0 . If the SOEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000","title":"fetchai/oef_search:0.12.0 protocol"},{"location":"aea/protocol/#fetchaifipa0120-protocol","text":"This protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. The fetchai/fipa:0.12.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" END = \"end\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:0.12.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:0.12.0 protocol check out the generic skills step by step guide .","title":"fetchai/fipa:0.12.0 protocol"},{"location":"aea/protocol/#fipa-dialogue","text":"Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of FipaDialogue and FipaDialogues for the buyer and seller: from aea.common import Address from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage class BuyerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class BuyerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class SellerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class SellerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: buyer_address = \"buyer_address_stub\" seller_address = \"seller_address_stub\" buyer_dialogues = BuyerDialogues ( buyer_address ) seller_dialogues = SellerDialogues ( seller_address ) First, the buyer creates a message destined for the seller and updates the dialogues: cfp_msg = FipaMessage ( message_id = 1 , dialogue_reference = buyer_dialogues . new_self_initiated_dialogue_reference (), target = 0 , performative = FipaMessage . Performative . CFP , query = Query ([ Constraint ( \"something\" , ConstraintType ( \">\" , 1 ))]), ) cfp_msg . counterparty = seller_addr # Extends the outgoing list of messages. buyer_dialogue = buyer_dialogues . update ( cfp_msg ) If the message has been correctly constructed, the buyer_dialogue will be returned, otherwise it will be None . In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=cfp_msg) However, here we simply continue with the seller: # change the incoming message field & counterparty cfp_msg . is_incoming = True cfp_msg . counterparty = buyer_address In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: # Creates a new dialogue for the seller side based on the income message. seller_dialogue = seller_dialogues . update ( cfp_msg ) Next, the seller can generate a proposal: # Generate a proposal message to send to the buyer. proposal = Description ({ \"foo1\" : 1 , \"bar1\" : 2 }) message_id = cfp_msg . message_id + 1 target = cfp_msg . message_id proposal_msg = FipaMessage ( message_id = message_id , dialogue_reference = seller_dialogue . dialogue_label . dialogue_reference , target = target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = cfp_msg . counterparty # Then we update the dialogue seller_dialogue . update ( proposal_msg ) In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=proposal_msg) The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following: retrieved_dialogue = seller_dialogues . get_dialogue ( cfp_msg )","title":"Fipa dialogue"},{"location":"aea/query-language/","text":"We recommend reading Defining a Data Model before reading this section. Along with the Data Model language, the AEA framework offers the possibility to specify queries defined over data models. The aea.helpers.search module implements the API that allows you to build queries. In one sentence, a Query is a set of constraints , defined over a data model . The outcome is a set of description (that is, instances of Description ) matching with the query. That is, all the description whose attributes satisfy the constraints in the query. In the next sections, we describe how to build queries. Constraints A Constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them. Relation There are several ConstraintTypes that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 )) Set The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , ( \"horror\" , \"science fiction\" , \"non-fiction\" ))) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , ( 1990 , 1995 , 2000 ))) Range The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 ))) Distance The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the centre ), such that will be considered only the instances whose location attribute value is within a distance from the centre. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint Expressions The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite ConstraintExpressions , e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or . Not The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 )))) And The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))]) Or The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))]) Queries A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it. The check method The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid with respect to the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid with respect to a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (with respect to to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with respect to the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"The Query Language"},{"location":"aea/query-language/#constraints","text":"A Constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them.","title":"Constraints"},{"location":"aea/query-language/#relation","text":"There are several ConstraintTypes that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 ))","title":"Relation"},{"location":"aea/query-language/#set","text":"The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , ( \"horror\" , \"science fiction\" , \"non-fiction\" ))) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , ( 1990 , 1995 , 2000 )))","title":"Set"},{"location":"aea/query-language/#range","text":"The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 )))","title":"Range"},{"location":"aea/query-language/#distance","text":"The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the centre ), such that will be considered only the instances whose location attribute value is within a distance from the centre. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False`","title":"Distance"},{"location":"aea/query-language/#constraint-expressions","text":"The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite ConstraintExpressions , e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or .","title":"Constraint Expressions"},{"location":"aea/query-language/#not","text":"The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 ))))","title":"Not"},{"location":"aea/query-language/#and","text":"The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))])","title":"And"},{"location":"aea/query-language/#or","text":"The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))])","title":"Or"},{"location":"aea/query-language/#queries","text":"A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it.","title":"Queries"},{"location":"aea/query-language/#the-check-method","text":"The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False","title":"The check method"},{"location":"aea/query-language/#validity","text":"A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid with respect to the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid with respect to a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (with respect to to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with respect to the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"aea/questions-and-answers/","text":"What is the Open Economic Framework (OEF)? The Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. As such the OEF defines the decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). You can read more about the ledgers and the OEF here What is the AEA? AEA is short for Autonomous Economic Agents. AEAs act independently of constant user input and autonomously execute actions to achieve their objective. Their goal is to create economic value for you, their owner. You can read more about the AEAs here How do agents talk to others when they don't know each other? For the Autonomous Economic Agents (AEAs) to be able to talk to others, firstly they need to find them, and then, implement the same protocols in order to be able to deserialise the envelops they receive. You can read more about the Search and Discovery here and more about envelops and protocols here How does an AEA use blockchain? The AEA framework enables the agents to interact with public blockchains to complete transactions. Currently, the framework supports two different networks natively: the Fetch.ai network and the Ethereum network. You can read more about the integration of ledger here How does one install third party libraries? The framework supports the use of third-party libraries hosted on PyPI. We can directly reference the external dependencies in an AEA package's configuration file. The CLI install command will install each dependency that the specific AEA needs and is listed in the one of it's packages configuration files. How does one connect to a database? You have two options to connect to a database: - Creating a wrapper that communicates with the database and imports a Model. You can find an example implementation in the `weather_station` package - Using an ORM (object-relational mapping) library, and implementing the logic inside a class that inherits from the Model abstract class. For a detailed example of how to use an ORM follow the ORM use case How does one connect to a live-stream of data? You can create a wrapper class that communicates with the source and import this class in your skill, or you can use a third-party library by listing the dependency in the skill's `.yaml` file. Then you can import this library in a strategy class that inherits from the Model abstract class. You can find example of this implementation in the thermometer step by step guide How does one connect a frontend? There are two options that one could connect a frontend. The first option would be to create an HTTP connection and then create an app that will communicate with this connections. The other option is to create a frontend client that will communicate with the agent via the OEF communication network . You can find a more detailed approach here . Is the AEA framework ideal for agent-based modelling? The goal of agent-based modelling is to search for explanatory insight into the collective behaviour of agents obeying simple rules, typically in natural systems rather than in designing agents or solving specific practical or engineering problems. Although it would be potentially possible, it would be inefficient to use the AEA framework for that kind of problem. You can find more details here Can you manage multiple AEA projects at once with the CLI? Individual CLI calls are currently scoped to a single project. You can have multiple AEA projects in a given root directory but you will have to use the CLI for each project independently. We are looking to add support for interacting with multiple AEA projects via a single CLI call in the future. You can find more details about the CLI commands here When a new AEA is created, is the `vendor` folder populated with some default packages? All AEA projects by default hold the `fetchai/stub:0.15.0` connection, the `fetchai/default:0.11.0` protocol and the `fetchai/error:0.11.0` skill. These (as all other packages installed from the registry) are placed in the vendor's folder. You can find more details about the file structure here Is there a standardization for private key files? Currently, the private keys are stored in `.txt` files. This is temporary and will be improved soon. How to use the same protocol in different skills? By default, envelopes of a given protocol get routed to all skills which have a handler supporting that protocol. The `URI` in the `EnvelopeContext` can be used to route envelopes of a given protocol to a specific skill. The `URI` path needs to be set to the skill's `public_id.to_uri_path`. Why does the AEA framework use its own package registry? AEA packages could be described as personalized plugins for the AEA runtime. They are not like a library and therefore not suitable for distribution via PyPI .","title":"Q&A"},{"location":"aea/quickstart/","text":"If you want to create Autonomous Economic Agents (AEAs) that can act independently of constant user input and autonomously execute actions to achieve their objective, you can use the Fetch.ai AEA framework. This example will take you through the simplest AEA in order to make you familiar with the framework basics. System Requirements The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200b Option 1: Manual system preparation Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.7: sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio . Option 2: Using Docker \u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b Preliminaries We have created a template repo for AEA development here which you can optionally fork and use immediately. Alternatively, create and enter into a new working directory: mkdir my_aea_projects/ cd my_aea_projects/ Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell For more guidance on setting up a development environment check out this guide . Installation The following installs the entire AEA package which also includes a command-line interface (CLI) . pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements . Setup author name AEAs are composed from components. The components can be developed by anyone and are available on the AEA registry . To use the registry we need to register an author name. You can setup your author name using the init command: aea init This is your unique author name in the Fetch.ai ecosystem. You should see a similar output (with your input replacing the sample input): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.9.2 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run `aea init --local` instead. Echo skill demo The echo skill demo is a simple demo that introduces you to the main business logic components of an AEA. The echo skill simply echoes received messages back to the sender. The fastest way to create your first AEA is to fetch it! aea fetch fetchai/my_first_aea:0.18.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.13.0 This copies the `fetchai/echo:0.13.0` skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill `fetchai/echo:0.13.0` consists of the name of the author of the skill, followed by the skill name and its version. Communication via envelopes and messages AEAs use envelopes containing messages for communication. To learn more check out the next section in the getting started series. Usage of the stub connection In this demo we use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.11.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello, Run the AEA Run the AEA with the default fetchai/stub:0.15.0 connection. aea run or aea run --connections fetchai/stub:0.15.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.9.2 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act . This is the main agent loop in action. Add a message to the input file From a different terminal and same directory, we send the AEA a message wrapped in an envelop using the CLI interact command: cd my_first_aea aea interact You can now send the AEA messages via an interactive tool by typing hello into the prompt and hitting enter twice (once to send, once more to check for a response). You will see the Echo Handler dealing with the envelope and contained message (your dialogue reference will be different): info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '1' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = my_first_aea_interact info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Manual approach Optionally, from a different terminal and same directory (i.e. the `my_first_aea` project), we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.11.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the `Echo Handler` dealing with the envelope and responding with the same message to the `output_file`, and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the `aea interact` command. Stop the AEA Stop the AEA by pressing CTRL C You should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. Write a test for the AEA We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The `AEATestCase` classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the `my_first_aea` folder): svn export https://github.com/fetchai/agents-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file `test.py` in your AEA project directory (the same level as the `aea-config.yaml` file). To run, execute the following: pytest test.py Delete the AEA Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea Next steps To gain an understanding of the core components of the framework, please continue to the next step of 'Getting Started': Core components For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Generic step by step guide","title":"AEA quick start"},{"location":"aea/quickstart/#system-requirements","text":"The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200b","title":"System Requirements"},{"location":"aea/quickstart/#option-1-manual-system-preparation","text":"Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.7: sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio .","title":"Option 1: Manual system preparation"},{"location":"aea/quickstart/#option-2-using-docker","text":"\u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b","title":"Option 2: Using Docker"},{"location":"aea/quickstart/#preliminaries","text":"We have created a template repo for AEA development here which you can optionally fork and use immediately. Alternatively, create and enter into a new working directory: mkdir my_aea_projects/ cd my_aea_projects/ Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell For more guidance on setting up a development environment check out this guide .","title":"Preliminaries"},{"location":"aea/quickstart/#installation","text":"The following installs the entire AEA package which also includes a command-line interface (CLI) . pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements .","title":"Installation"},{"location":"aea/quickstart/#setup-author-name","text":"AEAs are composed from components. The components can be developed by anyone and are available on the AEA registry . To use the registry we need to register an author name. You can setup your author name using the init command: aea init This is your unique author name in the Fetch.ai ecosystem. You should see a similar output (with your input replacing the sample input): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.9.2 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run `aea init --local` instead.","title":"Setup author name"},{"location":"aea/quickstart/#echo-skill-demo","text":"The echo skill demo is a simple demo that introduces you to the main business logic components of an AEA. The echo skill simply echoes received messages back to the sender. The fastest way to create your first AEA is to fetch it! aea fetch fetchai/my_first_aea:0.18.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.13.0 This copies the `fetchai/echo:0.13.0` skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill `fetchai/echo:0.13.0` consists of the name of the author of the skill, followed by the skill name and its version.","title":"Echo skill demo"},{"location":"aea/quickstart/#communication-via-envelopes-and-messages","text":"AEAs use envelopes containing messages for communication. To learn more check out the next section in the getting started series.","title":"Communication via envelopes and messages"},{"location":"aea/quickstart/#usage-of-the-stub-connection","text":"In this demo we use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.11.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello,","title":"Usage of the stub connection"},{"location":"aea/quickstart/#run-the-aea","text":"Run the AEA with the default fetchai/stub:0.15.0 connection. aea run or aea run --connections fetchai/stub:0.15.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.9.2 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act . This is the main agent loop in action.","title":"Run the AEA"},{"location":"aea/quickstart/#add-a-message-to-the-input-file","text":"From a different terminal and same directory, we send the AEA a message wrapped in an envelop using the CLI interact command: cd my_first_aea aea interact You can now send the AEA messages via an interactive tool by typing hello into the prompt and hitting enter twice (once to send, once more to check for a response). You will see the Echo Handler dealing with the envelope and contained message (your dialogue reference will be different): info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '1' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = my_first_aea_interact info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Manual approach Optionally, from a different terminal and same directory (i.e. the `my_first_aea` project), we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.11.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the `Echo Handler` dealing with the envelope and responding with the same message to the `output_file`, and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the `aea interact` command.","title":"Add a message to the input file"},{"location":"aea/quickstart/#stop-the-aea","text":"Stop the AEA by pressing CTRL C You should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called.","title":"Stop the AEA"},{"location":"aea/quickstart/#write-a-test-for-the-aea","text":"We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The `AEATestCase` classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the `my_first_aea` folder): svn export https://github.com/fetchai/agents-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file `test.py` in your AEA project directory (the same level as the `aea-config.yaml` file). To run, execute the following: pytest test.py","title":"Write a test for the AEA"},{"location":"aea/quickstart/#delete-the-aea","text":"Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea","title":"Delete the AEA"},{"location":"aea/quickstart/#next-steps","text":"To gain an understanding of the core components of the framework, please continue to the next step of 'Getting Started': Core components For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Generic step by step guide","title":"Next steps"},{"location":"aea/raspberry-set-up/","text":"Prerequisites Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible. Preparing the Raspberry Pi If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below. NOOBS NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your SD card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your WiFi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade Install a virtual environment You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv Create and launch a virtual environment pipenv --python 3 .7 && pipenv shell Installing the AEA-framework Install the package from source: pip install aea [ all ]","title":"Build an AEA on a Raspberry Pi"},{"location":"aea/raspberry-set-up/#prerequisites","text":"Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible.","title":"Prerequisites"},{"location":"aea/raspberry-set-up/#preparing-the-raspberry-pi","text":"If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below.","title":"Preparing the Raspberry Pi"},{"location":"aea/raspberry-set-up/#noobs","text":"NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your SD card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your WiFi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade","title":"NOOBS"},{"location":"aea/raspberry-set-up/#install-a-virtual-environment","text":"You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv","title":"Install a virtual environment"},{"location":"aea/raspberry-set-up/#create-and-launch-a-virtual-environment","text":"pipenv --python 3 .7 && pipenv shell","title":"Create and launch a virtual environment"},{"location":"aea/raspberry-set-up/#installing-the-aea-framework","text":"Install the package from source: pip install aea [ all ]","title":"Installing the AEA-framework"},{"location":"aea/runtime-cost/","text":"Measuring runtime cost It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios.","title":"Profiling"},{"location":"aea/runtime-cost/#measuring-runtime-cost","text":"It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios.","title":"Measuring runtime cost"},{"location":"aea/scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection. Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a contract aea scaffold contract my_contract Scaffold a connection aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffolding packages"},{"location":"aea/scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection.","title":"Scaffold generator"},{"location":"aea/scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"aea/scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"aea/scaffolding/#scaffold-a-contract","text":"aea scaffold contract my_contract","title":"Scaffold a contract"},{"location":"aea/scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffold a connection"},{"location":"aea/simple-oef-usage/","text":"You can use the SOEF in the agent framework by using the SOEF connection as a package in your agent project. Add the SOEF package Check out the CLI guide on details how to add a connection. You will want to add the fetchai/soef:0.15.0 connection package. Register your agent and its services Register agent location To register your agent's location, you have to send a message in the fetchai/oef_search:0.12.0 protocol to the SOEF connection. First, define a data model for location data: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_LOCATION_MODEL = DataModel ( \"location_agent\" , [ Attribute ( \"location\" , Location , True , \"The location where the agent is.\" )], \"A data model to describe location of an agent.\" , ) It is important to use this exact data model, as the SOEF connection can only process specific data models. Second, create a location object: from aea.helpers.search.models import Location agent_location = Location ( 52.2057092 , 2.1183431 ) Third, construct a service description instance with location and data model: from aea.helpers.search.models import Description service_instance = { \"location\" : agent_location } service_description = Description ( service_instance , data_model = AGENT_LOCATION_MODEL ) Finally, construct a message and send it: from packages.fetchai.protocols.oef_search.message import OefSearchMessage message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , ) In case everything is registered OK, you will not receive any message back. If something goes wrong you will receive an error message with performative OefSearchMessage.Performative.OEF_ERROR . Register personality pieces To register personality pieces, you have to use a specific data model: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_PERSONALITY_MODEL = DataModel ( \"personality_agent\" , [ Attribute ( \"piece\" , str , True , \"The personality piece key.\" ), Attribute ( \"value\" , str , True , \"The personality piece value.\" ), ], \"A data model to describe the personality of an agent.\" , ) An example follows: service_instance = { \"piece\" : \"genus\" , \"value\" : \"service\" } service_description = Description ( service_instance , data_model = AGENT_PERSONALITY_MODEL ) Register services To set some service key and value you have to use a specific data model: SET_SERVICE_KEY_MODEL = DataModel ( \"set_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" ), Attribute ( \"value\" , str , True , \"Service key value.\" ), ], \"A data model to set service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" , \"value\" : \"test\" } service_description = Description ( service_instance , data_model = SET_SERVICE_KEY_MODEL ) Remove service key To remove service key have to use a specific data model: REMOVE_SERVICE_KEY_MODEL = DataModel ( \"remove_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" )], \"A data model to remove service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" } service_description = Description ( service_instance , data_model = REMOVE_SERVICE_KEY_MODEL ) Perform a search To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional. An example follows: from aea.helpers.search.models import ( Constraint , ConstraintType , Location , Query , ) radius = 0.1 close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) personality_filters = [ Constraint ( \"genus\" , ConstraintType ( \"==\" , \"vehicle\" )), Constraint ( \"classification\" , ConstraintType ( \"==\" , \"mobility.railway.train\" ) ), ] service_key_filters = [ Constraint ( \"test\" , ConstraintType ( \"==\" , \"test\" )), ] closeness_query = Query ( [ close_to_my_service ] + personality_filters + service_key_filters ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = closeness_query , ) In case of error you will received a message with OefSearchMessage.Performative.OEF_ERROR . In case of successful search you will receive a message with performative OefSearchMessage.Performative.SEARCH_RESULT and the list of matched agents addresses. Generic command To send a generic command request to the SOEF use the following (here on the example of setting a declared name): import urllib AGENT_GENERIC_COMMAND_MODEL = DataModel ( \"generic_command\" , [ Attribute ( \"command\" , str , True , \"Command name to execute.\" ), Attribute ( \"parameters\" , str , False , \"Url encoded parameters string.\" ), ], \"A data model to describe the generic soef command.\" , ) declared_name = \"new_declared_name\" service_description = Description ( { \"command\" : \"set_declared_name\" , \"parameters\" : urllib . parse . urlencode ({ \"name\" : declared_name }), }, data_model = AGENT_GENERIC_COMMAND_MODEL , ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , )","title":"SOEF Connection"},{"location":"aea/simple-oef-usage/#add-the-soef-package","text":"Check out the CLI guide on details how to add a connection. You will want to add the fetchai/soef:0.15.0 connection package.","title":"Add the SOEF package"},{"location":"aea/simple-oef-usage/#register-your-agent-and-its-services","text":"","title":"Register your agent and its services"},{"location":"aea/simple-oef-usage/#register-agent-location","text":"To register your agent's location, you have to send a message in the fetchai/oef_search:0.12.0 protocol to the SOEF connection. First, define a data model for location data: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_LOCATION_MODEL = DataModel ( \"location_agent\" , [ Attribute ( \"location\" , Location , True , \"The location where the agent is.\" )], \"A data model to describe location of an agent.\" , ) It is important to use this exact data model, as the SOEF connection can only process specific data models. Second, create a location object: from aea.helpers.search.models import Location agent_location = Location ( 52.2057092 , 2.1183431 ) Third, construct a service description instance with location and data model: from aea.helpers.search.models import Description service_instance = { \"location\" : agent_location } service_description = Description ( service_instance , data_model = AGENT_LOCATION_MODEL ) Finally, construct a message and send it: from packages.fetchai.protocols.oef_search.message import OefSearchMessage message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , ) In case everything is registered OK, you will not receive any message back. If something goes wrong you will receive an error message with performative OefSearchMessage.Performative.OEF_ERROR .","title":"Register agent location"},{"location":"aea/simple-oef-usage/#register-personality-pieces","text":"To register personality pieces, you have to use a specific data model: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_PERSONALITY_MODEL = DataModel ( \"personality_agent\" , [ Attribute ( \"piece\" , str , True , \"The personality piece key.\" ), Attribute ( \"value\" , str , True , \"The personality piece value.\" ), ], \"A data model to describe the personality of an agent.\" , ) An example follows: service_instance = { \"piece\" : \"genus\" , \"value\" : \"service\" } service_description = Description ( service_instance , data_model = AGENT_PERSONALITY_MODEL )","title":"Register personality pieces"},{"location":"aea/simple-oef-usage/#register-services","text":"To set some service key and value you have to use a specific data model: SET_SERVICE_KEY_MODEL = DataModel ( \"set_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" ), Attribute ( \"value\" , str , True , \"Service key value.\" ), ], \"A data model to set service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" , \"value\" : \"test\" } service_description = Description ( service_instance , data_model = SET_SERVICE_KEY_MODEL )","title":"Register services"},{"location":"aea/simple-oef-usage/#remove-service-key","text":"To remove service key have to use a specific data model: REMOVE_SERVICE_KEY_MODEL = DataModel ( \"remove_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" )], \"A data model to remove service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" } service_description = Description ( service_instance , data_model = REMOVE_SERVICE_KEY_MODEL )","title":"Remove service key"},{"location":"aea/simple-oef-usage/#perform-a-search","text":"To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional. An example follows: from aea.helpers.search.models import ( Constraint , ConstraintType , Location , Query , ) radius = 0.1 close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) personality_filters = [ Constraint ( \"genus\" , ConstraintType ( \"==\" , \"vehicle\" )), Constraint ( \"classification\" , ConstraintType ( \"==\" , \"mobility.railway.train\" ) ), ] service_key_filters = [ Constraint ( \"test\" , ConstraintType ( \"==\" , \"test\" )), ] closeness_query = Query ( [ close_to_my_service ] + personality_filters + service_key_filters ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = closeness_query , ) In case of error you will received a message with OefSearchMessage.Performative.OEF_ERROR . In case of successful search you will receive a message with performative OefSearchMessage.Performative.SEARCH_RESULT and the list of matched agents addresses.","title":"Perform a search"},{"location":"aea/simple-oef-usage/#generic-command","text":"To send a generic command request to the SOEF use the following (here on the example of setting a declared name): import urllib AGENT_GENERIC_COMMAND_MODEL = DataModel ( \"generic_command\" , [ Attribute ( \"command\" , str , True , \"Command name to execute.\" ), Attribute ( \"parameters\" , str , False , \"Url encoded parameters string.\" ), ], \"A data model to describe the generic soef command.\" , ) declared_name = \"new_declared_name\" service_description = Description ( { \"command\" : \"set_declared_name\" , \"parameters\" : urllib . parse . urlencode ({ \"name\" : declared_name }), }, data_model = AGENT_GENERIC_COMMAND_MODEL , ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , )","title":"Generic command"},{"location":"aea/simple-oef/","text":"Simple-OEF: Agent Search and Discovery This documentation has been produced for the Simple-OEF version 0.3.4 . Concepts The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents . Agents register with the soef and are then able to conduct searches around them to find other agents that may be able to help. It is a relatively simple implementation focussing on functionality, performance and ease-of-use. As it develops, it will evolve into a full-scale decentralised, multi-dimensional digital world. The work-flow is: Find relevant agents on the soef, Communicate using the Agent Framework's peer-to-peer network, Negotiate and then transact on the ledger in order to exchange value for tokens When an agent registers with the soef, it is issued with a unique reference which is quoted in all subsequent transactions. This way, the soef knows who its talking to. The soef is transaction based, so it does not need a permanent connection to be maintained in order to work with it. If it does not hear from an agent for a period of time, that agent will be timed out and automatically unregistered. This period of time is typically about one hour, but you can see the soef's configuration at: http://soef.fetch.ai:9002 Agents identify themselves in a number of ways. These include their address, their given name, their classification and their genus. They can also describe how they \"look\" in other ways, and specify the services that they provide. In order to register, agents must provide a valid address and a given name. The address can be for the Fetch.ai native ledger, the Fetch.ai Cosmos ledger or the Ethereum ledger. It is this that uniquely identifies them, and addresses cannot be duplicated or shared. The given name can be anything and it is not used for search filtering. Typically, it can be thought of as a debugging aid or a context. Names could be Alice, Bob or Jim, as well as they could be a flight number, train identity or reference code. They appear in find results, but are not used to find by. Describing an Agent Agents describe themselves in three ways: Identity : their address and ledger type along with their given name Personality pieces : how they look Service keys : what they do , sell or want . We cover all of these in this next section. It's important to understand the difference between personality pieces and service keys, as agents only have one appearance, but they can provide many services. Search results can be filtered by a number of both, and wildcards are permitted where relevant. Personality Pieces Agents can have a number of personality pieces. These describe how an agent appears, where it is, and other properties such as heading, supported protocols and types of transactions. All personality pieces are optional, but the more you set, the easier it is for searchers to narrow you down accurately . Piece Description genus Coarse type of agent, includes things such as vehicle , building , iot . See the genus table below. classification An agent's classification, typically in the form mobility.railway.train . See note below on classifications. No fixed classifications are specified. Classifications can contain alphanumeric characters, the period, underscore and colon ( _.: ). architecture Agent's architecture. See the architecture table below. Introduced in version 0.1.20 . The vast majority of agents should set this to agentframework . dynamics.moving Boolean, indicates if the agent is moving or not. dynamics.heading Indicates the heading of the agent, in radians, with 0.0 pointing due north. dynamics.altitude Altitude of the agent in metres from MSL dynamics.position Indicates the GPS co-ordinates of the agent as latitude and longitude. action.buyer Boolean, indicates whether the agent wishes to buy information, i.e., is an agent that requires value from another agent. action.seller Boolean, indicates whether the agent sells information, i.e., provides value. Value provided can be zero-cost. Genus list A genus is a coarse agent class. It is the roughest description of what an agent is, and an easy way of filtering large groups of agents out of searches. The supported genus list is: Name Description test Agent is a test agent, and should be generally ignored. vehicle Moving objects such as trains, planes and automobiles avatar An agent that represents a human being service An agent that provides a service iot An agent that represents an Internet of Things device data An agent that represents data furniture Small fixed location items such as signs, mobile masts building Large fixed location item such as house, railway station, school buyer Indicates the agent is a buyer only and does not have value to deliver viewer The agent is a view in the world, acting as a \"camera\" to view content financial Financial agent: service, exchange, autonomous market maker, etc. The best way to use genus is to pick the best fit choice. If there isn't one for you, then do not specify it. If you feel that a high-level genus is missing, please make the suggestion in our Developer Discord (see here ). Architectures An architecture is a clue to other agents to describe how the agent is built. The vast majority of agents will be built using the Fetch Agent Framework, but in some cases, such as light-weight IoT devices or test/debugging, agents are built otherwise. Architecture offers a way of describing or filtering, as agents with a similar architecture are more likely to be able to communicate with each other in a meaningful way. Architecture Description custom Custom agent architecture agentframework Built using the Fetch Agent Framework A note on classifications There is currently no fixed set of guidelines as to how classifications are used. It is expected that agent builders will converge on a set of standards, and as those become clearer, they will be documented as \"by convention\" classification uses. Here are some examples of classifications in use: mobility.railway.station mobility.railway.train mobility.road.taxi infrastructure.road.sign When filtering by classifications, the * wildcard can be used to, for example, capture all mobility related agents with a wildcard of mobility.* . Service Keys Agents can have a number of service keys. Service keys are simple key/value pairs that describe the list of services that the agent provides. Whilst personality pieces can be thought of as how an agent looks , service keys are what an agent has or does . Service keys are user defined and as with personality pieces, currently have no convention for formatting. They are at the agent builder's discretion. As this changes, the documentation will be updated. However, for buyer agents, three suggested keys are: buying_genus buying_architecture buying_classifications data_type si_unit This allows searches to look for potential buyers of classifications, genus or with a compatible architecture. Finding Agents The soef is designed for geographic searches where agents are able to find other agents near to them that are able to provide them with the value that they want, or who might wish to have the value they provide. However, it also allows for positionless searches on a single node. Future versions of the soef will support searches across nodes, and dimensional reduction-based fuzzy searches. Geographic searches are performed using the find_around_me operation. This allows searches that: Are within a certain range in KM Optionally must be positioned within an angle of a heading That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match Positionless searches are performed using the find_on_this_node operation. This allows searches that: That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match At least one filter must be supplied in positionless searches. Positionless searches are not boundless, they are capped at a specific number. The tighter the filters, the less likely that you will be capped. Some limits apply to the maximum number of filters, range and returned results. This may vary from soef instance to soef instance. You can see (and parse if required) these by getting the soef status at: http://soef.fetch.ai:9002 The soef returns XML that includes information about all found agents. An example of that, unparsed, looks like this: <response> <success> 1 </success> <total> 1 </total> <capped> 0 </capped> <results> <agent name= \"TrainNumber1234\" genus= \"vehicle\" classification= \"mobility.railway.train\" user_context= \"18:00 to Berlin\" > <identities> <identity chain_identifier= \"fetchai\" > 2h6fi8oCkMz9GCpL7EUYMHjzgdRFGmDP5V4Ls97jZpzjg523yY </identity> </identities> <range_in_km> 55.7363 </range_in_km> <location accuracy= \"3\" > <latitude> 52.5 </latitude> <longitude> 0.2 </longitude> </location> </agent> </results> </response> The <location> block is only returned if the agent has set itself to disclose its position in a find. Likewise, the user_context=\"\" is only returned if enabled . Normally, the default is not to, and agents will then only return the <range_in_km> item. This is because agents may deliver their precise location as part of the value that they deliver, and therefore it would need to be negotiated and potentially paid for. However, sometimes, it is desirable for agents to always deliver their position when found but specify the accuracy. Because of this, the soef supports four levels of accuracy: Level Accuracy none Default do not disclose position, range only. low Rounded to nearest 11km medium Rounded to nearest 1.1km high Rounded to nearest 110 metres maximum No rounding: supplied in maximum available detail Technical Details For the majority of use cases, the soef will be used from the Agent Framework. As a result, talking to it directly will not be needed. There are some occasions where interacting with the soef directly may be required, and this section documents the API functionality. Until version 1.0 and main-net version 2 (expected in early 2021), some of the security and paid-for-services are not implemented and where they are, they generally not enforced. Digital signatures for the sign-on process and unique identity recovery will be implemented, as will encryption on sensitive data transport, for example. Thus the API is likely to change substantially in the coming months, particularly the initial registration process. It is not recommended that you invest in substantial code that talks to the soef directly until after 1.0, and it is always preferred to go through the Agent Framework. Registration Agents register at the /register page on the soef. They are expected to provide four pieces of information: An API key A chain identifier, which can be either fetchai_v1 for the Fetch native network (testnet or mainnet), fetchai_v2_* for the Fetch version 2 network or ethereum for the Ethereum network. See the \"Chain identifiers\" table below for a complete list of supported chain identifiers. An address, which must be a valid address for the specified chain identifier A \"given name\" (see \"Concepts\", above), which can be anything from Alice to Bob, or a flight number, or any other user-given context. It must not exceed 128 characters. If registration is successful, the soef will return a result like this: <response> <encrypted> 0 </encrypted> <token> 0A709D1ED170A3E96C4AC9D014BCAE30 </token> <page_address> oef_AEC97453A80FFFF5F11E612594585F611D1728FFCD74BBF4FE915BBBB052 </page_address> </response> This indicates success and that the agent is now in the Lobby . The lobby is a temporary holding pen where newly registered agents wait until the negotiation is complete. If an agent does not respond and complete its registration within 60 seconds, it is removed from the lobby and registration is cancelled. The <page_address> is the unique URL for the new agent. This must be quoted in all subsequent interactions and is how the soef identifies that specific agent. To complete registration, use the unique URL and specify the parameters: token= with the token that was returned above and command=acknowledge If this works, you will receive a success response: <response> <success> 1 </success> </response> At this point, your agent is now fully registered and can then communicate with the soef. Agents that do not contact the soef at least once over a specified interval will be automatically unregistered. The typical setting for this is 60 minutes. Chain identifiers The soef supports a selection of chain identifiers designed to allow agents to distinguish networks in searches, but also to identify the type of address used for verification purposes. Chain identifier Network fetchai_v1 Version 1 Fetch.ai network (testnet or mainnet). Versions prior to 0.2 of the soef used fetchai for this, which is retained for compatibility. fetchai_v2_testnet_stable Version 2 Fetch.ai stable testnet, also known as \"Agentland\". Versions prior to 0.2 of the soef used fetchai_cosmos which is retained for compatibility, but deprecated. fetchai_v2_testnet_incentivised Current incentivised testnet. Fetch.ai are running a high-reward sequence of testnets in Q4 2020 and Q1 2021 leading to V2 mainnet. fetchai_v2_misc Miscellaneous v2 network. These are temporary or transient testnets where there is a desire to separate the chain ID from other v2 networks. fetchai_v2_mainnet Fetch.ai v2 mainnet. Not yet active. Commands The soef has a number of commands that can be used to set or update personality pieces, manage service keys, unregister, find other agents and other operations. These commands are specified using the agent's unique URL and a command= parameter. There may then be other required and optional parameters for that particular command. Command Details unregister Unregisters the agent from the soef. The unique URL is invalidated and the agent will no longer appear in searches. No parameters. ping Say hello. This is for agents that have been idle for a long period of time and wish to maintain their connection. No parameters. set_personality_piece Sets or updates a personality piece. Specify the piece (see personality piece table above) and the value . For personality pieces with multiple values, such as dynamics.position , separate them with the pipe character | . set_service_key Sets or updates a service key. Specify the key and the value to assign to it. remove_service_key Removes an existing service key. Specify the key . set_find_position_disclosure_accuracy Sets the find disclosure accuracy. See the table in \"Finding Agents\", above, for the accepted values for the parameter accuracy . find_around_me Geographic finding of agents around me. This allows various filters, such as personality pieces and service keys, to be specified. See below, as this is more complex. find_on_this_node Positionless finding of agents on this node. Various filters such as personality pieces and service keys can narrow the search. See below for more information. set_position This is a direct internal mapping to set_personality_piece with a piece of dynamics.position . It existed in the earliest versions of the soef and remains as a short-cut. It expects longitude and latitude as parameters. set_declared_name This allows an agent's declared name to be changed after registration. It takes one parameter, name , to specify the replacement name. Names cannot exceed 128 characters and must not contain illegal characters. set_user_context Sets an optional user-context for an agent to what is specified in the value parameter. This can be optionally disclosed in find_around_me if enabled. See set_disclose_user_context , below. The user context must not contain illegal characters and is limited to 160 maximum. set_disclose_user_context If the disclose parameter is set to true , the optional user context is disclosed if it has been set. Default is false . Find commands in detail find_around_me and find_on_this_node are the big commands. Ultimately, they will cost a small amount of tokens to use, depending on the size of the request, as it involves the most computing time. This provides an incentive for soef operators to maintain soef nodes that correspond to subject areas, geographic areas or both. The command has a number of parameters specifying the filtering required. For find_around_me , the range_in_km is required , whereas narrowing down agents to be within a certain angle of a direction is optional. This cannot exceed a certain range, typically between 50 and 75km. This, and other configuration items, are available on the soef's configuration page. There are other parameters that are optional, although for find_on_this_node at least one ppfilter or skfilter must be specified. The parameters are: Parameter Use range_in_km Range in kilometres to include agents in results. of_heading Optional: if a pizza-slice type search is required, this is the direction, in degrees, with 0.0 being north. within Optional: if a pizza-slice search, this is the angle in degrees from the of_heading that is allowed. If either of_heading or within are specified, both must be specified. Example: of_heading set to 90.0 and within set to 30 would exclude any agents that are not within 30 degrees of direct east of the me agent. chains_must_match Boolean. Must be true or false . Default is false . If specified, this ensures that any agents returned in the search will have the same chain identifier as you. ppfilter Specify a personality piece filter. Multiple ppfilter s can be specified. Example use is: ppfilter=dynamics.moving,true . Wildcards can be used where relevant, e.g.: ppfilter=classification,mobility* will match all classifications that start with mobility , whereas ppfilter=classification,*mobility* will match all classifications with mobility anywhere in it. skfilter Specify a service key filter. Multiple skfilter s can be specified. Example use is: skfilter=fruit,peach which will require any returned results to have a service key of fruit and a value of peach . Wildcards can be specified, so skfilter=fruit,pea* will match any agent with a service key of fruit that starts pea , so pear and peach would match. SK Filters: filter modes The skfilter parameter for find_around_me also supports a mode . Four modes are supported: Mode string Description PS Key must be present, and success is required PF Key must be present, and failure is required OS Only match if present, and success is required OF Only match if present, and failure is required For example: command=find_around_me&range_in_km=50&skfilter=type,fruit,PS&skfilter=size,large,OF In this example, the key type must be present, and it must match to fruit . If the size key is present, and it is set to large , then do not match. I.e., return everything that's a fruit within 50km except where the size is large. Further information You can find further information, or talk to us, in the #agents channel on our official developer Discord server, which you can access here . We welcome your feedback and strive to deliver the best decentralised search and discovery service for agents that is possible. There are many upcoming features, including the operation incentive mechanisms, additional security and encryption, active searches (where results happen without find_around_me being issued), non-geographic searches across one and many soef nodes and dimensional-reduction based approximate searches. [Docs: issue 15, 0.3.4 , 28-Dec-2020 , TWS]","title":"Simple OEF"},{"location":"aea/simple-oef/#simple-oef-agent-search-and-discovery","text":"This documentation has been produced for the Simple-OEF version 0.3.4 .","title":"Simple-OEF: Agent Search and Discovery"},{"location":"aea/simple-oef/#concepts","text":"The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents . Agents register with the soef and are then able to conduct searches around them to find other agents that may be able to help. It is a relatively simple implementation focussing on functionality, performance and ease-of-use. As it develops, it will evolve into a full-scale decentralised, multi-dimensional digital world. The work-flow is: Find relevant agents on the soef, Communicate using the Agent Framework's peer-to-peer network, Negotiate and then transact on the ledger in order to exchange value for tokens When an agent registers with the soef, it is issued with a unique reference which is quoted in all subsequent transactions. This way, the soef knows who its talking to. The soef is transaction based, so it does not need a permanent connection to be maintained in order to work with it. If it does not hear from an agent for a period of time, that agent will be timed out and automatically unregistered. This period of time is typically about one hour, but you can see the soef's configuration at: http://soef.fetch.ai:9002 Agents identify themselves in a number of ways. These include their address, their given name, their classification and their genus. They can also describe how they \"look\" in other ways, and specify the services that they provide. In order to register, agents must provide a valid address and a given name. The address can be for the Fetch.ai native ledger, the Fetch.ai Cosmos ledger or the Ethereum ledger. It is this that uniquely identifies them, and addresses cannot be duplicated or shared. The given name can be anything and it is not used for search filtering. Typically, it can be thought of as a debugging aid or a context. Names could be Alice, Bob or Jim, as well as they could be a flight number, train identity or reference code. They appear in find results, but are not used to find by.","title":"Concepts"},{"location":"aea/simple-oef/#describing-an-agent","text":"Agents describe themselves in three ways: Identity : their address and ledger type along with their given name Personality pieces : how they look Service keys : what they do , sell or want . We cover all of these in this next section. It's important to understand the difference between personality pieces and service keys, as agents only have one appearance, but they can provide many services. Search results can be filtered by a number of both, and wildcards are permitted where relevant.","title":"Describing an Agent"},{"location":"aea/simple-oef/#personality-pieces","text":"Agents can have a number of personality pieces. These describe how an agent appears, where it is, and other properties such as heading, supported protocols and types of transactions. All personality pieces are optional, but the more you set, the easier it is for searchers to narrow you down accurately . Piece Description genus Coarse type of agent, includes things such as vehicle , building , iot . See the genus table below. classification An agent's classification, typically in the form mobility.railway.train . See note below on classifications. No fixed classifications are specified. Classifications can contain alphanumeric characters, the period, underscore and colon ( _.: ). architecture Agent's architecture. See the architecture table below. Introduced in version 0.1.20 . The vast majority of agents should set this to agentframework . dynamics.moving Boolean, indicates if the agent is moving or not. dynamics.heading Indicates the heading of the agent, in radians, with 0.0 pointing due north. dynamics.altitude Altitude of the agent in metres from MSL dynamics.position Indicates the GPS co-ordinates of the agent as latitude and longitude. action.buyer Boolean, indicates whether the agent wishes to buy information, i.e., is an agent that requires value from another agent. action.seller Boolean, indicates whether the agent sells information, i.e., provides value. Value provided can be zero-cost.","title":"Personality Pieces"},{"location":"aea/simple-oef/#genus-list","text":"A genus is a coarse agent class. It is the roughest description of what an agent is, and an easy way of filtering large groups of agents out of searches. The supported genus list is: Name Description test Agent is a test agent, and should be generally ignored. vehicle Moving objects such as trains, planes and automobiles avatar An agent that represents a human being service An agent that provides a service iot An agent that represents an Internet of Things device data An agent that represents data furniture Small fixed location items such as signs, mobile masts building Large fixed location item such as house, railway station, school buyer Indicates the agent is a buyer only and does not have value to deliver viewer The agent is a view in the world, acting as a \"camera\" to view content financial Financial agent: service, exchange, autonomous market maker, etc. The best way to use genus is to pick the best fit choice. If there isn't one for you, then do not specify it. If you feel that a high-level genus is missing, please make the suggestion in our Developer Discord (see here ).","title":"Genus list"},{"location":"aea/simple-oef/#architectures","text":"An architecture is a clue to other agents to describe how the agent is built. The vast majority of agents will be built using the Fetch Agent Framework, but in some cases, such as light-weight IoT devices or test/debugging, agents are built otherwise. Architecture offers a way of describing or filtering, as agents with a similar architecture are more likely to be able to communicate with each other in a meaningful way. Architecture Description custom Custom agent architecture agentframework Built using the Fetch Agent Framework","title":"Architectures"},{"location":"aea/simple-oef/#a-note-on-classifications","text":"There is currently no fixed set of guidelines as to how classifications are used. It is expected that agent builders will converge on a set of standards, and as those become clearer, they will be documented as \"by convention\" classification uses. Here are some examples of classifications in use: mobility.railway.station mobility.railway.train mobility.road.taxi infrastructure.road.sign When filtering by classifications, the * wildcard can be used to, for example, capture all mobility related agents with a wildcard of mobility.* .","title":"A note on classifications"},{"location":"aea/simple-oef/#service-keys","text":"Agents can have a number of service keys. Service keys are simple key/value pairs that describe the list of services that the agent provides. Whilst personality pieces can be thought of as how an agent looks , service keys are what an agent has or does . Service keys are user defined and as with personality pieces, currently have no convention for formatting. They are at the agent builder's discretion. As this changes, the documentation will be updated. However, for buyer agents, three suggested keys are: buying_genus buying_architecture buying_classifications data_type si_unit This allows searches to look for potential buyers of classifications, genus or with a compatible architecture.","title":"Service Keys"},{"location":"aea/simple-oef/#finding-agents","text":"The soef is designed for geographic searches where agents are able to find other agents near to them that are able to provide them with the value that they want, or who might wish to have the value they provide. However, it also allows for positionless searches on a single node. Future versions of the soef will support searches across nodes, and dimensional reduction-based fuzzy searches. Geographic searches are performed using the find_around_me operation. This allows searches that: Are within a certain range in KM Optionally must be positioned within an angle of a heading That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match Positionless searches are performed using the find_on_this_node operation. This allows searches that: That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match At least one filter must be supplied in positionless searches. Positionless searches are not boundless, they are capped at a specific number. The tighter the filters, the less likely that you will be capped. Some limits apply to the maximum number of filters, range and returned results. This may vary from soef instance to soef instance. You can see (and parse if required) these by getting the soef status at: http://soef.fetch.ai:9002 The soef returns XML that includes information about all found agents. An example of that, unparsed, looks like this: <response> <success> 1 </success> <total> 1 </total> <capped> 0 </capped> <results> <agent name= \"TrainNumber1234\" genus= \"vehicle\" classification= \"mobility.railway.train\" user_context= \"18:00 to Berlin\" > <identities> <identity chain_identifier= \"fetchai\" > 2h6fi8oCkMz9GCpL7EUYMHjzgdRFGmDP5V4Ls97jZpzjg523yY </identity> </identities> <range_in_km> 55.7363 </range_in_km> <location accuracy= \"3\" > <latitude> 52.5 </latitude> <longitude> 0.2 </longitude> </location> </agent> </results> </response> The <location> block is only returned if the agent has set itself to disclose its position in a find. Likewise, the user_context=\"\" is only returned if enabled . Normally, the default is not to, and agents will then only return the <range_in_km> item. This is because agents may deliver their precise location as part of the value that they deliver, and therefore it would need to be negotiated and potentially paid for. However, sometimes, it is desirable for agents to always deliver their position when found but specify the accuracy. Because of this, the soef supports four levels of accuracy: Level Accuracy none Default do not disclose position, range only. low Rounded to nearest 11km medium Rounded to nearest 1.1km high Rounded to nearest 110 metres maximum No rounding: supplied in maximum available detail","title":"Finding Agents"},{"location":"aea/simple-oef/#technical-details","text":"For the majority of use cases, the soef will be used from the Agent Framework. As a result, talking to it directly will not be needed. There are some occasions where interacting with the soef directly may be required, and this section documents the API functionality. Until version 1.0 and main-net version 2 (expected in early 2021), some of the security and paid-for-services are not implemented and where they are, they generally not enforced. Digital signatures for the sign-on process and unique identity recovery will be implemented, as will encryption on sensitive data transport, for example. Thus the API is likely to change substantially in the coming months, particularly the initial registration process. It is not recommended that you invest in substantial code that talks to the soef directly until after 1.0, and it is always preferred to go through the Agent Framework.","title":"Technical Details"},{"location":"aea/simple-oef/#registration","text":"Agents register at the /register page on the soef. They are expected to provide four pieces of information: An API key A chain identifier, which can be either fetchai_v1 for the Fetch native network (testnet or mainnet), fetchai_v2_* for the Fetch version 2 network or ethereum for the Ethereum network. See the \"Chain identifiers\" table below for a complete list of supported chain identifiers. An address, which must be a valid address for the specified chain identifier A \"given name\" (see \"Concepts\", above), which can be anything from Alice to Bob, or a flight number, or any other user-given context. It must not exceed 128 characters. If registration is successful, the soef will return a result like this: <response> <encrypted> 0 </encrypted> <token> 0A709D1ED170A3E96C4AC9D014BCAE30 </token> <page_address> oef_AEC97453A80FFFF5F11E612594585F611D1728FFCD74BBF4FE915BBBB052 </page_address> </response> This indicates success and that the agent is now in the Lobby . The lobby is a temporary holding pen where newly registered agents wait until the negotiation is complete. If an agent does not respond and complete its registration within 60 seconds, it is removed from the lobby and registration is cancelled. The <page_address> is the unique URL for the new agent. This must be quoted in all subsequent interactions and is how the soef identifies that specific agent. To complete registration, use the unique URL and specify the parameters: token= with the token that was returned above and command=acknowledge If this works, you will receive a success response: <response> <success> 1 </success> </response> At this point, your agent is now fully registered and can then communicate with the soef. Agents that do not contact the soef at least once over a specified interval will be automatically unregistered. The typical setting for this is 60 minutes.","title":"Registration"},{"location":"aea/simple-oef/#chain-identifiers","text":"The soef supports a selection of chain identifiers designed to allow agents to distinguish networks in searches, but also to identify the type of address used for verification purposes. Chain identifier Network fetchai_v1 Version 1 Fetch.ai network (testnet or mainnet). Versions prior to 0.2 of the soef used fetchai for this, which is retained for compatibility. fetchai_v2_testnet_stable Version 2 Fetch.ai stable testnet, also known as \"Agentland\". Versions prior to 0.2 of the soef used fetchai_cosmos which is retained for compatibility, but deprecated. fetchai_v2_testnet_incentivised Current incentivised testnet. Fetch.ai are running a high-reward sequence of testnets in Q4 2020 and Q1 2021 leading to V2 mainnet. fetchai_v2_misc Miscellaneous v2 network. These are temporary or transient testnets where there is a desire to separate the chain ID from other v2 networks. fetchai_v2_mainnet Fetch.ai v2 mainnet. Not yet active.","title":"Chain identifiers"},{"location":"aea/simple-oef/#commands","text":"The soef has a number of commands that can be used to set or update personality pieces, manage service keys, unregister, find other agents and other operations. These commands are specified using the agent's unique URL and a command= parameter. There may then be other required and optional parameters for that particular command. Command Details unregister Unregisters the agent from the soef. The unique URL is invalidated and the agent will no longer appear in searches. No parameters. ping Say hello. This is for agents that have been idle for a long period of time and wish to maintain their connection. No parameters. set_personality_piece Sets or updates a personality piece. Specify the piece (see personality piece table above) and the value . For personality pieces with multiple values, such as dynamics.position , separate them with the pipe character | . set_service_key Sets or updates a service key. Specify the key and the value to assign to it. remove_service_key Removes an existing service key. Specify the key . set_find_position_disclosure_accuracy Sets the find disclosure accuracy. See the table in \"Finding Agents\", above, for the accepted values for the parameter accuracy . find_around_me Geographic finding of agents around me. This allows various filters, such as personality pieces and service keys, to be specified. See below, as this is more complex. find_on_this_node Positionless finding of agents on this node. Various filters such as personality pieces and service keys can narrow the search. See below for more information. set_position This is a direct internal mapping to set_personality_piece with a piece of dynamics.position . It existed in the earliest versions of the soef and remains as a short-cut. It expects longitude and latitude as parameters. set_declared_name This allows an agent's declared name to be changed after registration. It takes one parameter, name , to specify the replacement name. Names cannot exceed 128 characters and must not contain illegal characters. set_user_context Sets an optional user-context for an agent to what is specified in the value parameter. This can be optionally disclosed in find_around_me if enabled. See set_disclose_user_context , below. The user context must not contain illegal characters and is limited to 160 maximum. set_disclose_user_context If the disclose parameter is set to true , the optional user context is disclosed if it has been set. Default is false .","title":"Commands"},{"location":"aea/simple-oef/#find-commands-in-detail","text":"find_around_me and find_on_this_node are the big commands. Ultimately, they will cost a small amount of tokens to use, depending on the size of the request, as it involves the most computing time. This provides an incentive for soef operators to maintain soef nodes that correspond to subject areas, geographic areas or both. The command has a number of parameters specifying the filtering required. For find_around_me , the range_in_km is required , whereas narrowing down agents to be within a certain angle of a direction is optional. This cannot exceed a certain range, typically between 50 and 75km. This, and other configuration items, are available on the soef's configuration page. There are other parameters that are optional, although for find_on_this_node at least one ppfilter or skfilter must be specified. The parameters are: Parameter Use range_in_km Range in kilometres to include agents in results. of_heading Optional: if a pizza-slice type search is required, this is the direction, in degrees, with 0.0 being north. within Optional: if a pizza-slice search, this is the angle in degrees from the of_heading that is allowed. If either of_heading or within are specified, both must be specified. Example: of_heading set to 90.0 and within set to 30 would exclude any agents that are not within 30 degrees of direct east of the me agent. chains_must_match Boolean. Must be true or false . Default is false . If specified, this ensures that any agents returned in the search will have the same chain identifier as you. ppfilter Specify a personality piece filter. Multiple ppfilter s can be specified. Example use is: ppfilter=dynamics.moving,true . Wildcards can be used where relevant, e.g.: ppfilter=classification,mobility* will match all classifications that start with mobility , whereas ppfilter=classification,*mobility* will match all classifications with mobility anywhere in it. skfilter Specify a service key filter. Multiple skfilter s can be specified. Example use is: skfilter=fruit,peach which will require any returned results to have a service key of fruit and a value of peach . Wildcards can be specified, so skfilter=fruit,pea* will match any agent with a service key of fruit that starts pea , so pear and peach would match.","title":"Find commands in detail"},{"location":"aea/simple-oef/#sk-filters-filter-modes","text":"The skfilter parameter for find_around_me also supports a mode . Four modes are supported: Mode string Description PS Key must be present, and success is required PF Key must be present, and failure is required OS Only match if present, and success is required OF Only match if present, and failure is required For example: command=find_around_me&range_in_km=50&skfilter=type,fruit,PS&skfilter=size,large,OF In this example, the key type must be present, and it must match to fruit . If the size key is present, and it is set to large , then do not match. I.e., return everything that's a fruit within 50km except where the size is large.","title":"SK Filters: filter modes"},{"location":"aea/simple-oef/#further-information","text":"You can find further information, or talk to us, in the #agents channel on our official developer Discord server, which you can access here . We welcome your feedback and strive to deliver the best decentralised search and discovery service for agents that is possible. There are many upcoming features, including the operation incentive mechanisms, additional security and encryption, active searches (where results happen without find_around_me being issued), non-geographic searches across one and many soef nodes and dimensional-reduction based approximate searches. [Docs: issue 15, 0.3.4 , 28-Dec-2020 , TWS]","title":"Further information"},{"location":"aea/skill-guide/","text":"This guide will take you through the development of your first skill. It will teach you, how to connect the agent to the digital world, register the agent and search for other agents. Autonomous Economic Agents are not, generally secret agents. You want them to be seen and found by other agents so that they can trade and do other useful things. Usually, this means connecting to Fetch.ai\u2019s search-and-discovery mechanism, the simple OEF (or SOEF, for short). The SOEF lets your agents register, be found, and find other agents. You can then negotiate using the AEA framework\u2019s peer-to-peer network (ACN) and trade. This guide covers getting your agent connected to the SOEF, and describing your agent to make itself visible. Typically, this means setting a name, a genus (a high-level description of what the agent represents, e.g., vehicle , building or service ), a classification ( infrastructure.railway.train , for example) and then a bunch of other descriptors, where applicable, that provide the agent's position, whether it buys or sells, and other descriptive items. The more you describe your agent, the easier it is for others to find it using specific filters. Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Step 1: Setup We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the SOEF search node and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the SOEF search node via the P2P communication network . from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Location , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) service_key_filter = Constraint ( search_query [ \"search_key\" ], ConstraintType ( search_query [ \"constraint_type\" ], search_query [ \"search_value\" ], ), ) self . query = Query ([ close_to_my_service , service_key_filter ]) super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"setting up MySearchBehaviour\" ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) self . context . logger . info ( \"sending search request to OEF search node, search_count= {} \" . format ( self . sent_search_count ) ) search_request , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = self . query , ) self . context . outbox . put_message ( message = search_request ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchBehaviour\" ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues with your author handle (run aea init to set or check the author name). Step 3: Develop a Handler So far, we have tasked the AEA with sending search requests to the SOEF search node . However, we have no way of handling the responses sent to the AEA by the SOEF search node at the moment. The AEA would simply respond to the SOEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a Handler to deal with the incoming search responses. from typing import Optional , cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"setting up MySearchHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" self . received_search_count += 1 nb_agents_found = len ( oef_search_msg . agents ) self . context . logger . info ( \"found number of agents= {} , received search count= {} \" . format ( nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchHandler\" ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context , the SkillContext . We place this code in my_aea/skills/my_search/handlers.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import ( with your author handle (run aea init to set or check the author name). Step 4: Add dialogues model We have implemented a behaviour and a handler. We now implement a Model , in particular we implement the Dialogue and Dialogues classes. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Address , Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) We add this code in the file my_aea/skills/my_search/my_model.py , replacing its original content. We then rename my_aea/skills/my_search/my_model.py to my_aea/skills/my_search/dialogues.py . Step 5: Create the configuration file Based on our skill components above, we create the following configuration file. name : my_search author : fetchai version : 0.1.0 type : skill description : A simple search skill utilising the SOEF search node. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : {} fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.12.0 skills : [] behaviours : my_search_behaviour : args : location : latitude : 51.5194 longitude : 0.127 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Similarly, we replace my_aea/skills/my_search/__init__.py as follows: # -*- coding: utf-8 -*- # ------------------------------------------------------------------------------ # # Copyright 2018-2019 Fetch.AI Limited # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ \"\"\"This module contains the implementation of the error skill.\"\"\" from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"fetchai/my_search:0.1.0\" ) Again, ensure the author field matches your own. Step 6: Update fingerprint We need to update the fingerprint of our skill next: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.) Step 7: Add the OEF protocol and connection Our AEA does not have the OEF protocol yet so let's add it. aea add protocol fetchai/oef_search:0.12.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the soef and P2P connections and install the AEA's dependencies as well as configure the AEA: aea add connection fetchai/soef:0.15.0 aea add connection fetchai/p2p_libp2p:0.14.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' The last command will ensure that search requests are processed by the correct connection. Step 8: Run a service provider AEA In order to be able to find another AEA when searching, from a different terminal window, we fetch another finished AEA and install its Python dependencies: aea fetch fetchai/simple_service_registration:0.19.0 && cd simple_service_registration && aea install && aea build This AEA will simply register a location service on the SOEF search node so we can search for it. We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then we run the AEA: aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the simple_service_registration AEA. Click here to see full code We use a `TickerBehaviour` to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogues , ) from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_agent () self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" pass def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering agent on SOEF.\" ) def _register_service ( self ) -> None : \"\"\" Register the agent's service. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering service on SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) We create a `Model` type strategy class and place it in `strategy.py`. We use a generic data model to register the service. from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location from aea.skills.base import Model DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) } self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) assert ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data ), \"service_data must contain keys `key` and `value`\" self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} super () . __init__ ( ** kwargs ) def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description We create a `Model` type dialogue class and place it in `dialogues.py`. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) Finally, we have a handler, placed in `handlers.py`: from typing import Optional , cast from aea.configurations.base import PublicId from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) LEDGER_API_ADDRESS = \"fetchai/ledger:0.12.0\" class OefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.4.0 type : skill description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmRr1oe3zWKyPcktzKP4BiKqjCqmKjEDdLUQhn1JzNm4nD dialogues.py : QmayFh6ytPefJng5ENTUg46zsd6guHCZSsG3Cc2sy3xz6y handlers.py : QmViyyV5KvR3kkLEMpvDfqH5QtHowTbnpDxRYnKABpVvpC strategy.py : Qmdp6LCPZSnnyfM4EdRDTGZPqwxiJ3A1jsc3oF2Hv4m5Mv fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.12.0 skills : [] behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : oef_search : args : {} class_name : OefSearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service class_name : Strategy dependencies : {} Step 9: Run the Search AEA First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then, in the search AEA, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm1uJpFsqSgHStJdtTBPpDme1fo8uFEvvY182D2y89jQuj\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the search AEA to connect to the same local agent communication network as the service registration AEA. We can then launch our AEA. aea run We can see that the AEA sends search requests to the SOEF search node and receives search responses from the SOEF search node . The search response returns one or more agents (the service provider and potentially other agents which match the query). We stop the AEA with CTRL + C . Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: Core components (Part 2) Relevant deep-dives We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Build your first skill - search & discovery"},{"location":"aea/skill-guide/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/skill-guide/#step-1-setup","text":"We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the SOEF search node and process the resulting response.","title":"Step 1: Setup"},{"location":"aea/skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the SOEF search node via the P2P communication network . from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Location , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) service_key_filter = Constraint ( search_query [ \"search_key\" ], ConstraintType ( search_query [ \"constraint_type\" ], search_query [ \"search_value\" ], ), ) self . query = Query ([ close_to_my_service , service_key_filter ]) super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"setting up MySearchBehaviour\" ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) self . context . logger . info ( \"sending search request to OEF search node, search_count= {} \" . format ( self . sent_search_count ) ) search_request , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = self . query , ) self . context . outbox . put_message ( message = search_request ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchBehaviour\" ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues with your author handle (run aea init to set or check the author name).","title":"Step 2: Develop a Behaviour"},{"location":"aea/skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the AEA with sending search requests to the SOEF search node . However, we have no way of handling the responses sent to the AEA by the SOEF search node at the moment. The AEA would simply respond to the SOEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a Handler to deal with the incoming search responses. from typing import Optional , cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"setting up MySearchHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" self . received_search_count += 1 nb_agents_found = len ( oef_search_msg . agents ) self . context . logger . info ( \"found number of agents= {} , received search count= {} \" . format ( nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchHandler\" ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context , the SkillContext . We place this code in my_aea/skills/my_search/handlers.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import ( with your author handle (run aea init to set or check the author name).","title":"Step 3: Develop a Handler"},{"location":"aea/skill-guide/#step-4-add-dialogues-model","text":"We have implemented a behaviour and a handler. We now implement a Model , in particular we implement the Dialogue and Dialogues classes. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Address , Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) We add this code in the file my_aea/skills/my_search/my_model.py , replacing its original content. We then rename my_aea/skills/my_search/my_model.py to my_aea/skills/my_search/dialogues.py .","title":"Step 4: Add dialogues model"},{"location":"aea/skill-guide/#step-5-create-the-configuration-file","text":"Based on our skill components above, we create the following configuration file. name : my_search author : fetchai version : 0.1.0 type : skill description : A simple search skill utilising the SOEF search node. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : {} fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.12.0 skills : [] behaviours : my_search_behaviour : args : location : latitude : 51.5194 longitude : 0.127 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Similarly, we replace my_aea/skills/my_search/__init__.py as follows: # -*- coding: utf-8 -*- # ------------------------------------------------------------------------------ # # Copyright 2018-2019 Fetch.AI Limited # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ \"\"\"This module contains the implementation of the error skill.\"\"\" from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"fetchai/my_search:0.1.0\" ) Again, ensure the author field matches your own.","title":"Step 5: Create the configuration file"},{"location":"aea/skill-guide/#step-6-update-fingerprint","text":"We need to update the fingerprint of our skill next: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.)","title":"Step 6: Update fingerprint"},{"location":"aea/skill-guide/#step-7-add-the-oef-protocol-and-connection","text":"Our AEA does not have the OEF protocol yet so let's add it. aea add protocol fetchai/oef_search:0.12.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the soef and P2P connections and install the AEA's dependencies as well as configure the AEA: aea add connection fetchai/soef:0.15.0 aea add connection fetchai/p2p_libp2p:0.14.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' The last command will ensure that search requests are processed by the correct connection.","title":"Step 7: Add the OEF protocol and connection"},{"location":"aea/skill-guide/#step-8-run-a-service-provider-aea","text":"In order to be able to find another AEA when searching, from a different terminal window, we fetch another finished AEA and install its Python dependencies: aea fetch fetchai/simple_service_registration:0.19.0 && cd simple_service_registration && aea install && aea build This AEA will simply register a location service on the SOEF search node so we can search for it. We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then we run the AEA: aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the simple_service_registration AEA. Click here to see full code We use a `TickerBehaviour` to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import cast from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogues , ) from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_agent () self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" pass def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering agent on SOEF.\" ) def _register_service ( self ) -> None : \"\"\" Register the agent's service. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"registering service on SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = oef_search_dialogues . new_self_initiated_dialogue_reference (), service_description = description , ) oef_search_msg . counterparty = self . context . search_service_address oef_search_dialogues . update ( oef_search_msg ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) We create a `Model` type strategy class and place it in `strategy.py`. We use a generic data model to register the service. from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location from aea.skills.base import Model DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) } self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) assert ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data ), \"service_data must contain keys `key` and `value`\" self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} super () . __init__ ( ** kwargs ) def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description We create a `Model` type dialogue class and place it in `dialogues.py`. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) Finally, we have a handler, placed in `handlers.py`: from typing import Optional , cast from aea.configurations.base import PublicId from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) LEDGER_API_ADDRESS = \"fetchai/ledger:0.12.0\" class OefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.4.0 type : skill description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=0.9.0, <0.10.0' fingerprint : __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmRr1oe3zWKyPcktzKP4BiKqjCqmKjEDdLUQhn1JzNm4nD dialogues.py : QmayFh6ytPefJng5ENTUg46zsd6guHCZSsG3Cc2sy3xz6y handlers.py : QmViyyV5KvR3kkLEMpvDfqH5QtHowTbnpDxRYnKABpVvpC strategy.py : Qmdp6LCPZSnnyfM4EdRDTGZPqwxiJ3A1jsc3oF2Hv4m5Mv fingerprint_ignore_patterns : [] contracts : [] protocols : - fetchai/oef_search:0.12.0 skills : [] behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : oef_search : args : {} class_name : OefSearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service class_name : Strategy dependencies : {}","title":"Step 8: Run a service provider AEA"},{"location":"aea/skill-guide/#step-9-run-the-search-aea","text":"First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then, in the search AEA, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm1uJpFsqSgHStJdtTBPpDme1fo8uFEvvY182D2y89jQuj\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the search AEA to connect to the same local agent communication network as the service registration AEA. We can then launch our AEA. aea run We can see that the AEA sends search requests to the SOEF search node and receives search responses from the SOEF search node . The search response returns one or more agents (the service provider and potentially other agents which match the query). We stop the AEA with CTRL + C .","title":"Step 9: Run the Search AEA"},{"location":"aea/skill-guide/#next-steps","text":"","title":"Next steps"},{"location":"aea/skill-guide/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: Core components (Part 2)","title":"Recommended"},{"location":"aea/skill-guide/#relevant-deep-dives","text":"We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Relevant deep-dives"},{"location":"aea/skill-testing/","text":"In this guide we describe some of the tools the framework offers for testing skills. The BaseSkillTestCase class The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" ) Specifying Skill Path You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides. Setting up Each Test You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test. Skill and Skill Context The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour . Dummy Agent Context The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , ) Some Useful Skill Attributes Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" . Some Useful BaseSkillTestCase Methods There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution. Checking Logger Output You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger. Next steps You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Testing Skills"},{"location":"aea/skill-testing/#the-baseskilltestcase-class","text":"The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" )","title":"The BaseSkillTestCase class"},{"location":"aea/skill-testing/#specifying-skill-path","text":"You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides.","title":"Specifying Skill Path"},{"location":"aea/skill-testing/#setting-up-each-test","text":"You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test.","title":"Setting up Each Test"},{"location":"aea/skill-testing/#skill-and-skill-context","text":"The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour .","title":"Skill and Skill Context"},{"location":"aea/skill-testing/#dummy-agent-context","text":"The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , )","title":"Dummy Agent Context"},{"location":"aea/skill-testing/#some-useful-skill-attributes","text":"Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" .","title":"Some Useful Skill Attributes"},{"location":"aea/skill-testing/#some-useful-baseskilltestcase-methods","text":"There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution.","title":"Some Useful BaseSkillTestCase Methods"},{"location":"aea/skill-testing/#checking-logger-output","text":"You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger.","title":"Checking Logger Output"},{"location":"aea/skill-testing/#next-steps","text":"You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Next steps"},{"location":"aea/skill/","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages (see next section). Behaviour : none, one or more Behaviours encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.). Model : none, one or more Models that inherit from the Model can be accessed via the SkillContext . Task : none, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of skills, but Task s are declared in or from skills if a packaging approach for AEA creation is used. A skill can read (parts of) the state of the the AEA (as summarised in the AgentContext ), and suggest actions to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means skills are horizontally arranged. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. The framework places no limits on the complexity of skills. They can implement simple (e.g. if-this-then-that ) or complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default skill, called error . Additional skills can be added as packages. Independence of skills Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker . Context The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context )) behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution. tasks.py Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass Models The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model Skill configuration Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:0.11.0 Error skill All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.11.0 protocol which provides error codes for the above. Custom Error handler The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Skills"},{"location":"aea/skill/#independence-of-skills","text":"Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker .","title":"Independence of skills"},{"location":"aea/skill/#context","text":"The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"aea/skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"aea/skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context ))","title":"handlers.py"},{"location":"aea/skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution.","title":"behaviours.py"},{"location":"aea/skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass","title":"tasks.py"},{"location":"aea/skill/#models","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model","title":"Models"},{"location":"aea/skill/#skill-configuration","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:0.11.0","title":"Skill configuration"},{"location":"aea/skill/#error-skill","text":"All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.11.0 protocol which provides error codes for the above.","title":"Error skill"},{"location":"aea/skill/#custom-error-handler","text":"The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Custom Error handler"},{"location":"aea/standalone-transaction/","text":"In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer First, import the python and application specific libraries and set the static variables. import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create the private keys # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) Send transaction Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Create stand-alone transaction"},{"location":"aea/standalone-transaction/#create-the-private-keys","text":"# Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"aea/standalone-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"aea/standalone-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] )","title":"Generate wealth"},{"location":"aea/standalone-transaction/#send-transaction","text":"Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Send transaction"},{"location":"aea/step-one/","text":"There are a number of ways to build an AEA: To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here . Using the CLI aea fetch command, pull in an already built project and run as is or extend it to your needs. The last option is to build an AEA programmatically as described here . Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides: the AEA vs Agents guide shows the difference between an agent and an AEA in code, the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.","title":"Ways to build an AEA"},{"location":"aea/tac-skills-contract/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. This demo uses another AEA - a controller AEA - to take the role of running the competition. Transactions are validated on an ERC1155 smart contract on the Ropsten Ethereum testnet. In the below video we discuss the framework and TAC in more detail: Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions: Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.20.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_control_contract:0.17.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build Then, generate a private key. aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Create the TAC participant AEAs In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_one cd tac_participant_one aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build cd .. aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_two cd tac_participant_two aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build Add keys for all AEAs Create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the game parameters in the controller Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least five minutes - better 10 - in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \" Update the connection parameters Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller. Run Ganache Run the following command docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat tac_controller_contract/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_one/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_two/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth of one of the AEAs, use: aea get-wealth ethereum You should get 1000000000000000000000 . Run the AEAs First, launch the tac_contract_controller : aea run tac_contract_controller The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"TAC skills ledger-based"},{"location":"aea/tac-skills-contract/#discussion","text":"The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. This demo uses another AEA - a controller AEA - to take the role of running the competition. Transactions are validated on an ERC1155 smart contract on the Ropsten Ethereum testnet. In the below video we discuss the framework and TAC in more detail:","title":"Discussion"},{"location":"aea/tac-skills-contract/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills-contract/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills-contract/#transaction-communication","text":"This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills-contract/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills-contract/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills-contract/#demo-instructions","text":"","title":"Demo instructions:"},{"location":"aea/tac-skills-contract/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.20.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_control_contract:0.17.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build Then, generate a private key. aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt","title":"Create TAC controller AEA"},{"location":"aea/tac-skills-contract/#create-the-tac-participant-aeas","text":"In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_one cd tac_participant_one aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build cd .. aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_two cd tac_participant_two aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:0.10.0\": \"fetchai/ledger:0.12.0\", \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea install aea build","title":"Create the TAC participant AEAs"},{"location":"aea/tac-skills-contract/#add-keys-for-all-aeas","text":"Create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for all AEAs"},{"location":"aea/tac-skills-contract/#update-the-game-parameters-in-the-controller","text":"Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least five minutes - better 10 - in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \"","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills-contract/#update-the-connection-parameters","text":"Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller.","title":"Update the connection parameters"},{"location":"aea/tac-skills-contract/#run-ganache","text":"Run the following command docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat tac_controller_contract/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_one/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_two/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth of one of the AEAs, use: aea get-wealth ethereum You should get 1000000000000000000000 .","title":"Run Ganache"},{"location":"aea/tac-skills-contract/#run-the-aeas","text":"First, launch the tac_contract_controller : aea run tac_contract_controller The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills-contract/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac-skills/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger. Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent . We also have an AEA in the role of the buyer, referred to as Buyer_Agent . During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions: Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.18.0 cd tac_controller aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_control:0.15.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Create the TAC participant AEAs In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_two cd tac_participant_two aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Add keys for all AEAs Create the private key for the AEA for Fetch.ai AgentLand : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the game parameters in the controller Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \" Update the connection parameters Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller. Run the AEAs First, launch the tac_controller : aea run The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"TAC skills"},{"location":"aea/tac-skills/#discussion","text":"The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger.","title":"Discussion"},{"location":"aea/tac-skills/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills/#transaction-communication","text":"This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent . We also have an AEA in the role of the buyer, referred to as Buyer_Agent . During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills/#demo-instructions","text":"","title":"Demo instructions:"},{"location":"aea/tac-skills/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.18.0 cd tac_controller aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_control:0.15.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build","title":"Create TAC controller AEA"},{"location":"aea/tac-skills/#create-the-tac-participant-aeas","text":"In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant:0.20.0 --alias tac_participant_two cd tac_participant_two aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/tac_participation:0.16.0 aea add skill fetchai/tac_negotiation:0.18.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' aea install aea build","title":"Create the TAC participant AEAs"},{"location":"aea/tac-skills/#add-keys-for-all-aeas","text":"Create the private key for the AEA for Fetch.ai AgentLand : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for all AEAs"},{"location":"aea/tac-skills/#update-the-game-parameters-in-the-controller","text":"Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \"","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills/#update-the-connection-parameters","text":"Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller.","title":"Update the connection parameters"},{"location":"aea/tac-skills/#run-the-aeas","text":"First, launch the tac_controller : aea run The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac/","text":"The original TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The Visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"aea/tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"aea/tac/#quick-start","text":"Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The Visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"aea/tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"aea/tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"aea/thermometer-skills/","text":"The AEA thermometer skills demonstrate an interaction between two AEAs. The provider of thermometer data (the thermometer ). The buyer of thermometer data (the thermometer_client ). Discussion The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction. Communication This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create thermometer AEA First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.18.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Create thermometer client Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.19.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Add keys for the thermometer AEA First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the thermometer client AEA The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run both AEAs Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA. Then run the thermometer client AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Thermometer skills"},{"location":"aea/thermometer-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction.","title":"Discussion"},{"location":"aea/thermometer-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/thermometer-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/thermometer-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/thermometer-skills/#demo-instructions","text":"A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions"},{"location":"aea/thermometer-skills/#create-thermometer-aea","text":"First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.18.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create thermometer AEA"},{"location":"aea/thermometer-skills/#create-thermometer-client","text":"Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.19.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/thermometer_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create thermometer client"},{"location":"aea/thermometer-skills/#add-keys-for-the-thermometer-aea","text":"First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the thermometer AEA"},{"location":"aea/thermometer-skills/#add-keys-and-generate-wealth-for-the-thermometer-client-aea","text":"The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the thermometer client AEA"},{"location":"aea/thermometer-skills/#run-both-aeas","text":"Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA. Then run the thermometer client AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/thermometer-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Cleaning up"},{"location":"aea/trust/","text":"AEA applications operate within different orders of trustlessness. For example, using the AEA weather skills demo without ledger payments means that clients must trust that any data the weather station sends is sufficient, including no data at all. Similarly, the weather station must trust the weather clients to send payment via some mechanism. A step up, if you run the weather skills demo with a ledger (Fetch.ai or Ethereum) then the clients must again trust the weather station to send sufficient data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the weather clients as it can observe the transactions taking place on the public ledger. We can expand trustlessness even further by incorporating a third-party as an arbitrator or some escrow contract. However, in the weather skills demo there are limits to trustlessness as the station ultimately offers unverifiable data. Finally, in the case of (non-fungible) token transactions where there is an atomic swap, full trustlessness is apparent. This is demonstrated in the TAC.","title":"Trust issues"},{"location":"aea/upgrading/","text":"This page provides some tips of how to upgrade between versions. v0.9.1 to v0.9.2 No backwards incompatible changes for skill and connection development. v0.9.0 to v0.9.1 No backwards incompatible changes for skill and connection development. v0.8.0 to v0.9.0 This release introduces proof of representation to the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p / fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to latest packages by running aea upgrade . v0.7.5 to v0.8.0 Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to latest packages by running aea upgrade . v0.7.4 to v0.7.5 No backwards incompatible changes for skill and connection development. v0.7.3 to v0.7.4 No backwards incompatible changes for skill and connection development. v0.7.2 to v0.7.3 No backwards incompatible changes for skill and connection development. v0.7.1 to v0.7.2 No backwards incompatible changes for skill and connection development. v0.7.0 to v0.7.1 To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the generate command. v0.6.3 to v0.7.0 Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML. v0.6.2 to v0.6.3 A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible. v0.6.1 to v0.6.2 No public APIs have been changed. v0.6.0 to v0.6.1 The soef connection and oef_search protocol have backward incompatible changes. v0.5.4 to v0.6.0 Dialogue and Dialogues API updates The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages. FetchAICrypto - default crypto The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai . Private key file naming The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern. Type in package YAML The package YAML files now contain a type field. This must be added for the loading mechanism to work properly. Moved address type The address type has moved to aea.common . The import paths must be updated. v0.5.3 to v0.5.4 The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail. v0.5.2 to v0.5.3 Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail. v0.5.1 to 0.5.2 No public APIs have been changed. v0.5.0 to 0.5.1 No public APIs have been changed. v0.4.1 to 0.5.0 A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] . v0.4.0 to v0.4.1 There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources. v0.3.3 to v0.4.0 Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"Upgrading"},{"location":"aea/upgrading/#v091-to-v092","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.1 to v0.9.2"},{"location":"aea/upgrading/#v090-to-v091","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.0 to v0.9.1"},{"location":"aea/upgrading/#v080-to-v090","text":"This release introduces proof of representation to the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p / fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to latest packages by running aea upgrade .","title":"v0.8.0 to v0.9.0"},{"location":"aea/upgrading/#v075-to-v080","text":"Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to latest packages by running aea upgrade .","title":"v0.7.5 to v0.8.0"},{"location":"aea/upgrading/#v074-to-v075","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.4 to v0.7.5"},{"location":"aea/upgrading/#v073-to-v074","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.3 to v0.7.4"},{"location":"aea/upgrading/#v072-to-v073","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.2 to v0.7.3"},{"location":"aea/upgrading/#v071-to-v072","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.1 to v0.7.2"},{"location":"aea/upgrading/#v070-to-v071","text":"To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the generate command.","title":"v0.7.0 to v0.7.1"},{"location":"aea/upgrading/#v063-to-v070","text":"Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML.","title":"v0.6.3 to v0.7.0"},{"location":"aea/upgrading/#v062-to-v063","text":"A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible.","title":"v0.6.2 to v0.6.3"},{"location":"aea/upgrading/#v061-to-v062","text":"No public APIs have been changed.","title":"v0.6.1 to v0.6.2"},{"location":"aea/upgrading/#v060-to-v061","text":"The soef connection and oef_search protocol have backward incompatible changes.","title":"v0.6.0 to v0.6.1"},{"location":"aea/upgrading/#v054-to-v060","text":"","title":"v0.5.4 to v0.6.0"},{"location":"aea/upgrading/#dialogue-and-dialogues-api-updates","text":"The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages.","title":"Dialogue and Dialogues API updates"},{"location":"aea/upgrading/#fetchaicrypto-default-crypto","text":"The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai .","title":"FetchAICrypto - default crypto"},{"location":"aea/upgrading/#private-key-file-naming","text":"The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern.","title":"Private key file naming"},{"location":"aea/upgrading/#type-in-package-yaml","text":"The package YAML files now contain a type field. This must be added for the loading mechanism to work properly.","title":"Type in package YAML"},{"location":"aea/upgrading/#moved-address-type","text":"The address type has moved to aea.common . The import paths must be updated.","title":"Moved address type"},{"location":"aea/upgrading/#v053-to-v054","text":"The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail.","title":"v0.5.3 to v0.5.4"},{"location":"aea/upgrading/#v052-to-v053","text":"Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail.","title":"v0.5.2 to v0.5.3"},{"location":"aea/upgrading/#v051-to-052","text":"No public APIs have been changed.","title":"v0.5.1 to 0.5.2"},{"location":"aea/upgrading/#v050-to-051","text":"No public APIs have been changed.","title":"v0.5.0 to 0.5.1"},{"location":"aea/upgrading/#v041-to-050","text":"A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] .","title":"v0.4.1 to 0.5.0"},{"location":"aea/upgrading/#v040-to-v041","text":"There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources.","title":"v0.4.0 to v0.4.1"},{"location":"aea/upgrading/#v033-to-v040","text":"Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"v0.3.3 to v0.4.0"},{"location":"aea/version/","text":"The current version of the Python based Autonomous Economic Agent framework is . The framework is under rapid development with frequent breaking changes in the run-up to v1 due in Q1 2021. The Python based AEA framework is in principle compatible with any AEA framework, independent of the language it is implemented in. The language agnostic definition provides details on the aspects an implementation has to satisfy to qualify as an AEA framework.","title":"Version"},{"location":"aea/vision/","text":"The AEA framework has two commercial roles which are outlined below. Open source technology for everyone We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers Decentralised agent economy for businesses We envisage the AEA framework to be used by businesses of all sizes to deploy multi-agent solutions into the decentralized agent economy cultivated by Fetch.ai. With start up grants we kick start solutions while testing product-market fit and identifying our user base.","title":"Vision"},{"location":"aea/vision/#open-source-technology-for-everyone","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers","title":"Open source technology for everyone"},{"location":"aea/vision/#decentralised-agent-economy-for-businesses","text":"We envisage the AEA framework to be used by businesses of all sizes to deploy multi-agent solutions into the decentralized agent economy cultivated by Fetch.ai. With start up grants we kick start solutions while testing product-market fit and identifying our user base.","title":"Decentralised agent economy for businesses"},{"location":"aea/wealth/","text":"To fund an AEA for testing on a test-net you need to request some test tokens from a faucet. Add a private key to the agent aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt or aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Note If you already have keys in your project, the commands will prompt you for confirmation whether or not to replace the existing keys. Using a faucet website First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum Using the CLI Simply generate wealth via the CLI: aea generate-wealth fetchai or aea generate-wealth ethereum Note This approach can be unreliable for non-fetchai test nets.","title":"Generating wealth"},{"location":"aea/wealth/#using-a-faucet-website","text":"First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum","title":"Using a faucet website"},{"location":"aea/wealth/#using-the-cli","text":"Simply generate wealth via the CLI: aea generate-wealth fetchai or aea generate-wealth ethereum Note This approach can be unreliable for non-fetchai test nets.","title":"Using the CLI"},{"location":"aea/weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs. The provider of weather data (the weather_station ). The buyer of weather data (the weather_client ). Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients. Communication This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions: A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the weather station First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.20.0 --alias my_weather_station cd my_weather_station aea install aea build Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/weather_station:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Create the weather client In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.21.0 --alias my_weather_client cd my_weather_client aea install aea build Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/weather_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }' Add keys for the weather station AEA First, create the private key for the weather station AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the weather client AEA The weather client needs to have some wealth to purchase the service from the weather station. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the AEAs Run both AEAs from their respective terminals. First, run the weather station AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the weather station. Then, in the weather client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the weather client to connect to the same local agent communication network as the weather station. Then run the weather client AEA: aea run You will see that the AEAs negotiate and then transact using the selected ledger. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"aea/weather-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients.","title":"Discussion"},{"location":"aea/weather-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/weather-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/weather-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/weather-skills/#demo-instructions","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions:"},{"location":"aea/weather-skills/#create-the-weather-station","text":"First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.20.0 --alias my_weather_station cd my_weather_station aea install aea build Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/weather_station:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the weather station"},{"location":"aea/weather-skills/#create-the-weather-client","text":"In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.21.0 --alias my_weather_client cd my_weather_client aea install aea build Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/p2p_libp2p:0.14.0 aea add connection fetchai/soef:0.15.0 aea add connection fetchai/ledger:0.12.0 aea add skill fetchai/weather_client:0.18.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.14.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:0.9.0\": \"fetchai/ledger:0.12.0\", \"fetchai/oef_search:0.12.0\": \"fetchai/soef:0.15.0\" }'","title":"Create the weather client"},{"location":"aea/weather-skills/#add-keys-for-the-weather-station-aea","text":"First, create the private key for the weather station AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the weather station AEA"},{"location":"aea/weather-skills/#add-keys-and-generate-wealth-for-the-weather-client-aea","text":"The weather client needs to have some wealth to purchase the service from the weather station. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai AgentLand use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai AgentLand network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the weather client AEA"},{"location":"aea/weather-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. First, run the weather station AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.14.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the weather station. Then, in the weather client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the weather client to connect to the same local agent communication network as the weather station. Then run the weather client AEA: aea run You will see that the AEAs negotiate and then transact using the selected ledger.","title":"Run the AEAs"},{"location":"aea/weather-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/api/abstract_agent/","text":"aea.abstract _ agent This module contains the interface definition of the abstract agent. AbstractAgent Objects class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent. name | @abstractproperty | name () -> str Get agent's name. start | @abstractmethod | start () -> None Start the agent. Returns : None stop | @abstractmethod | stop () -> None Stop the agent. Returns : None setup | @abstractmethod | setup () -> None Set up the agent. Returns : None act | @abstractmethod | act () -> None Perform actions on period. Returns : None handle _ envelope | @abstractmethod | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None get _ periodic _ tasks | @abstractmethod | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | @abstractmethod | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message get _ multiplexer _ setup _ options | @abstractmethod | get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs connections | @abstractproperty | connections () -> List [ Connection ] Return list of connections. storage _ uri | @abstractproperty | storage_uri () -> Optional [ str ] Return storage uri. exception _ handler | @abstractmethod | exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it teardown | @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"AbstractAgent"},{"location":"aea/api/abstract_agent/#aeaabstract_agent","text":"This module contains the interface definition of the abstract agent.","title":"aea.abstract_agent"},{"location":"aea/api/abstract_agent/#abstractagent-objects","text":"class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent.","title":"AbstractAgent Objects"},{"location":"aea/api/abstract_agent/#name","text":"| @abstractproperty | name () -> str Get agent's name.","title":"name"},{"location":"aea/api/abstract_agent/#start","text":"| @abstractmethod | start () -> None Start the agent. Returns : None","title":"start"},{"location":"aea/api/abstract_agent/#stop","text":"| @abstractmethod | stop () -> None Stop the agent. Returns : None","title":"stop"},{"location":"aea/api/abstract_agent/#setup","text":"| @abstractmethod | setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"aea/api/abstract_agent/#act","text":"| @abstractmethod | act () -> None Perform actions on period. Returns : None","title":"act"},{"location":"aea/api/abstract_agent/#handle_envelope","text":"| @abstractmethod | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"aea/api/abstract_agent/#get_periodic_tasks","text":"| @abstractmethod | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/abstract_agent/#get_message_handlers","text":"| @abstractmethod | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/abstract_agent/#get_multiplexer_setup_options","text":"| @abstractmethod | get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs","title":"get_multiplexer_setup_options"},{"location":"aea/api/abstract_agent/#connections","text":"| @abstractproperty | connections () -> List [ Connection ] Return list of connections.","title":"connections"},{"location":"aea/api/abstract_agent/#storage_uri","text":"| @abstractproperty | storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"aea/api/abstract_agent/#exception_handler","text":"| @abstractmethod | exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it","title":"exception_handler"},{"location":"aea/api/abstract_agent/#teardown","text":"| @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"aea/api/aea/","text":"aea.aea This module contains the implementation of an autonomous economic agent (AEA). AEA Objects class AEA ( Agent ) This class implements an autonomous economic agent. __ init __ | __init__ ( identity : Identity , wallet : Wallet , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , period : float = 0.05 , execution_timeout : float = 0 , max_reactions : int = 20 , error_handler_class : Optional [ Type [ AbstractErrorHandler ]] = None , decision_maker_handler_class : Optional [ Type [ DecisionMakerHandler ]] = None , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , connection_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ PublicId ] = None , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , connection_ids : Optional [ Collection [ PublicId ]] = None , search_service_address : str = DEFAULT_SEARCH_SERVICE_ADDRESS , storage_uri : Optional [ str ] = None , ** kwargs , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent wallet : the wallet of the agent. resources : the resources (protocols and skills) of the agent. loop : the event loop to run the connections. period : period to call agent's act execution_timeout : amount of time to limit single act/handle to execute. max_reactions : the processing rate of envelopes per tick (i.e. single loop). decision_maker_handler_class : the class implementing the decision maker handler to be used. skill_exception_policy : the skill exception policy enum loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode (async, threaded) to run AEA in. default_ledger : default ledger id currency_denominations : mapping from ledger id to currency denomination default_connection : public id to the default connection default_routing : dictionary for default routing. connection_ids : active connection ids. Default: consider all the ones in the resources. search_service_address : the address of the search service used. storage_uri : optional uri to set generic storage kwargs : keyword arguments to be attached in the agent context namespace. Returns : None get _ build _ dir | @classmethod | get_build_dir ( cls ) -> str Get agent build directory. context | @property | context () -> AgentContext Get (agent) context. resources | @property | resources () -> Resources Get resources. resources | @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources. filter | @property | filter () -> Filter Get the filter. active _ behaviours | @property | active_behaviours () -> List [ Behaviour ] Get all active behaviours to use in act. setup | setup () -> None Set up the agent. Performs the following: loads the resources (unless in programmatic mode) calls setup() on the resources Returns : None act | act () -> None Perform actions. Calls act() of each active behaviour. Returns : None active _ connections | @property | active_connections () -> List [ Connection ] Return list of active connections. get _ multiplexer _ setup _ options | get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs handle _ envelope | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. fetching the protocol referenced by the envelope, and returning an envelope to sender if the protocol is unsupported, using the error handler, or returning an envelope to sender if there is a decoding error, using the error handler, or returning an envelope to sender if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Arguments : envelope : the envelope to handle. Returns : None get _ periodic _ tasks | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler | exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it. teardown | teardown () -> None Tear down the agent. Performs the following: tears down the resources. Returns : None get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the task manager. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"AEA"},{"location":"aea/api/aea/#aeaaea","text":"This module contains the implementation of an autonomous economic agent (AEA).","title":"aea.aea"},{"location":"aea/api/aea/#aea-objects","text":"class AEA ( Agent ) This class implements an autonomous economic agent.","title":"AEA Objects"},{"location":"aea/api/aea/#__init__","text":"| __init__ ( identity : Identity , wallet : Wallet , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , period : float = 0.05 , execution_timeout : float = 0 , max_reactions : int = 20 , error_handler_class : Optional [ Type [ AbstractErrorHandler ]] = None , decision_maker_handler_class : Optional [ Type [ DecisionMakerHandler ]] = None , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , connection_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ PublicId ] = None , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , connection_ids : Optional [ Collection [ PublicId ]] = None , search_service_address : str = DEFAULT_SEARCH_SERVICE_ADDRESS , storage_uri : Optional [ str ] = None , ** kwargs , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent wallet : the wallet of the agent. resources : the resources (protocols and skills) of the agent. loop : the event loop to run the connections. period : period to call agent's act execution_timeout : amount of time to limit single act/handle to execute. max_reactions : the processing rate of envelopes per tick (i.e. single loop). decision_maker_handler_class : the class implementing the decision maker handler to be used. skill_exception_policy : the skill exception policy enum loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode (async, threaded) to run AEA in. default_ledger : default ledger id currency_denominations : mapping from ledger id to currency denomination default_connection : public id to the default connection default_routing : dictionary for default routing. connection_ids : active connection ids. Default: consider all the ones in the resources. search_service_address : the address of the search service used. storage_uri : optional uri to set generic storage kwargs : keyword arguments to be attached in the agent context namespace. Returns : None","title":"__init__"},{"location":"aea/api/aea/#get_build_dir","text":"| @classmethod | get_build_dir ( cls ) -> str Get agent build directory.","title":"get_build_dir"},{"location":"aea/api/aea/#context","text":"| @property | context () -> AgentContext Get (agent) context.","title":"context"},{"location":"aea/api/aea/#resources","text":"| @property | resources () -> Resources Get resources.","title":"resources"},{"location":"aea/api/aea/#resources_1","text":"| @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources.","title":"resources"},{"location":"aea/api/aea/#filter","text":"| @property | filter () -> Filter Get the filter.","title":"filter"},{"location":"aea/api/aea/#active_behaviours","text":"| @property | active_behaviours () -> List [ Behaviour ] Get all active behaviours to use in act.","title":"active_behaviours"},{"location":"aea/api/aea/#setup","text":"| setup () -> None Set up the agent. Performs the following: loads the resources (unless in programmatic mode) calls setup() on the resources Returns : None","title":"setup"},{"location":"aea/api/aea/#act","text":"| act () -> None Perform actions. Calls act() of each active behaviour. Returns : None","title":"act"},{"location":"aea/api/aea/#active_connections","text":"| @property | active_connections () -> List [ Connection ] Return list of active connections.","title":"active_connections"},{"location":"aea/api/aea/#get_multiplexer_setup_options","text":"| get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs","title":"get_multiplexer_setup_options"},{"location":"aea/api/aea/#handle_envelope","text":"| handle_envelope ( envelope : Envelope ) -> None Handle an envelope. fetching the protocol referenced by the envelope, and returning an envelope to sender if the protocol is unsupported, using the error handler, or returning an envelope to sender if there is a decoding error, using the error handler, or returning an envelope to sender if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"aea/api/aea/#get_periodic_tasks","text":"| get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/aea/#get_message_handlers","text":"| get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/aea/#exception_handler","text":"| exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"exception_handler"},{"location":"aea/api/aea/#teardown","text":"| teardown () -> None Tear down the agent. Performs the following: tears down the resources. Returns : None","title":"teardown"},{"location":"aea/api/aea/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id","title":"get_task_result"},{"location":"aea/api/aea/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the task manager. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"enqueue_task"},{"location":"aea/api/aea_builder/","text":"aea.aea _ builder This module contains utilities for building an AEA. _ DependenciesManager Objects class _DependenciesManager () Class to manage dependencies of agent packages. __ init __ | __init__ () Initialize the dependency graph. all _ dependencies | @property | all_dependencies () -> Set [ ComponentId ] Get all dependencies. dependencies _ highest _ version | @property | dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version. get _ components _ by _ type | get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type. protocols | @property | protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols. connections | @property | connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections. skills | @property | skills () -> Dict [ ComponentId , SkillConfig ] Get the skills. contracts | @property | contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts. add _ component | add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager.. Arguments : configuration : the component configuration to add. Returns : None remove _ component | remove_component ( component_id : ComponentId ) Remove a component. :return None Raises : ValueError : if some component depends on this package. pypi _ dependencies | @property | pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies install _ dependencies | install_dependencies () -> None Install extra dependencies for components. AEABuilder Objects class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ... first call my_aea_1 = builder.build() following agents will have different components. my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code first call my_aea_1 = builder.build() second call to build() would raise a Value Error. call reset builder.reset() re-add the component and private keys builder.add_component_instance(...) ... # add private keys second call my_aea_2 = builder.builder() __ init __ | __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) Initialize the builder. Arguments : with_default_packages : add the default packages. reset | reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not. Returns : None set _ period | set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self set _ execution _ timeout | set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self set _ max _ reactions | set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self set _ decision _ maker _ handler | set_decision_maker_handler ( decision_maker_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set decision maker handler class. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler Returns : self set _ error _ handler | set_error_handler ( error_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set error handler class. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler Returns : self set _ skill _ exception _ policy | set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self set _ connection _ exception _ policy | set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self set _ default _ routing | set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self set _ loop _ mode | set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self set _ runtime _ mode | set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self set _ storage _ uri | set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. :param storage uri: storage uri Returns : self set _ logging _ config | set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self set _ search _ service _ address | set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self set _ name | set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder set _ default _ connection | set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder add _ private _ key | add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder remove _ private _ key | remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder private _ key _ paths | @property | private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths. connection _ private _ key _ paths | @property | connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths. set _ default _ ledger | set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder set _ build _ entrypoint | set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder set _ currency _ denominations | set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denomincations. Arguments : currency_denominations : the mapping Returns : the AEABuilder add _ component | add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. | or if there's a missing dependency. Returns : the AEABuilder add _ component _ instance | add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. :params component: Component instance already initialized. set _ context _ namespace | set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace. remove _ component | remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder add _ protocol | add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder remove _ protocol | remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder add _ connection | add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder remove _ connection | remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder add _ skill | add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder remove _ skill | remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder add _ contract | add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder remove _ contract | remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder call _ all _ build _ entrypoints | call_all_build_entrypoints () Call all the build entrypoints. get _ build _ root _ directory | get_build_root_directory () -> str Get build directory root. run _ build _ for _ component _ configuration | @classmethod | run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration. install _ pypi _ dependencies | install_pypi_dependencies () -> None Install components extra dependecies. build | build ( connection_ids : Optional [ Collection [ PublicId ]] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. Returns : the AEA object. Raises : ValueError : if we cannot get _ default _ ledger | get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier. try _ to _ load _ agent _ configuration _ file | @classmethod | try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ]) -> AgentConfig Try to load the agent configuration file.. set _ from _ configuration | set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. :params agent_configuration: AgentConfig to get values from. :params aea_project_path: PathLike root directory of the agent project. Arguments : skip_consistency_check : if True, the consistency check are skipped. Returns : None from _ aea _ project | @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , create_keys : bool = True ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. create_keys : if True, create keys, otherwise just verify Returns : an AEABuilder. get _ configuration _ file _ path | @staticmethod | get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path. make _ component _ logger make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"AEA Builder"},{"location":"aea/api/aea_builder/#aeaaea_builder","text":"This module contains utilities for building an AEA.","title":"aea.aea_builder"},{"location":"aea/api/aea_builder/#_dependenciesmanager-objects","text":"class _DependenciesManager () Class to manage dependencies of agent packages.","title":"_DependenciesManager Objects"},{"location":"aea/api/aea_builder/#__init__","text":"| __init__ () Initialize the dependency graph.","title":"__init__"},{"location":"aea/api/aea_builder/#all_dependencies","text":"| @property | all_dependencies () -> Set [ ComponentId ] Get all dependencies.","title":"all_dependencies"},{"location":"aea/api/aea_builder/#dependencies_highest_version","text":"| @property | dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version.","title":"dependencies_highest_version"},{"location":"aea/api/aea_builder/#get_components_by_type","text":"| get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type.","title":"get_components_by_type"},{"location":"aea/api/aea_builder/#protocols","text":"| @property | protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols.","title":"protocols"},{"location":"aea/api/aea_builder/#connections","text":"| @property | connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections.","title":"connections"},{"location":"aea/api/aea_builder/#skills","text":"| @property | skills () -> Dict [ ComponentId , SkillConfig ] Get the skills.","title":"skills"},{"location":"aea/api/aea_builder/#contracts","text":"| @property | contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts.","title":"contracts"},{"location":"aea/api/aea_builder/#add_component","text":"| add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager.. Arguments : configuration : the component configuration to add. Returns : None","title":"add_component"},{"location":"aea/api/aea_builder/#remove_component","text":"| remove_component ( component_id : ComponentId ) Remove a component. :return None Raises : ValueError : if some component depends on this package.","title":"remove_component"},{"location":"aea/api/aea_builder/#pypi_dependencies","text":"| @property | pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies","title":"pypi_dependencies"},{"location":"aea/api/aea_builder/#install_dependencies","text":"| install_dependencies () -> None Install extra dependencies for components.","title":"install_dependencies"},{"location":"aea/api/aea_builder/#aeabuilder-objects","text":"class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ...","title":"AEABuilder Objects"},{"location":"aea/api/aea_builder/#first-call","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"aea/api/aea_builder/#following-agents-will-have-different-components","text":"my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code","title":"following agents will have different components."},{"location":"aea/api/aea_builder/#first-call_1","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"aea/api/aea_builder/#second-call-to-build-would-raise-a-value-error","text":"","title":"second call to build() would raise a Value Error."},{"location":"aea/api/aea_builder/#call-reset","text":"builder.reset()","title":"call reset"},{"location":"aea/api/aea_builder/#re-add-the-component-and-private-keys","text":"builder.add_component_instance(...) ... # add private keys","title":"re-add the component and private keys"},{"location":"aea/api/aea_builder/#second-call","text":"my_aea_2 = builder.builder()","title":"second call"},{"location":"aea/api/aea_builder/#__init___1","text":"| __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) Initialize the builder. Arguments : with_default_packages : add the default packages.","title":"__init__"},{"location":"aea/api/aea_builder/#reset","text":"| reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not. Returns : None","title":"reset"},{"location":"aea/api/aea_builder/#set_period","text":"| set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self","title":"set_period"},{"location":"aea/api/aea_builder/#set_execution_timeout","text":"| set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self","title":"set_execution_timeout"},{"location":"aea/api/aea_builder/#set_max_reactions","text":"| set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self","title":"set_max_reactions"},{"location":"aea/api/aea_builder/#set_decision_maker_handler","text":"| set_decision_maker_handler ( decision_maker_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set decision maker handler class. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler Returns : self","title":"set_decision_maker_handler"},{"location":"aea/api/aea_builder/#set_error_handler","text":"| set_error_handler ( error_handler_dotted_path : str , file_path : Path ) -> \"AEABuilder\" Set error handler class. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler Returns : self","title":"set_error_handler"},{"location":"aea/api/aea_builder/#set_skill_exception_policy","text":"| set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self","title":"set_skill_exception_policy"},{"location":"aea/api/aea_builder/#set_connection_exception_policy","text":"| set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self","title":"set_connection_exception_policy"},{"location":"aea/api/aea_builder/#set_default_routing","text":"| set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self","title":"set_default_routing"},{"location":"aea/api/aea_builder/#set_loop_mode","text":"| set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self","title":"set_loop_mode"},{"location":"aea/api/aea_builder/#set_runtime_mode","text":"| set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self","title":"set_runtime_mode"},{"location":"aea/api/aea_builder/#set_storage_uri","text":"| set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. :param storage uri: storage uri Returns : self","title":"set_storage_uri"},{"location":"aea/api/aea_builder/#set_logging_config","text":"| set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self","title":"set_logging_config"},{"location":"aea/api/aea_builder/#set_search_service_address","text":"| set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self","title":"set_search_service_address"},{"location":"aea/api/aea_builder/#set_name","text":"| set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder","title":"set_name"},{"location":"aea/api/aea_builder/#set_default_connection","text":"| set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder","title":"set_default_connection"},{"location":"aea/api/aea_builder/#add_private_key","text":"| add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"add_private_key"},{"location":"aea/api/aea_builder/#remove_private_key","text":"| remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"remove_private_key"},{"location":"aea/api/aea_builder/#private_key_paths","text":"| @property | private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths.","title":"private_key_paths"},{"location":"aea/api/aea_builder/#connection_private_key_paths","text":"| @property | connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths.","title":"connection_private_key_paths"},{"location":"aea/api/aea_builder/#set_default_ledger","text":"| set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder","title":"set_default_ledger"},{"location":"aea/api/aea_builder/#set_build_entrypoint","text":"| set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder","title":"set_build_entrypoint"},{"location":"aea/api/aea_builder/#set_currency_denominations","text":"| set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denomincations. Arguments : currency_denominations : the mapping Returns : the AEABuilder","title":"set_currency_denominations"},{"location":"aea/api/aea_builder/#add_component_1","text":"| add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. | or if there's a missing dependency. Returns : the AEABuilder","title":"add_component"},{"location":"aea/api/aea_builder/#add_component_instance","text":"| add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. :params component: Component instance already initialized.","title":"add_component_instance"},{"location":"aea/api/aea_builder/#set_context_namespace","text":"| set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace.","title":"set_context_namespace"},{"location":"aea/api/aea_builder/#remove_component_1","text":"| remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder","title":"remove_component"},{"location":"aea/api/aea_builder/#add_protocol","text":"| add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder","title":"add_protocol"},{"location":"aea/api/aea_builder/#remove_protocol","text":"| remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder","title":"remove_protocol"},{"location":"aea/api/aea_builder/#add_connection","text":"| add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder","title":"add_connection"},{"location":"aea/api/aea_builder/#remove_connection","text":"| remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder","title":"remove_connection"},{"location":"aea/api/aea_builder/#add_skill","text":"| add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder","title":"add_skill"},{"location":"aea/api/aea_builder/#remove_skill","text":"| remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder","title":"remove_skill"},{"location":"aea/api/aea_builder/#add_contract","text":"| add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder","title":"add_contract"},{"location":"aea/api/aea_builder/#remove_contract","text":"| remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder","title":"remove_contract"},{"location":"aea/api/aea_builder/#call_all_build_entrypoints","text":"| call_all_build_entrypoints () Call all the build entrypoints.","title":"call_all_build_entrypoints"},{"location":"aea/api/aea_builder/#get_build_root_directory","text":"| get_build_root_directory () -> str Get build directory root.","title":"get_build_root_directory"},{"location":"aea/api/aea_builder/#run_build_for_component_configuration","text":"| @classmethod | run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration.","title":"run_build_for_component_configuration"},{"location":"aea/api/aea_builder/#install_pypi_dependencies","text":"| install_pypi_dependencies () -> None Install components extra dependecies.","title":"install_pypi_dependencies"},{"location":"aea/api/aea_builder/#build","text":"| build ( connection_ids : Optional [ Collection [ PublicId ]] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. Returns : the AEA object. Raises : ValueError : if we cannot","title":"build"},{"location":"aea/api/aea_builder/#get_default_ledger","text":"| get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier.","title":"get_default_ledger"},{"location":"aea/api/aea_builder/#try_to_load_agent_configuration_file","text":"| @classmethod | try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ]) -> AgentConfig Try to load the agent configuration file..","title":"try_to_load_agent_configuration_file"},{"location":"aea/api/aea_builder/#set_from_configuration","text":"| set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. :params agent_configuration: AgentConfig to get values from. :params aea_project_path: PathLike root directory of the agent project. Arguments : skip_consistency_check : if True, the consistency check are skipped. Returns : None","title":"set_from_configuration"},{"location":"aea/api/aea_builder/#from_aea_project","text":"| @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , create_keys : bool = True ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. create_keys : if True, create keys, otherwise just verify Returns : an AEABuilder.","title":"from_aea_project"},{"location":"aea/api/aea_builder/#get_configuration_file_path","text":"| @staticmethod | get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path.","title":"get_configuration_file_path"},{"location":"aea/api/aea_builder/#make_component_logger","text":"make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"make_component_logger"},{"location":"aea/api/agent/","text":"aea.agent This module contains the implementation of a generic agent. Agent Objects class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage Returns : None connections | @property | connections () -> List [ Connection ] Return list of connections. storage _ uri | @property | storage_uri () -> Optional [ str ] Return storage uri. active _ connections | @property | active_connections () -> List [ Connection ] Return list of active connections. is _ running | @property | is_running () -> bool Get running state of the runtime and agent. is _ stopped | @property | is_stopped () -> bool Get running state of the runtime and agent. get _ multiplexer _ setup _ options | get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs identity | @property | identity () -> Identity Get the identity. inbox | @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. outbox | @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. name | @property | name () -> str Get the agent name. tick | @property | tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick. handle _ envelope | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None period | @property | period () -> float Get a period to call act. runtime | @property | runtime () -> BaseRuntime Get the runtime. start | start () -> None Start the agent. Performs the following: calls connect() on the multiplexer (unless in debug mode), and calls setup(), and calls start() on the liveness, and enters the agent main loop. While the liveness of the agent is not stopped it continues to loop over: increment the tick, call to act(), sleep for specified timeout, call to react(), call to update(). Returns : None stop | stop () -> None Stop the agent. Performs the following: calls stop() on the liveness, and calls teardown(), and calls disconnect() on the multiplexer. Returns : None state | @property | state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates get _ periodic _ tasks | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler | exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"Agent"},{"location":"aea/api/agent/#aeaagent","text":"This module contains the implementation of a generic agent.","title":"aea.agent"},{"location":"aea/api/agent/#agent-objects","text":"class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent.","title":"Agent Objects"},{"location":"aea/api/agent/#__init__","text":"| __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage Returns : None","title":"__init__"},{"location":"aea/api/agent/#connections","text":"| @property | connections () -> List [ Connection ] Return list of connections.","title":"connections"},{"location":"aea/api/agent/#storage_uri","text":"| @property | storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"aea/api/agent/#active_connections","text":"| @property | active_connections () -> List [ Connection ] Return list of active connections.","title":"active_connections"},{"location":"aea/api/agent/#is_running","text":"| @property | is_running () -> bool Get running state of the runtime and agent.","title":"is_running"},{"location":"aea/api/agent/#is_stopped","text":"| @property | is_stopped () -> bool Get running state of the runtime and agent.","title":"is_stopped"},{"location":"aea/api/agent/#get_multiplexer_setup_options","text":"| get_multiplexer_setup_options () -> Optional [ Dict ] Get options to pass to Multiplexer.setup. Returns : dict of kwargs","title":"get_multiplexer_setup_options"},{"location":"aea/api/agent/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/agent/#inbox","text":"| @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing.","title":"inbox"},{"location":"aea/api/agent/#outbox","text":"| @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer.","title":"outbox"},{"location":"aea/api/agent/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/agent/#tick","text":"| @property | tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick.","title":"tick"},{"location":"aea/api/agent/#handle_envelope","text":"| handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"aea/api/agent/#period","text":"| @property | period () -> float Get a period to call act.","title":"period"},{"location":"aea/api/agent/#runtime","text":"| @property | runtime () -> BaseRuntime Get the runtime.","title":"runtime"},{"location":"aea/api/agent/#start","text":"| start () -> None Start the agent. Performs the following: calls connect() on the multiplexer (unless in debug mode), and calls setup(), and calls start() on the liveness, and enters the agent main loop. While the liveness of the agent is not stopped it continues to loop over: increment the tick, call to act(), sleep for specified timeout, call to react(), call to update(). Returns : None","title":"start"},{"location":"aea/api/agent/#stop","text":"| stop () -> None Stop the agent. Performs the following: calls stop() on the liveness, and calls teardown(), and calls disconnect() on the multiplexer. Returns : None","title":"stop"},{"location":"aea/api/agent/#state","text":"| @property | state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates","title":"state"},{"location":"aea/api/agent/#get_periodic_tasks","text":"| get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/agent/#get_message_handlers","text":"| get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/agent/#exception_handler","text":"| exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"exception_handler"},{"location":"aea/api/agent_loop/","text":"aea.agent _ loop This module contains the implementation of an agent loop using asyncio. AgentLoopException Objects class AgentLoopException ( AEAException ) Exception for agent loop runtime errors. AgentLoopStates Objects class AgentLoopStates ( Enum ) Internal agent loop states. BaseAgentLoop Objects class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class. __ init __ | __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded = False ) -> None Init loop. :params agent: Agent or AEA to run. :params loop: optional asyncio event loop. if not specified a new loop will be created. agent | @property | agent () -> AbstractAgent Get agent. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects. run | async run () -> None Run agent loop. state | @property | state () -> AgentLoopStates Get current main loop state. is _ running | @property | is_running () -> bool Get running state of the loop. AsyncAgentLoop Objects class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA. __ init __ | __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded = False ) Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional","title":"Agent Loop"},{"location":"aea/api/agent_loop/#aeaagent_loop","text":"This module contains the implementation of an agent loop using asyncio.","title":"aea.agent_loop"},{"location":"aea/api/agent_loop/#agentloopexception-objects","text":"class AgentLoopException ( AEAException ) Exception for agent loop runtime errors.","title":"AgentLoopException Objects"},{"location":"aea/api/agent_loop/#agentloopstates-objects","text":"class AgentLoopStates ( Enum ) Internal agent loop states.","title":"AgentLoopStates Objects"},{"location":"aea/api/agent_loop/#baseagentloop-objects","text":"class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class.","title":"BaseAgentLoop Objects"},{"location":"aea/api/agent_loop/#__init__","text":"| __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded = False ) -> None Init loop. :params agent: Agent or AEA to run. :params loop: optional asyncio event loop. if not specified a new loop will be created.","title":"__init__"},{"location":"aea/api/agent_loop/#agent","text":"| @property | agent () -> AbstractAgent Get agent.","title":"agent"},{"location":"aea/api/agent_loop/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects.","title":"set_loop"},{"location":"aea/api/agent_loop/#run","text":"| async run () -> None Run agent loop.","title":"run"},{"location":"aea/api/agent_loop/#state","text":"| @property | state () -> AgentLoopStates Get current main loop state.","title":"state"},{"location":"aea/api/agent_loop/#is_running","text":"| @property | is_running () -> bool Get running state of the loop.","title":"is_running"},{"location":"aea/api/agent_loop/#asyncagentloop-objects","text":"class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA.","title":"AsyncAgentLoop Objects"},{"location":"aea/api/agent_loop/#__init___1","text":"| __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded = False ) Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional","title":"__init__"},{"location":"aea/api/common/","text":"aea.common This module contains the common types and interfaces used in the aea framework.","title":"Common"},{"location":"aea/api/common/#aeacommon","text":"This module contains the common types and interfaces used in the aea framework.","title":"aea.common"},{"location":"aea/api/exceptions/","text":"aea.exceptions Exceptions for the AEA package. AEAException Objects class AEAException ( Exception ) User-defined exception for the AEA framework. AEAPackageLoadingError Objects class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages. AEASetupError Objects class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages. AEATeardownError Objects class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages. AEAActException Objects class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages. AEAHandleException Objects class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages. AEAInstantiationException Objects class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages. AEAEnforceError Objects class AEAEnforceError ( AEAException ) Class for enforcement errors. AEAValidationError Objects class AEAValidationError ( AEAException ) Class for validation errors of an AEA. AEAComponentLoadException Objects class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA. _ StopRuntime Objects class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks. __ init __ | __init__ ( reraise : Optional [ Exception ] = None ) Init _StopRuntime exception. Arguments : reraise : exception to reraise. Returns : None enforce enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception parse _ exception parse_exception ( exception : Exception , limit =- 1 ) -> str Parse an exception to get the relevant lines. Arguments : limit : the limit Returns : exception as string","title":"Exceptions"},{"location":"aea/api/exceptions/#aeaexceptions","text":"Exceptions for the AEA package.","title":"aea.exceptions"},{"location":"aea/api/exceptions/#aeaexception-objects","text":"class AEAException ( Exception ) User-defined exception for the AEA framework.","title":"AEAException Objects"},{"location":"aea/api/exceptions/#aeapackageloadingerror-objects","text":"class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages.","title":"AEAPackageLoadingError Objects"},{"location":"aea/api/exceptions/#aeasetuperror-objects","text":"class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages.","title":"AEASetupError Objects"},{"location":"aea/api/exceptions/#aeateardownerror-objects","text":"class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages.","title":"AEATeardownError Objects"},{"location":"aea/api/exceptions/#aeaactexception-objects","text":"class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages.","title":"AEAActException Objects"},{"location":"aea/api/exceptions/#aeahandleexception-objects","text":"class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages.","title":"AEAHandleException Objects"},{"location":"aea/api/exceptions/#aeainstantiationexception-objects","text":"class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages.","title":"AEAInstantiationException Objects"},{"location":"aea/api/exceptions/#aeaenforceerror-objects","text":"class AEAEnforceError ( AEAException ) Class for enforcement errors.","title":"AEAEnforceError Objects"},{"location":"aea/api/exceptions/#aeavalidationerror-objects","text":"class AEAValidationError ( AEAException ) Class for validation errors of an AEA.","title":"AEAValidationError Objects"},{"location":"aea/api/exceptions/#aeacomponentloadexception-objects","text":"class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA.","title":"AEAComponentLoadException Objects"},{"location":"aea/api/exceptions/#_stopruntime-objects","text":"class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks.","title":"_StopRuntime Objects"},{"location":"aea/api/exceptions/#__init__","text":"| __init__ ( reraise : Optional [ Exception ] = None ) Init _StopRuntime exception. Arguments : reraise : exception to reraise. Returns : None","title":"__init__"},{"location":"aea/api/exceptions/#enforce","text":"enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception","title":"enforce"},{"location":"aea/api/exceptions/#parse_exception","text":"parse_exception ( exception : Exception , limit =- 1 ) -> str Parse an exception to get the relevant lines. Arguments : limit : the limit Returns : exception as string","title":"parse_exception"},{"location":"aea/api/launcher/","text":"aea.launcher This module contains the implementation of multiple AEA configs launcher. load _ agent load_agent ( agent_dir : Union [ PathLike , str ]) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory Returns : AEA instance AEADirTask Objects class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory. __ init __ | __init__ ( agent_dir : Union [ PathLike , str ]) -> None Init aea config dir task. Arguments : agent_dir : direcory with aea config. start | start () -> None Start task. stop | stop () Stop task. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. id | @property | id () -> Union [ PathLike , str ] Return agent_dir. AEADirMultiprocessTask Objects class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode. __ init __ | __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None ) Init aea config dir task. Arguments : agent_dir : direcory with aea config. log_level : debug level applied for AEA in subprocess start | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. stop | stop () Stop task. id | @property | id () -> Union [ PathLike , str ] Return agent_dir. failed | @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. :rerurn: bool AEALauncher Objects class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ | __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None ) -> None Init AEARunner. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses","title":"Launcher"},{"location":"aea/api/launcher/#aealauncher","text":"This module contains the implementation of multiple AEA configs launcher.","title":"aea.launcher"},{"location":"aea/api/launcher/#load_agent","text":"load_agent ( agent_dir : Union [ PathLike , str ]) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory Returns : AEA instance","title":"load_agent"},{"location":"aea/api/launcher/#aeadirtask-objects","text":"class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory.","title":"AEADirTask Objects"},{"location":"aea/api/launcher/#__init__","text":"| __init__ ( agent_dir : Union [ PathLike , str ]) -> None Init aea config dir task. Arguments : agent_dir : direcory with aea config.","title":"__init__"},{"location":"aea/api/launcher/#start","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/launcher/#stop","text":"| stop () Stop task.","title":"stop"},{"location":"aea/api/launcher/#create_async_task","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop.","title":"create_async_task"},{"location":"aea/api/launcher/#id","text":"| @property | id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"aea/api/launcher/#aeadirmultiprocesstask-objects","text":"class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode.","title":"AEADirMultiprocessTask Objects"},{"location":"aea/api/launcher/#__init___1","text":"| __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None ) Init aea config dir task. Arguments : agent_dir : direcory with aea config. log_level : debug level applied for AEA in subprocess","title":"__init__"},{"location":"aea/api/launcher/#start_1","text":"| start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"aea/api/launcher/#stop_1","text":"| stop () Stop task.","title":"stop"},{"location":"aea/api/launcher/#id_1","text":"| @property | id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"aea/api/launcher/#failed","text":"| @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. :rerurn: bool","title":"failed"},{"location":"aea/api/launcher/#aealauncher-objects","text":"class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEALauncher Objects"},{"location":"aea/api/launcher/#__init___2","text":"| __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None ) -> None Init AEARunner. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses","title":"__init__"},{"location":"aea/api/multiplexer/","text":"aea.multiplexer Module for the multiplexer class and related classes. MultiplexerStatus Objects class MultiplexerStatus ( AsyncState ) The connection status class. __ init __ | __init__ () Initialize the connection status. is _ connected | @property | is_connected () -> bool Return is connected. is _ connecting | @property | is_connecting () -> bool Return is connecting. is _ disconnected | @property | is_disconnected () -> bool Return is disconnected. is _ disconnecting | @property | is_disconnecting () -> bool Return is disconnected. AsyncMultiplexer Objects class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once. __ init __ | __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. agent_name : the name of the agent that owns the multiplexer, for logging purposes. run | async run () -> None Run multiplexer connect and recv/send tasks. default _ connection | @property | default_connection () -> Optional [ Connection ] Get the default connection. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects. Arguments : loop : asyncio event loop. Returns : None add _ connection | add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the mutliplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one. Returns : None in _ queue | @property | in_queue () -> AsyncFriendlyQueue Get the in queue. out _ queue | @property | out_queue () -> asyncio . Queue Get the out queue. connections | @property | connections () -> Tuple [ Connection , ... ] Get the connections. is _ connected | @property | is_connected () -> bool Check whether the multiplexer is processing envelopes. default _ routing | @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. default _ routing | @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) Set the default routing. connection _ status | @property | connection_status () -> MultiplexerStatus Get the connection status. connect | async connect () -> None Connect the multiplexer. disconnect | async disconnect () -> None Disconnect the multiplexer. get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout. async _ get | async async_get () -> Envelope Get an envelope async way. Returns : the envelope async _ wait | async async_wait () -> None Get an envelope async way. Returns : the envelope put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None setup | setup ( connections : Collection [ Connection ], default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None ) -> None Set up the multiplexer. Arguments : connections : the connections to use. It will replace the other ones. default_routing : the default routing. default_connection : the default connection. Returns : None. Multiplexer Objects class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility. __ init __ | __init__ ( * args , ** kwargs ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects. Arguments : loop : asyncio event loop. Returns : None connect | connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created. disconnect | disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect. put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None InBox Objects class InBox () A queue from where you can only consume envelopes. __ init __ | __init__ ( multiplexer : AsyncMultiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails. get _ nowait | get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object async _ get | async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object. async _ wait | async async_wait () -> None Check for a envelope on the in queue. Returns : the envelope object. OutBox Objects class OutBox () A queue from where you can only enqueue envelopes. __ init __ | __init__ ( multiplexer : AsyncMultiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not put | put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None put _ message | put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context Returns : None","title":"Multiplexer"},{"location":"aea/api/multiplexer/#aeamultiplexer","text":"Module for the multiplexer class and related classes.","title":"aea.multiplexer"},{"location":"aea/api/multiplexer/#multiplexerstatus-objects","text":"class MultiplexerStatus ( AsyncState ) The connection status class.","title":"MultiplexerStatus Objects"},{"location":"aea/api/multiplexer/#__init__","text":"| __init__ () Initialize the connection status.","title":"__init__"},{"location":"aea/api/multiplexer/#is_connected","text":"| @property | is_connected () -> bool Return is connected.","title":"is_connected"},{"location":"aea/api/multiplexer/#is_connecting","text":"| @property | is_connecting () -> bool Return is connecting.","title":"is_connecting"},{"location":"aea/api/multiplexer/#is_disconnected","text":"| @property | is_disconnected () -> bool Return is disconnected.","title":"is_disconnected"},{"location":"aea/api/multiplexer/#is_disconnecting","text":"| @property | is_disconnecting () -> bool Return is disconnected.","title":"is_disconnecting"},{"location":"aea/api/multiplexer/#asyncmultiplexer-objects","text":"class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once.","title":"AsyncMultiplexer Objects"},{"location":"aea/api/multiplexer/#__init___1","text":"| __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. agent_name : the name of the agent that owns the multiplexer, for logging purposes.","title":"__init__"},{"location":"aea/api/multiplexer/#run","text":"| async run () -> None Run multiplexer connect and recv/send tasks.","title":"run"},{"location":"aea/api/multiplexer/#default_connection","text":"| @property | default_connection () -> Optional [ Connection ] Get the default connection.","title":"default_connection"},{"location":"aea/api/multiplexer/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects. Arguments : loop : asyncio event loop. Returns : None","title":"set_loop"},{"location":"aea/api/multiplexer/#add_connection","text":"| add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the mutliplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one. Returns : None","title":"add_connection"},{"location":"aea/api/multiplexer/#in_queue","text":"| @property | in_queue () -> AsyncFriendlyQueue Get the in queue.","title":"in_queue"},{"location":"aea/api/multiplexer/#out_queue","text":"| @property | out_queue () -> asyncio . Queue Get the out queue.","title":"out_queue"},{"location":"aea/api/multiplexer/#connections","text":"| @property | connections () -> Tuple [ Connection , ... ] Get the connections.","title":"connections"},{"location":"aea/api/multiplexer/#is_connected_1","text":"| @property | is_connected () -> bool Check whether the multiplexer is processing envelopes.","title":"is_connected"},{"location":"aea/api/multiplexer/#default_routing","text":"| @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"aea/api/multiplexer/#default_routing_1","text":"| @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) Set the default routing.","title":"default_routing"},{"location":"aea/api/multiplexer/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/multiplexer/#connect","text":"| async connect () -> None Connect the multiplexer.","title":"connect"},{"location":"aea/api/multiplexer/#disconnect","text":"| async disconnect () -> None Disconnect the multiplexer.","title":"disconnect"},{"location":"aea/api/multiplexer/#get","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout.","title":"get"},{"location":"aea/api/multiplexer/#async_get","text":"| async async_get () -> Envelope Get an envelope async way. Returns : the envelope","title":"async_get"},{"location":"aea/api/multiplexer/#async_wait","text":"| async async_wait () -> None Get an envelope async way. Returns : the envelope","title":"async_wait"},{"location":"aea/api/multiplexer/#put","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None","title":"put"},{"location":"aea/api/multiplexer/#setup","text":"| setup ( connections : Collection [ Connection ], default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None ) -> None Set up the multiplexer. Arguments : connections : the connections to use. It will replace the other ones. default_routing : the default routing. default_connection : the default connection. Returns : None.","title":"setup"},{"location":"aea/api/multiplexer/#multiplexer-objects","text":"class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility.","title":"Multiplexer Objects"},{"location":"aea/api/multiplexer/#__init___2","text":"| __init__ ( * args , ** kwargs ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created.","title":"__init__"},{"location":"aea/api/multiplexer/#set_loop_1","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loopp related objects. Arguments : loop : asyncio event loop. Returns : None","title":"set_loop"},{"location":"aea/api/multiplexer/#connect_1","text":"| connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created.","title":"connect"},{"location":"aea/api/multiplexer/#disconnect_1","text":"| disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect.","title":"disconnect"},{"location":"aea/api/multiplexer/#put_1","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None","title":"put"},{"location":"aea/api/multiplexer/#inbox-objects","text":"class InBox () A queue from where you can only consume envelopes.","title":"InBox Objects"},{"location":"aea/api/multiplexer/#__init___3","text":"| __init__ ( multiplexer : AsyncMultiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/multiplexer/#empty","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/multiplexer/#get_1","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails.","title":"get"},{"location":"aea/api/multiplexer/#get_nowait","text":"| get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object","title":"get_nowait"},{"location":"aea/api/multiplexer/#async_get_1","text":"| async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object.","title":"async_get"},{"location":"aea/api/multiplexer/#async_wait_1","text":"| async async_wait () -> None Check for a envelope on the in queue. Returns : the envelope object.","title":"async_wait"},{"location":"aea/api/multiplexer/#outbox-objects","text":"class OutBox () A queue from where you can only enqueue envelopes.","title":"OutBox Objects"},{"location":"aea/api/multiplexer/#__init___4","text":"| __init__ ( multiplexer : AsyncMultiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/multiplexer/#empty_1","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/multiplexer/#put_2","text":"| put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None","title":"put"},{"location":"aea/api/multiplexer/#put_message","text":"| put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context Returns : None","title":"put_message"},{"location":"aea/api/runner/","text":"aea.runner This module contains the implementation of AEA multiple instances runner. AEAInstanceTask Objects class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance. __ init __ | __init__ ( agent : AEA ) Init aea instance task. Arguments : agent : AEA instance to run within task. start | start () -> None Start task. stop | stop () -> None Stop task. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime id | @property | id () Return agent name. AEARunner Objects class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ | __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"Runner"},{"location":"aea/api/runner/#aearunner","text":"This module contains the implementation of AEA multiple instances runner.","title":"aea.runner"},{"location":"aea/api/runner/#aeainstancetask-objects","text":"class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance.","title":"AEAInstanceTask Objects"},{"location":"aea/api/runner/#__init__","text":"| __init__ ( agent : AEA ) Init aea instance task. Arguments : agent : AEA instance to run within task.","title":"__init__"},{"location":"aea/api/runner/#start","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/runner/#stop","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/runner/#create_async_task","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime","title":"create_async_task"},{"location":"aea/api/runner/#id","text":"| @property | id () Return agent name.","title":"id"},{"location":"aea/api/runner/#aearunner-objects","text":"class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEARunner Objects"},{"location":"aea/api/runner/#__init___1","text":"| __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"aea/api/runtime/","text":"aea.runtime This module contains the implementation of runtime for economic agent (AEA). RuntimeStates Objects class RuntimeStates ( Enum ) Runtime states. BaseRuntime Objects class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations. __ init __ | __init__ ( agent : AbstractAgent , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init runtime. Arguments : agent : Agent to run. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. Returns : None storage | @property | storage () -> Optional [ Storage ] Get optional storage. loop _ mode | @property | loop_mode () -> str Get current loop mode. setup _ multiplexer | setup_multiplexer () -> None Set up the multiplexer. task _ manager | @property | task_manager () -> TaskManager Get the task manager. loop | @property | loop () -> Optional [ AbstractEventLoop ] Get event loop. multiplexer | @property | multiplexer () -> AsyncMultiplexer Get multiplexer. decision _ maker | @property | decision_maker () -> DecisionMaker Return decision maker if set. set _ decision _ maker | set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided. is _ running | @property | is_running () -> bool Get running state of the runtime. is _ stopped | @property | is_stopped () -> bool Get stopped state of the runtime. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. state | @property | state () -> RuntimeStates Get runtime state. Returns : RuntimeStates AsyncRuntime Objects class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop. __ init __ | __init__ ( agent : AbstractAgent , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded = False ) -> None Init runtime. Arguments : agent : Agent to run. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. Returns : None set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. run | async run () -> None Start runtime task. Starts multiplexer and agent loop. stop _ runtime | async stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer. run _ runtime | async run_runtime () -> None Run agent and starts multiplexer. ThreadedRuntime Objects class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"Runtime"},{"location":"aea/api/runtime/#aearuntime","text":"This module contains the implementation of runtime for economic agent (AEA).","title":"aea.runtime"},{"location":"aea/api/runtime/#runtimestates-objects","text":"class RuntimeStates ( Enum ) Runtime states.","title":"RuntimeStates Objects"},{"location":"aea/api/runtime/#baseruntime-objects","text":"class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations.","title":"BaseRuntime Objects"},{"location":"aea/api/runtime/#__init__","text":"| __init__ ( agent : AbstractAgent , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init runtime. Arguments : agent : Agent to run. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. Returns : None","title":"__init__"},{"location":"aea/api/runtime/#storage","text":"| @property | storage () -> Optional [ Storage ] Get optional storage.","title":"storage"},{"location":"aea/api/runtime/#loop_mode","text":"| @property | loop_mode () -> str Get current loop mode.","title":"loop_mode"},{"location":"aea/api/runtime/#setup_multiplexer","text":"| setup_multiplexer () -> None Set up the multiplexer.","title":"setup_multiplexer"},{"location":"aea/api/runtime/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/runtime/#loop","text":"| @property | loop () -> Optional [ AbstractEventLoop ] Get event loop.","title":"loop"},{"location":"aea/api/runtime/#multiplexer","text":"| @property | multiplexer () -> AsyncMultiplexer Get multiplexer.","title":"multiplexer"},{"location":"aea/api/runtime/#decision_maker","text":"| @property | decision_maker () -> DecisionMaker Return decision maker if set.","title":"decision_maker"},{"location":"aea/api/runtime/#set_decision_maker","text":"| set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided.","title":"set_decision_maker"},{"location":"aea/api/runtime/#is_running","text":"| @property | is_running () -> bool Get running state of the runtime.","title":"is_running"},{"location":"aea/api/runtime/#is_stopped","text":"| @property | is_stopped () -> bool Get stopped state of the runtime.","title":"is_stopped"},{"location":"aea/api/runtime/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"aea/api/runtime/#state","text":"| @property | state () -> RuntimeStates Get runtime state. Returns : RuntimeStates","title":"state"},{"location":"aea/api/runtime/#asyncruntime-objects","text":"class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop.","title":"AsyncRuntime Objects"},{"location":"aea/api/runtime/#__init___1","text":"| __init__ ( agent : AbstractAgent , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded = False ) -> None Init runtime. Arguments : agent : Agent to run. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. Returns : None","title":"__init__"},{"location":"aea/api/runtime/#set_loop_1","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"aea/api/runtime/#run","text":"| async run () -> None Start runtime task. Starts multiplexer and agent loop.","title":"run"},{"location":"aea/api/runtime/#stop_runtime","text":"| async stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer.","title":"stop_runtime"},{"location":"aea/api/runtime/#run_runtime","text":"| async run_runtime () -> None Run agent and starts multiplexer.","title":"run_runtime"},{"location":"aea/api/runtime/#threadedruntime-objects","text":"class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"ThreadedRuntime Objects"},{"location":"aea/api/components/base/","text":"aea.components.base This module contains definitions of agent components. Component Objects class Component ( ABC , WithLogger ) Abstract class for an agent component. __ init __ | __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False , ** kwargs , ,) Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized. component _ type | @property | component_type () -> ComponentType Get the component type. is _ vendor | @property | is_vendor () -> bool Get whether the component is vendorized or not. prefix _ import _ path | @property | prefix_import_path () Get the prefix import path for this component. component _ id | @property | component_id () -> ComponentId Ge the package id. public _ id | @property | public_id () -> PublicId Get the public id. configuration | @property | configuration () -> ComponentConfiguration Get the component configuration. directory | @property | directory () -> Path Get the directory. Raise error if it has not been set yet. directory | @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set. build _ directory | @property | build_directory () -> Optional [ str ] Get build directory for the component. load _ aea _ package load_aea_package ( configuration : ComponentConfiguration ) -> None Load the AEA package. It adds all the init .py modules into sys.modules . Arguments : configuration : the configuration object. Returns : None","title":"Base"},{"location":"aea/api/components/base/#aeacomponentsbase","text":"This module contains definitions of agent components.","title":"aea.components.base"},{"location":"aea/api/components/base/#component-objects","text":"class Component ( ABC , WithLogger ) Abstract class for an agent component.","title":"Component Objects"},{"location":"aea/api/components/base/#__init__","text":"| __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False , ** kwargs , ,) Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized.","title":"__init__"},{"location":"aea/api/components/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/components/base/#is_vendor","text":"| @property | is_vendor () -> bool Get whether the component is vendorized or not.","title":"is_vendor"},{"location":"aea/api/components/base/#prefix_import_path","text":"| @property | prefix_import_path () Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/components/base/#component_id","text":"| @property | component_id () -> ComponentId Ge the package id.","title":"component_id"},{"location":"aea/api/components/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/components/base/#configuration","text":"| @property | configuration () -> ComponentConfiguration Get the component configuration.","title":"configuration"},{"location":"aea/api/components/base/#directory","text":"| @property | directory () -> Path Get the directory. Raise error if it has not been set yet.","title":"directory"},{"location":"aea/api/components/base/#directory_1","text":"| @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set.","title":"directory"},{"location":"aea/api/components/base/#build_directory","text":"| @property | build_directory () -> Optional [ str ] Get build directory for the component.","title":"build_directory"},{"location":"aea/api/components/base/#load_aea_package","text":"load_aea_package ( configuration : ComponentConfiguration ) -> None Load the AEA package. It adds all the init .py modules into sys.modules . Arguments : configuration : the configuration object. Returns : None","title":"load_aea_package"},{"location":"aea/api/components/loader/","text":"aea.components.loader This module contains utilities for loading components. component _ type _ to _ class component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class load _ component _ from _ config load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. Returns : the component instance.","title":"Loader"},{"location":"aea/api/components/loader/#aeacomponentsloader","text":"This module contains utilities for loading components.","title":"aea.components.loader"},{"location":"aea/api/components/loader/#component_type_to_class","text":"component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class","title":"component_type_to_class"},{"location":"aea/api/components/loader/#load_component_from_config","text":"load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. Returns : the component instance.","title":"load_component_from_config"},{"location":"aea/api/configurations/base/","text":"aea.configurations.base Classes to handle AEA configurations. dependencies _ from _ json dependencies_from_json ( obj : Dict [ str , Dict ]) -> Dependencies Parse a JSON object to get an instance of Dependencies. Arguments : obj : a dictionary whose keys are package names and values are dictionary with package specifications. Returns : a Dependencies object. dependencies _ to _ json dependencies_to_json ( dependencies : Dependencies ) -> Dict [ str , Dict ] Transform a Dependencies object into a JSON object. Arguments : dependencies : an instance of \"Dependencies\" type. Returns : a dictionary whose keys are package names and values are the JSON version of a Dependency object. ProtocolSpecificationParseError Objects class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file. Configuration Objects class Configuration ( JSONSerializable , ABC ) Configuration class. __ init __ | __init__ () Initialize a configuration object. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object. ordered _ json | @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary. PackageConfiguration Objects class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None ) Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license_ : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint. build_entrypoint : path to a script to execute at build time. name | @property | name () -> str Get the name. name | @name . setter | name ( value : SimpleIdOrStr ) Set the name. author | @property | author () -> str Get the author. author | @author . setter | author ( value : SimpleIdOrStr ) Set the author. aea _ version | @property | aea_version () Get the 'aea_version' attribute. aea _ version | @aea_version . setter | aea_version ( new_aea_version : str ) Set the 'aea_version' attribute. directory | @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any. directory | @directory . setter | directory ( directory : Path ) -> None Set directory if not already set. package _ id | @property | package_id () -> PackageId Get package id. aea _ version _ specifiers | @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier. public _ id | @property | public_id () -> PublicId Get the public id. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. update | update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. Arguments : data : the data to replace. Returns : None validate _ config _ data | @classmethod | validate_config_data ( cls , json_data : Dict , env_vars_friendly : bool = False ) -> None Perform config validation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. make _ resulting _ config _ data | make_resulting_config_data ( overrides : Dict ) -> Dict Make config data with overrides applied. Does not update config, just creates json representation check _ overrides _ valid | check_overrides_valid ( overrides : Dict , env_vars_friendly : bool = False ) -> None Check overrides is correct, return list of errors if present. get _ overridable | get_overridable () -> dict Get dictionary of values that can be updated for this config. ComponentConfiguration Objects class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None ) Set component configuration. build _ directory | @property | build_directory () -> Optional [ str ] Get the component type. build _ directory | @build_directory . setter | build_directory ( value : Optional [ str ]) -> None Get the component type. component _ type | @property | component_type () -> ComponentType Get the component type. component _ id | @property | component_id () -> ComponentId Get the component id. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. check _ fingerprint | check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. :raises ValueError if: - the argument is not a valid package directory - the fingerprints do not match. check _ aea _ version | check_aea_version () Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier. check _ public _ id _ consistency | check_public_id_consistency ( directory : Path ) -> None Check that the public ids in the init file match the config. :raises ValueError if: - the argument is not a valid package directory - the public ids do not match. ConnectionConfig Objects class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration. __ init __ | __init__ ( name : SimpleIdOrStr = \"\" , author : SimpleIdOrStr = \"\" , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , connections : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , connection_id : Optional [ PublicId ] = None , is_abstract : bool = False , cert_requests : Optional [ List [ CertRequest ]] = None , ** config , ,) Initialize a connection configuration object. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. json | @property | json () -> Dict Return the JSON representation. ProtocolConfig Objects class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object. json | @property | json () -> Dict Return the JSON representation. SkillComponentConfiguration Objects class SkillComponentConfiguration () This class represent a skill component configuration. __ init __ | __init__ ( class_name : str , ** args ) Initialize a skill component configuration. Arguments : skill_component_type : the skill component type. class_name : the class name of the component. args : keyword arguments. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"SkillComponentConfiguration\" Initialize from a JSON object. SkillConfig Objects class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , connections : Optional [ Set [ PublicId ]] = None , protocols : Optional [ Set [ PublicId ]] = None , contracts : Optional [ Set [ PublicId ]] = None , skills : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , is_abstract : bool = False ) Initialize a skill configuration. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the skill dependencies. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. json | @property | json () -> Dict Return the JSON representation. get _ overridable | get_overridable () -> dict Get overrideable confg data. AgentConfig Objects class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file. __ init __ | __init__ ( agent_name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , registry_path : str = DEFAULT_REGISTRY_NAME , description : str = \"\" , logging_config : Optional [ Dict ] = None , period : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , error_handler : Optional [ Dict ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , connection_exception_policy : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ str ] = None , default_routing : Optional [ Dict [ str , str ]] = None , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , component_configurations : Optional [ Dict [ ComponentId , Dict ]] = None ) Instantiate the agent configuration object. component _ configurations | @property | component_configurations () -> Dict [ ComponentId , Dict ] Get the custom component configurations. component _ configurations | @component_configurations . setter | component_configurations ( d : Dict [ ComponentId , Dict ]) -> None Set the component configurations. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. private _ key _ paths _ dict | @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths. connection _ private _ key _ paths _ dict | @property | connection_private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of connection private key paths. component _ configurations _ json | component_configurations_json () -> List [ OrderedDict ] Get the component configurations in JSON format. json | @property | json () -> Dict Return the JSON representation. all _ components _ id | @property | all_components_id () -> List [ ComponentId ] Get list of the all components for this agent config. update | update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. To update the component parts, populate the field \"component_configurations\" as a mapping from ComponentId to configurations. Arguments : data : the data to replace. Returns : None SpeechActContentConfig Objects class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration. __ init __ | __init__ ( ** args ) Initialize a speech_act content configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ProtocolSpecification Objects class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , description : str = \"\" ) Initialize a protocol specification configuration object. protobuf _ snippets | @property | protobuf_snippets () -> Dict Get the protobuf snippets. protobuf _ snippets | @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) Set the protobuf snippets. dialogue _ config | @property | dialogue_config () -> Dict Get the dialogue config. dialogue _ config | @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) Set the dialogue config. json | @property | json () -> Dict Return the JSON representation. ContractConfig Objects class ContractConfig ( ComponentConfiguration ) Handle contract configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , contract_interface_paths : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" ) Initialize a protocol configuration object. json | @property | json () -> Dict Return the JSON representation.","title":"Base"},{"location":"aea/api/configurations/base/#aeaconfigurationsbase","text":"Classes to handle AEA configurations.","title":"aea.configurations.base"},{"location":"aea/api/configurations/base/#dependencies_from_json","text":"dependencies_from_json ( obj : Dict [ str , Dict ]) -> Dependencies Parse a JSON object to get an instance of Dependencies. Arguments : obj : a dictionary whose keys are package names and values are dictionary with package specifications. Returns : a Dependencies object.","title":"dependencies_from_json"},{"location":"aea/api/configurations/base/#dependencies_to_json","text":"dependencies_to_json ( dependencies : Dependencies ) -> Dict [ str , Dict ] Transform a Dependencies object into a JSON object. Arguments : dependencies : an instance of \"Dependencies\" type. Returns : a dictionary whose keys are package names and values are the JSON version of a Dependency object.","title":"dependencies_to_json"},{"location":"aea/api/configurations/base/#protocolspecificationparseerror-objects","text":"class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file.","title":"ProtocolSpecificationParseError Objects"},{"location":"aea/api/configurations/base/#configuration-objects","text":"class Configuration ( JSONSerializable , ABC ) Configuration class.","title":"Configuration Objects"},{"location":"aea/api/configurations/base/#__init__","text":"| __init__ () Initialize a configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#ordered_json","text":"| @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary.","title":"ordered_json"},{"location":"aea/api/configurations/base/#packageconfiguration-objects","text":"class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts","title":"PackageConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___1","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None ) Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license_ : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint. build_entrypoint : path to a script to execute at build time.","title":"__init__"},{"location":"aea/api/configurations/base/#name","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/base/#name_1","text":"| @name . setter | name ( value : SimpleIdOrStr ) Set the name.","title":"name"},{"location":"aea/api/configurations/base/#author","text":"| @property | author () -> str Get the author.","title":"author"},{"location":"aea/api/configurations/base/#author_1","text":"| @author . setter | author ( value : SimpleIdOrStr ) Set the author.","title":"author"},{"location":"aea/api/configurations/base/#aea_version","text":"| @property | aea_version () Get the 'aea_version' attribute.","title":"aea_version"},{"location":"aea/api/configurations/base/#aea_version_1","text":"| @aea_version . setter | aea_version ( new_aea_version : str ) Set the 'aea_version' attribute.","title":"aea_version"},{"location":"aea/api/configurations/base/#directory","text":"| @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any.","title":"directory"},{"location":"aea/api/configurations/base/#directory_1","text":"| @directory . setter | directory ( directory : Path ) -> None Set directory if not already set.","title":"directory"},{"location":"aea/api/configurations/base/#package_id","text":"| @property | package_id () -> PackageId Get package id.","title":"package_id"},{"location":"aea/api/configurations/base/#aea_version_specifiers","text":"| @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier.","title":"aea_version_specifiers"},{"location":"aea/api/configurations/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/base/#package_dependencies","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#update","text":"| update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. Arguments : data : the data to replace. Returns : None","title":"update"},{"location":"aea/api/configurations/base/#validate_config_data","text":"| @classmethod | validate_config_data ( cls , json_data : Dict , env_vars_friendly : bool = False ) -> None Perform config validation.","title":"validate_config_data"},{"location":"aea/api/configurations/base/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#make_resulting_config_data","text":"| make_resulting_config_data ( overrides : Dict ) -> Dict Make config data with overrides applied. Does not update config, just creates json representation","title":"make_resulting_config_data"},{"location":"aea/api/configurations/base/#check_overrides_valid","text":"| check_overrides_valid ( overrides : Dict , env_vars_friendly : bool = False ) -> None Check overrides is correct, return list of errors if present.","title":"check_overrides_valid"},{"location":"aea/api/configurations/base/#get_overridable","text":"| get_overridable () -> dict Get dictionary of values that can be updated for this config.","title":"get_overridable"},{"location":"aea/api/configurations/base/#componentconfiguration-objects","text":"class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration.","title":"ComponentConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___2","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None ) Set component configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#build_directory","text":"| @property | build_directory () -> Optional [ str ] Get the component type.","title":"build_directory"},{"location":"aea/api/configurations/base/#build_directory_1","text":"| @build_directory . setter | build_directory ( value : Optional [ str ]) -> None Get the component type.","title":"build_directory"},{"location":"aea/api/configurations/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#component_id","text":"| @property | component_id () -> ComponentId Get the component id.","title":"component_id"},{"location":"aea/api/configurations/base/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/base/#is_abstract_component","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#check_fingerprint","text":"| check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. :raises ValueError if: - the argument is not a valid package directory - the fingerprints do not match.","title":"check_fingerprint"},{"location":"aea/api/configurations/base/#check_aea_version","text":"| check_aea_version () Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier.","title":"check_aea_version"},{"location":"aea/api/configurations/base/#check_public_id_consistency","text":"| check_public_id_consistency ( directory : Path ) -> None Check that the public ids in the init file match the config. :raises ValueError if: - the argument is not a valid package directory - the public ids do not match.","title":"check_public_id_consistency"},{"location":"aea/api/configurations/base/#connectionconfig-objects","text":"class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration.","title":"ConnectionConfig Objects"},{"location":"aea/api/configurations/base/#__init___3","text":"| __init__ ( name : SimpleIdOrStr = \"\" , author : SimpleIdOrStr = \"\" , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , connections : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , connection_id : Optional [ PublicId ] = None , is_abstract : bool = False , cert_requests : Optional [ List [ CertRequest ]] = None , ** config , ,) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#package_dependencies_1","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#is_abstract_component_1","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#protocolconfig-objects","text":"class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration.","title":"ProtocolConfig Objects"},{"location":"aea/api/configurations/base/#__init___4","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_1","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#skillcomponentconfiguration-objects","text":"class SkillComponentConfiguration () This class represent a skill component configuration.","title":"SkillComponentConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___5","text":"| __init__ ( class_name : str , ** args ) Initialize a skill component configuration. Arguments : skill_component_type : the skill component type. class_name : the class name of the component. args : keyword arguments.","title":"__init__"},{"location":"aea/api/configurations/base/#json_2","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_2","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"SkillComponentConfiguration\" Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#skillconfig-objects","text":"class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file.","title":"SkillConfig Objects"},{"location":"aea/api/configurations/base/#__init___6","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , connections : Optional [ Set [ PublicId ]] = None , protocols : Optional [ Set [ PublicId ]] = None , contracts : Optional [ Set [ PublicId ]] = None , skills : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , is_abstract : bool = False ) Initialize a skill configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#package_dependencies_2","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the skill dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#is_abstract_component_2","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#json_3","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#get_overridable_1","text":"| get_overridable () -> dict Get overrideable confg data.","title":"get_overridable"},{"location":"aea/api/configurations/base/#agentconfig-objects","text":"class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file.","title":"AgentConfig Objects"},{"location":"aea/api/configurations/base/#__init___7","text":"| __init__ ( agent_name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , registry_path : str = DEFAULT_REGISTRY_NAME , description : str = \"\" , logging_config : Optional [ Dict ] = None , period : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , error_handler : Optional [ Dict ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , connection_exception_policy : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ str ] = None , default_routing : Optional [ Dict [ str , str ]] = None , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , component_configurations : Optional [ Dict [ ComponentId , Dict ]] = None ) Instantiate the agent configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#component_configurations","text":"| @property | component_configurations () -> Dict [ ComponentId , Dict ] Get the custom component configurations.","title":"component_configurations"},{"location":"aea/api/configurations/base/#component_configurations_1","text":"| @component_configurations . setter | component_configurations ( d : Dict [ ComponentId , Dict ]) -> None Set the component configurations.","title":"component_configurations"},{"location":"aea/api/configurations/base/#package_dependencies_3","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#private_key_paths_dict","text":"| @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths.","title":"private_key_paths_dict"},{"location":"aea/api/configurations/base/#connection_private_key_paths_dict","text":"| @property | connection_private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of connection private key paths.","title":"connection_private_key_paths_dict"},{"location":"aea/api/configurations/base/#component_configurations_json","text":"| component_configurations_json () -> List [ OrderedDict ] Get the component configurations in JSON format.","title":"component_configurations_json"},{"location":"aea/api/configurations/base/#json_4","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#all_components_id","text":"| @property | all_components_id () -> List [ ComponentId ] Get list of the all components for this agent config.","title":"all_components_id"},{"location":"aea/api/configurations/base/#update_1","text":"| update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. To update the component parts, populate the field \"component_configurations\" as a mapping from ComponentId to configurations. Arguments : data : the data to replace. Returns : None","title":"update"},{"location":"aea/api/configurations/base/#speechactcontentconfig-objects","text":"class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration.","title":"SpeechActContentConfig Objects"},{"location":"aea/api/configurations/base/#__init___8","text":"| __init__ ( ** args ) Initialize a speech_act content configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_5","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolspecification-objects","text":"class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification.","title":"ProtocolSpecification Objects"},{"location":"aea/api/configurations/base/#__init___9","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , description : str = \"\" ) Initialize a protocol specification configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#protobuf_snippets","text":"| @property | protobuf_snippets () -> Dict Get the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#protobuf_snippets_1","text":"| @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) Set the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#dialogue_config","text":"| @property | dialogue_config () -> Dict Get the dialogue config.","title":"dialogue_config"},{"location":"aea/api/configurations/base/#dialogue_config_1","text":"| @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) Set the dialogue config.","title":"dialogue_config"},{"location":"aea/api/configurations/base/#json_6","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#contractconfig-objects","text":"class ContractConfig ( ComponentConfiguration ) Handle contract configuration.","title":"ContractConfig Objects"},{"location":"aea/api/configurations/base/#__init___10","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , contract_interface_paths : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" ) Initialize a protocol configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_7","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/constants/","text":"aea.configurations.constants Module to declare constants.","title":"Constants"},{"location":"aea/api/configurations/constants/#aeaconfigurationsconstants","text":"Module to declare constants.","title":"aea.configurations.constants"},{"location":"aea/api/configurations/data_types/","text":"aea.configurations.data _ types Base config data types. JSONSerializable Objects class JSONSerializable ( ABC ) Interface for JSON-serializable objects. json | @property | @abstractmethod | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. PackageVersion Objects @functools . total_ordering class PackageVersion () A package version. __ init __ | __init__ ( version_like : PackageVersionLike ) Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object. is _ latest | @property | is_latest () -> bool Check whether the version is 'latest'. __ str __ | __str__ () -> str Get the string representation. __ eq __ | __eq__ ( other ) -> bool Check equality. __ lt __ | __lt__ ( other ) Compare with another object. PackageType Objects class PackageType ( Enum ) Package types. to _ plural | to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' __ str __ | __str__ () Convert to string. ComponentType Objects class ComponentType ( Enum ) Enum of component types supported. to _ package _ type | to_package_type () -> PackageType Get package type for component type. plurals | @staticmethod | plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts'] to _ plural | to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' __ str __ | __str__ () -> str Get the string representation. PublicId Objects class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True __ init __ | __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None ) Initialize the public identifier. author | @property | author () -> str Get the author. name | @property | name () -> str Get the name. version | @property | version () -> str Get the version string. package _ version | @property | package_version () -> PackageVersion Get the package version object. to _ any | to_any () -> \"PublicId\" Return the same public id, but with any version. same _ prefix | same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this. to _ latest | to_latest () -> \"PublicId\" Return the same public id, but with latest version. is _ valid _ str | @classmethod | is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity from _ str | @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. from _ uri _ path | @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. __ hash __ | __hash__ () Get the hash. __ str __ | __str__ () Get the string representation. __ repr __ | __repr__ () Get the representation. __ eq __ | __eq__ ( other ) Compare with another object. __ lt __ | __lt__ ( other ) Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different. PackageId Objects class PackageId () A package identifier. __ init __ | __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) Initialize the package id. Arguments : package_type : the package type. public_id : the public id. package _ type | @property | package_type () -> PackageType Get the package type. public _ id | @property | public_id () -> PublicId Get the public id. author | @property | author () -> str Get the author of the package. name | @property | name () -> str Get the name of the package. version | @property | version () -> str Get the version of the package. package _ prefix | @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version. from _ uri _ path | @classmethod | from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the public id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string __ hash __ | __hash__ () Get the hash. __ str __ | __str__ () Get the string representation. __ repr __ | __repr__ () Get the object representation in string. __ eq __ | __eq__ ( other ) Compare with another object. __ lt __ | __lt__ ( other ) Compare two public ids. ComponentId Objects class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False __ init __ | __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) Initialize the component id. Arguments : component_type : the component type. public_id : the public id. component _ type | @property | component_type () -> ComponentType Get the component type. component _ prefix | @property | component_prefix () -> Tuple [ ComponentType , str , str ] Get the component identifier without the version. same _ prefix | same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. json | @property | json () -> Dict Get the JSON representation. from _ json | @classmethod | from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data. PyPIPackageName Objects class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name. GitRef Objects class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag. Dependency Objects class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command. __ init __ | __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ Union [ str , Url ]] = None , git : Optional [ Union [ str , Url ]] = None , ref : Optional [ Union [ GitRef , str ]] = None ) Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag). name | @property | name () -> str Get the name. version | @property | version () -> str Get the version. index | @property | index () -> Optional [ str ] Get the index. git | @property | git () -> Optional [ str ] Get the git. ref | @property | ref () -> Optional [ str ] Get the ref. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary. to _ json | to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON. get _ pip _ install _ args | get_pip_install_args () -> List [ str ] Get 'pip install' arguments. __ str __ | __str__ () -> str Get the string representation. __ eq __ | __eq__ ( other ) Compare with another object. Dependencies A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set. CRUDCollection Objects class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection. __ init __ | __init__ () Instantiate a CRUD collection. create | create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection. read | read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present. update | update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None delete | delete ( item_id : str ) -> None Delete an item. read _ all | read_all () -> List [ Tuple [ str , T ]] Read all the items. keys | keys () -> Set [ str ] Get the set of keys.","title":"Data Types"},{"location":"aea/api/configurations/data_types/#aeaconfigurationsdata_types","text":"Base config data types.","title":"aea.configurations.data_types"},{"location":"aea/api/configurations/data_types/#jsonserializable-objects","text":"class JSONSerializable ( ABC ) Interface for JSON-serializable objects.","title":"JSONSerializable Objects"},{"location":"aea/api/configurations/data_types/#json","text":"| @property | @abstractmethod | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/data_types/#packageversion-objects","text":"@functools . total_ordering class PackageVersion () A package version.","title":"PackageVersion Objects"},{"location":"aea/api/configurations/data_types/#__init__","text":"| __init__ ( version_like : PackageVersionLike ) Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object.","title":"__init__"},{"location":"aea/api/configurations/data_types/#is_latest","text":"| @property | is_latest () -> bool Check whether the version is 'latest'.","title":"is_latest"},{"location":"aea/api/configurations/data_types/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__eq__","text":"| __eq__ ( other ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt__","text":"| __lt__ ( other ) Compare with another object.","title":"__lt__"},{"location":"aea/api/configurations/data_types/#packagetype-objects","text":"class PackageType ( Enum ) Package types.","title":"PackageType Objects"},{"location":"aea/api/configurations/data_types/#to_plural","text":"| to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts'","title":"to_plural"},{"location":"aea/api/configurations/data_types/#__str___1","text":"| __str__ () Convert to string.","title":"__str__"},{"location":"aea/api/configurations/data_types/#componenttype-objects","text":"class ComponentType ( Enum ) Enum of component types supported.","title":"ComponentType Objects"},{"location":"aea/api/configurations/data_types/#to_package_type","text":"| to_package_type () -> PackageType Get package type for component type.","title":"to_package_type"},{"location":"aea/api/configurations/data_types/#plurals","text":"| @staticmethod | plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts']","title":"plurals"},{"location":"aea/api/configurations/data_types/#to_plural_1","text":"| to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts'","title":"to_plural"},{"location":"aea/api/configurations/data_types/#__str___2","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#publicid-objects","text":"class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True","title":"PublicId Objects"},{"location":"aea/api/configurations/data_types/#__init___1","text":"| __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None ) Initialize the public identifier.","title":"__init__"},{"location":"aea/api/configurations/data_types/#author","text":"| @property | author () -> str Get the author.","title":"author"},{"location":"aea/api/configurations/data_types/#name","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/data_types/#version","text":"| @property | version () -> str Get the version string.","title":"version"},{"location":"aea/api/configurations/data_types/#package_version","text":"| @property | package_version () -> PackageVersion Get the package version object.","title":"package_version"},{"location":"aea/api/configurations/data_types/#to_any","text":"| to_any () -> \"PublicId\" Return the same public id, but with any version.","title":"to_any"},{"location":"aea/api/configurations/data_types/#same_prefix","text":"| same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this.","title":"same_prefix"},{"location":"aea/api/configurations/data_types/#to_latest","text":"| to_latest () -> \"PublicId\" Return the same public id, but with latest version.","title":"to_latest"},{"location":"aea/api/configurations/data_types/#is_valid_str","text":"| @classmethod | is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity","title":"is_valid_str"},{"location":"aea/api/configurations/data_types/#from_str","text":"| @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_str"},{"location":"aea/api/configurations/data_types/#from_uri_path","text":"| @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/data_types/#to_uri_path","text":"| @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/data_types/#json_1","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/data_types/#__hash__","text":"| __hash__ () Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/data_types/#__str___3","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__repr__","text":"| __repr__ () Get the representation.","title":"__repr__"},{"location":"aea/api/configurations/data_types/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt___1","text":"| __lt__ ( other ) Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different.","title":"__lt__"},{"location":"aea/api/configurations/data_types/#packageid-objects","text":"class PackageId () A package identifier.","title":"PackageId Objects"},{"location":"aea/api/configurations/data_types/#__init___2","text":"| __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) Initialize the package id. Arguments : package_type : the package type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/data_types/#package_type","text":"| @property | package_type () -> PackageType Get the package type.","title":"package_type"},{"location":"aea/api/configurations/data_types/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/data_types/#author_1","text":"| @property | author () -> str Get the author of the package.","title":"author"},{"location":"aea/api/configurations/data_types/#name_1","text":"| @property | name () -> str Get the name of the package.","title":"name"},{"location":"aea/api/configurations/data_types/#version_1","text":"| @property | version () -> str Get the version of the package.","title":"version"},{"location":"aea/api/configurations/data_types/#package_prefix","text":"| @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version.","title":"package_prefix"},{"location":"aea/api/configurations/data_types/#from_uri_path_1","text":"| @classmethod | from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the public id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/data_types/#to_uri_path_1","text":"| @property | to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/data_types/#__hash___1","text":"| __hash__ () Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/data_types/#__str___4","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__repr___1","text":"| __repr__ () Get the object representation in string.","title":"__repr__"},{"location":"aea/api/configurations/data_types/#__eq___2","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt___2","text":"| __lt__ ( other ) Compare two public ids.","title":"__lt__"},{"location":"aea/api/configurations/data_types/#componentid-objects","text":"class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False","title":"ComponentId Objects"},{"location":"aea/api/configurations/data_types/#__init___3","text":"| __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) Initialize the component id. Arguments : component_type : the component type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/data_types/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/data_types/#component_prefix","text":"| @property | component_prefix () -> Tuple [ ComponentType , str , str ] Get the component identifier without the version.","title":"component_prefix"},{"location":"aea/api/configurations/data_types/#same_prefix_1","text":"| same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this.","title":"same_prefix"},{"location":"aea/api/configurations/data_types/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/data_types/#json_2","text":"| @property | json () -> Dict Get the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json_2","text":"| @classmethod | from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data.","title":"from_json"},{"location":"aea/api/configurations/data_types/#pypipackagename-objects","text":"class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name.","title":"PyPIPackageName Objects"},{"location":"aea/api/configurations/data_types/#gitref-objects","text":"class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag.","title":"GitRef Objects"},{"location":"aea/api/configurations/data_types/#dependency-objects","text":"class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command.","title":"Dependency Objects"},{"location":"aea/api/configurations/data_types/#__init___4","text":"| __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ Union [ str , Url ]] = None , git : Optional [ Union [ str , Url ]] = None , ref : Optional [ Union [ GitRef , str ]] = None ) Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag).","title":"__init__"},{"location":"aea/api/configurations/data_types/#name_2","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/data_types/#version_2","text":"| @property | version () -> str Get the version.","title":"version"},{"location":"aea/api/configurations/data_types/#index","text":"| @property | index () -> Optional [ str ] Get the index.","title":"index"},{"location":"aea/api/configurations/data_types/#git","text":"| @property | git () -> Optional [ str ] Get the git.","title":"git"},{"location":"aea/api/configurations/data_types/#ref","text":"| @property | ref () -> Optional [ str ] Get the ref.","title":"ref"},{"location":"aea/api/configurations/data_types/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary.","title":"from_json"},{"location":"aea/api/configurations/data_types/#to_json","text":"| to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON.","title":"to_json"},{"location":"aea/api/configurations/data_types/#get_pip_install_args","text":"| get_pip_install_args () -> List [ str ] Get 'pip install' arguments.","title":"get_pip_install_args"},{"location":"aea/api/configurations/data_types/#__str___5","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__eq___3","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#dependencies","text":"A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.","title":"Dependencies"},{"location":"aea/api/configurations/data_types/#crudcollection-objects","text":"class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection.","title":"CRUDCollection Objects"},{"location":"aea/api/configurations/data_types/#__init___5","text":"| __init__ () Instantiate a CRUD collection.","title":"__init__"},{"location":"aea/api/configurations/data_types/#create","text":"| create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection.","title":"create"},{"location":"aea/api/configurations/data_types/#read","text":"| read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present.","title":"read"},{"location":"aea/api/configurations/data_types/#update","text":"| update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None","title":"update"},{"location":"aea/api/configurations/data_types/#delete","text":"| delete ( item_id : str ) -> None Delete an item.","title":"delete"},{"location":"aea/api/configurations/data_types/#read_all","text":"| read_all () -> List [ Tuple [ str , T ]] Read all the items.","title":"read_all"},{"location":"aea/api/configurations/data_types/#keys","text":"| keys () -> Set [ str ] Get the set of keys.","title":"keys"},{"location":"aea/api/configurations/loader/","text":"aea.configurations.loader Implementation of the parser for configuration file. BaseConfigLoader Objects class BaseConfigLoader () Base class for configuration loader classes. __ init __ | __init__ ( schema_filename : str ) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. validator | @property | validator () -> ConfigValidator Get the json schema validator. validate | validate ( json_data : Dict ) -> None Validate a JSON object. Arguments : json_data : the JSON data. Returns : None. required _ fields | @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields. ConfigLoader Objects class ConfigLoader ( Generic [ T ], BaseConfigLoader ) Parsing, serialization and validation for package configuration files. __ init __ | __init__ ( schema_filename : str , configuration_class : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.) configuration _ class | @property | configuration_class () -> Type [ T ] Get the configuration class of the loader. load _ protocol _ specification | load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises load | load ( file_pointer : TextIO ) -> T Load a configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. dump | dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None from _ configuration _ type | @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type. load _ agent _ config _ from _ json | load_agent_config_from_json ( configuration_json : List [ Dict ], validate : bool = True ) -> AgentConfig Load agent configuration from configuration json data. Arguments : configuration_json : list of dicts with aea configuration Returns : AgentConfig instance ConfigLoaders Objects class ConfigLoaders () Configuration Loader class to load any package type. from _ package _ type | @classmethod | from_package_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get a config loader from the configuration type. Arguments : configuration_type : the configuration type load _ component _ configuration load_component_configuration ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False ) -> ComponentConfiguration Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object. load _ package _ configuration load_package_configuration ( package_type : PackageType , directory : Path , skip_consistency_check : bool = False ) -> PackageConfiguration Load configuration and check that it is consistent against the directory. Arguments : package_type : the package type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object.","title":"Loader"},{"location":"aea/api/configurations/loader/#aeaconfigurationsloader","text":"Implementation of the parser for configuration file.","title":"aea.configurations.loader"},{"location":"aea/api/configurations/loader/#baseconfigloader-objects","text":"class BaseConfigLoader () Base class for configuration loader classes.","title":"BaseConfigLoader Objects"},{"location":"aea/api/configurations/loader/#__init__","text":"| __init__ ( schema_filename : str ) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'.","title":"__init__"},{"location":"aea/api/configurations/loader/#validator","text":"| @property | validator () -> ConfigValidator Get the json schema validator.","title":"validator"},{"location":"aea/api/configurations/loader/#validate","text":"| validate ( json_data : Dict ) -> None Validate a JSON object. Arguments : json_data : the JSON data. Returns : None.","title":"validate"},{"location":"aea/api/configurations/loader/#required_fields","text":"| @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields.","title":"required_fields"},{"location":"aea/api/configurations/loader/#configloader-objects","text":"class ConfigLoader ( Generic [ T ], BaseConfigLoader ) Parsing, serialization and validation for package configuration files.","title":"ConfigLoader Objects"},{"location":"aea/api/configurations/loader/#__init___1","text":"| __init__ ( schema_filename : str , configuration_class : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.)","title":"__init__"},{"location":"aea/api/configurations/loader/#configuration_class","text":"| @property | configuration_class () -> Type [ T ] Get the configuration class of the loader.","title":"configuration_class"},{"location":"aea/api/configurations/loader/#load_protocol_specification","text":"| load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load_protocol_specification"},{"location":"aea/api/configurations/loader/#load","text":"| load ( file_pointer : TextIO ) -> T Load a configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object.","title":"load"},{"location":"aea/api/configurations/loader/#dump","text":"| dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None","title":"dump"},{"location":"aea/api/configurations/loader/#from_configuration_type","text":"| @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type.","title":"from_configuration_type"},{"location":"aea/api/configurations/loader/#load_agent_config_from_json","text":"| load_agent_config_from_json ( configuration_json : List [ Dict ], validate : bool = True ) -> AgentConfig Load agent configuration from configuration json data. Arguments : configuration_json : list of dicts with aea configuration Returns : AgentConfig instance","title":"load_agent_config_from_json"},{"location":"aea/api/configurations/loader/#configloaders-objects","text":"class ConfigLoaders () Configuration Loader class to load any package type.","title":"ConfigLoaders Objects"},{"location":"aea/api/configurations/loader/#from_package_type","text":"| @classmethod | from_package_type ( cls , configuration_type : Union [ PackageType , str ]) -> \"ConfigLoader\" Get a config loader from the configuration type. Arguments : configuration_type : the configuration type","title":"from_package_type"},{"location":"aea/api/configurations/loader/#load_component_configuration","text":"load_component_configuration ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False ) -> ComponentConfiguration Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object.","title":"load_component_configuration"},{"location":"aea/api/configurations/loader/#load_package_configuration","text":"load_package_configuration ( package_type : PackageType , directory : Path , skip_consistency_check : bool = False ) -> PackageConfiguration Load configuration and check that it is consistent against the directory. Arguments : package_type : the package type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. Returns : the configuration object.","title":"load_package_configuration"},{"location":"aea/api/configurations/manager/","text":"aea.configurations.manager Implementation of the AgentConfigManager. VariableDoesNotExist Objects class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception. handle _ dotted _ path handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id]. find _ component _ directory _ from _ component _ id find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id. AgentConfigManager Objects class AgentConfigManager () AeaConfig manager. __ init __ | __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed. load _ component _ configuration | load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration agent _ config _ file _ path | @property | agent_config_file_path () -> Path Return agent config file path. load | @classmethod | load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path. set _ variable | set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects. Returns : None get _ variable | get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value. update _ config | update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overrided values dictionary Returns : None validate _ current _ config | validate_current_config () Check is current config valid. json | @property | json () -> Dict Return current agent config json representation. dump _ config | dump_config () -> None Save agent config on the disc. verify _ or _ create _ private _ keys | @classmethod | verify_or_create_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , bool ], None ], substitude_env_vars : bool = False , create_keys : bool = True ) -> \"AgentConfigManager\" Verify or create private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config Returns : the agent configuration manager. get _ overridables | get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"Manager"},{"location":"aea/api/configurations/manager/#aeaconfigurationsmanager","text":"Implementation of the AgentConfigManager.","title":"aea.configurations.manager"},{"location":"aea/api/configurations/manager/#variabledoesnotexist-objects","text":"class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception.","title":"VariableDoesNotExist Objects"},{"location":"aea/api/configurations/manager/#handle_dotted_path","text":"handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id].","title":"handle_dotted_path"},{"location":"aea/api/configurations/manager/#find_component_directory_from_component_id","text":"find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id.","title":"find_component_directory_from_component_id"},{"location":"aea/api/configurations/manager/#agentconfigmanager-objects","text":"class AgentConfigManager () AeaConfig manager.","title":"AgentConfigManager Objects"},{"location":"aea/api/configurations/manager/#__init__","text":"| __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed.","title":"__init__"},{"location":"aea/api/configurations/manager/#load_component_configuration","text":"| load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration","title":"load_component_configuration"},{"location":"aea/api/configurations/manager/#agent_config_file_path","text":"| @property | agent_config_file_path () -> Path Return agent config file path.","title":"agent_config_file_path"},{"location":"aea/api/configurations/manager/#load","text":"| @classmethod | load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path.","title":"load"},{"location":"aea/api/configurations/manager/#set_variable","text":"| set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects. Returns : None","title":"set_variable"},{"location":"aea/api/configurations/manager/#get_variable","text":"| get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value.","title":"get_variable"},{"location":"aea/api/configurations/manager/#update_config","text":"| update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overrided values dictionary Returns : None","title":"update_config"},{"location":"aea/api/configurations/manager/#validate_current_config","text":"| validate_current_config () Check is current config valid.","title":"validate_current_config"},{"location":"aea/api/configurations/manager/#json","text":"| @property | json () -> Dict Return current agent config json representation.","title":"json"},{"location":"aea/api/configurations/manager/#dump_config","text":"| dump_config () -> None Save agent config on the disc.","title":"dump_config"},{"location":"aea/api/configurations/manager/#verify_or_create_private_keys","text":"| @classmethod | verify_or_create_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , bool ], None ], substitude_env_vars : bool = False , create_keys : bool = True ) -> \"AgentConfigManager\" Verify or create private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config Returns : the agent configuration manager.","title":"verify_or_create_private_keys"},{"location":"aea/api/configurations/manager/#get_overridables","text":"| get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"get_overridables"},{"location":"aea/api/configurations/pypi/","text":"aea.configurations.pypi This module contains a checker for PyPI version consistency. and _ and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) Do the and between two specifier sets. is _ satisfiable is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know. is _ simple _ dep is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not to _ set _ specifier to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above). merge _ dependencies merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), we just filter them out. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies.","title":"Pypi"},{"location":"aea/api/configurations/pypi/#aeaconfigurationspypi","text":"This module contains a checker for PyPI version consistency.","title":"aea.configurations.pypi"},{"location":"aea/api/configurations/pypi/#and_","text":"and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) Do the and between two specifier sets.","title":"and_"},{"location":"aea/api/configurations/pypi/#is_satisfiable","text":"is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know.","title":"is_satisfiable"},{"location":"aea/api/configurations/pypi/#is_simple_dep","text":"is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not","title":"is_simple_dep"},{"location":"aea/api/configurations/pypi/#to_set_specifier","text":"to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above).","title":"to_set_specifier"},{"location":"aea/api/configurations/pypi/#merge_dependencies","text":"merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), we just filter them out. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies.","title":"merge_dependencies"},{"location":"aea/api/configurations/utils/","text":"aea.configurations.utils AEA configuration utils. replace _ component _ ids @singledispatch replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Update public id references in a package configuration. This depends on the actual configuration being considered. _ @replace_component_ids . register ( AgentConfig ) # type: ignore _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping. Returns : None _ @replace_component_ids . register ( ProtocolConfig ) # type: ignore _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Do nothing - protocols have no references. _ @replace_component_ids . register ( ConnectionConfig ) # type: ignore _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in a connection configuration. _ @replace_component_ids . register ( ContractConfig ) # type: ignore _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Do nothing - contracts have no references. _ @replace_component_ids . register ( SkillConfig ) # type: ignore _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in a skill configuration. get _ latest _ component _ id _ from _ prefix get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : Tuple [ ComponentType , str , str ]) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"Utils"},{"location":"aea/api/configurations/utils/#aeaconfigurationsutils","text":"AEA configuration utils.","title":"aea.configurations.utils"},{"location":"aea/api/configurations/utils/#replace_component_ids","text":"@singledispatch replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Update public id references in a package configuration. This depends on the actual configuration being considered.","title":"replace_component_ids"},{"location":"aea/api/configurations/utils/#_","text":"@replace_component_ids . register ( AgentConfig ) # type: ignore _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping. Returns : None","title":"_"},{"location":"aea/api/configurations/utils/#__1","text":"@replace_component_ids . register ( ProtocolConfig ) # type: ignore _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Do nothing - protocols have no references.","title":"_"},{"location":"aea/api/configurations/utils/#__2","text":"@replace_component_ids . register ( ConnectionConfig ) # type: ignore _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in a connection configuration.","title":"_"},{"location":"aea/api/configurations/utils/#__3","text":"@replace_component_ids . register ( ContractConfig ) # type: ignore _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Do nothing - contracts have no references.","title":"_"},{"location":"aea/api/configurations/utils/#__4","text":"@replace_component_ids . register ( SkillConfig ) # type: ignore _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) Replace references in a skill configuration.","title":"_"},{"location":"aea/api/configurations/utils/#get_latest_component_id_from_prefix","text":"get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : Tuple [ ComponentType , str , str ]) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"get_latest_component_id_from_prefix"},{"location":"aea/api/configurations/validation/","text":"aea.configurations.validation Implementation of the configuration validation. make _ jsonschema _ base _ uri make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form. ExtraPropertiesError Objects class ExtraPropertiesError ( ValueError ) Extra properties exception. __ str __ | __str__ () -> str Get string representation of the object. __ repr __ | __repr__ () -> str Get string representation of the object. CustomTypeChecker Objects class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables. is _ type | is_type ( instance , type ) Check is instance of type. ownAdditionalProperties ownAdditionalProperties ( validator , aP , instance , schema ) Additioinal properties validator. ConfigValidator Objects class ConfigValidator () Configuration validator implementation. __ init __ | __init__ ( schema_filename : str , env_vars_friendly : bool = False ) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. split _ component _ id _ and _ config | @staticmethod | split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Returns : the component id and the configuration object. Raises : ValueError : if the component id cannot be extracted. validate _ component _ configuration | @classmethod | validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Returns : None Raises : ValueError : if the configuration is not valid. validate | validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data. Returns : None. validate _ agent _ components _ configuration | validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : Returns : None required _ fields | @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields. validate _ data _ with _ pattern validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions filter _ data filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"Validation"},{"location":"aea/api/configurations/validation/#aeaconfigurationsvalidation","text":"Implementation of the configuration validation.","title":"aea.configurations.validation"},{"location":"aea/api/configurations/validation/#make_jsonschema_base_uri","text":"make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form.","title":"make_jsonschema_base_uri"},{"location":"aea/api/configurations/validation/#extrapropertieserror-objects","text":"class ExtraPropertiesError ( ValueError ) Extra properties exception.","title":"ExtraPropertiesError Objects"},{"location":"aea/api/configurations/validation/#__str__","text":"| __str__ () -> str Get string representation of the object.","title":"__str__"},{"location":"aea/api/configurations/validation/#__repr__","text":"| __repr__ () -> str Get string representation of the object.","title":"__repr__"},{"location":"aea/api/configurations/validation/#customtypechecker-objects","text":"class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables.","title":"CustomTypeChecker Objects"},{"location":"aea/api/configurations/validation/#is_type","text":"| is_type ( instance , type ) Check is instance of type.","title":"is_type"},{"location":"aea/api/configurations/validation/#ownadditionalproperties","text":"ownAdditionalProperties ( validator , aP , instance , schema ) Additioinal properties validator.","title":"ownAdditionalProperties"},{"location":"aea/api/configurations/validation/#configvalidator-objects","text":"class ConfigValidator () Configuration validator implementation.","title":"ConfigValidator Objects"},{"location":"aea/api/configurations/validation/#__init__","text":"| __init__ ( schema_filename : str , env_vars_friendly : bool = False ) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'.","title":"__init__"},{"location":"aea/api/configurations/validation/#split_component_id_and_config","text":"| @staticmethod | split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Returns : the component id and the configuration object. Raises : ValueError : if the component id cannot be extracted.","title":"split_component_id_and_config"},{"location":"aea/api/configurations/validation/#validate_component_configuration","text":"| @classmethod | validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Returns : None Raises : ValueError : if the configuration is not valid.","title":"validate_component_configuration"},{"location":"aea/api/configurations/validation/#validate","text":"| validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data. Returns : None.","title":"validate"},{"location":"aea/api/configurations/validation/#validate_agent_components_configuration","text":"| validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : Returns : None","title":"validate_agent_components_configuration"},{"location":"aea/api/configurations/validation/#required_fields","text":"| @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields.","title":"required_fields"},{"location":"aea/api/configurations/validation/#validate_data_with_pattern","text":"validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions","title":"validate_data_with_pattern"},{"location":"aea/api/configurations/validation/#filter_data","text":"filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"filter_data"},{"location":"aea/api/connections/base/","text":"aea.connections.base The base connection package. ConnectionStates Objects class ConnectionStates ( Enum ) Connection states enum. Connection Objects class Connection ( Component , ABC ) Abstract definition of a connection. __ init __ | __init__ ( configuration : ConnectionConfig , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs , ,) Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. loop | @property | loop () -> asyncio . AbstractEventLoop Get the event loop. address | @property | address () -> \"Address\" Get the address. crypto _ store | @property | crypto_store () -> CryptoStore Get the crypto store. has _ crypto _ store | @property | has_crypto_store () -> bool Check if the connection has the crypto store. component _ type | @property | component_type () -> ComponentType Get the component type. configuration | @property | configuration () -> ConnectionConfig Get the connection configuration. restricted _ to _ protocols | @property | restricted_to_protocols () -> Set [ PublicId ] Get the ids of the protocols this connection is restricted to. excluded _ protocols | @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection. state | @property | state () -> ConnectionStates Get the connection status. connect | @abstractmethod | async connect () Set up the connection. disconnect | @abstractmethod | async disconnect () Tear down the connection. send | @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None receive | @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred. from _ dir | @classmethod | from_dir ( cls , directory : str , identity : Identity , crypto_store : CryptoStore , ** kwargs ) -> \"Connection\" Load the connection from a directory. Arguments : directory : the directory to the connection package. identity : the identity object. crypto_store : object to access the connection crypto objects. Returns : the connection object. from _ config | @classmethod | from_config ( cls , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ** kwargs , ,) -> \"Connection\" Load a connection from a configuration. Arguments : configuration : the connection configuration. identity : the identity object. crypto_store : object to access the connection crypto objects. Returns : an instance of the concrete connection class. is _ connected | @property | is_connected () -> bool Return is connected state. is _ connecting | @property | is_connecting () -> bool Return is connecting state. is _ disconnected | @property | is_disconnected () -> bool Return is disconnected state.","title":"Base"},{"location":"aea/api/connections/base/#aeaconnectionsbase","text":"The base connection package.","title":"aea.connections.base"},{"location":"aea/api/connections/base/#connectionstates-objects","text":"class ConnectionStates ( Enum ) Connection states enum.","title":"ConnectionStates Objects"},{"location":"aea/api/connections/base/#connection-objects","text":"class Connection ( Component , ABC ) Abstract definition of a connection.","title":"Connection Objects"},{"location":"aea/api/connections/base/#__init__","text":"| __init__ ( configuration : ConnectionConfig , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs , ,) Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection.","title":"__init__"},{"location":"aea/api/connections/base/#loop","text":"| @property | loop () -> asyncio . AbstractEventLoop Get the event loop.","title":"loop"},{"location":"aea/api/connections/base/#address","text":"| @property | address () -> \"Address\" Get the address.","title":"address"},{"location":"aea/api/connections/base/#crypto_store","text":"| @property | crypto_store () -> CryptoStore Get the crypto store.","title":"crypto_store"},{"location":"aea/api/connections/base/#has_crypto_store","text":"| @property | has_crypto_store () -> bool Check if the connection has the crypto store.","title":"has_crypto_store"},{"location":"aea/api/connections/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/connections/base/#configuration","text":"| @property | configuration () -> ConnectionConfig Get the connection configuration.","title":"configuration"},{"location":"aea/api/connections/base/#restricted_to_protocols","text":"| @property | restricted_to_protocols () -> Set [ PublicId ] Get the ids of the protocols this connection is restricted to.","title":"restricted_to_protocols"},{"location":"aea/api/connections/base/#excluded_protocols","text":"| @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection.","title":"excluded_protocols"},{"location":"aea/api/connections/base/#state","text":"| @property | state () -> ConnectionStates Get the connection status.","title":"state"},{"location":"aea/api/connections/base/#connect","text":"| @abstractmethod | async connect () Set up the connection.","title":"connect"},{"location":"aea/api/connections/base/#disconnect","text":"| @abstractmethod | async disconnect () Tear down the connection.","title":"disconnect"},{"location":"aea/api/connections/base/#send","text":"| @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None","title":"send"},{"location":"aea/api/connections/base/#receive","text":"| @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred.","title":"receive"},{"location":"aea/api/connections/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , identity : Identity , crypto_store : CryptoStore , ** kwargs ) -> \"Connection\" Load the connection from a directory. Arguments : directory : the directory to the connection package. identity : the identity object. crypto_store : object to access the connection crypto objects. Returns : the connection object.","title":"from_dir"},{"location":"aea/api/connections/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ** kwargs , ,) -> \"Connection\" Load a connection from a configuration. Arguments : configuration : the connection configuration. identity : the identity object. crypto_store : object to access the connection crypto objects. Returns : an instance of the concrete connection class.","title":"from_config"},{"location":"aea/api/connections/base/#is_connected","text":"| @property | is_connected () -> bool Return is connected state.","title":"is_connected"},{"location":"aea/api/connections/base/#is_connecting","text":"| @property | is_connecting () -> bool Return is connecting state.","title":"is_connecting"},{"location":"aea/api/connections/base/#is_disconnected","text":"| @property | is_disconnected () -> bool Return is disconnected state.","title":"is_disconnected"},{"location":"aea/api/connections/stub/connection/","text":"packages.fetchai.connections.stub.connection This module contains the stub connection. StubConnection Objects class StubConnection ( Connection ) __ init __ | __init__ ( ** kwargs ) Initialize a stub connection. read _ envelopes | async read_envelopes () -> None Read envelopes from inptut file, decode and put into in_queue. receive | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. connect | async connect () -> None Set up the connection. disconnect | async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect. send | async send ( envelope : Envelope ) -> None Send messages. Returns : None","title":"Stub Connection"},{"location":"aea/api/connections/stub/connection/#packagesfetchaiconnectionsstubconnection","text":"This module contains the stub connection.","title":"packages.fetchai.connections.stub.connection"},{"location":"aea/api/connections/stub/connection/#stubconnection-objects","text":"class StubConnection ( Connection )","title":"StubConnection Objects"},{"location":"aea/api/connections/stub/connection/#__init__","text":"| __init__ ( ** kwargs ) Initialize a stub connection.","title":"__init__"},{"location":"aea/api/connections/stub/connection/#read_envelopes","text":"| async read_envelopes () -> None Read envelopes from inptut file, decode and put into in_queue.","title":"read_envelopes"},{"location":"aea/api/connections/stub/connection/#receive","text":"| async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope.","title":"receive"},{"location":"aea/api/connections/stub/connection/#connect","text":"| async connect () -> None Set up the connection.","title":"connect"},{"location":"aea/api/connections/stub/connection/#disconnect","text":"| async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect.","title":"disconnect"},{"location":"aea/api/connections/stub/connection/#send","text":"| async send ( envelope : Envelope ) -> None Send messages. Returns : None","title":"send"},{"location":"aea/api/context/base/","text":"aea.context.base This module contains the agent context class. AgentContext Objects class AgentContext () Provide read access to relevant objects of the agent for the skills. __ init __ | __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , ** kwargs ) Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id ledger_it_to_currency_denom : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker storage_callable : function that returns optional storage attached to agent. kwargs : keyword arguments to be attached in the agent context namespace. storage | @property | storage () -> Optional [ Storage ] Return storage instance if enabled in AEA. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. identity | @property | identity () -> Identity Get the identity. agent _ name | @property | agent_name () -> str Get agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get addresses. address | @property | address () -> Address Get the default address. connection _ status | @property | connection_status () -> MultiplexerStatus Get connection status of the multiplexer. outbox | @property | outbox () -> OutBox Get outbox. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get decision maker queue. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context. task _ manager | @property | task_manager () -> TaskManager Get the task manager. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. decision _ maker _ address | @property | decision_maker_address () -> Address Get the address of the decision maker. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. currency _ denominations | @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. default _ connection | @property | default_connection () -> Optional [ PublicId ] Get the default connection. default _ routing | @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"Context"},{"location":"aea/api/context/base/#aeacontextbase","text":"This module contains the agent context class.","title":"aea.context.base"},{"location":"aea/api/context/base/#agentcontext-objects","text":"class AgentContext () Provide read access to relevant objects of the agent for the skills.","title":"AgentContext Objects"},{"location":"aea/api/context/base/#__init__","text":"| __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , ** kwargs ) Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id ledger_it_to_currency_denom : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker storage_callable : function that returns optional storage attached to agent. kwargs : keyword arguments to be attached in the agent context namespace.","title":"__init__"},{"location":"aea/api/context/base/#storage","text":"| @property | storage () -> Optional [ Storage ] Return storage instance if enabled in AEA.","title":"storage"},{"location":"aea/api/context/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills.","title":"shared_state"},{"location":"aea/api/context/base/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/context/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/context/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get addresses.","title":"addresses"},{"location":"aea/api/context/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/context/base/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get connection status of the multiplexer.","title":"connection_status"},{"location":"aea/api/context/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/context/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get decision maker queue.","title":"decision_maker_message_queue"},{"location":"aea/api/context/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/context/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/context/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/context/base/#decision_maker_address","text":"| @property | decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"aea/api/context/base/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/context/base/#currency_denominations","text":"| @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"aea/api/context/base/#default_connection","text":"| @property | default_connection () -> Optional [ PublicId ] Get the default connection.","title":"default_connection"},{"location":"aea/api/context/base/#default_routing","text":"| @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"aea/api/context/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/contracts/base/","text":"aea.contracts.base The base contract. Contract Objects class Contract ( Component ) Abstract definition of a contract. __ init __ | __init__ ( contract_config : ContractConfig , ** kwargs ) Initialize the contract. Arguments : contract_config : the contract configurations. id | @property | id () -> PublicId Get the name. configuration | @property | configuration () -> ContractConfig Get the configuration. get _ instance | @classmethod | get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance from _ dir | @classmethod | from_dir ( cls , directory : str , ** kwargs ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the contract object. from _ config | @classmethod | from_config ( cls , configuration : ContractConfig , ** kwargs ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. Returns : the contract object. get _ deploy _ transaction | @classmethod | get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx get _ raw _ transaction | @classmethod | get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx get _ raw _ message | @classmethod | get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx get _ state | @classmethod | get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx","title":"Base"},{"location":"aea/api/contracts/base/#aeacontractsbase","text":"The base contract.","title":"aea.contracts.base"},{"location":"aea/api/contracts/base/#contract-objects","text":"class Contract ( Component ) Abstract definition of a contract.","title":"Contract Objects"},{"location":"aea/api/contracts/base/#__init__","text":"| __init__ ( contract_config : ContractConfig , ** kwargs ) Initialize the contract. Arguments : contract_config : the contract configurations.","title":"__init__"},{"location":"aea/api/contracts/base/#id","text":"| @property | id () -> PublicId Get the name.","title":"id"},{"location":"aea/api/contracts/base/#configuration","text":"| @property | configuration () -> ContractConfig Get the configuration.","title":"configuration"},{"location":"aea/api/contracts/base/#get_instance","text":"| @classmethod | get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance","title":"get_instance"},{"location":"aea/api/contracts/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , ** kwargs ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the contract object.","title":"from_dir"},{"location":"aea/api/contracts/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ContractConfig , ** kwargs ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. Returns : the contract object.","title":"from_config"},{"location":"aea/api/contracts/base/#get_deploy_transaction","text":"| @classmethod | get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx","title":"get_deploy_transaction"},{"location":"aea/api/contracts/base/#get_raw_transaction","text":"| @classmethod | get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx","title":"get_raw_transaction"},{"location":"aea/api/contracts/base/#get_raw_message","text":"| @classmethod | get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx","title":"get_raw_message"},{"location":"aea/api/contracts/base/#get_state","text":"| @classmethod | get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. Returns : the tx","title":"get_state"},{"location":"aea/api/crypto/base/","text":"aea.crypto.base Abstract module wrapping the public and private key cryptography and ledger api. Crypto Objects class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , ** kwargs ) Initialize the crypto object. The actual behaivour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. kwargs : keyword arguments. generate _ private _ key | @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent. load _ private _ key _ from _ path | @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str ) -> EntityClass Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the entity object. entity | @property | entity () -> EntityClass Return an entity object. Returns : an entity object private _ key | @property | @abstractmethod | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string address | @property | @abstractmethod | address () -> str Return the address. Returns : an address string sign _ message | @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | @abstractmethod | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in dict form. Arguments : transaction : the transaction to be signed Returns : signed transaction dump | @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None Helper Objects class Helper ( ABC ) Interface for helper class usable as Mixin for LedgerApi or as standalone class. is _ transaction _ settled | @staticmethod | @abstractmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. is _ transaction _ valid | @staticmethod | @abstractmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | @abstractmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | @abstractmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | @abstractmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @classmethod | @abstractmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate load _ contract _ interface | @classmethod | @abstractmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface LedgerApi Objects class LedgerApi ( Helper , ABC ) Interface for ledger APIs. api | @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. get _ balance | @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance. get _ state | @abstractmethod | get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the underlying ledger API. This usually takes the form of a web request to be waited synchronously. Arguments : callable_name : the name of the API function to be called. args : the positional arguments for the API function. kwargs : the keyword arguments for the API function. Returns : the ledger API response. get _ transfer _ transaction | @abstractmethod | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx Returns : the transfer transaction send _ signed _ transaction | @abstractmethod | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction get _ transaction _ receipt | @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | @abstractmethod | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | @abstractmethod | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance get _ deploy _ transaction | @abstractmethod | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. :returns tx: the transaction dictionary. update _ with _ gas _ estimate | @abstractmethod | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction FaucetApi Objects class FaucetApi ( ABC ) Interface for testnet faucet APIs. get _ wealth | @abstractmethod | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"Base"},{"location":"aea/api/crypto/base/#aeacryptobase","text":"Abstract module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.base"},{"location":"aea/api/crypto/base/#crypto-objects","text":"class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object.","title":"Crypto Objects"},{"location":"aea/api/crypto/base/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , ** kwargs ) Initialize the crypto object. The actual behaivour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. kwargs : keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/base/#generate_private_key","text":"| @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent.","title":"generate_private_key"},{"location":"aea/api/crypto/base/#load_private_key_from_path","text":"| @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str ) -> EntityClass Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the entity object.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/base/#entity","text":"| @property | entity () -> EntityClass Return an entity object. Returns : an entity object","title":"entity"},{"location":"aea/api/crypto/base/#private_key","text":"| @property | @abstractmethod | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/crypto/base/#public_key","text":"| @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string","title":"public_key"},{"location":"aea/api/crypto/base/#address","text":"| @property | @abstractmethod | address () -> str Return the address. Returns : an address string","title":"address"},{"location":"aea/api/crypto/base/#sign_message","text":"| @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/base/#sign_transaction","text":"| @abstractmethod | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in dict form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/base/#dump","text":"| @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/base/#helper-objects","text":"class Helper ( ABC ) Interface for helper class usable as Mixin for LedgerApi or as standalone class.","title":"Helper Objects"},{"location":"aea/api/crypto/base/#is_transaction_settled","text":"| @staticmethod | @abstractmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/base/#is_transaction_valid","text":"| @staticmethod | @abstractmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/base/#generate_tx_nonce","text":"| @staticmethod | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/base/#get_address_from_public_key","text":"| @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/base/#recover_message","text":"| @classmethod | @abstractmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/base/#recover_public_keys_from_message","text":"| @classmethod | @abstractmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/crypto/base/#get_hash","text":"| @staticmethod | @abstractmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/base/#is_valid_address","text":"| @classmethod | @abstractmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"is_valid_address"},{"location":"aea/api/crypto/base/#load_contract_interface","text":"| @classmethod | @abstractmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/crypto/base/#ledgerapi-objects","text":"class LedgerApi ( Helper , ABC ) Interface for ledger APIs.","title":"LedgerApi Objects"},{"location":"aea/api/crypto/base/#api","text":"| @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None.","title":"api"},{"location":"aea/api/crypto/base/#get_balance","text":"| @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance.","title":"get_balance"},{"location":"aea/api/crypto/base/#get_state","text":"| @abstractmethod | get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the underlying ledger API. This usually takes the form of a web request to be waited synchronously. Arguments : callable_name : the name of the API function to be called. args : the positional arguments for the API function. kwargs : the keyword arguments for the API function. Returns : the ledger API response.","title":"get_state"},{"location":"aea/api/crypto/base/#get_transfer_transaction","text":"| @abstractmethod | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/crypto/base/#send_signed_transaction","text":"| @abstractmethod | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction","title":"send_signed_transaction"},{"location":"aea/api/crypto/base/#get_transaction_receipt","text":"| @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/base/#get_transaction","text":"| @abstractmethod | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/base/#get_contract_instance","text":"| @abstractmethod | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/crypto/base/#get_deploy_transaction","text":"| @abstractmethod | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. :returns tx: the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/crypto/base/#update_with_gas_estimate","text":"| @abstractmethod | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction","title":"update_with_gas_estimate"},{"location":"aea/api/crypto/base/#faucetapi-objects","text":"class FaucetApi ( ABC ) Interface for testnet faucet APIs.","title":"FaucetApi Objects"},{"location":"aea/api/crypto/base/#get_wealth","text":"| @abstractmethod | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/cosmos/","text":"aea.crypto.cosmos Cosmos module wrapping the public and private key cryptography and ledger api. CosmosHelper Objects class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class. is _ transaction _ settled | @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. is _ transaction _ valid | @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate load _ contract _ interface | @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface CosmosCrypto Objects class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent private _ key | @property | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key | @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network. dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None _ CosmosApi Objects class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Cosmos ledger APIs. api | @property | api () -> None Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state | get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. get _ deploy _ transaction | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs ) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. :returns tx: the transaction dictionary. get _ handle _ transaction | get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). Returns : the unsigned CosmWasm HandleMsg execute _ contract _ query | execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt get _ transfer _ transaction | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = 80000 , memo : str = \"\" , chain_id : Optional [ str ] = None , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. Returns : the transfer transaction send _ signed _ transaction | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present is _ cosmwasm _ transaction | @staticmethod | is_cosmwasm_transaction ( tx_signed : JSONLike ) -> bool Check whether it is a cosmwasm tx. is _ transfer _ transaction | @staticmethod | is_transfer_transaction ( tx_signed : JSONLike ) -> bool Check whether it is a transfer tx. get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance get _ last _ code _ id | get_last_code_id () -> int Get ID of latest deployed .wasm bytecode. Returns : code id of last deployed .wasm bytecode get _ contract _ address | get_contract_address ( code_id : int ) -> str Get contract address of latest initialised contract by its ID. Arguments : code_id : id of deployed CosmWasm bytecode Returns : contract address of last initialised contract update _ with _ gas _ estimate | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction CosmosApi Objects class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs. CosmosFaucetApi Objects class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API. __ init __ | __init__ ( poll_interval = None ) Initialize CosmosFaucetApi. get _ wealth | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None :raises: RuntimeError of explicit faucet failures","title":"Cosmos"},{"location":"aea/api/crypto/cosmos/#aeacryptocosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.cosmos"},{"location":"aea/api/crypto/cosmos/#cosmoshelper-objects","text":"class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class.","title":"CosmosHelper Objects"},{"location":"aea/api/crypto/cosmos/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/cosmos/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/cosmos/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/cosmos/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/cosmos/#recover_message","text":"| @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/cosmos/#recover_public_keys_from_message","text":"| @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/crypto/cosmos/#get_hash","text":"| @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/cosmos/#is_valid_address","text":"| @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"is_valid_address"},{"location":"aea/api/crypto/cosmos/#load_contract_interface","text":"| @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/crypto/cosmos/#cosmoscrypto-objects","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto Objects"},{"location":"aea/api/crypto/cosmos/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/cosmos/#private_key","text":"| @property | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/crypto/cosmos/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/cosmos/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/cosmos/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/cosmos/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/cosmos/#sign_transaction","text":"| sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/cosmos/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"aea/api/crypto/cosmos/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/cosmos/#_cosmosapi-objects","text":"class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"_CosmosApi Objects"},{"location":"aea/api/crypto/cosmos/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the Cosmos ledger APIs.","title":"__init__"},{"location":"aea/api/crypto/cosmos/#api","text":"| @property | api () -> None Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/cosmos/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/cosmos/#get_state","text":"| get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args.","title":"get_state"},{"location":"aea/api/crypto/cosmos/#get_deploy_transaction","text":"| get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs ) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. :returns tx: the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/crypto/cosmos/#get_handle_transaction","text":"| get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). Returns : the unsigned CosmWasm HandleMsg","title":"get_handle_transaction"},{"location":"aea/api/crypto/cosmos/#execute_contract_query","text":"| execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt","title":"execute_contract_query"},{"location":"aea/api/crypto/cosmos/#get_transfer_transaction","text":"| get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = 80000 , memo : str = \"\" , chain_id : Optional [ str ] = None , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/crypto/cosmos/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/cosmos/#is_cosmwasm_transaction","text":"| @staticmethod | is_cosmwasm_transaction ( tx_signed : JSONLike ) -> bool Check whether it is a cosmwasm tx.","title":"is_cosmwasm_transaction"},{"location":"aea/api/crypto/cosmos/#is_transfer_transaction","text":"| @staticmethod | is_transfer_transaction ( tx_signed : JSONLike ) -> bool Check whether it is a transfer tx.","title":"is_transfer_transaction"},{"location":"aea/api/crypto/cosmos/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/cosmos/#get_transaction","text":"| get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/cosmos/#get_contract_instance","text":"| get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/crypto/cosmos/#get_last_code_id","text":"| get_last_code_id () -> int Get ID of latest deployed .wasm bytecode. Returns : code id of last deployed .wasm bytecode","title":"get_last_code_id"},{"location":"aea/api/crypto/cosmos/#get_contract_address","text":"| get_contract_address ( code_id : int ) -> str Get contract address of latest initialised contract by its ID. Arguments : code_id : id of deployed CosmWasm bytecode Returns : contract address of last initialised contract","title":"get_contract_address"},{"location":"aea/api/crypto/cosmos/#update_with_gas_estimate","text":"| update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction","title":"update_with_gas_estimate"},{"location":"aea/api/crypto/cosmos/#cosmosapi-objects","text":"class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"CosmosApi Objects"},{"location":"aea/api/crypto/cosmos/#cosmosfaucetapi-objects","text":"class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API.","title":"CosmosFaucetApi Objects"},{"location":"aea/api/crypto/cosmos/#__init___2","text":"| __init__ ( poll_interval = None ) Initialize CosmosFaucetApi.","title":"__init__"},{"location":"aea/api/crypto/cosmos/#get_wealth","text":"| get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None :raises: RuntimeError of explicit faucet failures","title":"get_wealth"},{"location":"aea/api/crypto/ethereum/","text":"aea.crypto.ethereum Ethereum module wrapping the public and private key cryptography and ledger api. SignedTransactionTranslator Objects class SignedTransactionTranslator () Translator for SignedTransaction. to _ dict | @staticmethod | to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict. from _ dict | @staticmethod | from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict. AttributeDictTranslator Objects class AttributeDictTranslator () Translator for AttributeDict. to _ dict | @classmethod | to_dict ( cls , attr_dict : AttributeDict ) -> JSONLike Simplify to dict. from _ dict | @classmethod | from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict. EthereumCrypto Objects class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent private _ key | @property | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key | @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network. dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None EthereumHelper Objects class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class. is _ transaction _ settled | @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. is _ transaction _ valid | @staticmethod | is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. load _ contract _ interface | @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface EthereumApi Objects class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs. api | @property | api () -> Web3 Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state | get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the ledger API. get _ transfer _ transaction | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : Optional [ int ] = None , gas_price : Optional [ str ] = None , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 3 (i.e. ropsten; mainnet has 1). gas_price : the gas price Returns : the transfer transaction update _ with _ gas _ estimate | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction send _ signed _ transaction | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance get _ deploy _ transaction | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , value : int = 0 , gas : int = 0 , ** kwargs , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. value : value to send to contract (ETH in Wei) gas : the gas to be used :returns tx: the transaction dictionary. is _ valid _ address | @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate EthereumFaucetApi Objects class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API. get _ wealth | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"Ethereum"},{"location":"aea/api/crypto/ethereum/#aeacryptoethereum","text":"Ethereum module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.ethereum"},{"location":"aea/api/crypto/ethereum/#signedtransactiontranslator-objects","text":"class SignedTransactionTranslator () Translator for SignedTransaction.","title":"SignedTransactionTranslator Objects"},{"location":"aea/api/crypto/ethereum/#to_dict","text":"| @staticmethod | to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict.","title":"to_dict"},{"location":"aea/api/crypto/ethereum/#from_dict","text":"| @staticmethod | from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict.","title":"from_dict"},{"location":"aea/api/crypto/ethereum/#attributedicttranslator-objects","text":"class AttributeDictTranslator () Translator for AttributeDict.","title":"AttributeDictTranslator Objects"},{"location":"aea/api/crypto/ethereum/#to_dict_1","text":"| @classmethod | to_dict ( cls , attr_dict : AttributeDict ) -> JSONLike Simplify to dict.","title":"to_dict"},{"location":"aea/api/crypto/ethereum/#from_dict_1","text":"| @classmethod | from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict.","title":"from_dict"},{"location":"aea/api/crypto/ethereum/#ethereumcrypto-objects","text":"class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger.","title":"EthereumCrypto Objects"},{"location":"aea/api/crypto/ethereum/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/ethereum/#private_key","text":"| @property | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/crypto/ethereum/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/ethereum/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/ethereum/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/ethereum/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/ethereum/#sign_transaction","text":"| sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/ethereum/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network.","title":"generate_private_key"},{"location":"aea/api/crypto/ethereum/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/ethereum/#ethereumhelper-objects","text":"class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class.","title":"EthereumHelper Objects"},{"location":"aea/api/crypto/ethereum/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/ethereum/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/ethereum/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ethereum/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/ethereum/#recover_message","text":"| @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/ethereum/#recover_public_keys_from_message","text":"| @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/crypto/ethereum/#get_hash","text":"| @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/ethereum/#load_contract_interface","text":"| @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/crypto/ethereum/#ethereumapi-objects","text":"class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs.","title":"EthereumApi Objects"},{"location":"aea/api/crypto/ethereum/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs.","title":"__init__"},{"location":"aea/api/crypto/ethereum/#api","text":"| @property | api () -> Web3 Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/ethereum/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/ethereum/#get_state","text":"| get_state ( callable_name : str , * args , ** kwargs ) -> Optional [ JSONLike ] Call a specified function on the ledger API.","title":"get_state"},{"location":"aea/api/crypto/ethereum/#get_transfer_transaction","text":"| get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : Optional [ int ] = None , gas_price : Optional [ str ] = None , ** kwargs , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx chain_id : the Chain ID of the Ethereum transaction. Default is 3 (i.e. ropsten; mainnet has 1). gas_price : the gas price Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/crypto/ethereum/#update_with_gas_estimate","text":"| update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction","title":"update_with_gas_estimate"},{"location":"aea/api/crypto/ethereum/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/ethereum/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/ethereum/#get_transaction","text":"| get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/ethereum/#get_contract_instance","text":"| get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/crypto/ethereum/#get_deploy_transaction","text":"| get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , value : int = 0 , gas : int = 0 , ** kwargs , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. value : value to send to contract (ETH in Wei) gas : the gas to be used :returns tx: the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/crypto/ethereum/#is_valid_address","text":"| @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"is_valid_address"},{"location":"aea/api/crypto/ethereum/#ethereumfaucetapi-objects","text":"class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API.","title":"EthereumFaucetApi Objects"},{"location":"aea/api/crypto/ethereum/#get_wealth","text":"| get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/fetchai/","text":"aea.crypto.fetchai Fetchai module wrapping the public and private key cryptography and ledger api. FetchAIHelper Objects class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class. FetchAICrypto Objects class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger. FetchAIApi Objects class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Fetch.ai ledger APIs. FetchAIFaucetApi Objects class FetchAIFaucetApi ( CosmosFaucetApi ) Fetchai testnet faucet API.","title":"Fetchai"},{"location":"aea/api/crypto/fetchai/#aeacryptofetchai","text":"Fetchai module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.fetchai"},{"location":"aea/api/crypto/fetchai/#fetchaihelper-objects","text":"class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class.","title":"FetchAIHelper Objects"},{"location":"aea/api/crypto/fetchai/#fetchaicrypto-objects","text":"class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger.","title":"FetchAICrypto Objects"},{"location":"aea/api/crypto/fetchai/#fetchaiapi-objects","text":"class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs.","title":"FetchAIApi Objects"},{"location":"aea/api/crypto/fetchai/#__init__","text":"| __init__ ( ** kwargs ) Initialize the Fetch.ai ledger APIs.","title":"__init__"},{"location":"aea/api/crypto/fetchai/#fetchaifaucetapi-objects","text":"class FetchAIFaucetApi ( CosmosFaucetApi ) Fetchai testnet faucet API.","title":"FetchAIFaucetApi Objects"},{"location":"aea/api/crypto/helpers/","text":"aea.crypto.helpers Module wrapping the helpers of public and private key cryptography. try _ validate _ private _ key _ path try_validate_private_key_path ( ledger_id : str , private_key_path : str , exit_on_error : bool = True ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. Returns : None :raises: ValueError if the identifier is invalid. create _ private _ key create_private_key ( ledger_id : str , private_key_file : str ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. Returns : None :raises: ValueError if the identifier is invalid. try _ generate _ testnet _ wealth try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused Returns : None private _ key _ verify _ or _ create private_key_verify_or_create ( aea_conf : AgentConfig , aea_project_path : Path , create_keys : bool = True ) -> None Check key or create if none present. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. Returns : None make _ certificate make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str ) -> str Create certificate.","title":"Helpers"},{"location":"aea/api/crypto/helpers/#aeacryptohelpers","text":"Module wrapping the helpers of public and private key cryptography.","title":"aea.crypto.helpers"},{"location":"aea/api/crypto/helpers/#try_validate_private_key_path","text":"try_validate_private_key_path ( ledger_id : str , private_key_path : str , exit_on_error : bool = True ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. Returns : None :raises: ValueError if the identifier is invalid.","title":"try_validate_private_key_path"},{"location":"aea/api/crypto/helpers/#create_private_key","text":"create_private_key ( ledger_id : str , private_key_file : str ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. Returns : None :raises: ValueError if the identifier is invalid.","title":"create_private_key"},{"location":"aea/api/crypto/helpers/#try_generate_testnet_wealth","text":"try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused Returns : None","title":"try_generate_testnet_wealth"},{"location":"aea/api/crypto/helpers/#private_key_verify_or_create","text":"private_key_verify_or_create ( aea_conf : AgentConfig , aea_project_path : Path , create_keys : bool = True ) -> None Check key or create if none present. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. Returns : None","title":"private_key_verify_or_create"},{"location":"aea/api/crypto/helpers/#make_certificate","text":"make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str ) -> str Create certificate.","title":"make_certificate"},{"location":"aea/api/crypto/ledger_apis/","text":"aea.crypto.ledger _ apis Module wrapping all the public and private keys cryptography. LedgerApis Objects class LedgerApis () Store all the ledger apis we initialise. has _ ledger | @staticmethod | has_ledger ( identifier : str ) -> bool Check if it has the api. get _ api | @classmethod | get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API. get _ balance | @classmethod | get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance get _ transfer _ transaction | @classmethod | get_transfer_transaction ( cls , identifier : str , sender_address : str , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs , ,) -> Optional [ Any ] Get a transaction to transfer from self to destination. Arguments : identifier : the identifier of the ledger sender_address : the address of the sender destination_address : the address of the receiver amount : the amount tx_nonce : verifies the authenticity of the tx tx_fee : the tx fee Returns : tx send _ signed _ transaction | @classmethod | send_signed_transaction ( cls , identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : identifier : the identifier of the ledger tx_signed : the signed transaction Returns : the tx_digest, if present get _ transaction _ receipt | @classmethod | get_transaction_receipt ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | @classmethod | get_transaction ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx, if present is _ transaction _ settled | @staticmethod | is_transaction_settled ( identifier : str , tx_receipt : Any ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction digest Returns : True if correctly settled, False otherwise is _ transaction _ valid | @staticmethod | is_transaction_valid ( identifier : str , tx : Any , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid. Arguments : identifier : Ledger identifier tx : the transaction seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. recover _ message | @staticmethod | recover_message ( identifier : str , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : identifier : ledger identifier. message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses get _ hash | @staticmethod | get_hash ( identifier : str , message : bytes ) -> str Get the hash of a message. Arguments : identifier : ledger identifier. message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @staticmethod | is_valid_address ( identifier : str , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#aeacryptoledger_apis","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.ledger_apis"},{"location":"aea/api/crypto/ledger_apis/#ledgerapis-objects","text":"class LedgerApis () Store all the ledger apis we initialise.","title":"LedgerApis Objects"},{"location":"aea/api/crypto/ledger_apis/#has_ledger","text":"| @staticmethod | has_ledger ( identifier : str ) -> bool Check if it has the api.","title":"has_ledger"},{"location":"aea/api/crypto/ledger_apis/#get_api","text":"| @classmethod | get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API.","title":"get_api"},{"location":"aea/api/crypto/ledger_apis/#get_balance","text":"| @classmethod | get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance","title":"get_balance"},{"location":"aea/api/crypto/ledger_apis/#get_transfer_transaction","text":"| @classmethod | get_transfer_transaction ( cls , identifier : str , sender_address : str , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs , ,) -> Optional [ Any ] Get a transaction to transfer from self to destination. Arguments : identifier : the identifier of the ledger sender_address : the address of the sender destination_address : the address of the receiver amount : the amount tx_nonce : verifies the authenticity of the tx tx_fee : the tx fee Returns : tx","title":"get_transfer_transaction"},{"location":"aea/api/crypto/ledger_apis/#send_signed_transaction","text":"| @classmethod | send_signed_transaction ( cls , identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : identifier : the identifier of the ledger tx_signed : the signed transaction Returns : the tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/ledger_apis/#get_transaction_receipt","text":"| @classmethod | get_transaction_receipt ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/ledger_apis/#get_transaction","text":"| @classmethod | get_transaction ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( identifier : str , tx_receipt : Any ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction digest Returns : True if correctly settled, False otherwise","title":"is_transaction_settled"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( identifier : str , tx : Any , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid. Arguments : identifier : Ledger identifier tx : the transaction seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise","title":"is_transaction_valid"},{"location":"aea/api/crypto/ledger_apis/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ledger_apis/#recover_message","text":"| @staticmethod | recover_message ( identifier : str , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : identifier : ledger identifier. message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/ledger_apis/#get_hash","text":"| @staticmethod | get_hash ( identifier : str , message : bytes ) -> str Get the hash of a message. Arguments : identifier : ledger identifier. message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/ledger_apis/#is_valid_address","text":"| @staticmethod | is_valid_address ( identifier : str , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"is_valid_address"},{"location":"aea/api/crypto/wallet/","text":"aea.crypto.wallet Module wrapping all the public and private keys cryptography. CryptoStore Objects class CryptoStore () Utility class to store and retrieve crypto objects. __ init __ | __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key. public _ keys | @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects | @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys | @property | private_keys () -> Dict [ str , str ] Get the crypto addresses. Wallet Objects class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication. __ init __ | __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections. public _ keys | @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects | @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys | @property | private_keys () -> Dict [ str , str ] Get the crypto addresses. main _ cryptos | @property | main_cryptos () -> CryptoStore Get the main crypto store. connection _ cryptos | @property | connection_cryptos () -> CryptoStore Get the connection crypto store. sign _ message | sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message sign _ transaction | sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"Wallet"},{"location":"aea/api/crypto/wallet/#aeacryptowallet","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.wallet"},{"location":"aea/api/crypto/wallet/#cryptostore-objects","text":"class CryptoStore () Utility class to store and retrieve crypto objects.","title":"CryptoStore Objects"},{"location":"aea/api/crypto/wallet/#__init__","text":"| __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key.","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys","text":"| @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects","text":"| @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/crypto/wallet/#private_keys","text":"| @property | private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"aea/api/crypto/wallet/#wallet-objects","text":"class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication.","title":"Wallet Objects"},{"location":"aea/api/crypto/wallet/#__init___1","text":"| __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections.","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys_1","text":"| @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects_1","text":"| @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses_1","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/crypto/wallet/#private_keys_1","text":"| @property | private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"aea/api/crypto/wallet/#main_cryptos","text":"| @property | main_cryptos () -> CryptoStore Get the main crypto store.","title":"main_cryptos"},{"location":"aea/api/crypto/wallet/#connection_cryptos","text":"| @property | connection_cryptos () -> CryptoStore Get the connection crypto store.","title":"connection_cryptos"},{"location":"aea/api/crypto/wallet/#sign_message","text":"| sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message","title":"sign_message"},{"location":"aea/api/crypto/wallet/#sign_transaction","text":"| sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"sign_transaction"},{"location":"aea/api/crypto/registries/base/","text":"aea.crypto.registries.base This module implements the base registry. ItemId Objects class ItemId ( RegexConstrainedString ) The identifier of an item class. name | @property | name () Get the id name. EntryPoint Objects class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className __ init __ | __init__ ( seq ) Initialize the entrypoint. import _ path | @property | import_path () -> str Get the import path. class _ name | @property | class_name () -> str Get the class name. load | load () -> Type [ ItemType ] Load the item object. Returns : the cyrpto object, loaded following the spec. ItemSpec Objects class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object. __ init __ | __init__ ( id_ : ItemId , entry_point : EntryPoint [ ItemType ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Dict , ,) Initialize an item specification. Arguments : id_ : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : other custom keyword arguments. make | make ( ** kwargs ) -> ItemType Instantiate an instance of the item object with appropriate arguments. Arguments : kwargs : the key word arguments Returns : an item get _ class | get_class () -> Type [ ItemType ] Get the class of the item with class variables instantiated. Returns : an item class Registry Objects class Registry ( Generic [ ItemType ]) Registry for generic classes. __ init __ | __init__ () Initialize the registry. supported _ ids | @property | supported_ids () -> Set [ str ] Get the supported item ids. register | register ( id_ : Union [ ItemId , str ], entry_point : Union [ EntryPoint [ ItemType ], str ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs , ,) Register an item type. Arguments : id_ : the identifier for the crypto type. entry_point : the entry point to load the crypto object. class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : arguments to provide to the crypto class. Returns : None. make | make ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None , ** kwargs ) -> ItemType Create an instance of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the object. Returns : the new item instance. make _ cls | make_cls ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None ) -> Type [ ItemType ] Load a class of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. Returns : the new item class. has _ spec | has_spec ( item_id : ItemId ) -> bool Check whether there exist a spec associated with an item id. Arguments : item_id : the item identifier. Returns : True if it is registered, False otherwise.","title":"Base"},{"location":"aea/api/crypto/registries/base/#aeacryptoregistriesbase","text":"This module implements the base registry.","title":"aea.crypto.registries.base"},{"location":"aea/api/crypto/registries/base/#itemid-objects","text":"class ItemId ( RegexConstrainedString ) The identifier of an item class.","title":"ItemId Objects"},{"location":"aea/api/crypto/registries/base/#name","text":"| @property | name () Get the id name.","title":"name"},{"location":"aea/api/crypto/registries/base/#entrypoint-objects","text":"class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className","title":"EntryPoint Objects"},{"location":"aea/api/crypto/registries/base/#__init__","text":"| __init__ ( seq ) Initialize the entrypoint.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#import_path","text":"| @property | import_path () -> str Get the import path.","title":"import_path"},{"location":"aea/api/crypto/registries/base/#class_name","text":"| @property | class_name () -> str Get the class name.","title":"class_name"},{"location":"aea/api/crypto/registries/base/#load","text":"| load () -> Type [ ItemType ] Load the item object. Returns : the cyrpto object, loaded following the spec.","title":"load"},{"location":"aea/api/crypto/registries/base/#itemspec-objects","text":"class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object.","title":"ItemSpec Objects"},{"location":"aea/api/crypto/registries/base/#__init___1","text":"| __init__ ( id_ : ItemId , entry_point : EntryPoint [ ItemType ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Dict , ,) Initialize an item specification. Arguments : id_ : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : other custom keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#make","text":"| make ( ** kwargs ) -> ItemType Instantiate an instance of the item object with appropriate arguments. Arguments : kwargs : the key word arguments Returns : an item","title":"make"},{"location":"aea/api/crypto/registries/base/#get_class","text":"| get_class () -> Type [ ItemType ] Get the class of the item with class variables instantiated. Returns : an item class","title":"get_class"},{"location":"aea/api/crypto/registries/base/#registry-objects","text":"class Registry ( Generic [ ItemType ]) Registry for generic classes.","title":"Registry Objects"},{"location":"aea/api/crypto/registries/base/#__init___2","text":"| __init__ () Initialize the registry.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#supported_ids","text":"| @property | supported_ids () -> Set [ str ] Get the supported item ids.","title":"supported_ids"},{"location":"aea/api/crypto/registries/base/#register","text":"| register ( id_ : Union [ ItemId , str ], entry_point : Union [ EntryPoint [ ItemType ], str ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs , ,) Register an item type. Arguments : id_ : the identifier for the crypto type. entry_point : the entry point to load the crypto object. class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : arguments to provide to the crypto class. Returns : None.","title":"register"},{"location":"aea/api/crypto/registries/base/#make_1","text":"| make ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None , ** kwargs ) -> ItemType Create an instance of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the object. Returns : the new item instance.","title":"make"},{"location":"aea/api/crypto/registries/base/#make_cls","text":"| make_cls ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None ) -> Type [ ItemType ] Load a class of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. Returns : the new item class.","title":"make_cls"},{"location":"aea/api/crypto/registries/base/#has_spec","text":"| has_spec ( item_id : ItemId ) -> bool Check whether there exist a spec associated with an item id. Arguments : item_id : the item identifier. Returns : True if it is registered, False otherwise.","title":"has_spec"},{"location":"aea/api/decision_maker/base/","text":"aea.decision _ maker.base This module contains the decision maker class. OwnershipState Objects class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger). set | @abstractmethod | set ( ** kwargs ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments Returns : None apply _ delta | @abstractmethod | apply_delta ( ** kwargs ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments Returns : None is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. is _ affordable _ transaction | @abstractmethod | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise. apply _ transactions | @abstractmethod | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state. __ copy __ | @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object. Preferences Objects class Preferences ( ABC ) Class to represent the preferences. set | @abstractmethod | set ( ** kwargs , ,) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. marginal _ utility | @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword argyments Returns : the marginal utility score utility _ diff _ from _ transaction | @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score. __ copy __ | @abstractmethod | __copy__ () -> \"Preferences\" Copy the object. ProtectedQueue Objects class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it. __ init __ | __init__ ( access_code : str ) Initialize the protected queue. Arguments : access_code : the access code to read from the queue put | put ( internal_message : Optional [ Message ], block = True , timeout = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None put _ nowait | put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None get | get ( block = True , timeout = None ) -> None Inaccessible get method. :raises: ValueError, access not permitted. Returns : None get _ nowait | get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted. Returns : None protected _ get | protected_get ( access_code : str , block = True , timeout = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message DecisionMakerHandler Objects class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker. __ init __ | __init__ ( identity : Identity , wallet : Wallet , ** kwargs ) Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet logger : the logger kwargs : the key word arguments agent _ name | @property | agent_name () -> str Get the agent name. identity | @property | identity () -> Identity Get identity of the agent. wallet | @property | wallet () -> Wallet Get wallet of the agent. context | @property | context () -> SimpleNamespace Get the context. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. handle | @abstractmethod | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None DecisionMaker Objects class DecisionMaker ( WithLogger ) This class implements the decision maker. __ init __ | __init__ ( decision_maker_handler : DecisionMakerHandler ) Initialize the decision maker. Arguments : agent_name : the agent name decision_maker_handler : the decision maker handler message _ in _ queue | @property | message_in_queue () -> ProtectedQueue Get (in) queue. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. decision _ maker _ handler | @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler. start | start () -> None Start the decision maker. stop | stop () -> None Stop the decision maker. execute | execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them Returns : None handle | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"Base"},{"location":"aea/api/decision_maker/base/#aeadecision_makerbase","text":"This module contains the decision maker class.","title":"aea.decision_maker.base"},{"location":"aea/api/decision_maker/base/#ownershipstate-objects","text":"class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger).","title":"OwnershipState Objects"},{"location":"aea/api/decision_maker/base/#set","text":"| @abstractmethod | set ( ** kwargs ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments Returns : None","title":"set"},{"location":"aea/api/decision_maker/base/#apply_delta","text":"| @abstractmethod | apply_delta ( ** kwargs ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments Returns : None","title":"apply_delta"},{"location":"aea/api/decision_maker/base/#is_initialized","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#is_affordable_transaction","text":"| @abstractmethod | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/base/#apply_transactions","text":"| @abstractmethod | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/base/#__copy__","text":"| @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#preferences-objects","text":"class Preferences ( ABC ) Class to represent the preferences.","title":"Preferences Objects"},{"location":"aea/api/decision_maker/base/#set_1","text":"| @abstractmethod | set ( ** kwargs , ,) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments","title":"set"},{"location":"aea/api/decision_maker/base/#is_initialized_1","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#marginal_utility","text":"| @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword argyments Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/base/#utility_diff_from_transaction","text":"| @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/base/#__copy___1","text":"| @abstractmethod | __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#protectedqueue-objects","text":"class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it.","title":"ProtectedQueue Objects"},{"location":"aea/api/decision_maker/base/#__init__","text":"| __init__ ( access_code : str ) Initialize the protected queue. Arguments : access_code : the access code to read from the queue","title":"__init__"},{"location":"aea/api/decision_maker/base/#put","text":"| put ( internal_message : Optional [ Message ], block = True , timeout = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None","title":"put"},{"location":"aea/api/decision_maker/base/#put_nowait","text":"| put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message Returns : None","title":"put_nowait"},{"location":"aea/api/decision_maker/base/#get","text":"| get ( block = True , timeout = None ) -> None Inaccessible get method. :raises: ValueError, access not permitted. Returns : None","title":"get"},{"location":"aea/api/decision_maker/base/#get_nowait","text":"| get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted. Returns : None","title":"get_nowait"},{"location":"aea/api/decision_maker/base/#protected_get","text":"| protected_get ( access_code : str , block = True , timeout = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message","title":"protected_get"},{"location":"aea/api/decision_maker/base/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"aea/api/decision_maker/base/#__init___1","text":"| __init__ ( identity : Identity , wallet : Wallet , ** kwargs ) Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet logger : the logger kwargs : the key word arguments","title":"__init__"},{"location":"aea/api/decision_maker/base/#agent_name","text":"| @property | agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"aea/api/decision_maker/base/#identity","text":"| @property | identity () -> Identity Get identity of the agent.","title":"identity"},{"location":"aea/api/decision_maker/base/#wallet","text":"| @property | wallet () -> Wallet Get wallet of the agent.","title":"wallet"},{"location":"aea/api/decision_maker/base/#context","text":"| @property | context () -> SimpleNamespace Get the context.","title":"context"},{"location":"aea/api/decision_maker/base/#message_out_queue","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/decision_maker/base/#decisionmaker-objects","text":"class DecisionMaker ( WithLogger ) This class implements the decision maker.","title":"DecisionMaker Objects"},{"location":"aea/api/decision_maker/base/#__init___2","text":"| __init__ ( decision_maker_handler : DecisionMakerHandler ) Initialize the decision maker. Arguments : agent_name : the agent name decision_maker_handler : the decision maker handler","title":"__init__"},{"location":"aea/api/decision_maker/base/#message_in_queue","text":"| @property | message_in_queue () -> ProtectedQueue Get (in) queue.","title":"message_in_queue"},{"location":"aea/api/decision_maker/base/#message_out_queue_1","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#decision_maker_handler","text":"| @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler.","title":"decision_maker_handler"},{"location":"aea/api/decision_maker/base/#start","text":"| start () -> None Start the decision maker.","title":"start"},{"location":"aea/api/decision_maker/base/#stop","text":"| stop () -> None Stop the decision maker.","title":"stop"},{"location":"aea/api/decision_maker/base/#execute","text":"| execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them Returns : None","title":"execute"},{"location":"aea/api/decision_maker/base/#handle_1","text":"| handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/decision_maker/default/","text":"aea.decision _ maker.default This module contains the decision maker class. GoalPursuitReadiness Objects class GoalPursuitReadiness () The goal pursuit readiness. Status Objects class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal __ init __ | __init__ () Instantiate the goal pursuit readiness. is _ ready | @property | is_ready () -> bool Get the readiness. update | update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status Returns : None OwnershipState Objects class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent (can proxy a ledger). __ init __ | __init__ () Instantiate an ownership state object. Arguments : decision_maker : the decision maker set | set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state. apply _ delta | apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good Returns : None is _ initialized | @property | is_initialized () -> bool Get the initialization status. amount _ by _ currency _ id | @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state. quantities _ by _ good _ id | @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state. is _ affordable _ transaction | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise. is _ affordable | is_affordable ( terms : Terms ) -> bool Check if the tx is affordable. Arguments : terms : the transaction terms Returns : whether the transaction is affordable or not update | update ( terms : Terms ) -> None Update the agent state from a transaction. Arguments : terms : the transaction terms Returns : None apply _ transactions | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state. __ copy __ | __copy__ () -> \"OwnershipState\" Copy the object. Preferences Objects class Preferences ( BasePreferences ) Class to represent the preferences. __ init __ | __init__ () Instantiate an agent preference object. set | set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , ** kwargs , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset. is _ initialized | @property | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good. logarithmic _ utility | logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value linear _ utility | linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value utility | utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value. marginal _ utility | marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings Returns : the marginal utility score utility _ diff _ from _ transaction | utility_diff_from_transaction ( ownership_state : BaseOwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score. is _ utility _ enhancing | is_utility_enhancing ( ownership_state : BaseOwnershipState , terms : Terms ) -> bool Check if the tx is utility enhancing. Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms Returns : whether the transaction is utility enhancing or not __ copy __ | __copy__ () -> \"Preferences\" Copy the object. DecisionMakerHandler Objects class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker. SigningDialogues Objects class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues. __ init __ | __init__ ( self_address : Address , ** kwargs ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None StateUpdateDialogues Objects class StateUpdateDialogues ( BaseStateUpdateDialogues ) This class keeps track of all oef_search dialogues. __ init __ | __init__ ( self_address : Address , ** kwargs ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None __ init __ | __init__ ( identity : Identity , wallet : Wallet ) Initialize the decision maker. Arguments : identity : the identity wallet : the wallet handle | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"Default"},{"location":"aea/api/decision_maker/default/#aeadecision_makerdefault","text":"This module contains the decision maker class.","title":"aea.decision_maker.default"},{"location":"aea/api/decision_maker/default/#goalpursuitreadiness-objects","text":"class GoalPursuitReadiness () The goal pursuit readiness.","title":"GoalPursuitReadiness Objects"},{"location":"aea/api/decision_maker/default/#status-objects","text":"class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal","title":"Status Objects"},{"location":"aea/api/decision_maker/default/#__init__","text":"| __init__ () Instantiate the goal pursuit readiness.","title":"__init__"},{"location":"aea/api/decision_maker/default/#is_ready","text":"| @property | is_ready () -> bool Get the readiness.","title":"is_ready"},{"location":"aea/api/decision_maker/default/#update","text":"| update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status Returns : None","title":"update"},{"location":"aea/api/decision_maker/default/#ownershipstate-objects","text":"class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent (can proxy a ledger).","title":"OwnershipState Objects"},{"location":"aea/api/decision_maker/default/#__init___1","text":"| __init__ () Instantiate an ownership state object. Arguments : decision_maker : the decision maker","title":"__init__"},{"location":"aea/api/decision_maker/default/#set","text":"| set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state.","title":"set"},{"location":"aea/api/decision_maker/default/#apply_delta","text":"| apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good Returns : None","title":"apply_delta"},{"location":"aea/api/decision_maker/default/#is_initialized","text":"| @property | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/default/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state.","title":"amount_by_currency_id"},{"location":"aea/api/decision_maker/default/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state.","title":"quantities_by_good_id"},{"location":"aea/api/decision_maker/default/#is_affordable_transaction","text":"| is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/default/#is_affordable","text":"| is_affordable ( terms : Terms ) -> bool Check if the tx is affordable. Arguments : terms : the transaction terms Returns : whether the transaction is affordable or not","title":"is_affordable"},{"location":"aea/api/decision_maker/default/#update_1","text":"| update ( terms : Terms ) -> None Update the agent state from a transaction. Arguments : terms : the transaction terms Returns : None","title":"update"},{"location":"aea/api/decision_maker/default/#apply_transactions","text":"| apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/default/#__copy__","text":"| __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/default/#preferences-objects","text":"class Preferences ( BasePreferences ) Class to represent the preferences.","title":"Preferences Objects"},{"location":"aea/api/decision_maker/default/#__init___2","text":"| __init__ () Instantiate an agent preference object.","title":"__init__"},{"location":"aea/api/decision_maker/default/#set_1","text":"| set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , ** kwargs , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset.","title":"set"},{"location":"aea/api/decision_maker/default/#is_initialized_1","text":"| @property | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/default/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency.","title":"exchange_params_by_currency_id"},{"location":"aea/api/decision_maker/default/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good.","title":"utility_params_by_good_id"},{"location":"aea/api/decision_maker/default/#logarithmic_utility","text":"| logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/decision_maker/default/#linear_utility","text":"| linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/decision_maker/default/#utility","text":"| utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value.","title":"utility"},{"location":"aea/api/decision_maker/default/#marginal_utility","text":"| marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/default/#utility_diff_from_transaction","text":"| utility_diff_from_transaction ( ownership_state : BaseOwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/default/#is_utility_enhancing","text":"| is_utility_enhancing ( ownership_state : BaseOwnershipState , terms : Terms ) -> bool Check if the tx is utility enhancing. Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms Returns : whether the transaction is utility enhancing or not","title":"is_utility_enhancing"},{"location":"aea/api/decision_maker/default/#__copy___1","text":"| __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/default/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"aea/api/decision_maker/default/#signingdialogues-objects","text":"class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues.","title":"SigningDialogues Objects"},{"location":"aea/api/decision_maker/default/#__init___3","text":"| __init__ ( self_address : Address , ** kwargs ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/decision_maker/default/#stateupdatedialogues-objects","text":"class StateUpdateDialogues ( BaseStateUpdateDialogues ) This class keeps track of all oef_search dialogues.","title":"StateUpdateDialogues Objects"},{"location":"aea/api/decision_maker/default/#__init___4","text":"| __init__ ( self_address : Address , ** kwargs ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/decision_maker/default/#__init___5","text":"| __init__ ( identity : Identity , wallet : Wallet ) Initialize the decision maker. Arguments : identity : the identity wallet : the wallet","title":"__init__"},{"location":"aea/api/decision_maker/default/#handle","text":"| handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message Returns : None","title":"handle"},{"location":"aea/api/error_handler/base/","text":"aea.error _ handler.base This module contains the abstract error handler class. AbstractErrorHandler Objects class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes. send _ unsupported _ protocol | @classmethod | @abstractmethod | send_unsupported_protocol ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None send _ decoding _ error | @classmethod | @abstractmethod | send_decoding_error ( cls , envelope : Envelope , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None send _ unsupported _ skill | @classmethod | @abstractmethod | send_unsupported_skill ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"Base"},{"location":"aea/api/error_handler/base/#aeaerror_handlerbase","text":"This module contains the abstract error handler class.","title":"aea.error_handler.base"},{"location":"aea/api/error_handler/base/#abstracterrorhandler-objects","text":"class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes.","title":"AbstractErrorHandler Objects"},{"location":"aea/api/error_handler/base/#send_unsupported_protocol","text":"| @classmethod | @abstractmethod | send_unsupported_protocol ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/error_handler/base/#send_decoding_error","text":"| @classmethod | @abstractmethod | send_decoding_error ( cls , envelope : Envelope , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None","title":"send_decoding_error"},{"location":"aea/api/error_handler/base/#send_unsupported_skill","text":"| @classmethod | @abstractmethod | send_unsupported_skill ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_skill"},{"location":"aea/api/error_handler/default/","text":"aea.error _ handler.default This module contains the default error handler class. ErrorHandler Objects class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes. send _ unsupported _ protocol | @classmethod | send_unsupported_protocol ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None send _ decoding _ error | @classmethod | send_decoding_error ( cls , envelope : Envelope , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None send _ unsupported _ skill | @classmethod | send_unsupported_skill ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"Default"},{"location":"aea/api/error_handler/default/#aeaerror_handlerdefault","text":"This module contains the default error handler class.","title":"aea.error_handler.default"},{"location":"aea/api/error_handler/default/#errorhandler-objects","text":"class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes.","title":"ErrorHandler Objects"},{"location":"aea/api/error_handler/default/#send_unsupported_protocol","text":"| @classmethod | send_unsupported_protocol ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/error_handler/default/#send_decoding_error","text":"| @classmethod | send_decoding_error ( cls , envelope : Envelope , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None","title":"send_decoding_error"},{"location":"aea/api/error_handler/default/#send_unsupported_skill","text":"| @classmethod | send_unsupported_skill ( cls , envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_skill"},{"location":"aea/api/helpers/async_friendly_queue/","text":"aea.helpers.async _ friendly _ queue This module contains the implementation of AsyncFriendlyQueue. AsyncFriendlyQueue Objects class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method. __ init __ | __init__ ( * args , ** kwargs ) Init queue. put | put ( item : Any , * args , ** kwargs ) -> None Put an item into the queue. Arguments : item : item to put in the queue :param args, kwargs: similar to queue.Queue.put get | get ( * args , ** kwargs ) -> Any Get an item into the queue. :param args, kwargs: similar to queue.Queue.get async _ wait | async async_wait () -> None Wait an item appears in the queue. Returns : None async _ get | async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"Async Friendly Queue"},{"location":"aea/api/helpers/async_friendly_queue/#aeahelpersasync_friendly_queue","text":"This module contains the implementation of AsyncFriendlyQueue.","title":"aea.helpers.async_friendly_queue"},{"location":"aea/api/helpers/async_friendly_queue/#asyncfriendlyqueue-objects","text":"class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method.","title":"AsyncFriendlyQueue Objects"},{"location":"aea/api/helpers/async_friendly_queue/#__init__","text":"| __init__ ( * args , ** kwargs ) Init queue.","title":"__init__"},{"location":"aea/api/helpers/async_friendly_queue/#put","text":"| put ( item : Any , * args , ** kwargs ) -> None Put an item into the queue. Arguments : item : item to put in the queue :param args, kwargs: similar to queue.Queue.put","title":"put"},{"location":"aea/api/helpers/async_friendly_queue/#get","text":"| get ( * args , ** kwargs ) -> Any Get an item into the queue. :param args, kwargs: similar to queue.Queue.get","title":"get"},{"location":"aea/api/helpers/async_friendly_queue/#async_wait","text":"| async async_wait () -> None Wait an item appears in the queue. Returns : None","title":"async_wait"},{"location":"aea/api/helpers/async_friendly_queue/#async_get","text":"| async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"async_get"},{"location":"aea/api/helpers/async_utils/","text":"aea.helpers.async _ utils This module contains the misc utils for async code. ensure _ list ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence. AsyncState Objects class AsyncState () Awaitable state. __ init __ | __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set. set | set ( state : Any ) -> None Set state. add _ callback | add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed. Returns : None get | get () -> Any Get state. wait | async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. :params state_or_states: state or list of states. Returns : tuple of previous state and new state. transit | @contextmanager | transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default Returns : None PeriodicCaller Objects class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio. __ init __ | __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop start | start () -> None Activate period calls. stop | stop () -> None Remove from schedule. AnotherThreadTask Objects class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely. __ init __ | __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on. result | result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds. cancel | cancel () -> None Cancel coroutine task execution in a target loop. done | done () -> bool Check task is done. ThreadedAsyncRunner Objects class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside. __ init __ | __init__ ( loop = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it. start | start () -> None Start event loop in dedicated thread. run | run () -> None Run code inside thread. call | call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run. stop | stop () -> None Stop event loop in thread. AwaitableProc Objects class AwaitableProc () Async-friendly subprocess.Popen. __ init __ | __init__ ( * args , ** kwargs ) Initialise awaitable proc. start | async start () Start the subprocess. ItemGetter Objects class ItemGetter () Virtual queue like object to get items from getters function. __ init __ | __init__ ( getters : List [ Callable ]) -> None Init ItemGetter. Arguments : getters : List of couroutines to be awaited. get | async get () -> Any Get item. HandlerItemGetter Objects class HandlerItemGetter ( ItemGetter ) ItemGetter with handler passed. __ init __ | __init__ ( getters : List [ Tuple [ Callable [[ Any ], None ], Callable ]]) Init HandlerItemGetter. Arguments : getters : List of tuples of handler and couroutine to be awaiteed for an item. Runnable Objects class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed. __ init __ | __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True. Returns : None start | start () -> bool Start runnable. Returns : bool started or not. is _ running | @property | is_running () -> bool Get running state. run | @abstractmethod | async run () -> Any Implement run logic respectfull to CancelError on termination. wait _ completed | wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherise None stop | stop ( force : bool = False ) -> None Stop runnable. start _ and _ wait _ completed | start_and_wait_completed ( * args , ** kwargs ) -> Awaitable Alias for start and wait methods.","title":"Async Utils"},{"location":"aea/api/helpers/async_utils/#aeahelpersasync_utils","text":"This module contains the misc utils for async code.","title":"aea.helpers.async_utils"},{"location":"aea/api/helpers/async_utils/#ensure_list","text":"ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence.","title":"ensure_list"},{"location":"aea/api/helpers/async_utils/#asyncstate-objects","text":"class AsyncState () Awaitable state.","title":"AsyncState Objects"},{"location":"aea/api/helpers/async_utils/#__init__","text":"| __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#set","text":"| set ( state : Any ) -> None Set state.","title":"set"},{"location":"aea/api/helpers/async_utils/#add_callback","text":"| add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed. Returns : None","title":"add_callback"},{"location":"aea/api/helpers/async_utils/#get","text":"| get () -> Any Get state.","title":"get"},{"location":"aea/api/helpers/async_utils/#wait","text":"| async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. :params state_or_states: state or list of states. Returns : tuple of previous state and new state.","title":"wait"},{"location":"aea/api/helpers/async_utils/#transit","text":"| @contextmanager | transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default Returns : None","title":"transit"},{"location":"aea/api/helpers/async_utils/#periodiccaller-objects","text":"class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio.","title":"PeriodicCaller Objects"},{"location":"aea/api/helpers/async_utils/#__init___1","text":"| __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start","text":"| start () -> None Activate period calls.","title":"start"},{"location":"aea/api/helpers/async_utils/#stop","text":"| stop () -> None Remove from schedule.","title":"stop"},{"location":"aea/api/helpers/async_utils/#anotherthreadtask-objects","text":"class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely.","title":"AnotherThreadTask Objects"},{"location":"aea/api/helpers/async_utils/#__init___2","text":"| __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#result","text":"| result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds.","title":"result"},{"location":"aea/api/helpers/async_utils/#cancel","text":"| cancel () -> None Cancel coroutine task execution in a target loop.","title":"cancel"},{"location":"aea/api/helpers/async_utils/#done","text":"| done () -> bool Check task is done.","title":"done"},{"location":"aea/api/helpers/async_utils/#threadedasyncrunner-objects","text":"class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside.","title":"ThreadedAsyncRunner Objects"},{"location":"aea/api/helpers/async_utils/#__init___3","text":"| __init__ ( loop = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start_1","text":"| start () -> None Start event loop in dedicated thread.","title":"start"},{"location":"aea/api/helpers/async_utils/#run","text":"| run () -> None Run code inside thread.","title":"run"},{"location":"aea/api/helpers/async_utils/#call","text":"| call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run.","title":"call"},{"location":"aea/api/helpers/async_utils/#stop_1","text":"| stop () -> None Stop event loop in thread.","title":"stop"},{"location":"aea/api/helpers/async_utils/#awaitableproc-objects","text":"class AwaitableProc () Async-friendly subprocess.Popen.","title":"AwaitableProc Objects"},{"location":"aea/api/helpers/async_utils/#__init___4","text":"| __init__ ( * args , ** kwargs ) Initialise awaitable proc.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start_2","text":"| async start () Start the subprocess.","title":"start"},{"location":"aea/api/helpers/async_utils/#itemgetter-objects","text":"class ItemGetter () Virtual queue like object to get items from getters function.","title":"ItemGetter Objects"},{"location":"aea/api/helpers/async_utils/#__init___5","text":"| __init__ ( getters : List [ Callable ]) -> None Init ItemGetter. Arguments : getters : List of couroutines to be awaited.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#get_1","text":"| async get () -> Any Get item.","title":"get"},{"location":"aea/api/helpers/async_utils/#handleritemgetter-objects","text":"class HandlerItemGetter ( ItemGetter ) ItemGetter with handler passed.","title":"HandlerItemGetter Objects"},{"location":"aea/api/helpers/async_utils/#__init___6","text":"| __init__ ( getters : List [ Tuple [ Callable [[ Any ], None ], Callable ]]) Init HandlerItemGetter. Arguments : getters : List of tuples of handler and couroutine to be awaiteed for an item.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#runnable-objects","text":"class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed.","title":"Runnable Objects"},{"location":"aea/api/helpers/async_utils/#__init___7","text":"| __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True. Returns : None","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start_3","text":"| start () -> bool Start runnable. Returns : bool started or not.","title":"start"},{"location":"aea/api/helpers/async_utils/#is_running","text":"| @property | is_running () -> bool Get running state.","title":"is_running"},{"location":"aea/api/helpers/async_utils/#run_1","text":"| @abstractmethod | async run () -> Any Implement run logic respectfull to CancelError on termination.","title":"run"},{"location":"aea/api/helpers/async_utils/#wait_completed","text":"| wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherise None","title":"wait_completed"},{"location":"aea/api/helpers/async_utils/#stop_2","text":"| stop ( force : bool = False ) -> None Stop runnable.","title":"stop"},{"location":"aea/api/helpers/async_utils/#start_and_wait_completed","text":"| start_and_wait_completed ( * args , ** kwargs ) -> Awaitable Alias for start and wait methods.","title":"start_and_wait_completed"},{"location":"aea/api/helpers/base/","text":"aea.helpers.base Miscellaneous helpers. locate locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary. load _ module load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Returns : None Raises : ValueError : if the filepath provided is not a module. Exception : if the execution of the module raises exception. load _ env _ file load_env_file ( env_file : str ) Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file. Returns : None. sigint _ crossplatform sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. Returns : None win _ popen _ kwargs win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32 send _ control _ c send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C crossplatform to terminate a subprocess. Arguments : process : the process to send the signal to. Returns : None RegexConstrainedString Objects class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour. __ init __ | __init__ ( seq ) Initialize a regex constrained string. SimpleId Objects class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') cd @contextlib . contextmanager cd ( path ) Change working directory temporarily. get _ logger _ method get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definion module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with try _ decorator try_decorator ( error_message : str , default_return = None , logger_method = \"error\" ) Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs MaxRetriesError Objects class MaxRetriesError ( Exception ) Exception for retry decorator. retry _ decorator retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method = \"error\" ) Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : num of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs exception _ log _ and _ reraise @contextlib . contextmanager exception_log_and_reraise ( log_method : Callable , message : str ) Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text. recursive _ update recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. Returns : None find _ topological _ order find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Returns : the topological order for the graph (as a sequence of nodes) Raises : ValueError : if the graph contains a cycle. reachable _ nodes reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph. cached _ property Objects class cached_property () Cached property from python3.8 functools. __ init __ | __init__ ( func ) Init cached property. __ set _ name __ | __set_name__ ( _ , name ) Set name. __ get __ | __get__ ( instance , _ = None ) Get instance. ensure _ dir ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it. dict _ to _ path _ value dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value. parse _ datetime _ from _ str parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string. CertRequest Objects class CertRequest () Certificate request for proof of representation. __ init __ | __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , save_path : str ) Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC. not_before : specify the lower bound for certificate validity. if it is a string, it must follow the format: 'YYYY-MM-DD' It will be interpreted as timezone UTC-0. save_path : the save_path where to save the certificate. public _ key | @property | public_key () -> Optional [ str ] Get the public key. ledger _ id | @property | ledger_id () -> str Get the ledger id. key _ identifier | @property | key_identifier () -> Optional [ str ] Get the key identifier. identifier | @property | identifier () -> str Get the identifier. not _ before _ string | @property | not_before_string () -> str Get the not_before field as string. not _ after _ string | @property | not_after_string () -> str Get the not_after field as string. not _ before | @property | not_before () -> datetime . datetime Get the not_before field. not _ after | @property | not_after () -> datetime . datetime Get the not_after field. save _ path | @property | save_path () -> Path Get the save_path public _ key _ or _ identifier | @property | public_key_or_identifier () -> str Get the public key or identifier. get _ message | get_message ( public_key : str ) -> bytes Get the message to sign. get _ signature | get_signature () -> str Get signature from save_path. json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation. __ eq __ | __eq__ ( other ) Check equality. compute _ specifier _ from _ version compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version, by varying only on the patch number. I.e. from \"{major}.{minor}.{patch}\", return \">={major}.{minor}.0, <{major}.{minor + 1}.0\" Arguments : version : the version Returns : the specifier set decorator _ with _ optional _ params decorator_with_optional_params ( decorator ) Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ... delete _ directory _ contents delete_directory_contents ( directory : Path ) Delete the content of a directory, without deleting it.","title":"Base"},{"location":"aea/api/helpers/base/#aeahelpersbase","text":"Miscellaneous helpers.","title":"aea.helpers.base"},{"location":"aea/api/helpers/base/#locate","text":"locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary.","title":"locate"},{"location":"aea/api/helpers/base/#load_module","text":"load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Returns : None Raises : ValueError : if the filepath provided is not a module. Exception : if the execution of the module raises exception.","title":"load_module"},{"location":"aea/api/helpers/base/#load_env_file","text":"load_env_file ( env_file : str ) Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file. Returns : None.","title":"load_env_file"},{"location":"aea/api/helpers/base/#sigint_crossplatform","text":"sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. Returns : None","title":"sigint_crossplatform"},{"location":"aea/api/helpers/base/#win_popen_kwargs","text":"win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32","title":"win_popen_kwargs"},{"location":"aea/api/helpers/base/#send_control_c","text":"send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C crossplatform to terminate a subprocess. Arguments : process : the process to send the signal to. Returns : None","title":"send_control_c"},{"location":"aea/api/helpers/base/#regexconstrainedstring-objects","text":"class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour.","title":"RegexConstrainedString Objects"},{"location":"aea/api/helpers/base/#__init__","text":"| __init__ ( seq ) Initialize a regex constrained string.","title":"__init__"},{"location":"aea/api/helpers/base/#simpleid-objects","text":"class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')","title":"SimpleId Objects"},{"location":"aea/api/helpers/base/#cd","text":"@contextlib . contextmanager cd ( path ) Change working directory temporarily.","title":"cd"},{"location":"aea/api/helpers/base/#get_logger_method","text":"get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definion module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with","title":"get_logger_method"},{"location":"aea/api/helpers/base/#try_decorator","text":"try_decorator ( error_message : str , default_return = None , logger_method = \"error\" ) Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs","title":"try_decorator"},{"location":"aea/api/helpers/base/#maxretrieserror-objects","text":"class MaxRetriesError ( Exception ) Exception for retry decorator.","title":"MaxRetriesError Objects"},{"location":"aea/api/helpers/base/#retry_decorator","text":"retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method = \"error\" ) Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : num of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs","title":"retry_decorator"},{"location":"aea/api/helpers/base/#exception_log_and_reraise","text":"@contextlib . contextmanager exception_log_and_reraise ( log_method : Callable , message : str ) Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text.","title":"exception_log_and_reraise"},{"location":"aea/api/helpers/base/#recursive_update","text":"recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. Returns : None","title":"recursive_update"},{"location":"aea/api/helpers/base/#find_topological_order","text":"find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Returns : the topological order for the graph (as a sequence of nodes) Raises : ValueError : if the graph contains a cycle.","title":"find_topological_order"},{"location":"aea/api/helpers/base/#reachable_nodes","text":"reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph.","title":"reachable_nodes"},{"location":"aea/api/helpers/base/#cached_property-objects","text":"class cached_property () Cached property from python3.8 functools.","title":"cached_property Objects"},{"location":"aea/api/helpers/base/#__init___1","text":"| __init__ ( func ) Init cached property.","title":"__init__"},{"location":"aea/api/helpers/base/#__set_name__","text":"| __set_name__ ( _ , name ) Set name.","title":"__set_name__"},{"location":"aea/api/helpers/base/#__get__","text":"| __get__ ( instance , _ = None ) Get instance.","title":"__get__"},{"location":"aea/api/helpers/base/#ensure_dir","text":"ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it.","title":"ensure_dir"},{"location":"aea/api/helpers/base/#dict_to_path_value","text":"dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value.","title":"dict_to_path_value"},{"location":"aea/api/helpers/base/#parse_datetime_from_str","text":"parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string.","title":"parse_datetime_from_str"},{"location":"aea/api/helpers/base/#certrequest-objects","text":"class CertRequest () Certificate request for proof of representation.","title":"CertRequest Objects"},{"location":"aea/api/helpers/base/#__init___2","text":"| __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , save_path : str ) Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC. not_before : specify the lower bound for certificate validity. if it is a string, it must follow the format: 'YYYY-MM-DD' It will be interpreted as timezone UTC-0. save_path : the save_path where to save the certificate.","title":"__init__"},{"location":"aea/api/helpers/base/#public_key","text":"| @property | public_key () -> Optional [ str ] Get the public key.","title":"public_key"},{"location":"aea/api/helpers/base/#ledger_id","text":"| @property | ledger_id () -> str Get the ledger id.","title":"ledger_id"},{"location":"aea/api/helpers/base/#key_identifier","text":"| @property | key_identifier () -> Optional [ str ] Get the key identifier.","title":"key_identifier"},{"location":"aea/api/helpers/base/#identifier","text":"| @property | identifier () -> str Get the identifier.","title":"identifier"},{"location":"aea/api/helpers/base/#not_before_string","text":"| @property | not_before_string () -> str Get the not_before field as string.","title":"not_before_string"},{"location":"aea/api/helpers/base/#not_after_string","text":"| @property | not_after_string () -> str Get the not_after field as string.","title":"not_after_string"},{"location":"aea/api/helpers/base/#not_before","text":"| @property | not_before () -> datetime . datetime Get the not_before field.","title":"not_before"},{"location":"aea/api/helpers/base/#not_after","text":"| @property | not_after () -> datetime . datetime Get the not_after field.","title":"not_after"},{"location":"aea/api/helpers/base/#save_path","text":"| @property | save_path () -> Path Get the save_path","title":"save_path"},{"location":"aea/api/helpers/base/#public_key_or_identifier","text":"| @property | public_key_or_identifier () -> str Get the public key or identifier.","title":"public_key_or_identifier"},{"location":"aea/api/helpers/base/#get_message","text":"| get_message ( public_key : str ) -> bytes Get the message to sign.","title":"get_message"},{"location":"aea/api/helpers/base/#get_signature","text":"| get_signature () -> str Get signature from save_path.","title":"get_signature"},{"location":"aea/api/helpers/base/#json","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/helpers/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation.","title":"from_json"},{"location":"aea/api/helpers/base/#__eq__","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/base/#compute_specifier_from_version","text":"compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version, by varying only on the patch number. I.e. from \"{major}.{minor}.{patch}\", return \">={major}.{minor}.0, <{major}.{minor + 1}.0\" Arguments : version : the version Returns : the specifier set","title":"compute_specifier_from_version"},{"location":"aea/api/helpers/base/#decorator_with_optional_params","text":"decorator_with_optional_params ( decorator ) Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ...","title":"decorator_with_optional_params"},{"location":"aea/api/helpers/base/#delete_directory_contents","text":"delete_directory_contents ( directory : Path ) Delete the content of a directory, without deleting it.","title":"delete_directory_contents"},{"location":"aea/api/helpers/constants/","text":"aea.helpers.constants Module with helpers constants.","title":"Constants"},{"location":"aea/api/helpers/constants/#aeahelpersconstants","text":"Module with helpers constants.","title":"aea.helpers.constants"},{"location":"aea/api/helpers/env_vars/","text":"aea.helpers.env _ vars Implementation of the environment variables support. is _ env _ variable is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern. replace _ with _ env _ var replace_with_env_var ( value : str , env_variables : dict , default_value = NotSet ) -> JSON_TYPES Replace env var with value. apply _ env _ variables apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied. convert _ value _ str _ to _ type convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"Env Vars"},{"location":"aea/api/helpers/env_vars/#aeahelpersenv_vars","text":"Implementation of the environment variables support.","title":"aea.helpers.env_vars"},{"location":"aea/api/helpers/env_vars/#is_env_variable","text":"is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern.","title":"is_env_variable"},{"location":"aea/api/helpers/env_vars/#replace_with_env_var","text":"replace_with_env_var ( value : str , env_variables : dict , default_value = NotSet ) -> JSON_TYPES Replace env var with value.","title":"replace_with_env_var"},{"location":"aea/api/helpers/env_vars/#apply_env_variables","text":"apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied.","title":"apply_env_variables"},{"location":"aea/api/helpers/env_vars/#convert_value_str_to_type","text":"convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"convert_value_str_to_type"},{"location":"aea/api/helpers/exception_policy/","text":"aea.helpers.exception _ policy This module contains enum of aea exception policies. ExceptionPolicyEnum Objects class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"Exception Policy"},{"location":"aea/api/helpers/exception_policy/#aeahelpersexception_policy","text":"This module contains enum of aea exception policies.","title":"aea.helpers.exception_policy"},{"location":"aea/api/helpers/exception_policy/#exceptionpolicyenum-objects","text":"class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"ExceptionPolicyEnum Objects"},{"location":"aea/api/helpers/exec_timeout/","text":"aea.helpers.exec _ timeout Python code execution time limit tools. TimeoutResult Objects class TimeoutResult () Result of ExecTimeout context manager. __ init __ | __init__ () Init. set _ cancelled _ by _ timeout | set_cancelled_by_timeout () -> None Set code was terminated cause timeout. Returns : None is _ cancelled _ by _ timeout | is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool TimeoutException Objects class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager BaseExecTimeout Objects class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout. __ init __ | __init__ ( timeout : float = 0.0 ) Init. Arguments : timeout : number of seconds to execute code before interruption __ enter __ | __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult __ exit __ | __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Returns : bool ExecTimeoutSigAlarm Objects class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread. ExecTimeoutThreadGuard Objects class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled. __ init __ | __init__ ( timeout : float = 0.0 ) Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption start | @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. Returns : None stop | @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start. Returns : None","title":"Exec Timeout"},{"location":"aea/api/helpers/exec_timeout/#aeahelpersexec_timeout","text":"Python code execution time limit tools.","title":"aea.helpers.exec_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutresult-objects","text":"class TimeoutResult () Result of ExecTimeout context manager.","title":"TimeoutResult Objects"},{"location":"aea/api/helpers/exec_timeout/#__init__","text":"| __init__ () Init.","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#set_cancelled_by_timeout","text":"| set_cancelled_by_timeout () -> None Set code was terminated cause timeout. Returns : None","title":"set_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#is_cancelled_by_timeout","text":"| is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool","title":"is_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutexception-objects","text":"class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager","title":"TimeoutException Objects"},{"location":"aea/api/helpers/exec_timeout/#baseexectimeout-objects","text":"class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout.","title":"BaseExecTimeout Objects"},{"location":"aea/api/helpers/exec_timeout/#__init___1","text":"| __init__ ( timeout : float = 0.0 ) Init. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#__enter__","text":"| __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult","title":"__enter__"},{"location":"aea/api/helpers/exec_timeout/#__exit__","text":"| __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Returns : bool","title":"__exit__"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutsigalarm-objects","text":"class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread.","title":"ExecTimeoutSigAlarm Objects"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutthreadguard-objects","text":"class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled.","title":"ExecTimeoutThreadGuard Objects"},{"location":"aea/api/helpers/exec_timeout/#__init___2","text":"| __init__ ( timeout : float = 0.0 ) Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#start","text":"| @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. Returns : None","title":"start"},{"location":"aea/api/helpers/exec_timeout/#stop","text":"| @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start. Returns : None","title":"stop"},{"location":"aea/api/helpers/file_io/","text":"aea.helpers.file _ io Read to and write from file with envelopes. lock _ file @contextmanager lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) Lock file in context manager. Arguments : file_descriptor : file descriptio of file to lock. write _ envelope write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file. write _ with _ lock write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock. envelope _ from _ bytes envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Returns : Envelope :raise: Exception","title":"File IO"},{"location":"aea/api/helpers/file_io/#aeahelpersfile_io","text":"Read to and write from file with envelopes.","title":"aea.helpers.file_io"},{"location":"aea/api/helpers/file_io/#lock_file","text":"@contextmanager lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) Lock file in context manager. Arguments : file_descriptor : file descriptio of file to lock.","title":"lock_file"},{"location":"aea/api/helpers/file_io/#write_envelope","text":"write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file.","title":"write_envelope"},{"location":"aea/api/helpers/file_io/#write_with_lock","text":"write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock.","title":"write_with_lock"},{"location":"aea/api/helpers/file_io/#envelope_from_bytes","text":"envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Returns : Envelope :raise: Exception","title":"envelope_from_bytes"},{"location":"aea/api/helpers/file_lock/","text":"aea.helpers.file _ lock Patch of 'fnctl' to make it compatible with Windows.","title":"File Lock"},{"location":"aea/api/helpers/file_lock/#aeahelpersfile_lock","text":"Patch of 'fnctl' to make it compatible with Windows.","title":"aea.helpers.file_lock"},{"location":"aea/api/helpers/install_dependency/","text":"aea.helpers.install _ dependency Helper to install python dependecies. install _ dependency install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification Returns : None run _ install _ subprocess run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"Install Dependency"},{"location":"aea/api/helpers/install_dependency/#aeahelpersinstall_dependency","text":"Helper to install python dependecies.","title":"aea.helpers.install_dependency"},{"location":"aea/api/helpers/install_dependency/#install_dependency","text":"install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification Returns : None","title":"install_dependency"},{"location":"aea/api/helpers/install_dependency/#run_install_subprocess","text":"run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"run_install_subprocess"},{"location":"aea/api/helpers/logging/","text":"aea.helpers.logging Logging helpers. get _ logger get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name. AgentLoggerAdapter Objects class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages. __ init __ | __init__ ( logger : Logger , agent_name : str ) Initialize the logger adapter. Arguments : agent_name : the agent name. process | process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message. WithLogger Objects class WithLogger () Interface to endow subclasses with a logger. __ init __ | __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided. logger | @property | logger () -> Logger Get the component logger. logger | @logger . setter | logger ( logger : Optional [ Logger ]) Set the logger.","title":"Logging"},{"location":"aea/api/helpers/logging/#aeahelperslogging","text":"Logging helpers.","title":"aea.helpers.logging"},{"location":"aea/api/helpers/logging/#get_logger","text":"get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name.","title":"get_logger"},{"location":"aea/api/helpers/logging/#agentloggeradapter-objects","text":"class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages.","title":"AgentLoggerAdapter Objects"},{"location":"aea/api/helpers/logging/#__init__","text":"| __init__ ( logger : Logger , agent_name : str ) Initialize the logger adapter. Arguments : agent_name : the agent name.","title":"__init__"},{"location":"aea/api/helpers/logging/#process","text":"| process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message.","title":"process"},{"location":"aea/api/helpers/logging/#withlogger-objects","text":"class WithLogger () Interface to endow subclasses with a logger.","title":"WithLogger Objects"},{"location":"aea/api/helpers/logging/#__init___1","text":"| __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided.","title":"__init__"},{"location":"aea/api/helpers/logging/#logger","text":"| @property | logger () -> Logger Get the component logger.","title":"logger"},{"location":"aea/api/helpers/logging/#logger_1","text":"| @logger . setter | logger ( logger : Optional [ Logger ]) Set the logger.","title":"logger"},{"location":"aea/api/helpers/multiple_executor/","text":"aea.helpers.multiple _ executor This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess . ExecutorExceptionPolicies Objects class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes. AbstractExecutorTask Objects class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes. __ init __ | __init__ () Init task. future | @property | future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution. future | @future . setter | future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution. start | @abstractmethod | start () Implement start task function here. stop | @abstractmethod | stop () -> None Implement stop task function here. create _ async _ task | @abstractmethod | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop. id | @property | id () -> Any Return task id. failed | @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. :rerurn: bool AbstractMultiprocessExecutorTask Objects class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor. start | @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Returns : task to run in asyncio loop. AbstractMultipleExecutor Objects class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes. __ init __ | __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks is _ running | @property | is_running () -> bool Return running state of the executor. start | start () -> None Start tasks. stop | stop () -> None Stop tasks. num _ failed | @property | num_failed () -> int Return number of failed tasks. failed _ tasks | @property | failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks. not _ failed _ tasks | @property | not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks. ThreadExecutor Objects class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. ProcessExecutor Objects class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads. AsyncExecutor Objects class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. AbstractMultipleRunner Objects class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode. __ init __ | __init__ ( mode : str , fail_policy = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor is _ running | @property | is_running () -> bool Return state of the executor. start | start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread. Returns : None stop | stop ( timeout : float = 0 ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode. Returns : None num _ failed | @property | num_failed () Return number of failed tasks. failed | @property | failed () Return sequence failed tasks. not _ failed | @property | not_failed () Return sequence successful tasks. join _ thread | join_thread () -> None Join thread if running in thread mode.","title":"MultipleExecutor"},{"location":"aea/api/helpers/multiple_executor/#aeahelpersmultiple_executor","text":"This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess .","title":"aea.helpers.multiple_executor"},{"location":"aea/api/helpers/multiple_executor/#executorexceptionpolicies-objects","text":"class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes.","title":"ExecutorExceptionPolicies Objects"},{"location":"aea/api/helpers/multiple_executor/#abstractexecutortask-objects","text":"class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes.","title":"AbstractExecutorTask Objects"},{"location":"aea/api/helpers/multiple_executor/#__init__","text":"| __init__ () Init task.","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#future","text":"| @property | future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution.","title":"future"},{"location":"aea/api/helpers/multiple_executor/#future_1","text":"| @future . setter | future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution.","title":"future"},{"location":"aea/api/helpers/multiple_executor/#start","text":"| @abstractmethod | start () Implement start task function here.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop","text":"| @abstractmethod | stop () -> None Implement stop task function here.","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#create_async_task","text":"| @abstractmethod | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop.","title":"create_async_task"},{"location":"aea/api/helpers/multiple_executor/#id","text":"| @property | id () -> Any Return task id.","title":"id"},{"location":"aea/api/helpers/multiple_executor/#failed","text":"| @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. :rerurn: bool","title":"failed"},{"location":"aea/api/helpers/multiple_executor/#abstractmultiprocessexecutortask-objects","text":"class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor.","title":"AbstractMultiprocessExecutorTask Objects"},{"location":"aea/api/helpers/multiple_executor/#start_1","text":"| @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#create_async_task_1","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Returns : task to run in asyncio loop.","title":"create_async_task"},{"location":"aea/api/helpers/multiple_executor/#abstractmultipleexecutor-objects","text":"class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes.","title":"AbstractMultipleExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#__init___1","text":"| __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#is_running","text":"| @property | is_running () -> bool Return running state of the executor.","title":"is_running"},{"location":"aea/api/helpers/multiple_executor/#start_2","text":"| start () -> None Start tasks.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop_1","text":"| stop () -> None Stop tasks.","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#num_failed","text":"| @property | num_failed () -> int Return number of failed tasks.","title":"num_failed"},{"location":"aea/api/helpers/multiple_executor/#failed_tasks","text":"| @property | failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks.","title":"failed_tasks"},{"location":"aea/api/helpers/multiple_executor/#not_failed_tasks","text":"| @property | not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks.","title":"not_failed_tasks"},{"location":"aea/api/helpers/multiple_executor/#threadexecutor-objects","text":"class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"ThreadExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#processexecutor-objects","text":"class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads.","title":"ProcessExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#asyncexecutor-objects","text":"class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"AsyncExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#abstractmultiplerunner-objects","text":"class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode.","title":"AbstractMultipleRunner Objects"},{"location":"aea/api/helpers/multiple_executor/#__init___2","text":"| __init__ ( mode : str , fail_policy = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#is_running_1","text":"| @property | is_running () -> bool Return state of the executor.","title":"is_running"},{"location":"aea/api/helpers/multiple_executor/#start_3","text":"| start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread. Returns : None","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop_2","text":"| stop ( timeout : float = 0 ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode. Returns : None","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#num_failed_1","text":"| @property | num_failed () Return number of failed tasks.","title":"num_failed"},{"location":"aea/api/helpers/multiple_executor/#failed_1","text":"| @property | failed () Return sequence failed tasks.","title":"failed"},{"location":"aea/api/helpers/multiple_executor/#not_failed","text":"| @property | not_failed () Return sequence successful tasks.","title":"not_failed"},{"location":"aea/api/helpers/multiple_executor/#join_thread","text":"| join_thread () -> None Join thread if running in thread mode.","title":"join_thread"},{"location":"aea/api/helpers/pipe/","text":"aea.helpers.pipe Portable pipe implementation for Linux, MacOS, and Windows. IPCChannelClient Objects class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side. connect | @abstractmethod | async connect ( timeout = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect write | @abstractmethod | async write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write read | @abstractmethod | async read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes close | @abstractmethod | async close () -> None Close the communication channel. Returns : None IPCChannel Objects class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel. in _ path | @property | @abstractmethod | in_path () -> str Rendezvous point for incoming communication. Returns : path out _ path | @property | @abstractmethod | out_path () -> str Rendezvous point for outgoing communication. Returns : path PosixNamedPipeProtocol Objects class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing daa connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success write | async write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe read | async read () -> Optional [ bytes ] Read from pipe. Returns : read bytes close | async close () -> None Disconnect pipe. TCPSocketProtocol Objects class TCPSocketProtocol () TCP socket communication protocol. __ init __ | __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer write | async write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read from socket. Returns : read bytes close | async close () -> None Disconnect socket. TCPSocketChannel Objects class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets. __ init __ | __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize tcp socket interprocess communication channel. connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established write | async write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read from channel. Arguments : data : read bytes close | async close () -> None Disconnect from channel and clean it up. in _ path | @property | in_path () -> str Rendezvous point for incoming communication. out _ path | @property | out_path () -> str Rendezvous point for outgoing communication. PosixNamedPipeChannel Objects class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes. __ init __ | __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize posix named pipe interprocess communication channel. connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating sucess write | async write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel read | async read () -> Optional [ bytes ] Read from the channel. Returns : read bytes close | async close () -> None Close the channel and clean it up. in _ path | @property | in_path () -> str Rendezvous point for incoming communication. out _ path | @property | out_path () -> str Rendezvous point for outgoing communication. TCPSocketChannelClient Objects class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established write | async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close | async close () -> None Disconnect from communication channel. PosixNamedPipeChannelClient Objects class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established write | async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close | async close () -> None Disconnect from communication channel. make _ ipc _ channel make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel make _ ipc _ channel _ client make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"Pipe"},{"location":"aea/api/helpers/pipe/#aeahelperspipe","text":"Portable pipe implementation for Linux, MacOS, and Windows.","title":"aea.helpers.pipe"},{"location":"aea/api/helpers/pipe/#ipcchannelclient-objects","text":"class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side.","title":"IPCChannelClient Objects"},{"location":"aea/api/helpers/pipe/#connect","text":"| @abstractmethod | async connect ( timeout = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect","title":"connect"},{"location":"aea/api/helpers/pipe/#write","text":"| @abstractmethod | async write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read","text":"| @abstractmethod | async read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close","text":"| @abstractmethod | async close () -> None Close the communication channel. Returns : None","title":"close"},{"location":"aea/api/helpers/pipe/#ipcchannel-objects","text":"class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel.","title":"IPCChannel Objects"},{"location":"aea/api/helpers/pipe/#in_path","text":"| @property | @abstractmethod | in_path () -> str Rendezvous point for incoming communication. Returns : path","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path","text":"| @property | @abstractmethod | out_path () -> str Rendezvous point for outgoing communication. Returns : path","title":"out_path"},{"location":"aea/api/helpers/pipe/#posixnamedpipeprotocol-objects","text":"class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol.","title":"PosixNamedPipeProtocol Objects"},{"location":"aea/api/helpers/pipe/#__init__","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing daa","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_1","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success","title":"connect"},{"location":"aea/api/helpers/pipe/#write_1","text":"| async write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe","title":"write"},{"location":"aea/api/helpers/pipe/#read_1","text":"| async read () -> Optional [ bytes ] Read from pipe. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_1","text":"| async close () -> None Disconnect pipe.","title":"close"},{"location":"aea/api/helpers/pipe/#tcpsocketprotocol-objects","text":"class TCPSocketProtocol () TCP socket communication protocol.","title":"TCPSocketProtocol Objects"},{"location":"aea/api/helpers/pipe/#__init___1","text":"| __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer","title":"__init__"},{"location":"aea/api/helpers/pipe/#write_2","text":"| async write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_2","text":"| async read () -> Optional [ bytes ] Read from socket. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_2","text":"| async close () -> None Disconnect socket.","title":"close"},{"location":"aea/api/helpers/pipe/#tcpsocketchannel-objects","text":"class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets.","title":"TCPSocketChannel Objects"},{"location":"aea/api/helpers/pipe/#__init___2","text":"| __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize tcp socket interprocess communication channel.","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_2","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established","title":"connect"},{"location":"aea/api/helpers/pipe/#write_3","text":"| async write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_3","text":"| async read () -> Optional [ bytes ] Read from channel. Arguments : data : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_3","text":"| async close () -> None Disconnect from channel and clean it up.","title":"close"},{"location":"aea/api/helpers/pipe/#in_path_1","text":"| @property | in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path_1","text":"| @property | out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"aea/api/helpers/pipe/#posixnamedpipechannel-objects","text":"class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes.","title":"PosixNamedPipeChannel Objects"},{"location":"aea/api/helpers/pipe/#__init___3","text":"| __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize posix named pipe interprocess communication channel.","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_3","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating sucess","title":"connect"},{"location":"aea/api/helpers/pipe/#write_4","text":"| async write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel","title":"write"},{"location":"aea/api/helpers/pipe/#read_4","text":"| async read () -> Optional [ bytes ] Read from the channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_4","text":"| async close () -> None Close the channel and clean it up.","title":"close"},{"location":"aea/api/helpers/pipe/#in_path_2","text":"| @property | in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path_2","text":"| @property | out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"aea/api/helpers/pipe/#tcpsocketchannelclient-objects","text":"class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets.","title":"TCPSocketChannelClient Objects"},{"location":"aea/api/helpers/pipe/#__init___4","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_4","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established","title":"connect"},{"location":"aea/api/helpers/pipe/#write_5","text":"| async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_5","text":"| async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_5","text":"| async close () -> None Disconnect from communication channel.","title":"close"},{"location":"aea/api/helpers/pipe/#posixnamedpipechannelclient-objects","text":"class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes.","title":"PosixNamedPipeChannelClient Objects"},{"location":"aea/api/helpers/pipe/#__init___5","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_5","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established","title":"connect"},{"location":"aea/api/helpers/pipe/#write_6","text":"| async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_6","text":"| async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_6","text":"| async close () -> None Disconnect from communication channel.","title":"close"},{"location":"aea/api/helpers/pipe/#make_ipc_channel","text":"make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel"},{"location":"aea/api/helpers/pipe/#make_ipc_channel_client","text":"make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel_client"},{"location":"aea/api/helpers/profiling/","text":"aea.helpers.profiling Implementation of background profiling daemon. Profiling Objects class Profiling ( Runnable ) Profiling service. __ init __ | __init__ ( period : int = 0 , objects_instances_to_count : List [ Type ] = None , objects_created_to_count : List [ Type ] = None , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True )) -> None Init profiler. Arguments : period : delay between profiling output in seconds. output_function : function to display ouput, one str argument. set _ counters | set_counters () Modify obj. new to count objects created created. run | async run () -> None Run profiling. output _ profile _ data | output_profile_data () -> None Render profiling data and call output_function. get _ profile _ data | get_profile_data () -> Dict Get profiling data dict. get _ objects _ instances | get_objects_instances () -> Dict Return dict with counted object instances present now. get _ objecst _ created | get_objecst_created () -> Dict Return dict with counted object instances created.","title":"Profiling"},{"location":"aea/api/helpers/profiling/#aeahelpersprofiling","text":"Implementation of background profiling daemon.","title":"aea.helpers.profiling"},{"location":"aea/api/helpers/profiling/#profiling-objects","text":"class Profiling ( Runnable ) Profiling service.","title":"Profiling Objects"},{"location":"aea/api/helpers/profiling/#__init__","text":"| __init__ ( period : int = 0 , objects_instances_to_count : List [ Type ] = None , objects_created_to_count : List [ Type ] = None , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True )) -> None Init profiler. Arguments : period : delay between profiling output in seconds. output_function : function to display ouput, one str argument.","title":"__init__"},{"location":"aea/api/helpers/profiling/#set_counters","text":"| set_counters () Modify obj. new to count objects created created.","title":"set_counters"},{"location":"aea/api/helpers/profiling/#run","text":"| async run () -> None Run profiling.","title":"run"},{"location":"aea/api/helpers/profiling/#output_profile_data","text":"| output_profile_data () -> None Render profiling data and call output_function.","title":"output_profile_data"},{"location":"aea/api/helpers/profiling/#get_profile_data","text":"| get_profile_data () -> Dict Get profiling data dict.","title":"get_profile_data"},{"location":"aea/api/helpers/profiling/#get_objects_instances","text":"| get_objects_instances () -> Dict Return dict with counted object instances present now.","title":"get_objects_instances"},{"location":"aea/api/helpers/profiling/#get_objecst_created","text":"| get_objecst_created () -> Dict Return dict with counted object instances created.","title":"get_objecst_created"},{"location":"aea/api/helpers/serializers/","text":"aea.helpers.serializers This module contains Serializers that can be used for custom types. DictProtobufStructSerializer Objects class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes encode | @classmethod | encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes decode | @classmethod | decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"Serializers"},{"location":"aea/api/helpers/serializers/#aeahelpersserializers","text":"This module contains Serializers that can be used for custom types.","title":"aea.helpers.serializers"},{"location":"aea/api/helpers/serializers/#dictprotobufstructserializer-objects","text":"class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes","title":"DictProtobufStructSerializer Objects"},{"location":"aea/api/helpers/serializers/#encode","text":"| @classmethod | encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes","title":"encode"},{"location":"aea/api/helpers/serializers/#decode","text":"| @classmethod | decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"decode"},{"location":"aea/api/helpers/sym_link/","text":"aea.helpers.sym _ link Sym link implementation for Linux, MacOS, and Windows. make _ symlink make_symlink ( link_name : str , target : str ) Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target. cd @contextlib . contextmanager cd ( path ) Change directory with context manager. create _ symlink create_symlink ( link_path : Path , target_path : Path , root_path : Path ) Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relatve path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link","title":"Sym Link"},{"location":"aea/api/helpers/sym_link/#aeahelperssym_link","text":"Sym link implementation for Linux, MacOS, and Windows.","title":"aea.helpers.sym_link"},{"location":"aea/api/helpers/sym_link/#make_symlink","text":"make_symlink ( link_name : str , target : str ) Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target.","title":"make_symlink"},{"location":"aea/api/helpers/sym_link/#cd","text":"@contextlib . contextmanager cd ( path ) Change directory with context manager.","title":"cd"},{"location":"aea/api/helpers/sym_link/#create_symlink","text":"create_symlink ( link_path : Path , target_path : Path , root_path : Path ) Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relatve path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link","title":"create_symlink"},{"location":"aea/api/helpers/win32/","text":"aea.helpers.win32 Helpers for Windows. enable _ ctrl _ c _ support enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"Win32"},{"location":"aea/api/helpers/win32/#aeahelperswin32","text":"Helpers for Windows.","title":"aea.helpers.win32"},{"location":"aea/api/helpers/win32/#enable_ctrl_c_support","text":"enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"enable_ctrl_c_support"},{"location":"aea/api/helpers/yaml_utils/","text":"aea.helpers.yaml _ utils Helper functions related to YAML loading/dumping. _ AEAYamlLoader Objects class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'. __ init __ | __init__ ( * args , ** kwargs ) Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files. _ AEAYamlDumper Objects class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'. __ init __ | __init__ ( * args , ** kwargs ) Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files. yaml _ load yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content. yaml _ load _ all yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content. yaml _ dump yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. Returns : None yaml _ dump _ all yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. Returns : None","title":"YamlUtils"},{"location":"aea/api/helpers/yaml_utils/#aeahelpersyaml_utils","text":"Helper functions related to YAML loading/dumping.","title":"aea.helpers.yaml_utils"},{"location":"aea/api/helpers/yaml_utils/#_aeayamlloader-objects","text":"class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'.","title":"_AEAYamlLoader Objects"},{"location":"aea/api/helpers/yaml_utils/#__init__","text":"| __init__ ( * args , ** kwargs ) Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files.","title":"__init__"},{"location":"aea/api/helpers/yaml_utils/#_aeayamldumper-objects","text":"class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'.","title":"_AEAYamlDumper Objects"},{"location":"aea/api/helpers/yaml_utils/#__init___1","text":"| __init__ ( * args , ** kwargs ) Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files.","title":"__init__"},{"location":"aea/api/helpers/yaml_utils/#yaml_load","text":"yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content.","title":"yaml_load"},{"location":"aea/api/helpers/yaml_utils/#yaml_load_all","text":"yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content.","title":"yaml_load_all"},{"location":"aea/api/helpers/yaml_utils/#yaml_dump","text":"yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. Returns : None","title":"yaml_dump"},{"location":"aea/api/helpers/yaml_utils/#yaml_dump_all","text":"yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. Returns : None","title":"yaml_dump_all"},{"location":"aea/api/helpers/acn/agent_record/","text":"aea.helpers.acn.agent _ record This module contains types and helpers for acn Proof-of-Representation. AgentRecord Objects class AgentRecord () Agent Proof-of-Representation to representative. __ init __ | __init__ ( address : str , representative_public_key : str , message : bytes , signature : str , ledger_id : str ) Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key message : message to be signed as proof-of-represenation of this AgentRecord signature : proof-of-representation of this AgentRecord ledger_id : ledger id address | @property | address () -> str Get agent address public _ key | @property | public_key () -> str Get agent public key representative _ public _ key | @property | representative_public_key () -> str Get agent representative's public key signature | @property | signature () -> str Get record signature message | @property | message () -> bytes Get the message. ledger _ id | @property | ledger_id () -> str Get ledger id. __ str __ | __str__ () Get string representation. from _ cert _ request | @classmethod | from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str ) -> \"AgentRecord\" Get agent record from cert request.","title":"Agent Record"},{"location":"aea/api/helpers/acn/agent_record/#aeahelpersacnagent_record","text":"This module contains types and helpers for acn Proof-of-Representation.","title":"aea.helpers.acn.agent_record"},{"location":"aea/api/helpers/acn/agent_record/#agentrecord-objects","text":"class AgentRecord () Agent Proof-of-Representation to representative.","title":"AgentRecord Objects"},{"location":"aea/api/helpers/acn/agent_record/#__init__","text":"| __init__ ( address : str , representative_public_key : str , message : bytes , signature : str , ledger_id : str ) Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key message : message to be signed as proof-of-represenation of this AgentRecord signature : proof-of-representation of this AgentRecord ledger_id : ledger id","title":"__init__"},{"location":"aea/api/helpers/acn/agent_record/#address","text":"| @property | address () -> str Get agent address","title":"address"},{"location":"aea/api/helpers/acn/agent_record/#public_key","text":"| @property | public_key () -> str Get agent public key","title":"public_key"},{"location":"aea/api/helpers/acn/agent_record/#representative_public_key","text":"| @property | representative_public_key () -> str Get agent representative's public key","title":"representative_public_key"},{"location":"aea/api/helpers/acn/agent_record/#signature","text":"| @property | signature () -> str Get record signature","title":"signature"},{"location":"aea/api/helpers/acn/agent_record/#message","text":"| @property | message () -> bytes Get the message.","title":"message"},{"location":"aea/api/helpers/acn/agent_record/#ledger_id","text":"| @property | ledger_id () -> str Get ledger id.","title":"ledger_id"},{"location":"aea/api/helpers/acn/agent_record/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/acn/agent_record/#from_cert_request","text":"| @classmethod | from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str ) -> \"AgentRecord\" Get agent record from cert request.","title":"from_cert_request"},{"location":"aea/api/helpers/acn/uri/","text":"aea.helpers.acn.uri This module contains types and helpers for libp2p connections Uris. Uri Objects class Uri () Holds a node address in format \"host:port\". __ init __ | __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) Initialise Uri. __ str __ | __str__ () Get string representation. __ repr __ | __repr__ () Get object representation. host | @property | host () -> str Get host. port | @property | port () -> int Get port.","title":"URI"},{"location":"aea/api/helpers/acn/uri/#aeahelpersacnuri","text":"This module contains types and helpers for libp2p connections Uris.","title":"aea.helpers.acn.uri"},{"location":"aea/api/helpers/acn/uri/#uri-objects","text":"class Uri () Holds a node address in format \"host:port\".","title":"Uri Objects"},{"location":"aea/api/helpers/acn/uri/#__init__","text":"| __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) Initialise Uri.","title":"__init__"},{"location":"aea/api/helpers/acn/uri/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/acn/uri/#__repr__","text":"| __repr__ () Get object representation.","title":"__repr__"},{"location":"aea/api/helpers/acn/uri/#host","text":"| @property | host () -> str Get host.","title":"host"},{"location":"aea/api/helpers/acn/uri/#port","text":"| @property | port () -> int Get port.","title":"port"},{"location":"aea/api/helpers/ipfs/base/","text":"aea.helpers.ipfs.base This module contains helper methods and classes for the 'aea' package. IPFSHashOnly Objects class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon. get | get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path","title":"Base"},{"location":"aea/api/helpers/ipfs/base/#aeahelpersipfsbase","text":"This module contains helper methods and classes for the 'aea' package.","title":"aea.helpers.ipfs.base"},{"location":"aea/api/helpers/ipfs/base/#ipfshashonly-objects","text":"class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon.","title":"IPFSHashOnly Objects"},{"location":"aea/api/helpers/ipfs/base/#get","text":"| get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path","title":"get"},{"location":"aea/api/helpers/multiaddr/base/","text":"aea.helpers.multiaddr.base This module contains multiaddress class. MultiAddr Objects class MultiAddr () Protocol Labs' Multiaddress representation of a network address. __ init __ | __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key compute _ peerid | @staticmethod | compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id. from _ string | @classmethod | from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string public _ key | @property | public_key () -> str Get the public key. peer _ id | @property | peer_id () -> str Get the peer id. host | @property | host () -> str Get the peer host. port | @property | port () -> int Get the peer port. format | format () -> str Canonical representation of a multiaddress. __ str __ | __str__ () -> str Default string representation of a mutliaddress.","title":"Base"},{"location":"aea/api/helpers/multiaddr/base/#aeahelpersmultiaddrbase","text":"This module contains multiaddress class.","title":"aea.helpers.multiaddr.base"},{"location":"aea/api/helpers/multiaddr/base/#multiaddr-objects","text":"class MultiAddr () Protocol Labs' Multiaddress representation of a network address.","title":"MultiAddr Objects"},{"location":"aea/api/helpers/multiaddr/base/#__init__","text":"| __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key","title":"__init__"},{"location":"aea/api/helpers/multiaddr/base/#compute_peerid","text":"| @staticmethod | compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id.","title":"compute_peerid"},{"location":"aea/api/helpers/multiaddr/base/#from_string","text":"| @classmethod | from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string","title":"from_string"},{"location":"aea/api/helpers/multiaddr/base/#public_key","text":"| @property | public_key () -> str Get the public key.","title":"public_key"},{"location":"aea/api/helpers/multiaddr/base/#peer_id","text":"| @property | peer_id () -> str Get the peer id.","title":"peer_id"},{"location":"aea/api/helpers/multiaddr/base/#host","text":"| @property | host () -> str Get the peer host.","title":"host"},{"location":"aea/api/helpers/multiaddr/base/#port","text":"| @property | port () -> int Get the peer port.","title":"port"},{"location":"aea/api/helpers/multiaddr/base/#format","text":"| format () -> str Canonical representation of a multiaddress.","title":"format"},{"location":"aea/api/helpers/multiaddr/base/#__str__","text":"| __str__ () -> str Default string representation of a mutliaddress.","title":"__str__"},{"location":"aea/api/helpers/preference_representations/base/","text":"aea.helpers.preference _ representations.base Preference representation helpers. logarithmic _ utility logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 1 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value linear _ utility linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"Base"},{"location":"aea/api/helpers/preference_representations/base/#aeahelperspreference_representationsbase","text":"Preference representation helpers.","title":"aea.helpers.preference_representations.base"},{"location":"aea/api/helpers/preference_representations/base/#logarithmic_utility","text":"logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 1 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/helpers/preference_representations/base/#linear_utility","text":"linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/helpers/search/generic/","text":"aea.helpers.search.generic This module contains a generic data model. GenericDataModel Objects class GenericDataModel ( DataModel ) Generic data model. __ init __ | __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"Generic"},{"location":"aea/api/helpers/search/generic/#aeahelperssearchgeneric","text":"This module contains a generic data model.","title":"aea.helpers.search.generic"},{"location":"aea/api/helpers/search/generic/#genericdatamodel-objects","text":"class GenericDataModel ( DataModel ) Generic data model.","title":"GenericDataModel Objects"},{"location":"aea/api/helpers/search/generic/#__init__","text":"| __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"__init__"},{"location":"aea/api/helpers/search/models/","text":"aea.helpers.search.models Useful classes for the OEF search. Location Objects class Location () Data structure to represent locations (i.e. a pair of latitude and longitude). __ init __ | __init__ ( latitude : float , longitude : float ) Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location. tuple | @property | tuple () -> Tuple [ float , float ] Get the tuple representation of a location. distance | distance ( other : \"Location\" ) -> float Get the distance to another location. Arguments : other : the other location :retun: the distance __ eq __ | __eq__ ( other ) Compare equality of two locations. __ str __ | __str__ () Get the string representation of the data model. encode | encode () -> models_pb2 . Query . Location Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , location_pb ) -> \"Location\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : location_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object AttributeInconsistencyException Objects class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type. Attribute Objects class Attribute () Implements an attribute for an OEF data model. __ init __ | __init__ ( name : str , type_ : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type_ : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute. __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the data model. encode | encode () -> models_pb2 . Query . Attribute Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , attribute_pb ) -> \"Attribute\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : attribute_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object DataModel Objects class DataModel () Implements an OEF data model. __ init __ | __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model. __ eq __ | __eq__ ( other ) -> bool Compare with another object. __ str __ | __str__ () Get the string representation of the data model. encode | encode () -> models_pb2 . Query . DataModel Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , data_model_pb ) -> \"DataModel\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : data_model_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object generate _ data _ model generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified. Description Objects class Description () Implements an OEF description. __ init __ | __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) :pram data_model_name: the data model name if a datamodel is created on the fly. values | @property | values () -> Dict Get the values. __ eq __ | __eq__ ( other ) -> bool Compare with another object. __ iter __ | __iter__ () Create an iterator. __ str __ | __str__ () Get the string representation of the description. encode | @classmethod | encode ( cls , description_pb , description : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. description : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , description_pb ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument. ConstraintTypes Objects class ConstraintTypes ( Enum ) Types of constraint. __ str __ | __str__ () Get the string representation. ConstraintType Objects class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", (1, 2, 3)) not_in_a_set = ConstraintType(\"not_in\", (\"C\", \"Java\", \"Python\")) __ init __ | __init__ ( type_ : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type_ : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not check _ validity | check_validity () Check the validity of the input provided. Returns : None Raises : ValueError : if the value is not valid wrt the constraint type. is _ valid | is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise. get _ data _ type | get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type() check | check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized. __ eq __ | __eq__ ( other ) Check equality with another object. __ str __ | __str__ () Get the string representation of the constraint type. encode | encode () Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , constraint_type_pb , category : str ) -> \"ConstraintType\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_type_pb : the protocol buffer object corresponding with this class. category : the category of the constraint ('relation', 'set', 'range', 'distance). Returns : A new instance of this class matching the protocol buffer object ConstraintExpr Objects class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node. check | @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model. Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () -> None Check whether a Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements. And Objects class And ( ConstraintExpr ) Implementation of the 'And' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements. __ eq __ | __eq__ ( other ) Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . And Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , and_pb ) -> \"And\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : and_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Or Objects class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements. __ eq __ | __eq__ ( other ) Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . Or Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , or_pb ) -> \"Or\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : or_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Not Objects class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression. __ init __ | __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate. check | check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . Not Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , not_pb ) -> \"Not\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : not_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Constraint Objects class Constraint ( ConstraintExpr ) The atomic component of a constraint expression. __ init __ | __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type. check | check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", (\"horror\", \"science_fiction\"))) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the constraint. encode | encode () -> models_pb2 . Query . ConstraintExpr . Constraint Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , constraint_pb ) -> \"Constraint\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Query Objects class Query () This class lets you build a query for the OEF. __ init __ | __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to. check | check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Given a data model, check whether the query is valid for that data model. Returns : True if the query is compliant with the data model, False otherwise. check _ validity | check_validity () Check whether the` object is valid. :return None Raises : ValueError : if the query does not satisfy some sanity requirements. __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the constraint. encode | @classmethod | encode ( cls , query_pb , query : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_pb : the protocol buffer object wrapping an object that corresponds with this class. query : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , query_pb ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument. haversine haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"Models"},{"location":"aea/api/helpers/search/models/#aeahelperssearchmodels","text":"Useful classes for the OEF search.","title":"aea.helpers.search.models"},{"location":"aea/api/helpers/search/models/#location-objects","text":"class Location () Data structure to represent locations (i.e. a pair of latitude and longitude).","title":"Location Objects"},{"location":"aea/api/helpers/search/models/#__init__","text":"| __init__ ( latitude : float , longitude : float ) Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location.","title":"__init__"},{"location":"aea/api/helpers/search/models/#tuple","text":"| @property | tuple () -> Tuple [ float , float ] Get the tuple representation of a location.","title":"tuple"},{"location":"aea/api/helpers/search/models/#distance","text":"| distance ( other : \"Location\" ) -> float Get the distance to another location. Arguments : other : the other location :retun: the distance","title":"distance"},{"location":"aea/api/helpers/search/models/#__eq__","text":"| __eq__ ( other ) Compare equality of two locations.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str__","text":"| __str__ () Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode","text":"| encode () -> models_pb2 . Query . Location Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode","text":"| @classmethod | decode ( cls , location_pb ) -> \"Location\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : location_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#attributeinconsistencyexception-objects","text":"class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type.","title":"AttributeInconsistencyException Objects"},{"location":"aea/api/helpers/search/models/#attribute-objects","text":"class Attribute () Implements an attribute for an OEF data model.","title":"Attribute Objects"},{"location":"aea/api/helpers/search/models/#__init___1","text":"| __init__ ( name : str , type_ : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type_ : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___1","text":"| __str__ () Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_1","text":"| encode () -> models_pb2 . Query . Attribute Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_1","text":"| @classmethod | decode ( cls , attribute_pb ) -> \"Attribute\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : attribute_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#datamodel-objects","text":"class DataModel () Implements an OEF data model.","title":"DataModel Objects"},{"location":"aea/api/helpers/search/models/#__init___2","text":"| __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___2","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___2","text":"| __str__ () Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_2","text":"| encode () -> models_pb2 . Query . DataModel Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_2","text":"| @classmethod | decode ( cls , data_model_pb ) -> \"DataModel\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : data_model_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#generate_data_model","text":"generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified.","title":"generate_data_model"},{"location":"aea/api/helpers/search/models/#description-objects","text":"class Description () Implements an OEF description.","title":"Description Objects"},{"location":"aea/api/helpers/search/models/#__init___3","text":"| __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) :pram data_model_name: the data model name if a datamodel is created on the fly.","title":"__init__"},{"location":"aea/api/helpers/search/models/#values","text":"| @property | values () -> Dict Get the values.","title":"values"},{"location":"aea/api/helpers/search/models/#__eq___3","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__iter__","text":"| __iter__ () Create an iterator.","title":"__iter__"},{"location":"aea/api/helpers/search/models/#__str___3","text":"| __str__ () Get the string representation of the description.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_3","text":"| @classmethod | encode ( cls , description_pb , description : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. description : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_3","text":"| @classmethod | decode ( cls , description_pb ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#constrainttypes-objects","text":"class ConstraintTypes ( Enum ) Types of constraint.","title":"ConstraintTypes Objects"},{"location":"aea/api/helpers/search/models/#__str___4","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/search/models/#constrainttype-objects","text":"class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", (1, 2, 3)) not_in_a_set = ConstraintType(\"not_in\", (\"C\", \"Java\", \"Python\"))","title":"ConstraintType Objects"},{"location":"aea/api/helpers/search/models/#__init___4","text":"| __init__ ( type_ : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type_ : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_validity","text":"| check_validity () Check the validity of the input provided. Returns : None Raises : ValueError : if the value is not valid wrt the constraint type.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#is_valid","text":"| is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#get_data_type","text":"| get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type()","title":"get_data_type"},{"location":"aea/api/helpers/search/models/#check","text":"| check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___4","text":"| __eq__ ( other ) Check equality with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___5","text":"| __str__ () Get the string representation of the constraint type.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_4","text":"| encode () Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_4","text":"| @classmethod | decode ( cls , constraint_type_pb , category : str ) -> \"ConstraintType\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_type_pb : the protocol buffer object corresponding with this class. category : the category of the constraint ('relation', 'set', 'range', 'distance). Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#constraintexpr-objects","text":"class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node.","title":"ConstraintExpr Objects"},{"location":"aea/api/helpers/search/models/#check_1","text":"| @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_1","text":"| @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model. Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_1","text":"| check_validity () -> None Check whether a Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#and-objects","text":"class And ( ConstraintExpr ) Implementation of the 'And' constraint expression.","title":"And Objects"},{"location":"aea/api/helpers/search/models/#__init___5","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_2","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_2","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_2","text":"| check_validity () Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___5","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_5","text":"| encode () -> models_pb2 . Query . ConstraintExpr . And Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_5","text":"| @classmethod | decode ( cls , and_pb ) -> \"And\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : and_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#or-objects","text":"class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression.","title":"Or Objects"},{"location":"aea/api/helpers/search/models/#__init___6","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_3","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_3","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_3","text":"| check_validity () Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___6","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_6","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Or Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_6","text":"| @classmethod | decode ( cls , or_pb ) -> \"Or\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : or_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#not-objects","text":"class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression.","title":"Not Objects"},{"location":"aea/api/helpers/search/models/#__init___7","text":"| __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_4","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_4","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___7","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_7","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Not Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_7","text":"| @classmethod | decode ( cls , not_pb ) -> \"Not\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : not_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#constraint-objects","text":"class Constraint ( ConstraintExpr ) The atomic component of a constraint expression.","title":"Constraint Objects"},{"location":"aea/api/helpers/search/models/#__init___8","text":"| __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_5","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", (\"horror\", \"science_fiction\"))) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_5","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___8","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___6","text":"| __str__ () Get the string representation of the constraint.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_8","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Constraint Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_8","text":"| @classmethod | decode ( cls , constraint_pb ) -> \"Constraint\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#query-objects","text":"class Query () This class lets you build a query for the OEF.","title":"Query Objects"},{"location":"aea/api/helpers/search/models/#__init___9","text":"| __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_6","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_6","text":"| is_valid ( data_model : DataModel ) -> bool Given a data model, check whether the query is valid for that data model. Returns : True if the query is compliant with the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_4","text":"| check_validity () Check whether the` object is valid. :return None Raises : ValueError : if the query does not satisfy some sanity requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___9","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___7","text":"| __str__ () Get the string representation of the constraint.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_9","text":"| @classmethod | encode ( cls , query_pb , query : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_pb : the protocol buffer object wrapping an object that corresponds with this class. query : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_9","text":"| @classmethod | decode ( cls , query_pb ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#haversine","text":"haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"haversine"},{"location":"aea/api/helpers/storage/generic_storage/","text":"aea.helpers.storage.generic _ storage This module contains the storage implementation. AsyncCollection Objects class AsyncCollection () Async collection. __ init __ | __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) Init collection object. Arguments : storage_backend : storage backed to use. collection_name : srt put | async put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get | async get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove | async remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find | async find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None list | async list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. SyncCollection Objects class SyncCollection () Async collection. __ init __ | __init__ ( async_collection_coro , loop : asyncio . AbstractEventLoop ) Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running. put | put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get | get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove | remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find | find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies list | list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. Storage Objects class Storage ( Runnable ) Generic storage. __ init __ | __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init stortage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True. Returns : None wait _ connected | async wait_connected () -> None Wait generic storage is connected. is _ connected | @property | is_connected () -> bool Get running state of the storage. run | async run () Connect storage. get _ collection | async get_collection ( collection_name : str ) -> AsyncCollection Get async collection. get _ sync _ collection | get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection. __ repr __ | __repr__ () -> str Get string representation of the storage.","title":"GenericStorage"},{"location":"aea/api/helpers/storage/generic_storage/#aeahelpersstoragegeneric_storage","text":"This module contains the storage implementation.","title":"aea.helpers.storage.generic_storage"},{"location":"aea/api/helpers/storage/generic_storage/#asynccollection-objects","text":"class AsyncCollection () Async collection.","title":"AsyncCollection Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init__","text":"| __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) Init collection object. Arguments : storage_backend : storage backed to use. collection_name : srt","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#put","text":"| async put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/generic_storage/#get","text":"| async get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/generic_storage/#remove","text":"| async remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/generic_storage/#find","text":"| async find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None","title":"find"},{"location":"aea/api/helpers/storage/generic_storage/#list","text":"| async list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/generic_storage/#synccollection-objects","text":"class SyncCollection () Async collection.","title":"SyncCollection Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init___1","text":"| __init__ ( async_collection_coro , loop : asyncio . AbstractEventLoop ) Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running.","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#put_1","text":"| put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/generic_storage/#get_1","text":"| get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/generic_storage/#remove_1","text":"| remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/generic_storage/#find_1","text":"| find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies","title":"find"},{"location":"aea/api/helpers/storage/generic_storage/#list_1","text":"| list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/generic_storage/#storage-objects","text":"class Storage ( Runnable ) Generic storage.","title":"Storage Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init___2","text":"| __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init stortage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True. Returns : None","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#wait_connected","text":"| async wait_connected () -> None Wait generic storage is connected.","title":"wait_connected"},{"location":"aea/api/helpers/storage/generic_storage/#is_connected","text":"| @property | is_connected () -> bool Get running state of the storage.","title":"is_connected"},{"location":"aea/api/helpers/storage/generic_storage/#run","text":"| async run () Connect storage.","title":"run"},{"location":"aea/api/helpers/storage/generic_storage/#get_collection","text":"| async get_collection ( collection_name : str ) -> AsyncCollection Get async collection.","title":"get_collection"},{"location":"aea/api/helpers/storage/generic_storage/#get_sync_collection","text":"| get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection.","title":"get_sync_collection"},{"location":"aea/api/helpers/storage/generic_storage/#__repr__","text":"| __repr__ () -> str Get string representation of the storage.","title":"__repr__"},{"location":"aea/api/helpers/storage/backends/base/","text":"aea.helpers.storage.backends.base This module contains storage abstract backend class. AbstractStorageBackend Objects class AbstractStorageBackend ( ABC ) Abstract base class for storage backend. __ init __ | __init__ ( uri : str ) -> None Init backend. connect | @abstractmethod | async connect () -> None Connect to backend. disconnect | @abstractmethod | async disconnect () -> None Disconnect the backend. ensure _ collection | @abstractmethod | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None put | @abstractmethod | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None get | @abstractmethod | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove | @abstractmethod | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None find | @abstractmethod | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies list | @abstractmethod | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Base"},{"location":"aea/api/helpers/storage/backends/base/#aeahelpersstoragebackendsbase","text":"This module contains storage abstract backend class.","title":"aea.helpers.storage.backends.base"},{"location":"aea/api/helpers/storage/backends/base/#abstractstoragebackend-objects","text":"class AbstractStorageBackend ( ABC ) Abstract base class for storage backend.","title":"AbstractStorageBackend Objects"},{"location":"aea/api/helpers/storage/backends/base/#__init__","text":"| __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"aea/api/helpers/storage/backends/base/#connect","text":"| @abstractmethod | async connect () -> None Connect to backend.","title":"connect"},{"location":"aea/api/helpers/storage/backends/base/#disconnect","text":"| @abstractmethod | async disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"aea/api/helpers/storage/backends/base/#ensure_collection","text":"| @abstractmethod | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None","title":"ensure_collection"},{"location":"aea/api/helpers/storage/backends/base/#put","text":"| @abstractmethod | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/backends/base/#get","text":"| @abstractmethod | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/backends/base/#remove","text":"| @abstractmethod | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/backends/base/#find","text":"| @abstractmethod | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies","title":"find"},{"location":"aea/api/helpers/storage/backends/base/#list","text":"| @abstractmethod | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/backends/sqlite/","text":"aea.helpers.storage.backends.sqlite This module contains sqlite storage backend implementation. SqliteStorageBackend Objects class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend. __ init __ | __init__ ( uri : str ) -> None Init backend. connect | async connect () -> None Connect to backend. disconnect | async disconnect () -> None Disconnect the backend. ensure _ collection | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None put | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None get | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None find | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None list | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Sqlite"},{"location":"aea/api/helpers/storage/backends/sqlite/#aeahelpersstoragebackendssqlite","text":"This module contains sqlite storage backend implementation.","title":"aea.helpers.storage.backends.sqlite"},{"location":"aea/api/helpers/storage/backends/sqlite/#sqlitestoragebackend-objects","text":"class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend.","title":"SqliteStorageBackend Objects"},{"location":"aea/api/helpers/storage/backends/sqlite/#__init__","text":"| __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"aea/api/helpers/storage/backends/sqlite/#connect","text":"| async connect () -> None Connect to backend.","title":"connect"},{"location":"aea/api/helpers/storage/backends/sqlite/#disconnect","text":"| async disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"aea/api/helpers/storage/backends/sqlite/#ensure_collection","text":"| async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None","title":"ensure_collection"},{"location":"aea/api/helpers/storage/backends/sqlite/#put","text":"| async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/backends/sqlite/#get","text":"| async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/backends/sqlite/#remove","text":"| async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/backends/sqlite/#find","text":"| async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None","title":"find"},{"location":"aea/api/helpers/storage/backends/sqlite/#list","text":"| async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/transaction/base/","text":"aea.helpers.transaction.base This module contains terms related classes. RawTransaction Objects class RawTransaction () This class represents an instance of RawTransaction. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of RawTransaction. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () Get the body. encode | @staticmethod | encode ( raw_transaction_protobuf_object , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , raw_transaction_protobuf_object ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. RawMessage Objects class RawMessage () This class represents an instance of RawMessage. __ init __ | __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) Initialise an instance of RawMessage. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () Get the body. is _ deprecated _ mode | @property | is_deprecated_mode () Get the is_deprecated_mode. encode | @staticmethod | encode ( raw_message_protobuf_object , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , raw_message_protobuf_object ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. SignedTransaction Objects class SignedTransaction () This class represents an instance of SignedTransaction. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of SignedTransaction. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () Get the body. encode | @staticmethod | encode ( signed_transaction_protobuf_object , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , signed_transaction_protobuf_object ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. SignedMessage Objects class SignedMessage () This class represents an instance of RawMessage. __ init __ | __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) Initialise an instance of SignedMessage. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () Get the body. is _ deprecated _ mode | @property | is_deprecated_mode () Get the is_deprecated_mode. encode | @staticmethod | encode ( signed_message_protobuf_object , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , signed_message_protobuf_object ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. State Objects class State () This class represents an instance of State. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of State. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> JSONLike Get the body. encode | @staticmethod | encode ( state_protobuf_object , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , state_protobuf_object ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. Terms Objects class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction. __ init __ | __init__ ( ledger_id : str , sender_address : Address , counterparty_address : Address , amount_by_currency_id : Dict [ str , int ], quantities_by_good_id : Dict [ str , int ], nonce : str , is_sender_payable_tx_fee : bool = True , fee_by_currency_id : Optional [ Dict [ str , int ]] = None , is_strict : bool = False , ** kwargs , ,) Instantiate terms of a transaction. Arguments : ledger_id : the ledger on which the terms are to be settled. sender_address : the sender address of the transaction. counterparty_address : the counterparty address of the transaction. amount_by_currency_id : the amount by the currency of the transaction. quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. is_sender_payable_tx_fee : whether the sender or counterparty pays the tx fee. nonce : nonce to be included in transaction to discriminate otherwise identical transactions. fee_by_currency_id : the fee associated with the transaction. is_strict : whether or not terms must have quantities and amounts of opposite signs. id | @property | id () -> str Get hash of the terms. sender _ hash | @property | sender_hash () -> str Get the sender hash. counterparty _ hash | @property | counterparty_hash () -> str Get the sender hash. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. sender _ address | @property | sender_address () -> Address Get the sender address. counterparty _ address | @property | counterparty_address () -> Address Get the counterparty address. counterparty _ address | @counterparty_address . setter | counterparty_address ( counterparty_address : Address ) -> None Set the counterparty address. amount _ by _ currency _ id | @property | amount_by_currency_id () -> Dict [ str , int ] Get the amount by currency id. is _ sender _ payable _ tx _ fee | @property | is_sender_payable_tx_fee () -> bool Bool indicating whether the tx fee is paid by sender or counterparty. is _ single _ currency | @property | is_single_currency () -> bool Check whether a single currency is used for payment. is _ empty _ currency | @property | is_empty_currency () -> bool Check whether a single currency is used for payment. currency _ id | @property | currency_id () -> str Get the amount the sender must pay. sender _ payable _ amount | @property | sender_payable_amount () -> int Get the amount the sender must pay. sender _ payable _ amount _ incl _ fee | @property | sender_payable_amount_incl_fee () -> int Get the amount the sender must pay inclusive fee. counterparty _ payable _ amount | @property | counterparty_payable_amount () -> int Get the amount the counterparty must pay. counterparty _ payable _ amount _ incl _ fee | @property | counterparty_payable_amount_incl_fee () -> int Get the amount the counterparty must pay. quantities _ by _ good _ id | @property | quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good id. good _ ids | @property | good_ids () -> List [ str ] Get the (ordered) good ids. sender _ supplied _ quantities | @property | sender_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the sender. counterparty _ supplied _ quantities | @property | counterparty_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the counterparty. nonce | @property | nonce () -> str Get the nonce. has _ fee | @property | has_fee () -> bool Check if fee is set. fee | @property | fee () -> int Get the fee. sender _ fee | @property | sender_fee () -> int Get the sender fee. counterparty _ fee | @property | counterparty_fee () -> int Get the counterparty fee. fee _ by _ currency _ id | @property | fee_by_currency_id () -> Dict [ str , int ] Get fee by currency. kwargs | @property | kwargs () -> JSONLike Get the kwargs. is _ strict | @property | is_strict () -> bool Get is_strict. get _ hash | @staticmethod | get_hash ( ledger_id : str , sender_address : str , counterparty_address : str , good_ids : List [ str ], sender_supplied_quantities : List [ int ], counterparty_supplied_quantities : List [ int ], sender_payable_amount : int , counterparty_payable_amount : int , nonce : str ) -> str Generate a hash from transaction information. Arguments : sender_addr : the sender address counterparty_addr : the counterparty address good_ids : the list of good ids sender_supplied_quantities : the quantities supplied by the sender (must all be positive) counterparty_supplied_quantities : the quantities supplied by the counterparty (must all be positive) sender_payable_amount : the amount payable by the sender counterparty_payable_amount : the amount payable by the counterparty tx_nonce : the nonce of the transaction Returns : the hash encode | @staticmethod | encode ( terms_protobuf_object , terms_object : \"Terms\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the terms_protobuf_object argument must be matched with the instance of this class in the 'terms_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. terms_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , terms_protobuf_object ) -> \"Terms\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'terms_protobuf_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'terms_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. TransactionDigest Objects class TransactionDigest () This class represents an instance of TransactionDigest. __ init __ | __init__ ( ledger_id : str , body : str ) Initialise an instance of TransactionDigest. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> str Get the receipt. encode | @staticmethod | encode ( transaction_digest_protobuf_object , transaction_digest_object : \"TransactionDigest\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_digest_protobuf_object argument must be matched with the instance of this class in the 'transaction_digest_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_digest_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , transaction_digest_protobuf_object ) -> \"TransactionDigest\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation. TransactionReceipt Objects class TransactionReceipt () This class represents an instance of TransactionReceipt. __ init __ | __init__ ( ledger_id : str , receipt : JSONLike , transaction : JSONLike ) Initialise an instance of TransactionReceipt. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. receipt | @property | receipt () -> JSONLike Get the receipt. transaction | @property | transaction () -> JSONLike Get the transaction. encode | @staticmethod | encode ( transaction_receipt_protobuf_object , transaction_receipt_object : \"TransactionReceipt\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_receipt_protobuf_object argument must be matched with the instance of this class in the 'transaction_receipt_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_receipt_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , transaction_receipt_protobuf_object ) -> \"TransactionReceipt\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. __ eq __ | __eq__ ( other ) Check equality. __ str __ | __str__ () Get string representation.","title":"Base"},{"location":"aea/api/helpers/transaction/base/#aeahelperstransactionbase","text":"This module contains terms related classes.","title":"aea.helpers.transaction.base"},{"location":"aea/api/helpers/transaction/base/#rawtransaction-objects","text":"class RawTransaction () This class represents an instance of RawTransaction.","title":"RawTransaction Objects"},{"location":"aea/api/helpers/transaction/base/#__init__","text":"| __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of RawTransaction.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body","text":"| @property | body () Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode","text":"| @staticmethod | encode ( raw_transaction_protobuf_object , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode","text":"| @classmethod | decode ( cls , raw_transaction_protobuf_object ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq__","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#rawmessage-objects","text":"class RawMessage () This class represents an instance of RawMessage.","title":"RawMessage Objects"},{"location":"aea/api/helpers/transaction/base/#__init___1","text":"| __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) Initialise an instance of RawMessage.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_1","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_1","text":"| @property | body () Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#is_deprecated_mode","text":"| @property | is_deprecated_mode () Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"aea/api/helpers/transaction/base/#encode_1","text":"| @staticmethod | encode ( raw_message_protobuf_object , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_1","text":"| @classmethod | decode ( cls , raw_message_protobuf_object ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___1","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___1","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#signedtransaction-objects","text":"class SignedTransaction () This class represents an instance of SignedTransaction.","title":"SignedTransaction Objects"},{"location":"aea/api/helpers/transaction/base/#__init___2","text":"| __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of SignedTransaction.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_2","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_2","text":"| @property | body () Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_2","text":"| @staticmethod | encode ( signed_transaction_protobuf_object , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_2","text":"| @classmethod | decode ( cls , signed_transaction_protobuf_object ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___2","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___2","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#signedmessage-objects","text":"class SignedMessage () This class represents an instance of RawMessage.","title":"SignedMessage Objects"},{"location":"aea/api/helpers/transaction/base/#__init___3","text":"| __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) Initialise an instance of SignedMessage.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_3","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_3","text":"| @property | body () Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#is_deprecated_mode_1","text":"| @property | is_deprecated_mode () Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"aea/api/helpers/transaction/base/#encode_3","text":"| @staticmethod | encode ( signed_message_protobuf_object , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_3","text":"| @classmethod | decode ( cls , signed_message_protobuf_object ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___3","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___3","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#state-objects","text":"class State () This class represents an instance of State.","title":"State Objects"},{"location":"aea/api/helpers/transaction/base/#__init___4","text":"| __init__ ( ledger_id : str , body : JSONLike ) Initialise an instance of State.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_4","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_4","text":"| @property | body () -> JSONLike Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_4","text":"| @staticmethod | encode ( state_protobuf_object , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_4","text":"| @classmethod | decode ( cls , state_protobuf_object ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___4","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___4","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#terms-objects","text":"class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction.","title":"Terms Objects"},{"location":"aea/api/helpers/transaction/base/#__init___5","text":"| __init__ ( ledger_id : str , sender_address : Address , counterparty_address : Address , amount_by_currency_id : Dict [ str , int ], quantities_by_good_id : Dict [ str , int ], nonce : str , is_sender_payable_tx_fee : bool = True , fee_by_currency_id : Optional [ Dict [ str , int ]] = None , is_strict : bool = False , ** kwargs , ,) Instantiate terms of a transaction. Arguments : ledger_id : the ledger on which the terms are to be settled. sender_address : the sender address of the transaction. counterparty_address : the counterparty address of the transaction. amount_by_currency_id : the amount by the currency of the transaction. quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. is_sender_payable_tx_fee : whether the sender or counterparty pays the tx fee. nonce : nonce to be included in transaction to discriminate otherwise identical transactions. fee_by_currency_id : the fee associated with the transaction. is_strict : whether or not terms must have quantities and amounts of opposite signs.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#id","text":"| @property | id () -> str Get hash of the terms.","title":"id"},{"location":"aea/api/helpers/transaction/base/#sender_hash","text":"| @property | sender_hash () -> str Get the sender hash.","title":"sender_hash"},{"location":"aea/api/helpers/transaction/base/#counterparty_hash","text":"| @property | counterparty_hash () -> str Get the sender hash.","title":"counterparty_hash"},{"location":"aea/api/helpers/transaction/base/#ledger_id_5","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#sender_address","text":"| @property | sender_address () -> Address Get the sender address.","title":"sender_address"},{"location":"aea/api/helpers/transaction/base/#counterparty_address","text":"| @property | counterparty_address () -> Address Get the counterparty address.","title":"counterparty_address"},{"location":"aea/api/helpers/transaction/base/#counterparty_address_1","text":"| @counterparty_address . setter | counterparty_address ( counterparty_address : Address ) -> None Set the counterparty address.","title":"counterparty_address"},{"location":"aea/api/helpers/transaction/base/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> Dict [ str , int ] Get the amount by currency id.","title":"amount_by_currency_id"},{"location":"aea/api/helpers/transaction/base/#is_sender_payable_tx_fee","text":"| @property | is_sender_payable_tx_fee () -> bool Bool indicating whether the tx fee is paid by sender or counterparty.","title":"is_sender_payable_tx_fee"},{"location":"aea/api/helpers/transaction/base/#is_single_currency","text":"| @property | is_single_currency () -> bool Check whether a single currency is used for payment.","title":"is_single_currency"},{"location":"aea/api/helpers/transaction/base/#is_empty_currency","text":"| @property | is_empty_currency () -> bool Check whether a single currency is used for payment.","title":"is_empty_currency"},{"location":"aea/api/helpers/transaction/base/#currency_id","text":"| @property | currency_id () -> str Get the amount the sender must pay.","title":"currency_id"},{"location":"aea/api/helpers/transaction/base/#sender_payable_amount","text":"| @property | sender_payable_amount () -> int Get the amount the sender must pay.","title":"sender_payable_amount"},{"location":"aea/api/helpers/transaction/base/#sender_payable_amount_incl_fee","text":"| @property | sender_payable_amount_incl_fee () -> int Get the amount the sender must pay inclusive fee.","title":"sender_payable_amount_incl_fee"},{"location":"aea/api/helpers/transaction/base/#counterparty_payable_amount","text":"| @property | counterparty_payable_amount () -> int Get the amount the counterparty must pay.","title":"counterparty_payable_amount"},{"location":"aea/api/helpers/transaction/base/#counterparty_payable_amount_incl_fee","text":"| @property | counterparty_payable_amount_incl_fee () -> int Get the amount the counterparty must pay.","title":"counterparty_payable_amount_incl_fee"},{"location":"aea/api/helpers/transaction/base/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good id.","title":"quantities_by_good_id"},{"location":"aea/api/helpers/transaction/base/#good_ids","text":"| @property | good_ids () -> List [ str ] Get the (ordered) good ids.","title":"good_ids"},{"location":"aea/api/helpers/transaction/base/#sender_supplied_quantities","text":"| @property | sender_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the sender.","title":"sender_supplied_quantities"},{"location":"aea/api/helpers/transaction/base/#counterparty_supplied_quantities","text":"| @property | counterparty_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the counterparty.","title":"counterparty_supplied_quantities"},{"location":"aea/api/helpers/transaction/base/#nonce","text":"| @property | nonce () -> str Get the nonce.","title":"nonce"},{"location":"aea/api/helpers/transaction/base/#has_fee","text":"| @property | has_fee () -> bool Check if fee is set.","title":"has_fee"},{"location":"aea/api/helpers/transaction/base/#fee","text":"| @property | fee () -> int Get the fee.","title":"fee"},{"location":"aea/api/helpers/transaction/base/#sender_fee","text":"| @property | sender_fee () -> int Get the sender fee.","title":"sender_fee"},{"location":"aea/api/helpers/transaction/base/#counterparty_fee","text":"| @property | counterparty_fee () -> int Get the counterparty fee.","title":"counterparty_fee"},{"location":"aea/api/helpers/transaction/base/#fee_by_currency_id","text":"| @property | fee_by_currency_id () -> Dict [ str , int ] Get fee by currency.","title":"fee_by_currency_id"},{"location":"aea/api/helpers/transaction/base/#kwargs","text":"| @property | kwargs () -> JSONLike Get the kwargs.","title":"kwargs"},{"location":"aea/api/helpers/transaction/base/#is_strict","text":"| @property | is_strict () -> bool Get is_strict.","title":"is_strict"},{"location":"aea/api/helpers/transaction/base/#get_hash","text":"| @staticmethod | get_hash ( ledger_id : str , sender_address : str , counterparty_address : str , good_ids : List [ str ], sender_supplied_quantities : List [ int ], counterparty_supplied_quantities : List [ int ], sender_payable_amount : int , counterparty_payable_amount : int , nonce : str ) -> str Generate a hash from transaction information. Arguments : sender_addr : the sender address counterparty_addr : the counterparty address good_ids : the list of good ids sender_supplied_quantities : the quantities supplied by the sender (must all be positive) counterparty_supplied_quantities : the quantities supplied by the counterparty (must all be positive) sender_payable_amount : the amount payable by the sender counterparty_payable_amount : the amount payable by the counterparty tx_nonce : the nonce of the transaction Returns : the hash","title":"get_hash"},{"location":"aea/api/helpers/transaction/base/#encode_5","text":"| @staticmethod | encode ( terms_protobuf_object , terms_object : \"Terms\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the terms_protobuf_object argument must be matched with the instance of this class in the 'terms_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. terms_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_5","text":"| @classmethod | decode ( cls , terms_protobuf_object ) -> \"Terms\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'terms_protobuf_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'terms_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___5","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___5","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#transactiondigest-objects","text":"class TransactionDigest () This class represents an instance of TransactionDigest.","title":"TransactionDigest Objects"},{"location":"aea/api/helpers/transaction/base/#__init___6","text":"| __init__ ( ledger_id : str , body : str ) Initialise an instance of TransactionDigest.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_6","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_5","text":"| @property | body () -> str Get the receipt.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_6","text":"| @staticmethod | encode ( transaction_digest_protobuf_object , transaction_digest_object : \"TransactionDigest\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_digest_protobuf_object argument must be matched with the instance of this class in the 'transaction_digest_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_digest_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_6","text":"| @classmethod | decode ( cls , transaction_digest_protobuf_object ) -> \"TransactionDigest\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___6","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___6","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#transactionreceipt-objects","text":"class TransactionReceipt () This class represents an instance of TransactionReceipt.","title":"TransactionReceipt Objects"},{"location":"aea/api/helpers/transaction/base/#__init___7","text":"| __init__ ( ledger_id : str , receipt : JSONLike , transaction : JSONLike ) Initialise an instance of TransactionReceipt.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_7","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#receipt","text":"| @property | receipt () -> JSONLike Get the receipt.","title":"receipt"},{"location":"aea/api/helpers/transaction/base/#transaction","text":"| @property | transaction () -> JSONLike Get the transaction.","title":"transaction"},{"location":"aea/api/helpers/transaction/base/#encode_7","text":"| @staticmethod | encode ( transaction_receipt_protobuf_object , transaction_receipt_object : \"TransactionReceipt\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_receipt_protobuf_object argument must be matched with the instance of this class in the 'transaction_receipt_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_receipt_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_7","text":"| @classmethod | decode ( cls , transaction_receipt_protobuf_object ) -> \"TransactionReceipt\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___7","text":"| __eq__ ( other ) Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___7","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/identity/base/","text":"aea.identity.base This module contains the identity class. Identity Objects class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair) __ init __ | __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_LEDGER ) Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address. default _ address _ key | @property | default_address_key () -> str Get the default address key. name | @property | name () -> str Get the agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get the addresses. address | @property | address () -> Address Get the default address.","title":"Identity"},{"location":"aea/api/identity/base/#aeaidentitybase","text":"This module contains the identity class.","title":"aea.identity.base"},{"location":"aea/api/identity/base/#identity-objects","text":"class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair)","title":"Identity Objects"},{"location":"aea/api/identity/base/#__init__","text":"| __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_LEDGER ) Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address.","title":"__init__"},{"location":"aea/api/identity/base/#default_address_key","text":"| @property | default_address_key () -> str Get the default address key.","title":"default_address_key"},{"location":"aea/api/identity/base/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/identity/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get the addresses.","title":"addresses"},{"location":"aea/api/identity/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/mail/base/","text":"aea.mail.base Mail module abstract base classes. AEAConnectionError Objects class AEAConnectionError ( Exception ) Exception class for connection errors. Empty Objects class Empty ( Exception ) Exception for when the inbox is empty. URI Objects class URI () URI following RFC3986. __ init __ | __init__ ( uri_raw : str ) Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant scheme | @property | scheme () -> str Get the scheme. netloc | @property | netloc () -> str Get the netloc. path | @property | path () -> str Get the path. params | @property | params () -> str Get the params. query | @property | query () -> str Get the query. fragment | @property | fragment () -> str Get the fragment. username | @property | username () -> Optional [ str ] Get the username. password | @property | password () -> Optional [ str ] Get the password. host | @property | host () -> Optional [ str ] Get the host. port | @property | port () -> Optional [ int ] Get the port. __ str __ | __str__ () Get string representation. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeContext Objects class EnvelopeContext () Extra information for the handling of an envelope. __ init __ | __init__ ( connection_id : Optional [ PublicId ] = None , skill_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. skill_id : the skill id used for routing the incoming envelope in the AEA. uri : the URI sent with the envelope. connection _ id | @property | connection_id () -> Optional [ PublicId ] Get the connection id. skill _ id | @property | skill_id () -> Optional [ PublicId ] Get the skill id. uri _ raw | @property | uri_raw () -> str Get uri in string format. __ str __ | __str__ () Get the string representation. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeSerializer Objects class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope. encode | @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope ProtobufEnvelopeSerializer Objects class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf. encode | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope Envelope Objects class Envelope () The top level message class for agent to agent communication. __ init __ | __init__ ( to : Address , sender : Address , protocol_id : PublicId , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message. context : the optional envelope context. to | @property | to () -> Address Get address of receiver. to | @to . setter | to ( to : Address ) -> None Set address of receiver. sender | @property | sender () -> Address Get address of sender. sender | @sender . setter | sender ( sender : Address ) -> None Set address of sender. protocol _ id | @property | protocol_id () -> PublicId Get protocol id. protocol _ id | @protocol_id . setter | protocol_id ( protocol_id : PublicId ) -> None Set the protocol id. message | @property | message () -> Union [ Message , bytes ] Get the protocol-specific message. message | @message . setter | message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message. message _ bytes | @property | message_bytes () -> bytes Get the protocol-specific message. context | @property | context () -> EnvelopeContext Get the envelope context. skill _ id | @property | skill_id () -> Optional [ PublicId ] Get the skill id from an envelope context, if set. Returns : skill id connection _ id | @property | connection_id () -> Optional [ PublicId ] Get the connection id from an envelope context, if set. Returns : connection id is _ sender _ public _ id | @property | is_sender_public_id () Check if sender is a public id. is _ to _ public _ id | @property | is_to_public_id () Check if to is a public id. __ eq __ | __eq__ ( other ) Compare with another object. encode | encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope. decode | @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope. __ str __ | __str__ () Get the string representation of an envelope.","title":"Mail"},{"location":"aea/api/mail/base/#aeamailbase","text":"Mail module abstract base classes.","title":"aea.mail.base"},{"location":"aea/api/mail/base/#aeaconnectionerror-objects","text":"class AEAConnectionError ( Exception ) Exception class for connection errors.","title":"AEAConnectionError Objects"},{"location":"aea/api/mail/base/#empty-objects","text":"class Empty ( Exception ) Exception for when the inbox is empty.","title":"Empty Objects"},{"location":"aea/api/mail/base/#uri-objects","text":"class URI () URI following RFC3986.","title":"URI Objects"},{"location":"aea/api/mail/base/#__init__","text":"| __init__ ( uri_raw : str ) Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant","title":"__init__"},{"location":"aea/api/mail/base/#scheme","text":"| @property | scheme () -> str Get the scheme.","title":"scheme"},{"location":"aea/api/mail/base/#netloc","text":"| @property | netloc () -> str Get the netloc.","title":"netloc"},{"location":"aea/api/mail/base/#path","text":"| @property | path () -> str Get the path.","title":"path"},{"location":"aea/api/mail/base/#params","text":"| @property | params () -> str Get the params.","title":"params"},{"location":"aea/api/mail/base/#query","text":"| @property | query () -> str Get the query.","title":"query"},{"location":"aea/api/mail/base/#fragment","text":"| @property | fragment () -> str Get the fragment.","title":"fragment"},{"location":"aea/api/mail/base/#username","text":"| @property | username () -> Optional [ str ] Get the username.","title":"username"},{"location":"aea/api/mail/base/#password","text":"| @property | password () -> Optional [ str ] Get the password.","title":"password"},{"location":"aea/api/mail/base/#host","text":"| @property | host () -> Optional [ str ] Get the host.","title":"host"},{"location":"aea/api/mail/base/#port","text":"| @property | port () -> Optional [ int ] Get the port.","title":"port"},{"location":"aea/api/mail/base/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopecontext-objects","text":"class EnvelopeContext () Extra information for the handling of an envelope.","title":"EnvelopeContext Objects"},{"location":"aea/api/mail/base/#__init___1","text":"| __init__ ( connection_id : Optional [ PublicId ] = None , skill_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. skill_id : the skill id used for routing the incoming envelope in the AEA. uri : the URI sent with the envelope.","title":"__init__"},{"location":"aea/api/mail/base/#connection_id","text":"| @property | connection_id () -> Optional [ PublicId ] Get the connection id.","title":"connection_id"},{"location":"aea/api/mail/base/#skill_id","text":"| @property | skill_id () -> Optional [ PublicId ] Get the skill id.","title":"skill_id"},{"location":"aea/api/mail/base/#uri_raw","text":"| @property | uri_raw () -> str Get uri in string format.","title":"uri_raw"},{"location":"aea/api/mail/base/#__str___1","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopeserializer-objects","text":"class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope.","title":"EnvelopeSerializer Objects"},{"location":"aea/api/mail/base/#encode","text":"| @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode","text":"| @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#protobufenvelopeserializer-objects","text":"class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf.","title":"ProtobufEnvelopeSerializer Objects"},{"location":"aea/api/mail/base/#encode_1","text":"| encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode_1","text":"| decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#envelope-objects","text":"class Envelope () The top level message class for agent to agent communication.","title":"Envelope Objects"},{"location":"aea/api/mail/base/#__init___2","text":"| __init__ ( to : Address , sender : Address , protocol_id : PublicId , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message. context : the optional envelope context.","title":"__init__"},{"location":"aea/api/mail/base/#to","text":"| @property | to () -> Address Get address of receiver.","title":"to"},{"location":"aea/api/mail/base/#to_1","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/mail/base/#sender","text":"| @property | sender () -> Address Get address of sender.","title":"sender"},{"location":"aea/api/mail/base/#sender_1","text":"| @sender . setter | sender ( sender : Address ) -> None Set address of sender.","title":"sender"},{"location":"aea/api/mail/base/#protocol_id","text":"| @property | protocol_id () -> PublicId Get protocol id.","title":"protocol_id"},{"location":"aea/api/mail/base/#protocol_id_1","text":"| @protocol_id . setter | protocol_id ( protocol_id : PublicId ) -> None Set the protocol id.","title":"protocol_id"},{"location":"aea/api/mail/base/#message","text":"| @property | message () -> Union [ Message , bytes ] Get the protocol-specific message.","title":"message"},{"location":"aea/api/mail/base/#message_1","text":"| @message . setter | message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message.","title":"message"},{"location":"aea/api/mail/base/#message_bytes","text":"| @property | message_bytes () -> bytes Get the protocol-specific message.","title":"message_bytes"},{"location":"aea/api/mail/base/#context","text":"| @property | context () -> EnvelopeContext Get the envelope context.","title":"context"},{"location":"aea/api/mail/base/#skill_id_1","text":"| @property | skill_id () -> Optional [ PublicId ] Get the skill id from an envelope context, if set. Returns : skill id","title":"skill_id"},{"location":"aea/api/mail/base/#connection_id_1","text":"| @property | connection_id () -> Optional [ PublicId ] Get the connection id from an envelope context, if set. Returns : connection id","title":"connection_id"},{"location":"aea/api/mail/base/#is_sender_public_id","text":"| @property | is_sender_public_id () Check if sender is a public id.","title":"is_sender_public_id"},{"location":"aea/api/mail/base/#is_to_public_id","text":"| @property | is_to_public_id () Check if to is a public id.","title":"is_to_public_id"},{"location":"aea/api/mail/base/#__eq___2","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#encode_2","text":"| encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode_2","text":"| @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope.","title":"decode"},{"location":"aea/api/mail/base/#__str___2","text":"| __str__ () Get the string representation of an envelope.","title":"__str__"},{"location":"aea/api/manager/manager/","text":"aea.manager.manager This module contains the implementation of AEA agents manager. AgentRunAsyncTask Objects class AgentRunAsyncTask () Async task wrapper for agent. __ init __ | __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent and loop. create _ run _ loop | create_run_loop () -> None Create run loop. start | start () -> None Start task. wait | wait () -> asyncio . Future Return future to wait task completed. stop | stop () -> None Stop task. run | async run () -> None Run task body. is _ running | @property | is_running () -> bool Return is task running. AgentRunThreadTask Objects class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent. __ init __ | __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent and loop. create _ run _ loop | create_run_loop () -> None Create run loop. start | start () -> None Run task in a dedicated thread. MultiAgentManager Objects class MultiAgentManager () Multi agents manager. __ init __ | __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME ) -> None Initialize manager. Arguments : working_dir : directory to store base agents. keys _ dir | @property | keys_dir () -> str Get the keys directory. certs _ dir | @property | certs_dir () -> str Get the certs directory. is _ running | @property | is_running () -> bool Is manager running. dict _ state | @property | dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state. add _ error _ callback | add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> None Add error callback to call on error raised. start _ manager | start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance. stop _ manager | stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None add _ project | add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. remove _ project | remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project. list _ projects | list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects add _ agent | add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. config : agent config (used for agent re-creation). Returns : manager add _ agent _ with _ config | add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager get _ agent _ overridables | get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict. set _ agent _ overrides | set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> None Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : None list _ agents _ info | list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running. list _ agents | list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names remove _ agent | remove_agent ( agent_name : str ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove Returns : None start _ agent | start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None start _ all _ agents | start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None stop _ agent | stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : None stop _ all _ agents | stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : None stop _ agents | stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Returns : None start _ agents | start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Returns : None get _ agent _ alias | get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Returns : AgentAlias","title":"Manager"},{"location":"aea/api/manager/manager/#aeamanagermanager","text":"This module contains the implementation of AEA agents manager.","title":"aea.manager.manager"},{"location":"aea/api/manager/manager/#agentrunasynctask-objects","text":"class AgentRunAsyncTask () Async task wrapper for agent.","title":"AgentRunAsyncTask Objects"},{"location":"aea/api/manager/manager/#__init__","text":"| __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent and loop.","title":"__init__"},{"location":"aea/api/manager/manager/#create_run_loop","text":"| create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"aea/api/manager/manager/#start","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/manager/manager/#wait","text":"| wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"aea/api/manager/manager/#stop","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/manager/manager/#run","text":"| async run () -> None Run task body.","title":"run"},{"location":"aea/api/manager/manager/#is_running","text":"| @property | is_running () -> bool Return is task running.","title":"is_running"},{"location":"aea/api/manager/manager/#agentrunthreadtask-objects","text":"class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent.","title":"AgentRunThreadTask Objects"},{"location":"aea/api/manager/manager/#__init___1","text":"| __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent and loop.","title":"__init__"},{"location":"aea/api/manager/manager/#create_run_loop_1","text":"| create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"aea/api/manager/manager/#start_1","text":"| start () -> None Run task in a dedicated thread.","title":"start"},{"location":"aea/api/manager/manager/#multiagentmanager-objects","text":"class MultiAgentManager () Multi agents manager.","title":"MultiAgentManager Objects"},{"location":"aea/api/manager/manager/#__init___2","text":"| __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME ) -> None Initialize manager. Arguments : working_dir : directory to store base agents.","title":"__init__"},{"location":"aea/api/manager/manager/#keys_dir","text":"| @property | keys_dir () -> str Get the keys directory.","title":"keys_dir"},{"location":"aea/api/manager/manager/#certs_dir","text":"| @property | certs_dir () -> str Get the certs directory.","title":"certs_dir"},{"location":"aea/api/manager/manager/#is_running_1","text":"| @property | is_running () -> bool Is manager running.","title":"is_running"},{"location":"aea/api/manager/manager/#dict_state","text":"| @property | dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state.","title":"dict_state"},{"location":"aea/api/manager/manager/#add_error_callback","text":"| add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> None Add error callback to call on error raised.","title":"add_error_callback"},{"location":"aea/api/manager/manager/#start_manager","text":"| start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance.","title":"start_manager"},{"location":"aea/api/manager/manager/#stop_manager","text":"| stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None","title":"stop_manager"},{"location":"aea/api/manager/manager/#add_project","text":"| add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent.","title":"add_project"},{"location":"aea/api/manager/manager/#remove_project","text":"| remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project.","title":"remove_project"},{"location":"aea/api/manager/manager/#list_projects","text":"| list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects","title":"list_projects"},{"location":"aea/api/manager/manager/#add_agent","text":"| add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. config : agent config (used for agent re-creation). Returns : manager","title":"add_agent"},{"location":"aea/api/manager/manager/#add_agent_with_config","text":"| add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager","title":"add_agent_with_config"},{"location":"aea/api/manager/manager/#get_agent_overridables","text":"| get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict.","title":"get_agent_overridables"},{"location":"aea/api/manager/manager/#set_agent_overrides","text":"| set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> None Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : None","title":"set_agent_overrides"},{"location":"aea/api/manager/manager/#list_agents_info","text":"| list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running.","title":"list_agents_info"},{"location":"aea/api/manager/manager/#list_agents","text":"| list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names","title":"list_agents"},{"location":"aea/api/manager/manager/#remove_agent","text":"| remove_agent ( agent_name : str ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove Returns : None","title":"remove_agent"},{"location":"aea/api/manager/manager/#start_agent","text":"| start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None","title":"start_agent"},{"location":"aea/api/manager/manager/#start_all_agents","text":"| start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None","title":"start_all_agents"},{"location":"aea/api/manager/manager/#stop_agent","text":"| stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : None","title":"stop_agent"},{"location":"aea/api/manager/manager/#stop_all_agents","text":"| stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : None","title":"stop_all_agents"},{"location":"aea/api/manager/manager/#stop_agents","text":"| stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Returns : None","title":"stop_agents"},{"location":"aea/api/manager/manager/#start_agents","text":"| start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Returns : None","title":"start_agents"},{"location":"aea/api/manager/manager/#get_agent_alias","text":"| get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Returns : AgentAlias","title":"get_agent_alias"},{"location":"aea/api/manager/project/","text":"aea.manager.project This module contains the implementation of AEA agents project configuiration. _ Base Objects class _Base () Base class to share some methods. builder | @property | builder () -> AEABuilder Get AEABuilder instance. install _ pypi _ dependencies | install_pypi_dependencies () -> None Install python dependencies for the project. Project Objects class Project ( _Base ) Agent project representation. __ init __ | __init__ ( public_id : PublicId , path : str ) Init project with public_id and project's path. build | build () -> None Call all build entry points. load | @classmethod | load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local :param is_remote whether to fetch from remote registry_path : the path to the registry locally skip_consistency_check : consistency checks flag remove | remove () -> None Remove project, do cleanup. builder | @property | builder () -> AEABuilder Get builder instance. AgentAlias Objects class AgentAlias ( _Base ) Agent alias representation. __ init __ | __init__ ( project : Project , agent_name : str , keys_dir : Optional [ str ]) Init agent alias with project, config, name, agent, builder. set _ agent _ config _ from _ data | set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data Returns : None builder | @property | builder () -> AEABuilder Get builder instance. agent _ config | @property | agent_config () -> AgentConfig Get agent config. remove _ from _ project | remove_from_project () Remove agent alias from project. dict | @property | dict () -> Dict [ str , Any ] Convert AgentAlias to dict. config _ json | @property | config_json () -> List [ Dict ] Get agent config json data. get _ aea _ instance | get_aea_instance () -> AEA Build new aea instance. issue _ certificates | issue_certificates () -> None Issue the certificates for this agent. set _ overrides | set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config. agent _ config _ manager | @property | agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config. get _ overridables | get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config.","title":"Project"},{"location":"aea/api/manager/project/#aeamanagerproject","text":"This module contains the implementation of AEA agents project configuiration.","title":"aea.manager.project"},{"location":"aea/api/manager/project/#_base-objects","text":"class _Base () Base class to share some methods.","title":"_Base Objects"},{"location":"aea/api/manager/project/#builder","text":"| @property | builder () -> AEABuilder Get AEABuilder instance.","title":"builder"},{"location":"aea/api/manager/project/#install_pypi_dependencies","text":"| install_pypi_dependencies () -> None Install python dependencies for the project.","title":"install_pypi_dependencies"},{"location":"aea/api/manager/project/#project-objects","text":"class Project ( _Base ) Agent project representation.","title":"Project Objects"},{"location":"aea/api/manager/project/#__init__","text":"| __init__ ( public_id : PublicId , path : str ) Init project with public_id and project's path.","title":"__init__"},{"location":"aea/api/manager/project/#build","text":"| build () -> None Call all build entry points.","title":"build"},{"location":"aea/api/manager/project/#load","text":"| @classmethod | load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local :param is_remote whether to fetch from remote registry_path : the path to the registry locally skip_consistency_check : consistency checks flag","title":"load"},{"location":"aea/api/manager/project/#remove","text":"| remove () -> None Remove project, do cleanup.","title":"remove"},{"location":"aea/api/manager/project/#builder_1","text":"| @property | builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"aea/api/manager/project/#agentalias-objects","text":"class AgentAlias ( _Base ) Agent alias representation.","title":"AgentAlias Objects"},{"location":"aea/api/manager/project/#__init___1","text":"| __init__ ( project : Project , agent_name : str , keys_dir : Optional [ str ]) Init agent alias with project, config, name, agent, builder.","title":"__init__"},{"location":"aea/api/manager/project/#set_agent_config_from_data","text":"| set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data Returns : None","title":"set_agent_config_from_data"},{"location":"aea/api/manager/project/#builder_2","text":"| @property | builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"aea/api/manager/project/#agent_config","text":"| @property | agent_config () -> AgentConfig Get agent config.","title":"agent_config"},{"location":"aea/api/manager/project/#remove_from_project","text":"| remove_from_project () Remove agent alias from project.","title":"remove_from_project"},{"location":"aea/api/manager/project/#dict","text":"| @property | dict () -> Dict [ str , Any ] Convert AgentAlias to dict.","title":"dict"},{"location":"aea/api/manager/project/#config_json","text":"| @property | config_json () -> List [ Dict ] Get agent config json data.","title":"config_json"},{"location":"aea/api/manager/project/#get_aea_instance","text":"| get_aea_instance () -> AEA Build new aea instance.","title":"get_aea_instance"},{"location":"aea/api/manager/project/#issue_certificates","text":"| issue_certificates () -> None Issue the certificates for this agent.","title":"issue_certificates"},{"location":"aea/api/manager/project/#set_overrides","text":"| set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config.","title":"set_overrides"},{"location":"aea/api/manager/project/#agent_config_manager","text":"| @property | agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config.","title":"agent_config_manager"},{"location":"aea/api/manager/project/#get_overridables","text":"| get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config.","title":"get_overridables"},{"location":"aea/api/protocols/base/","text":"aea.protocols.base This module contains the base message and serialization definition. Message Objects class Message () This class implements a message. Performative Objects class Performative ( Enum ) Performatives for the base message. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( _body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. json | json () -> dict Get json friendly str representation of the message. from _ json | @classmethod | from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. has _ sender | @property | has_sender () -> bool Check if it has a sender. sender | @property | sender () -> Address Get the sender of the message in Address form. :return the address sender | @sender . setter | sender ( sender : Address ) -> None Set the sender of the message. has _ to | @property | has_to () -> bool Check if it has a sender. to | @property | to () -> Address Get address of receiver. to | @to . setter | to ( to : Address ) -> None Set address of receiver. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> \"Performative\" Get the performative of the message. target | @property | target () -> int Get the target of the message. set | set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None get | get ( key : str ) -> Optional [ Any ] Get value for key. is _ set | is_set ( key : str ) -> bool Check value is set for key. __ eq __ | __eq__ ( other ) Compare with another object. __ repr __ | __repr__ () Get the representation of the message. __ str __ | __str__ () Get the string representation of the message. Abbreviated to prevent spamming of logs. encode | encode () -> bytes Encode the message. decode | @classmethod | decode ( cls , data : bytes ) -> \"Message\" Decode the message. has _ dialogue _ info | @property | has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise. Encoder Objects class Encoder ( ABC ) Encoder interface. encode | @staticmethod | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message. Decoder Objects class Decoder ( ABC ) Decoder interface. decode | @staticmethod | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message. Serializer Objects class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol. Protocol Objects class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message. __ init __ | __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs ) Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class. serializer | @property | serializer () -> Type [ Serializer ] Get the serializer. from _ dir | @classmethod | from_dir ( cls , directory : str , ** kwargs ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the protocol object. from _ config | @classmethod | from_config ( cls , configuration : ProtocolConfig , ** kwargs ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. Returns : the protocol object.","title":"Base"},{"location":"aea/api/protocols/base/#aeaprotocolsbase","text":"This module contains the base message and serialization definition.","title":"aea.protocols.base"},{"location":"aea/api/protocols/base/#message-objects","text":"class Message () This class implements a message.","title":"Message Objects"},{"location":"aea/api/protocols/base/#performative-objects","text":"class Performative ( Enum ) Performatives for the base message.","title":"Performative Objects"},{"location":"aea/api/protocols/base/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/base/#__init__","text":"| __init__ ( _body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"aea/api/protocols/base/#json","text":"| json () -> dict Get json friendly str representation of the message.","title":"json"},{"location":"aea/api/protocols/base/#from_json","text":"| @classmethod | from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data.","title":"from_json"},{"location":"aea/api/protocols/base/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/base/#has_sender","text":"| @property | has_sender () -> bool Check if it has a sender.","title":"has_sender"},{"location":"aea/api/protocols/base/#sender","text":"| @property | sender () -> Address Get the sender of the message in Address form. :return the address","title":"sender"},{"location":"aea/api/protocols/base/#sender_1","text":"| @sender . setter | sender ( sender : Address ) -> None Set the sender of the message.","title":"sender"},{"location":"aea/api/protocols/base/#has_to","text":"| @property | has_to () -> bool Check if it has a sender.","title":"has_to"},{"location":"aea/api/protocols/base/#to","text":"| @property | to () -> Address Get address of receiver.","title":"to"},{"location":"aea/api/protocols/base/#to_1","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/protocols/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/base/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/base/#performative","text":"| @property | performative () -> \"Performative\" Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/base/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/base/#set","text":"| set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None","title":"set"},{"location":"aea/api/protocols/base/#get","text":"| get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"aea/api/protocols/base/#is_set","text":"| is_set ( key : str ) -> bool Check value is set for key.","title":"is_set"},{"location":"aea/api/protocols/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/protocols/base/#__repr__","text":"| __repr__ () Get the representation of the message.","title":"__repr__"},{"location":"aea/api/protocols/base/#__str___1","text":"| __str__ () Get the string representation of the message. Abbreviated to prevent spamming of logs.","title":"__str__"},{"location":"aea/api/protocols/base/#encode","text":"| encode () -> bytes Encode the message.","title":"encode"},{"location":"aea/api/protocols/base/#decode","text":"| @classmethod | decode ( cls , data : bytes ) -> \"Message\" Decode the message.","title":"decode"},{"location":"aea/api/protocols/base/#has_dialogue_info","text":"| @property | has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise.","title":"has_dialogue_info"},{"location":"aea/api/protocols/base/#encoder-objects","text":"class Encoder ( ABC ) Encoder interface.","title":"Encoder Objects"},{"location":"aea/api/protocols/base/#encode_1","text":"| @staticmethod | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message.","title":"encode"},{"location":"aea/api/protocols/base/#decoder-objects","text":"class Decoder ( ABC ) Decoder interface.","title":"Decoder Objects"},{"location":"aea/api/protocols/base/#decode_1","text":"| @staticmethod | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#serializer-objects","text":"class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol.","title":"Serializer Objects"},{"location":"aea/api/protocols/base/#protocol-objects","text":"class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message.","title":"Protocol Objects"},{"location":"aea/api/protocols/base/#__init___1","text":"| __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs ) Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class.","title":"__init__"},{"location":"aea/api/protocols/base/#serializer","text":"| @property | serializer () -> Type [ Serializer ] Get the serializer.","title":"serializer"},{"location":"aea/api/protocols/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , ** kwargs ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. Returns : the protocol object.","title":"from_dir"},{"location":"aea/api/protocols/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ProtocolConfig , ** kwargs ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. Returns : the protocol object.","title":"from_config"},{"location":"aea/api/protocols/default/custom_types/","text":"packages.fetchai.protocols.default.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode Objects class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode | @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"aea/api/protocols/default/custom_types/#packagesfetchaiprotocolsdefaultcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"packages.fetchai.protocols.default.custom_types"},{"location":"aea/api/protocols/default/custom_types/#errorcode-objects","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode Objects"},{"location":"aea/api/protocols/default/custom_types/#encode","text":"| @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/protocols/default/custom_types/#decode","text":"| @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"aea/api/protocols/default/dialogues/","text":"packages.fetchai.protocols.default.dialogues This module contains the classes required for default dialogue management. DefaultDialogue: The dialogue class maintains state of a dialogue and manages it. DefaultDialogues: The dialogues class keeps track of all dialogues. DefaultDialogue Objects class DefaultDialogue ( Dialogue ) The default dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a default dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a default dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ DefaultMessage ] = DefaultMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None DefaultDialogues Objects class DefaultDialogues ( Dialogues , ABC ) This class keeps track of all default dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ DefaultDialogue ] = DefaultDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/default/dialogues/#packagesfetchaiprotocolsdefaultdialogues","text":"This module contains the classes required for default dialogue management. DefaultDialogue: The dialogue class maintains state of a dialogue and manages it. DefaultDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.default.dialogues"},{"location":"aea/api/protocols/default/dialogues/#defaultdialogue-objects","text":"class DefaultDialogue ( Dialogue ) The default dialogue class maintains state of a dialogue and manages it.","title":"DefaultDialogue Objects"},{"location":"aea/api/protocols/default/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a default dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/default/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a default dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/default/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ DefaultMessage ] = DefaultMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/default/dialogues/#defaultdialogues-objects","text":"class DefaultDialogues ( Dialogues , ABC ) This class keeps track of all default dialogues.","title":"DefaultDialogues Objects"},{"location":"aea/api/protocols/default/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ DefaultDialogue ] = DefaultDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/default/message/","text":"packages.fetchai.protocols.default.message This module contains default's message definition. DefaultMessage Objects class DefaultMessage ( Message ) A protocol for exchanging any bytes message. Performative Objects class Performative ( Message . Performative ) Performatives for the default protocol. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. content | @property | content () -> bytes Get the 'content' content from the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. error _ data | @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message. error _ msg | @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"Message"},{"location":"aea/api/protocols/default/message/#packagesfetchaiprotocolsdefaultmessage","text":"This module contains default's message definition.","title":"packages.fetchai.protocols.default.message"},{"location":"aea/api/protocols/default/message/#defaultmessage-objects","text":"class DefaultMessage ( Message ) A protocol for exchanging any bytes message.","title":"DefaultMessage Objects"},{"location":"aea/api/protocols/default/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the default protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/default/message/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/default/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/default/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/default/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/default/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/default/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/default/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/default/message/#content","text":"| @property | content () -> bytes Get the 'content' content from the message.","title":"content"},{"location":"aea/api/protocols/default/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/default/message/#error_data","text":"| @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message.","title":"error_data"},{"location":"aea/api/protocols/default/message/#error_msg","text":"| @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"error_msg"},{"location":"aea/api/protocols/default/serialization/","text":"packages.fetchai.protocols.default.serialization Serialization module for default protocol. DefaultSerializer Objects class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"Serialization"},{"location":"aea/api/protocols/default/serialization/#packagesfetchaiprotocolsdefaultserialization","text":"Serialization module for default protocol.","title":"packages.fetchai.protocols.default.serialization"},{"location":"aea/api/protocols/default/serialization/#defaultserializer-objects","text":"class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol.","title":"DefaultSerializer Objects"},{"location":"aea/api/protocols/default/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/default/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"decode"},{"location":"aea/api/protocols/dialogue/base/","text":"aea.protocols.dialogue.base This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues. InvalidDialogueMessage Objects class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue. DialogueLabel Objects class DialogueLabel () The dialogue label class acts as an identifier for dialogues. __ init __ | __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference. dialogue _ starter _ reference | @property | dialogue_starter_reference () -> str Get the dialogue starter reference. dialogue _ responder _ reference | @property | dialogue_responder_reference () -> str Get the dialogue responder reference. dialogue _ opponent _ addr | @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent. dialogue _ starter _ addr | @property | dialogue_starter_addr () -> str Get the address of the dialogue starter. __ eq __ | __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects. __ hash __ | __hash__ () -> int Turn object into hash. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json. get _ incomplete _ version | get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label. __ str __ | __str__ () Get the string representation. from _ str | @classmethod | from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation. _ DialogueMeta Objects class _DialogueMeta ( type ) Metaclass for Dialogue. Adds slot support forevery subclass Creates classlevvel Rules instance __ new __ | __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) Construct a new type. Dialogue Objects class Dialogue (, metaclass = _DialogueMeta ) The dialogue class maintains state of a dialogue and manages it. Rules Objects class Rules () This class defines the rules for the dialogue. __ init __ | __init__ ( initial_performatives : FrozenSet [ Message . Performative ], terminal_performatives : FrozenSet [ Message . Performative ], valid_replies : Dict [ Message . Performative , FrozenSet [ Message . Performative ]]) -> None Initialize a dialogue. Arguments : initial_performatives : the set of all initial performatives. terminal_performatives : the set of all terminal performatives. valid_replies : the reply structure of speech-acts. Returns : None initial _ performatives | @property | initial_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message terminal _ performatives | @property | terminal_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message valid _ replies | @property | valid_replies () -> Dict [ Message . Performative , FrozenSet [ Message . Performative ]] Get all the valid performatives which are a valid replies to performatives. Returns : the full valid reply structure. get _ valid _ replies | get_valid_replies ( performative : Message . Performative ) -> FrozenSet [ Message . Performative ] Given a performative , return the list of performatives which are its valid replies in a dialogue. Arguments : performative : the performative in a message Returns : list of valid performative replies Role Objects class Role ( Enum ) This class defines the agent's role in a dialogue. __ str __ | __str__ () Get the string representation. EndState Objects class EndState ( Enum ) This class defines the end states of a dialogue. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( dialogue_label : DialogueLabel , message_class : Type [ Message ], self_address : Address , role : Role ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None add _ terminal _ state _ callback | add_terminal_state_callback ( fn : Callable [[ \"Dialogue\" ], None ]) -> None Add callback to be called on dialogue reach terminal state. Arguments : fn : callable to be called with one argument: Dialogue Returns : None __ eq __ | __eq__ ( other ) -> bool Compare two dialogues. json | json () -> dict Get json representation of the dialogue. from _ json | @classmethod | from_json ( cls , message_class : Type [ Message ], data : dict ) -> \"Dialogue\" Create a dialogue instance with all messages from json data. Arguments : message_class : type of message used with this dialogue data : dict with data exported with Dialogue.to_json() method Returns : Dialogue instance dialogue _ label | @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label incomplete _ dialogue _ label | @property | incomplete_dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The incomplete dialogue label dialogue _ labels | @property | dialogue_labels () -> Set [ DialogueLabel ] Get the dialogue labels (incomplete and complete, if it exists) Returns : the dialogue labels self _ address | @property | self_address () -> Address Get the address of the entity for whom this dialogues is maintained. Returns : the address of this entity role | @property | role () -> \"Role\" Get the agent's role in the dialogue. Returns : the agent's role rules | @property | rules () -> \"Rules\" Get the dialogue rules. Returns : the rules message _ class | @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class is _ self _ initiated | @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise last _ incoming _ message | @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise last _ outgoing _ message | @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise last _ message | @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise is _ empty | @property | is_empty () -> bool Check whether the dialogue is empty. Returns : True if empty, False otherwise reply | reply ( performative : Message . Performative , target_message : Optional [ Message ] = None , target : Optional [ int ] = None , ** kwargs , ,) -> Message Reply to the 'target_message' in this dialogue with a message with 'performative', and contents from kwargs. Note if no target_message is provided, the last message in the dialogue will be replied to. Arguments : target_message : the message to reply to. target : the id of the message to reply to. performative : the performative of the reply message. kwargs : the content of the reply message. Returns : the reply message if it was successfully added as a reply, None otherwise. __ str __ | __str__ () -> str Get the string representation. Returns : The string representation of the dialogue DialogueStats Objects class DialogueStats () Class to handle statistics on default dialogues. __ init __ | __init__ ( end_states : FrozenSet [ Dialogue . EndState ]) -> None Initialize a StatsManager. Arguments : end_states : the list of dialogue endstates self _ initiated | @property | self_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on self initiated dialogues. other _ initiated | @property | other_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on other initiated dialogues. add _ dialogue _ endstate | add_dialogue_endstate ( end_state : Dialogue . EndState , is_self_initiated : bool ) -> None Add dialogue endstate stats. Arguments : end_state : the end state of the dialogue is_self_initiated : whether the dialogue is initiated by the agent or the opponent Returns : None find _ caller _ object find_caller_object ( object_type : Type ) Find caller object of certain type in the call stack. BasicDialoguesStorage Objects class BasicDialoguesStorage () Dialogues state storage. __ init __ | __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage. dialogues _ in _ terminal _ state | @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state. dialogues _ in _ active _ state | @property | dialogues_in_active_state () -> List [ \"Dialogue\" ] Get all dialogues in active state. is _ terminal _ dialogues _ kept | @property | is_terminal_dialogues_kept () -> bool Return True if dialogues should stay after terminal state. dialogue _ terminal _ state _ callback | dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Method to be called on dialogue terminal state reached. setup | setup () -> None Set up dialogue storage. teardown | teardown () -> None Tear down dialogue storage. add | add ( dialogue : Dialogue ) -> None Add dialogue to storage. Arguments : dialogue : dialogue to add. Returns : None remove | remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from storage by it's label. Arguments : dialogue_label : label of the dialogue to remove Returns : None get | get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Get dialogue stored by it's label. Arguments : dialogue_label : label of the dialogue Returns : dialogue if presents or None get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. is _ in _ incomplete | is_in_incomplete ( dialogue_label : DialogueLabel ) -> bool Check dialogue label presents in list of incomplete. set _ incomplete _ dialogue | set_incomplete_dialogue ( incomplete_dialogue_label , complete_dialogue_label ) -> None Set incomplete dialogue label. is _ dialogue _ present | is_dialogue_present ( dialogue_label : DialogueLabel ) -> bool Check dialogue with label specified presents in storage. get _ latest _ label | get_latest_label ( dialogue_label : DialogueLabel ) -> DialogueLabel Get latest label for dialogue. PersistDialoguesStorage Objects class PersistDialoguesStorage ( BasicDialoguesStorage ) Persist dialogues storage. Uses generic storage to load/save dialogues data on setup/teardown. __ init __ | __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage. get _ skill _ component | @staticmethod | get_skill_component () -> Optional [ SkillComponent ] Get skill component dialogues storage constructed for. setup | setup () -> None Set up dialogue storage. teardown | teardown () -> None Tear down dialogue storage. remove | remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from memory and persistent storage. PersistDialoguesStorageWithOffloading Objects class PersistDialoguesStorageWithOffloading ( PersistDialoguesStorage ) Dialogue Storage with dialogues offloading. dialogue _ terminal _ state _ callback | dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Call on dialogue reaches terminal staste. get | get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Try to get dialogue by label from memory or persists storage. get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. dialogues _ in _ terminal _ state | @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state. Dialogues Objects class Dialogues () The dialogues class keeps track of all dialogues for an agent. __ init __ | __init__ ( self_address : Address , end_states : FrozenSet [ Dialogue . EndState ], message_class : Type [ Message ], dialogue_class : Type [ Dialogue ], role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], keep_terminal_state_dialogues : Optional [ bool ] = None ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained end_states : the list of dialogue endstates keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not Returns : None is _ keep _ dialogues _ in _ terminal _ state | @property | is_keep_dialogues_in_terminal_state () -> bool Is requrired to keep dialogues in terminal state. self _ address | @property | self_address () -> Address Get the address of the agent for whom dialogues are maintained. dialogue _ stats | @property | dialogue_stats () -> DialogueStats Get the dialogue statistics. Returns : dialogue stats object message _ class | @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class dialogue _ class | @property | dialogue_class () -> Type [ Dialogue ] Get the dialogue class. Returns : the dialogue class get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. new _ self _ initiated _ dialogue _ reference | @classmethod | new_self_initiated_dialogue_reference ( cls ) -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue. Returns : the next nonce create | create ( counterparty : Address , performative : Message . Performative , ** kwargs , ,) -> Tuple [ Message , Dialogue ] Create a dialogue with 'counterparty', with an initial message whose performative is 'performative' and contents are from 'kwargs'. Arguments : counterparty : the counterparty of the dialogue. performative : the performative of the initial message. kwargs : the content of the initial message. Returns : the initial message and the dialogue. create _ with _ message | create_with_message ( counterparty : Address , initial_message : Message ) -> Dialogue Create a dialogue with 'counterparty', with an initial message provided. Arguments : counterparty : the counterparty of the dialogue. initial_message : the initial_message. Returns : the initial message and the dialogue. update | update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new incoming message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message, and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new incoming message Returns : the new or existing dialogue the message is intended for, or None in case of any errors. get _ dialogue | get_dialogue ( message : Message ) -> Optional [ Dialogue ] Retrieve the dialogue 'message' belongs to. Arguments : message : a message Returns : the dialogue, or None in case such a dialogue does not exist setup | setup () -> None Set up. teardown | teardown () -> None Tear down.","title":"Base"},{"location":"aea/api/protocols/dialogue/base/#aeaprotocolsdialoguebase","text":"This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues.","title":"aea.protocols.dialogue.base"},{"location":"aea/api/protocols/dialogue/base/#invaliddialoguemessage-objects","text":"class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue.","title":"InvalidDialogueMessage Objects"},{"location":"aea/api/protocols/dialogue/base/#dialoguelabel-objects","text":"class DialogueLabel () The dialogue label class acts as an identifier for dialogues.","title":"DialogueLabel Objects"},{"location":"aea/api/protocols/dialogue/base/#__init__","text":"| __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference.","title":"dialogue_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_starter_reference","text":"| @property | dialogue_starter_reference () -> str Get the dialogue starter reference.","title":"dialogue_starter_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_responder_reference","text":"| @property | dialogue_responder_reference () -> str Get the dialogue responder reference.","title":"dialogue_responder_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_opponent_addr","text":"| @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent.","title":"dialogue_opponent_addr"},{"location":"aea/api/protocols/dialogue/base/#dialogue_starter_addr","text":"| @property | dialogue_starter_addr () -> str Get the address of the dialogue starter.","title":"dialogue_starter_addr"},{"location":"aea/api/protocols/dialogue/base/#__eq__","text":"| __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects.","title":"__eq__"},{"location":"aea/api/protocols/dialogue/base/#__hash__","text":"| __hash__ () -> int Turn object into hash.","title":"__hash__"},{"location":"aea/api/protocols/dialogue/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/protocols/dialogue/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json.","title":"from_json"},{"location":"aea/api/protocols/dialogue/base/#get_incomplete_version","text":"| get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label.","title":"get_incomplete_version"},{"location":"aea/api/protocols/dialogue/base/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#from_str","text":"| @classmethod | from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation.","title":"from_str"},{"location":"aea/api/protocols/dialogue/base/#_dialoguemeta-objects","text":"class _DialogueMeta ( type ) Metaclass for Dialogue. Adds slot support forevery subclass Creates classlevvel Rules instance","title":"_DialogueMeta Objects"},{"location":"aea/api/protocols/dialogue/base/#__new__","text":"| __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) Construct a new type.","title":"__new__"},{"location":"aea/api/protocols/dialogue/base/#dialogue-objects","text":"class Dialogue (, metaclass = _DialogueMeta ) The dialogue class maintains state of a dialogue and manages it.","title":"Dialogue Objects"},{"location":"aea/api/protocols/dialogue/base/#rules-objects","text":"class Rules () This class defines the rules for the dialogue.","title":"Rules Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___1","text":"| __init__ ( initial_performatives : FrozenSet [ Message . Performative ], terminal_performatives : FrozenSet [ Message . Performative ], valid_replies : Dict [ Message . Performative , FrozenSet [ Message . Performative ]]) -> None Initialize a dialogue. Arguments : initial_performatives : the set of all initial performatives. terminal_performatives : the set of all terminal performatives. valid_replies : the reply structure of speech-acts. Returns : None","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#initial_performatives","text":"| @property | initial_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message","title":"initial_performatives"},{"location":"aea/api/protocols/dialogue/base/#terminal_performatives","text":"| @property | terminal_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message","title":"terminal_performatives"},{"location":"aea/api/protocols/dialogue/base/#valid_replies","text":"| @property | valid_replies () -> Dict [ Message . Performative , FrozenSet [ Message . Performative ]] Get all the valid performatives which are a valid replies to performatives. Returns : the full valid reply structure.","title":"valid_replies"},{"location":"aea/api/protocols/dialogue/base/#get_valid_replies","text":"| get_valid_replies ( performative : Message . Performative ) -> FrozenSet [ Message . Performative ] Given a performative , return the list of performatives which are its valid replies in a dialogue. Arguments : performative : the performative in a message Returns : list of valid performative replies","title":"get_valid_replies"},{"location":"aea/api/protocols/dialogue/base/#role-objects","text":"class Role ( Enum ) This class defines the agent's role in a dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/dialogue/base/#__str___1","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#endstate-objects","text":"class EndState ( Enum ) This class defines the end states of a dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/dialogue/base/#__str___2","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#__init___2","text":"| __init__ ( dialogue_label : DialogueLabel , message_class : Type [ Message ], self_address : Address , role : Role ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#add_terminal_state_callback","text":"| add_terminal_state_callback ( fn : Callable [[ \"Dialogue\" ], None ]) -> None Add callback to be called on dialogue reach terminal state. Arguments : fn : callable to be called with one argument: Dialogue Returns : None","title":"add_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#__eq___1","text":"| __eq__ ( other ) -> bool Compare two dialogues.","title":"__eq__"},{"location":"aea/api/protocols/dialogue/base/#json_1","text":"| json () -> dict Get json representation of the dialogue.","title":"json"},{"location":"aea/api/protocols/dialogue/base/#from_json_1","text":"| @classmethod | from_json ( cls , message_class : Type [ Message ], data : dict ) -> \"Dialogue\" Create a dialogue instance with all messages from json data. Arguments : message_class : type of message used with this dialogue data : dict with data exported with Dialogue.to_json() method Returns : Dialogue instance","title":"from_json"},{"location":"aea/api/protocols/dialogue/base/#dialogue_label","text":"| @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label","title":"dialogue_label"},{"location":"aea/api/protocols/dialogue/base/#incomplete_dialogue_label","text":"| @property | incomplete_dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The incomplete dialogue label","title":"incomplete_dialogue_label"},{"location":"aea/api/protocols/dialogue/base/#dialogue_labels","text":"| @property | dialogue_labels () -> Set [ DialogueLabel ] Get the dialogue labels (incomplete and complete, if it exists) Returns : the dialogue labels","title":"dialogue_labels"},{"location":"aea/api/protocols/dialogue/base/#self_address","text":"| @property | self_address () -> Address Get the address of the entity for whom this dialogues is maintained. Returns : the address of this entity","title":"self_address"},{"location":"aea/api/protocols/dialogue/base/#role","text":"| @property | role () -> \"Role\" Get the agent's role in the dialogue. Returns : the agent's role","title":"role"},{"location":"aea/api/protocols/dialogue/base/#rules","text":"| @property | rules () -> \"Rules\" Get the dialogue rules. Returns : the rules","title":"rules"},{"location":"aea/api/protocols/dialogue/base/#message_class","text":"| @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class","title":"message_class"},{"location":"aea/api/protocols/dialogue/base/#is_self_initiated","text":"| @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise","title":"is_self_initiated"},{"location":"aea/api/protocols/dialogue/base/#last_incoming_message","text":"| @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise","title":"last_incoming_message"},{"location":"aea/api/protocols/dialogue/base/#last_outgoing_message","text":"| @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise","title":"last_outgoing_message"},{"location":"aea/api/protocols/dialogue/base/#last_message","text":"| @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise","title":"last_message"},{"location":"aea/api/protocols/dialogue/base/#is_empty","text":"| @property | is_empty () -> bool Check whether the dialogue is empty. Returns : True if empty, False otherwise","title":"is_empty"},{"location":"aea/api/protocols/dialogue/base/#reply","text":"| reply ( performative : Message . Performative , target_message : Optional [ Message ] = None , target : Optional [ int ] = None , ** kwargs , ,) -> Message Reply to the 'target_message' in this dialogue with a message with 'performative', and contents from kwargs. Note if no target_message is provided, the last message in the dialogue will be replied to. Arguments : target_message : the message to reply to. target : the id of the message to reply to. performative : the performative of the reply message. kwargs : the content of the reply message. Returns : the reply message if it was successfully added as a reply, None otherwise.","title":"reply"},{"location":"aea/api/protocols/dialogue/base/#__str___3","text":"| __str__ () -> str Get the string representation. Returns : The string representation of the dialogue","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#dialoguestats-objects","text":"class DialogueStats () Class to handle statistics on default dialogues.","title":"DialogueStats Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___3","text":"| __init__ ( end_states : FrozenSet [ Dialogue . EndState ]) -> None Initialize a StatsManager. Arguments : end_states : the list of dialogue endstates","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#self_initiated","text":"| @property | self_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on self initiated dialogues.","title":"self_initiated"},{"location":"aea/api/protocols/dialogue/base/#other_initiated","text":"| @property | other_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on other initiated dialogues.","title":"other_initiated"},{"location":"aea/api/protocols/dialogue/base/#add_dialogue_endstate","text":"| add_dialogue_endstate ( end_state : Dialogue . EndState , is_self_initiated : bool ) -> None Add dialogue endstate stats. Arguments : end_state : the end state of the dialogue is_self_initiated : whether the dialogue is initiated by the agent or the opponent Returns : None","title":"add_dialogue_endstate"},{"location":"aea/api/protocols/dialogue/base/#find_caller_object","text":"find_caller_object ( object_type : Type ) Find caller object of certain type in the call stack.","title":"find_caller_object"},{"location":"aea/api/protocols/dialogue/base/#basicdialoguesstorage-objects","text":"class BasicDialoguesStorage () Dialogues state storage.","title":"BasicDialoguesStorage Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___4","text":"| __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_terminal_state","text":"| @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state.","title":"dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_active_state","text":"| @property | dialogues_in_active_state () -> List [ \"Dialogue\" ] Get all dialogues in active state.","title":"dialogues_in_active_state"},{"location":"aea/api/protocols/dialogue/base/#is_terminal_dialogues_kept","text":"| @property | is_terminal_dialogues_kept () -> bool Return True if dialogues should stay after terminal state.","title":"is_terminal_dialogues_kept"},{"location":"aea/api/protocols/dialogue/base/#dialogue_terminal_state_callback","text":"| dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Method to be called on dialogue terminal state reached.","title":"dialogue_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#setup","text":"| setup () -> None Set up dialogue storage.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown","text":"| teardown () -> None Tear down dialogue storage.","title":"teardown"},{"location":"aea/api/protocols/dialogue/base/#add","text":"| add ( dialogue : Dialogue ) -> None Add dialogue to storage. Arguments : dialogue : dialogue to add. Returns : None","title":"add"},{"location":"aea/api/protocols/dialogue/base/#remove","text":"| remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from storage by it's label. Arguments : dialogue_label : label of the dialogue to remove Returns : None","title":"remove"},{"location":"aea/api/protocols/dialogue/base/#get","text":"| get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Get dialogue stored by it's label. Arguments : dialogue_label : label of the dialogue Returns : dialogue if presents or None","title":"get"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#is_in_incomplete","text":"| is_in_incomplete ( dialogue_label : DialogueLabel ) -> bool Check dialogue label presents in list of incomplete.","title":"is_in_incomplete"},{"location":"aea/api/protocols/dialogue/base/#set_incomplete_dialogue","text":"| set_incomplete_dialogue ( incomplete_dialogue_label , complete_dialogue_label ) -> None Set incomplete dialogue label.","title":"set_incomplete_dialogue"},{"location":"aea/api/protocols/dialogue/base/#is_dialogue_present","text":"| is_dialogue_present ( dialogue_label : DialogueLabel ) -> bool Check dialogue with label specified presents in storage.","title":"is_dialogue_present"},{"location":"aea/api/protocols/dialogue/base/#get_latest_label","text":"| get_latest_label ( dialogue_label : DialogueLabel ) -> DialogueLabel Get latest label for dialogue.","title":"get_latest_label"},{"location":"aea/api/protocols/dialogue/base/#persistdialoguesstorage-objects","text":"class PersistDialoguesStorage ( BasicDialoguesStorage ) Persist dialogues storage. Uses generic storage to load/save dialogues data on setup/teardown.","title":"PersistDialoguesStorage Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___5","text":"| __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#get_skill_component","text":"| @staticmethod | get_skill_component () -> Optional [ SkillComponent ] Get skill component dialogues storage constructed for.","title":"get_skill_component"},{"location":"aea/api/protocols/dialogue/base/#setup_1","text":"| setup () -> None Set up dialogue storage.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown_1","text":"| teardown () -> None Tear down dialogue storage.","title":"teardown"},{"location":"aea/api/protocols/dialogue/base/#remove_1","text":"| remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from memory and persistent storage.","title":"remove"},{"location":"aea/api/protocols/dialogue/base/#persistdialoguesstoragewithoffloading-objects","text":"class PersistDialoguesStorageWithOffloading ( PersistDialoguesStorage ) Dialogue Storage with dialogues offloading.","title":"PersistDialoguesStorageWithOffloading Objects"},{"location":"aea/api/protocols/dialogue/base/#dialogue_terminal_state_callback_1","text":"| dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Call on dialogue reaches terminal staste.","title":"dialogue_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#get_1","text":"| get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Try to get dialogue by label from memory or persists storage.","title":"get"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty_1","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_terminal_state_1","text":"| @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state.","title":"dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#dialogues-objects","text":"class Dialogues () The dialogues class keeps track of all dialogues for an agent.","title":"Dialogues Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___6","text":"| __init__ ( self_address : Address , end_states : FrozenSet [ Dialogue . EndState ], message_class : Type [ Message ], dialogue_class : Type [ Dialogue ], role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], keep_terminal_state_dialogues : Optional [ bool ] = None ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained end_states : the list of dialogue endstates keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not Returns : None","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#is_keep_dialogues_in_terminal_state","text":"| @property | is_keep_dialogues_in_terminal_state () -> bool Is requrired to keep dialogues in terminal state.","title":"is_keep_dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#self_address_1","text":"| @property | self_address () -> Address Get the address of the agent for whom dialogues are maintained.","title":"self_address"},{"location":"aea/api/protocols/dialogue/base/#dialogue_stats","text":"| @property | dialogue_stats () -> DialogueStats Get the dialogue statistics. Returns : dialogue stats object","title":"dialogue_stats"},{"location":"aea/api/protocols/dialogue/base/#message_class_1","text":"| @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class","title":"message_class"},{"location":"aea/api/protocols/dialogue/base/#dialogue_class","text":"| @property | dialogue_class () -> Type [ Dialogue ] Get the dialogue class. Returns : the dialogue class","title":"dialogue_class"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty_2","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#new_self_initiated_dialogue_reference","text":"| @classmethod | new_self_initiated_dialogue_reference ( cls ) -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue. Returns : the next nonce","title":"new_self_initiated_dialogue_reference"},{"location":"aea/api/protocols/dialogue/base/#create","text":"| create ( counterparty : Address , performative : Message . Performative , ** kwargs , ,) -> Tuple [ Message , Dialogue ] Create a dialogue with 'counterparty', with an initial message whose performative is 'performative' and contents are from 'kwargs'. Arguments : counterparty : the counterparty of the dialogue. performative : the performative of the initial message. kwargs : the content of the initial message. Returns : the initial message and the dialogue.","title":"create"},{"location":"aea/api/protocols/dialogue/base/#create_with_message","text":"| create_with_message ( counterparty : Address , initial_message : Message ) -> Dialogue Create a dialogue with 'counterparty', with an initial message provided. Arguments : counterparty : the counterparty of the dialogue. initial_message : the initial_message. Returns : the initial message and the dialogue.","title":"create_with_message"},{"location":"aea/api/protocols/dialogue/base/#update","text":"| update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new incoming message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message, and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new incoming message Returns : the new or existing dialogue the message is intended for, or None in case of any errors.","title":"update"},{"location":"aea/api/protocols/dialogue/base/#get_dialogue","text":"| get_dialogue ( message : Message ) -> Optional [ Dialogue ] Retrieve the dialogue 'message' belongs to. Arguments : message : a message Returns : the dialogue, or None in case such a dialogue does not exist","title":"get_dialogue"},{"location":"aea/api/protocols/dialogue/base/#setup_2","text":"| setup () -> None Set up.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown_2","text":"| teardown () -> None Tear down.","title":"teardown"},{"location":"aea/api/protocols/generator/base/","text":"aea.protocols.generator.base This module contains the protocol generator. ProtocolGenerator Objects class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object. __ init __ | __init__ ( path_to_protocol_specification : str , output_path : str = \".\" , dotted_path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : path_to_protocol_specification : path to protocol specification file output_path : the path to the location in which the protocol module is to be generated. dotted_path_to_protocol_package : the path to the protocol package Returns : None generate _ protobuf _ only _ mode | generate_protobuf_only_mode () -> None Run the generator in \"protobuf only\" mode: a) validate the protocol specification. b) create the protocol buffer schema file. Returns : None generate _ full _ mode | generate_full_mode () -> Optional [ str ] Run the generator in \"full\" mode: a) validates the protocol specification. b) creates the protocol buffer schema file. c) generates python modules. d) applies black formatting e) applies isort formatting Returns : optional warning message generate | generate ( protobuf_only : bool = False ) -> Optional [ str ] Run the generator. If in \"full\" mode (protobuf_only is False), it: a) validates the protocol specification. b) creates the protocol buffer schema file. c) generates python modules. d) applies black formatting e) applies isort formatting If in \"protobuf only\" mode (protobuf_only is True), it only does a) and b). Arguments : protobuf_only : mode of running the generator. Returns : optional warning message.","title":"Base"},{"location":"aea/api/protocols/generator/base/#aeaprotocolsgeneratorbase","text":"This module contains the protocol generator.","title":"aea.protocols.generator.base"},{"location":"aea/api/protocols/generator/base/#protocolgenerator-objects","text":"class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object.","title":"ProtocolGenerator Objects"},{"location":"aea/api/protocols/generator/base/#__init__","text":"| __init__ ( path_to_protocol_specification : str , output_path : str = \".\" , dotted_path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : path_to_protocol_specification : path to protocol specification file output_path : the path to the location in which the protocol module is to be generated. dotted_path_to_protocol_package : the path to the protocol package Returns : None","title":"__init__"},{"location":"aea/api/protocols/generator/base/#generate_protobuf_only_mode","text":"| generate_protobuf_only_mode () -> None Run the generator in \"protobuf only\" mode: a) validate the protocol specification. b) create the protocol buffer schema file. Returns : None","title":"generate_protobuf_only_mode"},{"location":"aea/api/protocols/generator/base/#generate_full_mode","text":"| generate_full_mode () -> Optional [ str ] Run the generator in \"full\" mode: a) validates the protocol specification. b) creates the protocol buffer schema file. c) generates python modules. d) applies black formatting e) applies isort formatting Returns : optional warning message","title":"generate_full_mode"},{"location":"aea/api/protocols/generator/base/#generate","text":"| generate ( protobuf_only : bool = False ) -> Optional [ str ] Run the generator. If in \"full\" mode (protobuf_only is False), it: a) validates the protocol specification. b) creates the protocol buffer schema file. c) generates python modules. d) applies black formatting e) applies isort formatting If in \"protobuf only\" mode (protobuf_only is True), it only does a) and b). Arguments : protobuf_only : mode of running the generator. Returns : optional warning message.","title":"generate"},{"location":"aea/api/protocols/generator/common/","text":"aea.protocols.generator.common This module contains utility code for generator modules. is _ installed is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise check _ prerequisites check_prerequisites () -> None Check whether a programme is installed on the system. Returns : None load _ protocol _ specification load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object try _ run _ black _ formatting try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. Returns : None try _ run _ isort _ formatting try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. Returns : None try _ run _ protoc try_run_protoc ( path_to_generated_protocol_package , name ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : A completed process object. check _ protobuf _ using _ protoc check_protobuf_using_protoc ( path_to_generated_protocol_package , name ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"Common"},{"location":"aea/api/protocols/generator/common/#aeaprotocolsgeneratorcommon","text":"This module contains utility code for generator modules.","title":"aea.protocols.generator.common"},{"location":"aea/api/protocols/generator/common/#is_installed","text":"is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise","title":"is_installed"},{"location":"aea/api/protocols/generator/common/#check_prerequisites","text":"check_prerequisites () -> None Check whether a programme is installed on the system. Returns : None","title":"check_prerequisites"},{"location":"aea/api/protocols/generator/common/#load_protocol_specification","text":"load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object","title":"load_protocol_specification"},{"location":"aea/api/protocols/generator/common/#try_run_black_formatting","text":"try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. Returns : None","title":"try_run_black_formatting"},{"location":"aea/api/protocols/generator/common/#try_run_isort_formatting","text":"try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. Returns : None","title":"try_run_isort_formatting"},{"location":"aea/api/protocols/generator/common/#try_run_protoc","text":"try_run_protoc ( path_to_generated_protocol_package , name ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : A completed process object.","title":"try_run_protoc"},{"location":"aea/api/protocols/generator/common/#check_protobuf_using_protoc","text":"check_protobuf_using_protoc ( path_to_generated_protocol_package , name ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"check_protobuf_using_protoc"},{"location":"aea/api/protocols/generator/extract_specification/","text":"aea.protocols.generator.extract _ specification This module extracts a valid protocol specification into pythonic objects. PythonicProtocolSpecification Objects class PythonicProtocolSpecification () This class represents a protocol specification in python. __ init __ | __init__ () -> None Instantiate a Pythonic protocol specification. Returns : None extract extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"Extract Specification"},{"location":"aea/api/protocols/generator/extract_specification/#aeaprotocolsgeneratorextract_specification","text":"This module extracts a valid protocol specification into pythonic objects.","title":"aea.protocols.generator.extract_specification"},{"location":"aea/api/protocols/generator/extract_specification/#pythonicprotocolspecification-objects","text":"class PythonicProtocolSpecification () This class represents a protocol specification in python.","title":"PythonicProtocolSpecification Objects"},{"location":"aea/api/protocols/generator/extract_specification/#__init__","text":"| __init__ () -> None Instantiate a Pythonic protocol specification. Returns : None","title":"__init__"},{"location":"aea/api/protocols/generator/extract_specification/#extract","text":"extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"extract"},{"location":"aea/api/protocols/generator/validate/","text":"aea.protocols.generator.validate This module validates a protocol specification. validate validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"Validate"},{"location":"aea/api/protocols/generator/validate/#aeaprotocolsgeneratorvalidate","text":"This module validates a protocol specification.","title":"aea.protocols.generator.validate"},{"location":"aea/api/protocols/generator/validate/#validate","text":"validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"validate"},{"location":"aea/api/protocols/signing/custom_types/","text":"packages.fetchai.protocols.signing.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode Objects class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode | @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"aea/api/protocols/signing/custom_types/#packagesfetchaiprotocolssigningcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"packages.fetchai.protocols.signing.custom_types"},{"location":"aea/api/protocols/signing/custom_types/#errorcode-objects","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode Objects"},{"location":"aea/api/protocols/signing/custom_types/#encode","text":"| @staticmethod | encode ( error_code_protobuf_object , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/protocols/signing/custom_types/#decode","text":"| @classmethod | decode ( cls , error_code_protobuf_object ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"aea/api/protocols/signing/dialogues/","text":"packages.fetchai.protocols.signing.dialogues This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues. SigningDialogue Objects class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None SigningDialogues Objects class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/signing/dialogues/#packagesfetchaiprotocolssigningdialogues","text":"This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.signing.dialogues"},{"location":"aea/api/protocols/signing/dialogues/#signingdialogue-objects","text":"class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it.","title":"SigningDialogue Objects"},{"location":"aea/api/protocols/signing/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/signing/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/signing/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/signing/dialogues/#signingdialogues-objects","text":"class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues.","title":"SigningDialogues Objects"},{"location":"aea/api/protocols/signing/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/signing/message/","text":"packages.fetchai.protocols.signing.message This module contains signing's message definition. SigningMessage Objects class SigningMessage ( Message ) A protocol for communication between skills and decision maker. Performative Objects class Performative ( Message . Performative ) Performatives for the signing protocol. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of SigningMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. raw _ message | @property | raw_message () -> CustomRawMessage Get the 'raw_message' content from the message. raw _ transaction | @property | raw_transaction () -> CustomRawTransaction Get the 'raw_transaction' content from the message. signed _ message | @property | signed_message () -> CustomSignedMessage Get the 'signed_message' content from the message. signed _ transaction | @property | signed_transaction () -> CustomSignedTransaction Get the 'signed_transaction' content from the message. terms | @property | terms () -> CustomTerms Get the 'terms' content from the message.","title":"Message"},{"location":"aea/api/protocols/signing/message/#packagesfetchaiprotocolssigningmessage","text":"This module contains signing's message definition.","title":"packages.fetchai.protocols.signing.message"},{"location":"aea/api/protocols/signing/message/#signingmessage-objects","text":"class SigningMessage ( Message ) A protocol for communication between skills and decision maker.","title":"SigningMessage Objects"},{"location":"aea/api/protocols/signing/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the signing protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/signing/message/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/signing/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of SigningMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/signing/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/signing/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/signing/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/signing/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/signing/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/signing/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/signing/message/#raw_message","text":"| @property | raw_message () -> CustomRawMessage Get the 'raw_message' content from the message.","title":"raw_message"},{"location":"aea/api/protocols/signing/message/#raw_transaction","text":"| @property | raw_transaction () -> CustomRawTransaction Get the 'raw_transaction' content from the message.","title":"raw_transaction"},{"location":"aea/api/protocols/signing/message/#signed_message","text":"| @property | signed_message () -> CustomSignedMessage Get the 'signed_message' content from the message.","title":"signed_message"},{"location":"aea/api/protocols/signing/message/#signed_transaction","text":"| @property | signed_transaction () -> CustomSignedTransaction Get the 'signed_transaction' content from the message.","title":"signed_transaction"},{"location":"aea/api/protocols/signing/message/#terms","text":"| @property | terms () -> CustomTerms Get the 'terms' content from the message.","title":"terms"},{"location":"aea/api/protocols/signing/serialization/","text":"packages.fetchai.protocols.signing.serialization Serialization module for signing protocol. SigningSerializer Objects class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"Serialization"},{"location":"aea/api/protocols/signing/serialization/#packagesfetchaiprotocolssigningserialization","text":"Serialization module for signing protocol.","title":"packages.fetchai.protocols.signing.serialization"},{"location":"aea/api/protocols/signing/serialization/#signingserializer-objects","text":"class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol.","title":"SigningSerializer Objects"},{"location":"aea/api/protocols/signing/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/signing/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"decode"},{"location":"aea/api/protocols/state_update/dialogues/","text":"packages.fetchai.protocols.state _ update.dialogues This module contains the classes required for state_update dialogue management. StateUpdateDialogue: The dialogue class maintains state of a dialogue and manages it. StateUpdateDialogues: The dialogues class keeps track of all dialogues. StateUpdateDialogue Objects class StateUpdateDialogue ( Dialogue ) The state_update dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a state_update dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a state_update dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ StateUpdateMessage ] = StateUpdateMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None StateUpdateDialogues Objects class StateUpdateDialogues ( Dialogues , ABC ) This class keeps track of all state_update dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ StateUpdateDialogue ] = StateUpdateDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/state_update/dialogues/#packagesfetchaiprotocolsstate_updatedialogues","text":"This module contains the classes required for state_update dialogue management. StateUpdateDialogue: The dialogue class maintains state of a dialogue and manages it. StateUpdateDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.state_update.dialogues"},{"location":"aea/api/protocols/state_update/dialogues/#stateupdatedialogue-objects","text":"class StateUpdateDialogue ( Dialogue ) The state_update dialogue class maintains state of a dialogue and manages it.","title":"StateUpdateDialogue Objects"},{"location":"aea/api/protocols/state_update/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a state_update dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/state_update/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a state_update dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/state_update/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ StateUpdateMessage ] = StateUpdateMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/state_update/dialogues/#stateupdatedialogues-objects","text":"class StateUpdateDialogues ( Dialogues , ABC ) This class keeps track of all state_update dialogues.","title":"StateUpdateDialogues Objects"},{"location":"aea/api/protocols/state_update/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ StateUpdateDialogue ] = StateUpdateDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/state_update/message/","text":"packages.fetchai.protocols.state _ update.message This module contains state_update's message definition. StateUpdateMessage Objects class StateUpdateMessage ( Message ) A protocol for state updates to the decision maker state. Performative Objects class Performative ( Message . Performative ) Performatives for the state_update protocol. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of StateUpdateMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. amount _ by _ currency _ id | @property | amount_by_currency_id () -> Dict [ str , int ] Get the 'amount_by_currency_id' content from the message. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> Dict [ str , float ] Get the 'exchange_params_by_currency_id' content from the message. quantities _ by _ good _ id | @property | quantities_by_good_id () -> Dict [ str , int ] Get the 'quantities_by_good_id' content from the message. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> Dict [ str , float ] Get the 'utility_params_by_good_id' content from the message.","title":"Message"},{"location":"aea/api/protocols/state_update/message/#packagesfetchaiprotocolsstate_updatemessage","text":"This module contains state_update's message definition.","title":"packages.fetchai.protocols.state_update.message"},{"location":"aea/api/protocols/state_update/message/#stateupdatemessage-objects","text":"class StateUpdateMessage ( Message ) A protocol for state updates to the decision maker state.","title":"StateUpdateMessage Objects"},{"location":"aea/api/protocols/state_update/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the state_update protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/state_update/message/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/state_update/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ,) Initialise an instance of StateUpdateMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/state_update/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/state_update/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/state_update/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/state_update/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/state_update/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/state_update/message/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> Dict [ str , int ] Get the 'amount_by_currency_id' content from the message.","title":"amount_by_currency_id"},{"location":"aea/api/protocols/state_update/message/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> Dict [ str , float ] Get the 'exchange_params_by_currency_id' content from the message.","title":"exchange_params_by_currency_id"},{"location":"aea/api/protocols/state_update/message/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> Dict [ str , int ] Get the 'quantities_by_good_id' content from the message.","title":"quantities_by_good_id"},{"location":"aea/api/protocols/state_update/message/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> Dict [ str , float ] Get the 'utility_params_by_good_id' content from the message.","title":"utility_params_by_good_id"},{"location":"aea/api/protocols/state_update/serialization/","text":"packages.fetchai.protocols.state _ update.serialization Serialization module for state_update protocol. StateUpdateSerializer Objects class StateUpdateSerializer ( Serializer ) Serialization for the 'state_update' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'StateUpdate' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'StateUpdate' message. Arguments : obj : the bytes object. Returns : the 'StateUpdate' message.","title":"Serialization"},{"location":"aea/api/protocols/state_update/serialization/#packagesfetchaiprotocolsstate_updateserialization","text":"Serialization module for state_update protocol.","title":"packages.fetchai.protocols.state_update.serialization"},{"location":"aea/api/protocols/state_update/serialization/#stateupdateserializer-objects","text":"class StateUpdateSerializer ( Serializer ) Serialization for the 'state_update' protocol.","title":"StateUpdateSerializer Objects"},{"location":"aea/api/protocols/state_update/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'StateUpdate' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/state_update/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'StateUpdate' message. Arguments : obj : the bytes object. Returns : the 'StateUpdate' message.","title":"decode"},{"location":"aea/api/registries/base/","text":"aea.registries.base This module contains registries. Registry Objects class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry. __ init __ | __init__ ( agent_name : str = \"standalone\" ) Initialize the registry. Arguments : agent_name : the name of the agent register | @abstractmethod | register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id. unregister | @abstractmethod | unregister ( item_id : ItemId ) -> None Unregister an item. Arguments : item_id : the public id of the item. Returns : None :raises: ValueError if no item registered with that item id. fetch | @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ all | @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items. ids | @abstractmethod | ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids. setup | @abstractmethod | setup () -> None Set up registry. Returns : None teardown | @abstractmethod | teardown () -> None Teardown the registry. Returns : None PublicIdRegistry Objects class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package. __ init __ | __init__ () Initialize the registry. register | register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. unregister | unregister ( public_id : PublicId ) -> None Unregister an item. fetch | fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present. fetch _ all | fetch_all () -> List [ Item ] Fetch all the items. ids | ids () -> Set [ PublicId ] Get all the item ids. setup | setup () -> None Set up the items. teardown | teardown () -> None Tear down the items. AgentComponentRegistry Objects class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components. __ init __ | __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None register | register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added. unregister | unregister ( component_id : ComponentId ) -> None Unregister a component. Arguments : component_id : the ComponentId fetch | fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered fetch _ all | fetch_all () -> List [ Component ] Fetch all the components. :return the list of registered components. fetch _ by _ type | fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type :return the list of registered components of a given type. ids | ids () -> Set [ ComponentId ] Get the item ids. setup | setup () -> None Set up the registry. Returns : None teardown | teardown () -> None Teardown the registry. Returns : None ComponentRegistry Objects class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components. __ init __ | __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None register | register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id. unregister | unregister ( item_id : Tuple [ PublicId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item registered with that item id. fetch | fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ by _ skill | fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill. fetch _ all | fetch_all () -> List [ SkillComponentType ] Fetch all the items. unregister _ by _ skill | unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. ids | ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids. setup | setup () -> None Set up the items in the registry. Returns : None teardown | teardown () -> None Teardown the registry. Returns : None HandlerRegistry Objects class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry. __ init __ | __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None register | register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Returns : None Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists. unregister | unregister ( item_id : Tuple [ PublicId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item is registered with that item id. unregister _ by _ skill | unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. fetch _ by _ protocol | fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id fetch _ by _ protocol _ and _ skill | fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"Base"},{"location":"aea/api/registries/base/#aearegistriesbase","text":"This module contains registries.","title":"aea.registries.base"},{"location":"aea/api/registries/base/#registry-objects","text":"class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry.","title":"Registry Objects"},{"location":"aea/api/registries/base/#__init__","text":"| __init__ ( agent_name : str = \"standalone\" ) Initialize the registry. Arguments : agent_name : the name of the agent","title":"__init__"},{"location":"aea/api/registries/base/#register","text":"| @abstractmethod | register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister","text":"| @abstractmethod | unregister ( item_id : ItemId ) -> None Unregister an item. Arguments : item_id : the public id of the item. Returns : None :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch","text":"| @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all","text":"| @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items.","title":"fetch_all"},{"location":"aea/api/registries/base/#ids","text":"| @abstractmethod | ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup","text":"| @abstractmethod | setup () -> None Set up registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown","text":"| @abstractmethod | teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#publicidregistry-objects","text":"class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package.","title":"PublicIdRegistry Objects"},{"location":"aea/api/registries/base/#__init___1","text":"| __init__ () Initialize the registry.","title":"__init__"},{"location":"aea/api/registries/base/#register_1","text":"| register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item.","title":"register"},{"location":"aea/api/registries/base/#unregister_1","text":"| unregister ( public_id : PublicId ) -> None Unregister an item.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_1","text":"| fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present.","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all_1","text":"| fetch_all () -> List [ Item ] Fetch all the items.","title":"fetch_all"},{"location":"aea/api/registries/base/#ids_1","text":"| ids () -> Set [ PublicId ] Get all the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_1","text":"| setup () -> None Set up the items.","title":"setup"},{"location":"aea/api/registries/base/#teardown_1","text":"| teardown () -> None Tear down the items.","title":"teardown"},{"location":"aea/api/registries/base/#agentcomponentregistry-objects","text":"class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components.","title":"AgentComponentRegistry Objects"},{"location":"aea/api/registries/base/#__init___2","text":"| __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_2","text":"| register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added.","title":"register"},{"location":"aea/api/registries/base/#unregister_2","text":"| unregister ( component_id : ComponentId ) -> None Unregister a component. Arguments : component_id : the ComponentId","title":"unregister"},{"location":"aea/api/registries/base/#fetch_2","text":"| fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all_2","text":"| fetch_all () -> List [ Component ] Fetch all the components. :return the list of registered components.","title":"fetch_all"},{"location":"aea/api/registries/base/#fetch_by_type","text":"| fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type :return the list of registered components of a given type.","title":"fetch_by_type"},{"location":"aea/api/registries/base/#ids_2","text":"| ids () -> Set [ ComponentId ] Get the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_2","text":"| setup () -> None Set up the registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown_2","text":"| teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#componentregistry-objects","text":"class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components.","title":"ComponentRegistry Objects"},{"location":"aea/api/registries/base/#__init___3","text":"| __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_3","text":"| register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister_3","text":"| unregister ( item_id : Tuple [ PublicId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_3","text":"| fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_by_skill","text":"| fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill.","title":"fetch_by_skill"},{"location":"aea/api/registries/base/#fetch_all_3","text":"| fetch_all () -> List [ SkillComponentType ] Fetch all the items.","title":"fetch_all"},{"location":"aea/api/registries/base/#unregister_by_skill","text":"| unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#ids_3","text":"| ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_3","text":"| setup () -> None Set up the items in the registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown_3","text":"| teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#handlerregistry-objects","text":"class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry.","title":"HandlerRegistry Objects"},{"location":"aea/api/registries/base/#__init___4","text":"| __init__ ( ** kwargs ) -> None Instantiate the registry. Arguments : kwargs : kwargs Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_4","text":"| register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Returns : None Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists.","title":"register"},{"location":"aea/api/registries/base/#unregister_4","text":"| unregister ( item_id : Tuple [ PublicId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item is registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#unregister_by_skill_1","text":"| unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#fetch_by_protocol","text":"| fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol"},{"location":"aea/api/registries/base/#fetch_by_protocol_and_skill","text":"| fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol_and_skill"},{"location":"aea/api/registries/filter/","text":"aea.registries.filter This module contains registries. Filter Objects class Filter ( WithLogger ) This class implements the filter of an AEA. __ init __ | __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue resources | @property | resources () -> Resources Get resources. decision _ maker _ out _ queue | @property | decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue. get _ active _ handlers | get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active get _ active _ behaviours | get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active handle _ new _ handlers _ and _ behaviours | handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker. Returns : None get _ internal _ message | async get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue. handle _ internal _ message | handle_internal_message ( internal_message : Optional [ Message ]) -> None Handlle internal message.","title":"Filter"},{"location":"aea/api/registries/filter/#aearegistriesfilter","text":"This module contains registries.","title":"aea.registries.filter"},{"location":"aea/api/registries/filter/#filter-objects","text":"class Filter ( WithLogger ) This class implements the filter of an AEA.","title":"Filter Objects"},{"location":"aea/api/registries/filter/#__init__","text":"| __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue","title":"__init__"},{"location":"aea/api/registries/filter/#resources","text":"| @property | resources () -> Resources Get resources.","title":"resources"},{"location":"aea/api/registries/filter/#decision_maker_out_queue","text":"| @property | decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue.","title":"decision_maker_out_queue"},{"location":"aea/api/registries/filter/#get_active_handlers","text":"| get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active","title":"get_active_handlers"},{"location":"aea/api/registries/filter/#get_active_behaviours","text":"| get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active","title":"get_active_behaviours"},{"location":"aea/api/registries/filter/#handle_new_handlers_and_behaviours","text":"| handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker. Returns : None","title":"handle_new_handlers_and_behaviours"},{"location":"aea/api/registries/filter/#get_internal_message","text":"| async get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue.","title":"get_internal_message"},{"location":"aea/api/registries/filter/#handle_internal_message","text":"| handle_internal_message ( internal_message : Optional [ Message ]) -> None Handlle internal message.","title":"handle_internal_message"},{"location":"aea/api/registries/resources/","text":"aea.registries.resources This module contains the resources class. Resources Objects class Resources () This class implements the object that holds the resources of an AEA. __ init __ | __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. :return None agent _ name | @property | agent_name () -> str Get the agent name. component _ registry | @property | component_registry () -> AgentComponentRegistry Get the agent component registry. behaviour _ registry | @property | behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry. handler _ registry | @property | handler_registry () -> HandlerRegistry Get the handler registry. model _ registry | @property | model_registry () -> ComponentRegistry [ Model ] Get the model registry. add _ component | add_component ( component : Component ) Add a component to resources. add _ protocol | add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol Returns : None get _ protocol | get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None get _ all _ protocols | get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols. remove _ protocol | remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. Returns : None add _ contract | add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract Returns : None get _ contract | get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None get _ all _ contracts | get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts. remove _ contract | remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. Returns : None add _ connection | add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection Returns : None get _ connection | get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None get _ all _ connections | get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections. remove _ connection | remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed. Returns : None add _ skill | add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill Returns : None get _ skill | get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None get _ all _ skills | get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills. remove _ skill | remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. Returns : None get _ handler | get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler get _ handlers | get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol get _ all _ handlers | get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers get _ behaviour | get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None get _ behaviours | get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill get _ all _ behaviours | get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours setup | setup () -> None Set up the resources. Calls setup on all resources. Returns : None teardown | teardown () -> None Teardown the resources. Calls teardown on all resources. Returns : None","title":"Resources"},{"location":"aea/api/registries/resources/#aearegistriesresources","text":"This module contains the resources class.","title":"aea.registries.resources"},{"location":"aea/api/registries/resources/#resources-objects","text":"class Resources () This class implements the object that holds the resources of an AEA.","title":"Resources Objects"},{"location":"aea/api/registries/resources/#__init__","text":"| __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. :return None","title":"__init__"},{"location":"aea/api/registries/resources/#agent_name","text":"| @property | agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"aea/api/registries/resources/#component_registry","text":"| @property | component_registry () -> AgentComponentRegistry Get the agent component registry.","title":"component_registry"},{"location":"aea/api/registries/resources/#behaviour_registry","text":"| @property | behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry.","title":"behaviour_registry"},{"location":"aea/api/registries/resources/#handler_registry","text":"| @property | handler_registry () -> HandlerRegistry Get the handler registry.","title":"handler_registry"},{"location":"aea/api/registries/resources/#model_registry","text":"| @property | model_registry () -> ComponentRegistry [ Model ] Get the model registry.","title":"model_registry"},{"location":"aea/api/registries/resources/#add_component","text":"| add_component ( component : Component ) Add a component to resources.","title":"add_component"},{"location":"aea/api/registries/resources/#add_protocol","text":"| add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol Returns : None","title":"add_protocol"},{"location":"aea/api/registries/resources/#get_protocol","text":"| get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol"},{"location":"aea/api/registries/resources/#get_all_protocols","text":"| get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols.","title":"get_all_protocols"},{"location":"aea/api/registries/resources/#remove_protocol","text":"| remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. Returns : None","title":"remove_protocol"},{"location":"aea/api/registries/resources/#add_contract","text":"| add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract Returns : None","title":"add_contract"},{"location":"aea/api/registries/resources/#get_contract","text":"| get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None","title":"get_contract"},{"location":"aea/api/registries/resources/#get_all_contracts","text":"| get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts.","title":"get_all_contracts"},{"location":"aea/api/registries/resources/#remove_contract","text":"| remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. Returns : None","title":"remove_contract"},{"location":"aea/api/registries/resources/#add_connection","text":"| add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection Returns : None","title":"add_connection"},{"location":"aea/api/registries/resources/#get_connection","text":"| get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None","title":"get_connection"},{"location":"aea/api/registries/resources/#get_all_connections","text":"| get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections.","title":"get_all_connections"},{"location":"aea/api/registries/resources/#remove_connection","text":"| remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed. Returns : None","title":"remove_connection"},{"location":"aea/api/registries/resources/#add_skill","text":"| add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill Returns : None","title":"add_skill"},{"location":"aea/api/registries/resources/#get_skill","text":"| get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None","title":"get_skill"},{"location":"aea/api/registries/resources/#get_all_skills","text":"| get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills.","title":"get_all_skills"},{"location":"aea/api/registries/resources/#remove_skill","text":"| remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. Returns : None","title":"remove_skill"},{"location":"aea/api/registries/resources/#get_handler","text":"| get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler","title":"get_handler"},{"location":"aea/api/registries/resources/#get_handlers","text":"| get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol","title":"get_handlers"},{"location":"aea/api/registries/resources/#get_all_handlers","text":"| get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers","title":"get_all_handlers"},{"location":"aea/api/registries/resources/#get_behaviour","text":"| get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None","title":"get_behaviour"},{"location":"aea/api/registries/resources/#get_behaviours","text":"| get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill","title":"get_behaviours"},{"location":"aea/api/registries/resources/#get_all_behaviours","text":"| get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours","title":"get_all_behaviours"},{"location":"aea/api/registries/resources/#setup","text":"| setup () -> None Set up the resources. Calls setup on all resources. Returns : None","title":"setup"},{"location":"aea/api/registries/resources/#teardown","text":"| teardown () -> None Teardown the resources. Calls teardown on all resources. Returns : None","title":"teardown"},{"location":"aea/api/skills/base/","text":"aea.skills.base This module contains the base classes for the skills. SkillContext Objects class SkillContext () This class implements the context of a skill. __ init __ | __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) Initialize a skill context. :agent_context: the agent context. :skill: the skill. logger | @property | logger () -> Logger Get the logger. logger | @logger . setter | logger ( logger_ : Logger ) -> None Set the logger. set _ agent _ context | set_agent_context ( agent_context : AgentContext ) -> None Set the agent context. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. agent _ name | @property | agent_name () -> str Get agent name. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill context. is _ active | @property | is_active () -> bool Get the status of the skill (active/not active). is _ active | @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active). new _ behaviours | @property | new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours. new _ handlers | @property | new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. :return the queue of new handlers. agent _ addresses | @property | agent_addresses () -> Dict [ str , str ] Get addresses. agent _ address | @property | agent_address () -> str Get address. connection _ status | @property | connection_status () -> MultiplexerStatus Get connection status. outbox | @property | outbox () -> OutBox Get outbox. storage | @property | storage () -> Optional [ Storage ] Get optional storage for agent. message _ in _ queue | @property | message_in_queue () -> Queue Get message in queue. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get message queue of decision maker. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context. task _ manager | @property | task_manager () -> TaskManager Get behaviours of the skill. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. currency _ denominations | @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. decision _ maker _ address | @property | decision_maker_address () -> Address Get the address of the decision maker. handlers | @property | handlers () -> SimpleNamespace Get handlers of the skill. behaviours | @property | behaviours () -> SimpleNamespace Get behaviours of the skill. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace. __ getattr __ | __getattr__ ( item ) -> Any Get attribute. SkillComponent Objects class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes. __ init __ | __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs , ,) Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. name | @property | name () -> str Get the name of the skill component. context | @property | context () -> SkillContext Get the context of the skill component. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill component. configuration | @property | configuration () -> SkillComponentConfiguration Get the skill component configuration. config | @property | config () -> Dict [ Any , Any ] Get the config of the skill component. setup | @abstractmethod | setup () -> None Implement the setup. Returns : None teardown | @abstractmethod | teardown () -> None Implement the teardown. Returns : None parse _ module | @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) Parse the component module. AbstractBehaviour Objects class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> Optional [ datetime . datetime ] Get the start time of the behaviour. Behaviour Objects class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour. act | @abstractmethod | act () -> None Implement the behaviour. Returns : None is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour. Handler Objects class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour. handle | @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None handle _ wrapper | handle_wrapper ( message : Message ) -> None Wrap the call of the handler. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails. Model Objects class Model ( SkillComponent , ABC ) This class implements an abstract model. __ init __ | __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , keep_terminal_state_dialogues : Optional [ bool ] = None , ** kwargs , ,) -> None Initialize a model. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not Returns : None setup | setup () -> None Set the class up. teardown | teardown () -> None Tear the class down. parse _ module | @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model. Skill Objects class Skill ( Component ) This class implements a skill. __ init __ | __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None , ** kwargs , ,) Initialize a skill. Arguments : configuration : the skill configuration. skill_context : the skill context. handlers : dictionary of handlers. behaviours : dictionary of behaviours. models : dictionary of models. skill _ context | @property | skill_context () -> SkillContext Get the skill context. handlers | @property | handlers () -> Dict [ str , Handler ] Get the handlers. behaviours | @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers. models | @property | models () -> Dict [ str , Model ] Get the handlers. from _ dir | @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext , ** kwargs ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. agent_context : the skill context Returns : the skill object. logger | @property | logger () -> Logger Get the logger. In the case of a skill, return the logger provided by the skill context. logger | @logger . setter | logger ( * args ) -> None Set the logger. from _ config | @classmethod | from_config ( cls , configuration : SkillConfig , agent_context : AgentContext , ** kwargs ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. agent_context : the agent context. Returns : the skill.","title":"Base"},{"location":"aea/api/skills/base/#aeaskillsbase","text":"This module contains the base classes for the skills.","title":"aea.skills.base"},{"location":"aea/api/skills/base/#skillcontext-objects","text":"class SkillContext () This class implements the context of a skill.","title":"SkillContext Objects"},{"location":"aea/api/skills/base/#__init__","text":"| __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) Initialize a skill context. :agent_context: the agent context. :skill: the skill.","title":"__init__"},{"location":"aea/api/skills/base/#logger","text":"| @property | logger () -> Logger Get the logger.","title":"logger"},{"location":"aea/api/skills/base/#logger_1","text":"| @logger . setter | logger ( logger_ : Logger ) -> None Set the logger.","title":"logger"},{"location":"aea/api/skills/base/#set_agent_context","text":"| set_agent_context ( agent_context : AgentContext ) -> None Set the agent context.","title":"set_agent_context"},{"location":"aea/api/skills/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"aea/api/skills/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/skills/base/#skill_id","text":"| @property | skill_id () -> PublicId Get the skill id of the skill context.","title":"skill_id"},{"location":"aea/api/skills/base/#is_active","text":"| @property | is_active () -> bool Get the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#is_active_1","text":"| @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#new_behaviours","text":"| @property | new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours.","title":"new_behaviours"},{"location":"aea/api/skills/base/#new_handlers","text":"| @property | new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. :return the queue of new handlers.","title":"new_handlers"},{"location":"aea/api/skills/base/#agent_addresses","text":"| @property | agent_addresses () -> Dict [ str , str ] Get addresses.","title":"agent_addresses"},{"location":"aea/api/skills/base/#agent_address","text":"| @property | agent_address () -> str Get address.","title":"agent_address"},{"location":"aea/api/skills/base/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get connection status.","title":"connection_status"},{"location":"aea/api/skills/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/skills/base/#storage","text":"| @property | storage () -> Optional [ Storage ] Get optional storage for agent.","title":"storage"},{"location":"aea/api/skills/base/#message_in_queue","text":"| @property | message_in_queue () -> Queue Get message in queue.","title":"message_in_queue"},{"location":"aea/api/skills/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get message queue of decision maker.","title":"decision_maker_message_queue"},{"location":"aea/api/skills/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/skills/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get behaviours of the skill.","title":"task_manager"},{"location":"aea/api/skills/base/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/skills/base/#currency_denominations","text":"| @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"aea/api/skills/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/skills/base/#decision_maker_address","text":"| @property | decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"aea/api/skills/base/#handlers","text":"| @property | handlers () -> SimpleNamespace Get handlers of the skill.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours","text":"| @property | behaviours () -> SimpleNamespace Get behaviours of the skill.","title":"behaviours"},{"location":"aea/api/skills/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/skills/base/#__getattr__","text":"| __getattr__ ( item ) -> Any Get attribute.","title":"__getattr__"},{"location":"aea/api/skills/base/#skillcomponent-objects","text":"class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes.","title":"SkillComponent Objects"},{"location":"aea/api/skills/base/#__init___1","text":"| __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs , ,) Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context.","title":"__init__"},{"location":"aea/api/skills/base/#name","text":"| @property | name () -> str Get the name of the skill component.","title":"name"},{"location":"aea/api/skills/base/#context","text":"| @property | context () -> SkillContext Get the context of the skill component.","title":"context"},{"location":"aea/api/skills/base/#skill_id_1","text":"| @property | skill_id () -> PublicId Get the skill id of the skill component.","title":"skill_id"},{"location":"aea/api/skills/base/#configuration","text":"| @property | configuration () -> SkillComponentConfiguration Get the skill component configuration.","title":"configuration"},{"location":"aea/api/skills/base/#config","text":"| @property | config () -> Dict [ Any , Any ] Get the config of the skill component.","title":"config"},{"location":"aea/api/skills/base/#setup","text":"| @abstractmethod | setup () -> None Implement the setup. Returns : None","title":"setup"},{"location":"aea/api/skills/base/#teardown","text":"| @abstractmethod | teardown () -> None Implement the teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/base/#parse_module","text":"| @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) Parse the component module.","title":"parse_module"},{"location":"aea/api/skills/base/#abstractbehaviour-objects","text":"class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls.","title":"AbstractBehaviour Objects"},{"location":"aea/api/skills/base/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/base/#start_at","text":"| @property | start_at () -> Optional [ datetime . datetime ] Get the start time of the behaviour.","title":"start_at"},{"location":"aea/api/skills/base/#behaviour-objects","text":"class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour.","title":"Behaviour Objects"},{"location":"aea/api/skills/base/#act","text":"| @abstractmethod | act () -> None Implement the behaviour. Returns : None","title":"act"},{"location":"aea/api/skills/base/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/base/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/base/#parse_module_1","text":"| @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour.","title":"parse_module"},{"location":"aea/api/skills/base/#handler-objects","text":"class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour.","title":"Handler Objects"},{"location":"aea/api/skills/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None","title":"handle"},{"location":"aea/api/skills/base/#handle_wrapper","text":"| handle_wrapper ( message : Message ) -> None Wrap the call of the handler. This method must be called only by the framework.","title":"handle_wrapper"},{"location":"aea/api/skills/base/#parse_module_2","text":"| @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails.","title":"parse_module"},{"location":"aea/api/skills/base/#model-objects","text":"class Model ( SkillComponent , ABC ) This class implements an abstract model.","title":"Model Objects"},{"location":"aea/api/skills/base/#__init___2","text":"| __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , keep_terminal_state_dialogues : Optional [ bool ] = None , ** kwargs , ,) -> None Initialize a model. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not Returns : None","title":"__init__"},{"location":"aea/api/skills/base/#setup_1","text":"| setup () -> None Set the class up.","title":"setup"},{"location":"aea/api/skills/base/#teardown_1","text":"| teardown () -> None Tear the class down.","title":"teardown"},{"location":"aea/api/skills/base/#parse_module_3","text":"| @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model.","title":"parse_module"},{"location":"aea/api/skills/base/#skill-objects","text":"class Skill ( Component ) This class implements a skill.","title":"Skill Objects"},{"location":"aea/api/skills/base/#__init___3","text":"| __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None , ** kwargs , ,) Initialize a skill. Arguments : configuration : the skill configuration. skill_context : the skill context. handlers : dictionary of handlers. behaviours : dictionary of behaviours. models : dictionary of models.","title":"__init__"},{"location":"aea/api/skills/base/#skill_context","text":"| @property | skill_context () -> SkillContext Get the skill context.","title":"skill_context"},{"location":"aea/api/skills/base/#handlers_1","text":"| @property | handlers () -> Dict [ str , Handler ] Get the handlers.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours_1","text":"| @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers.","title":"behaviours"},{"location":"aea/api/skills/base/#models","text":"| @property | models () -> Dict [ str , Model ] Get the handlers.","title":"models"},{"location":"aea/api/skills/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext , ** kwargs ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. agent_context : the skill context Returns : the skill object.","title":"from_dir"},{"location":"aea/api/skills/base/#logger_2","text":"| @property | logger () -> Logger Get the logger. In the case of a skill, return the logger provided by the skill context.","title":"logger"},{"location":"aea/api/skills/base/#logger_3","text":"| @logger . setter | logger ( * args ) -> None Set the logger.","title":"logger"},{"location":"aea/api/skills/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : SkillConfig , agent_context : AgentContext , ** kwargs ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. agent_context : the agent context. Returns : the skill.","title":"from_config"},{"location":"aea/api/skills/behaviours/","text":"aea.skills.behaviours This module contains the classes for specific behaviours. SimpleBehaviour Objects class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour. __ init __ | __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class. setup | setup () -> None Set the behaviour up. act | act () -> None Do the action. teardown | teardown () -> None Tear the behaviour down. CompositeBehaviour Objects class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour. CyclicBehaviour Objects class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. number _ of _ executions | @property | number_of_executions () -> int Get the number of executions. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. OneShotBehaviour Objects class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. TickerBehaviour Objects class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval. __ init __ | __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> datetime . datetime Get the start time. last _ act _ time | @property | last_act_time () -> datetime . datetime Get the last time the act method has been called. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ time _ to _ act | is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise. SequenceBehaviour Objects class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially. __ init __ | __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : current _ behaviour | @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. act | act () -> None Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. State Objects class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger. __ init __ | __init__ ( ** kwargs ) Initialize a state of the state machine. event | @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour. is _ done | @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise. reset | reset () -> None Reset initial conditions. FSMBehaviour Objects class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour. __ init __ | __init__ ( ** kwargs ) Initialize the finite-state machine behaviour. is _ started | @property | is_started () -> bool Check if the behaviour is started. register _ state | register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists. register _ final _ state | register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists. unregister _ state | unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered. states | @property | states () -> Set [ str ] Get all the state names. initial _ state | @property | initial_state () -> Optional [ str ] Get the initial state name. initial _ state | @initial_state . setter | initial_state ( name : str ) Set the initial state. final _ states | @property | final_states () -> Set [ str ] Get the final state names. get _ state | get_state ( name ) -> Optional [ State ] Get a state from its name. act | act () Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. register _ transition | register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present. unregister _ transition | unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"Behaviors"},{"location":"aea/api/skills/behaviours/#aeaskillsbehaviours","text":"This module contains the classes for specific behaviours.","title":"aea.skills.behaviours"},{"location":"aea/api/skills/behaviours/#simplebehaviour-objects","text":"class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour.","title":"SimpleBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init__","text":"| __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class.","title":"__init__"},{"location":"aea/api/skills/behaviours/#setup","text":"| setup () -> None Set the behaviour up.","title":"setup"},{"location":"aea/api/skills/behaviours/#act","text":"| act () -> None Do the action.","title":"act"},{"location":"aea/api/skills/behaviours/#teardown","text":"| teardown () -> None Tear the behaviour down.","title":"teardown"},{"location":"aea/api/skills/behaviours/#compositebehaviour-objects","text":"class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour.","title":"CompositeBehaviour Objects"},{"location":"aea/api/skills/behaviours/#cyclicbehaviour-objects","text":"class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped.","title":"CyclicBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#number_of_executions","text":"| @property | number_of_executions () -> int Get the number of executions.","title":"number_of_executions"},{"location":"aea/api/skills/behaviours/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition.","title":"is_done"},{"location":"aea/api/skills/behaviours/#oneshotbehaviour-objects","text":"class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once.","title":"OneShotBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___2","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_done_1","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#act_wrapper_1","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#tickerbehaviour-objects","text":"class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval.","title":"TickerBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___3","text":"| __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset.","title":"__init__"},{"location":"aea/api/skills/behaviours/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/behaviours/#start_at","text":"| @property | start_at () -> datetime . datetime Get the start time.","title":"start_at"},{"location":"aea/api/skills/behaviours/#last_act_time","text":"| @property | last_act_time () -> datetime . datetime Get the last time the act method has been called.","title":"last_act_time"},{"location":"aea/api/skills/behaviours/#act_wrapper_2","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_time_to_act","text":"| is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise.","title":"is_time_to_act"},{"location":"aea/api/skills/behaviours/#sequencebehaviour-objects","text":"class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially.","title":"SequenceBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___4","text":"| __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs :","title":"__init__"},{"location":"aea/api/skills/behaviours/#current_behaviour","text":"| @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done.","title":"current_behaviour"},{"location":"aea/api/skills/behaviours/#act_1","text":"| act () -> None Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_2","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#state-objects","text":"class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.","title":"State Objects"},{"location":"aea/api/skills/behaviours/#__init___5","text":"| __init__ ( ** kwargs ) Initialize a state of the state machine.","title":"__init__"},{"location":"aea/api/skills/behaviours/#event","text":"| @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour.","title":"event"},{"location":"aea/api/skills/behaviours/#is_done_3","text":"| @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#reset","text":"| reset () -> None Reset initial conditions.","title":"reset"},{"location":"aea/api/skills/behaviours/#fsmbehaviour-objects","text":"class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour.","title":"FSMBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___6","text":"| __init__ ( ** kwargs ) Initialize the finite-state machine behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_started","text":"| @property | is_started () -> bool Check if the behaviour is started.","title":"is_started"},{"location":"aea/api/skills/behaviours/#register_state","text":"| register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_state"},{"location":"aea/api/skills/behaviours/#register_final_state","text":"| register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_final_state"},{"location":"aea/api/skills/behaviours/#unregister_state","text":"| unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered.","title":"unregister_state"},{"location":"aea/api/skills/behaviours/#states","text":"| @property | states () -> Set [ str ] Get all the state names.","title":"states"},{"location":"aea/api/skills/behaviours/#initial_state","text":"| @property | initial_state () -> Optional [ str ] Get the initial state name.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#initial_state_1","text":"| @initial_state . setter | initial_state ( name : str ) Set the initial state.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#final_states","text":"| @property | final_states () -> Set [ str ] Get the final state names.","title":"final_states"},{"location":"aea/api/skills/behaviours/#get_state","text":"| get_state ( name ) -> Optional [ State ] Get a state from its name.","title":"get_state"},{"location":"aea/api/skills/behaviours/#act_2","text":"| act () Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_4","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#register_transition","text":"| register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present.","title":"register_transition"},{"location":"aea/api/skills/behaviours/#unregister_transition","text":"| unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"unregister_transition"},{"location":"aea/api/skills/tasks/","text":"aea.skills.tasks This module contains the classes for tasks. Task Objects class Task ( WithLogger ) This class implements an abstract task. __ init __ | __init__ ( ** kwargs ) Initialize a task. __ call __ | __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed. is _ executed | @property | is_executed () -> bool Check if the task has already been executed. result | @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet. setup | setup () -> None Implement the task setup. Returns : None execute | @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None teardown | teardown () -> None Implement the task teardown. Returns : None init _ worker init_worker () -> None Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296 Returns : None TaskManager Objects class TaskManager ( WithLogger ) A Task manager. __ init __ | __init__ ( nb_workers : int = 1 , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. is _ started | @property | is_started () -> bool Get started status of TaskManager. Returns : bool nb _ workers | @property | nb_workers () -> int Get the number of workers. Returns : int enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running. get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id start | start () -> None Start the task manager. Returns : None stop | stop () -> None Stop the task manager. Returns : None","title":"Task"},{"location":"aea/api/skills/tasks/#aeaskillstasks","text":"This module contains the classes for tasks.","title":"aea.skills.tasks"},{"location":"aea/api/skills/tasks/#task-objects","text":"class Task ( WithLogger ) This class implements an abstract task.","title":"Task Objects"},{"location":"aea/api/skills/tasks/#__init__","text":"| __init__ ( ** kwargs ) Initialize a task.","title":"__init__"},{"location":"aea/api/skills/tasks/#__call__","text":"| __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed.","title":"__call__"},{"location":"aea/api/skills/tasks/#is_executed","text":"| @property | is_executed () -> bool Check if the task has already been executed.","title":"is_executed"},{"location":"aea/api/skills/tasks/#result","text":"| @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet.","title":"result"},{"location":"aea/api/skills/tasks/#setup","text":"| setup () -> None Implement the task setup. Returns : None","title":"setup"},{"location":"aea/api/skills/tasks/#execute","text":"| @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None","title":"execute"},{"location":"aea/api/skills/tasks/#teardown","text":"| teardown () -> None Implement the task teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/tasks/#init_worker","text":"init_worker () -> None Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296 Returns : None","title":"init_worker"},{"location":"aea/api/skills/tasks/#taskmanager-objects","text":"class TaskManager ( WithLogger ) A Task manager.","title":"TaskManager Objects"},{"location":"aea/api/skills/tasks/#__init___1","text":"| __init__ ( nb_workers : int = 1 , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called.","title":"__init__"},{"location":"aea/api/skills/tasks/#is_started","text":"| @property | is_started () -> bool Get started status of TaskManager. Returns : bool","title":"is_started"},{"location":"aea/api/skills/tasks/#nb_workers","text":"| @property | nb_workers () -> int Get the number of workers. Returns : int","title":"nb_workers"},{"location":"aea/api/skills/tasks/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"enqueue_task"},{"location":"aea/api/skills/tasks/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Returns : async result for task_id","title":"get_task_result"},{"location":"aea/api/skills/tasks/#start","text":"| start () -> None Start the task manager. Returns : None","title":"start"},{"location":"aea/api/skills/tasks/#stop","text":"| stop () -> None Stop the task manager. Returns : None","title":"stop"},{"location":"aea/api/skills/error/handlers/","text":"packages.fetchai.skills.error.handlers This package contains the implementation of the handler for the 'default' protocol. ErrorHandler Objects class ErrorHandler ( Handler ) This class implements the error handler. setup | setup () -> None Implement the setup. Returns : None handle | handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message teardown | teardown () -> None Implement the handler teardown. Returns : None send _ unsupported _ protocol | send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None send _ decoding _ error | send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None send _ unsupported _ skill | send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"Error Skill"},{"location":"aea/api/skills/error/handlers/#packagesfetchaiskillserrorhandlers","text":"This package contains the implementation of the handler for the 'default' protocol.","title":"packages.fetchai.skills.error.handlers"},{"location":"aea/api/skills/error/handlers/#errorhandler-objects","text":"class ErrorHandler ( Handler ) This class implements the error handler.","title":"ErrorHandler Objects"},{"location":"aea/api/skills/error/handlers/#setup","text":"| setup () -> None Implement the setup. Returns : None","title":"setup"},{"location":"aea/api/skills/error/handlers/#handle","text":"| handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message","title":"handle"},{"location":"aea/api/skills/error/handlers/#teardown","text":"| teardown () -> None Implement the handler teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/error/handlers/#send_unsupported_protocol","text":"| send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/skills/error/handlers/#send_decoding_error","text":"| send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None","title":"send_decoding_error"},{"location":"aea/api/skills/error/handlers/#send_unsupported_skill","text":"| send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_skill"},{"location":"aea/api/test_tools/constants/","text":"aea.test _ tools.constants This is a module with constants for test tools.","title":"Constants"},{"location":"aea/api/test_tools/constants/#aeatest_toolsconstants","text":"This is a module with constants for test tools.","title":"aea.test_tools.constants"},{"location":"aea/api/test_tools/exceptions/","text":"aea.test _ tools.exceptions Module with AEA testing exceptions. AEATestingException Objects class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"Exceptions"},{"location":"aea/api/test_tools/exceptions/#aeatest_toolsexceptions","text":"Module with AEA testing exceptions.","title":"aea.test_tools.exceptions"},{"location":"aea/api/test_tools/exceptions/#aeatestingexception-objects","text":"class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"AEATestingException Objects"},{"location":"aea/api/test_tools/generic/","text":"aea.test _ tools.generic This module contains generic tools for AEA end-to-end testing. write _ envelope _ to _ file write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path Returns : None read _ envelope _ from _ file read_envelope_from_file ( file_path : str ) Read an envelope from a file. :param file_path the file path. Returns : envelope nested _ set _ config nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path. Returns : None.","title":"Generic"},{"location":"aea/api/test_tools/generic/#aeatest_toolsgeneric","text":"This module contains generic tools for AEA end-to-end testing.","title":"aea.test_tools.generic"},{"location":"aea/api/test_tools/generic/#write_envelope_to_file","text":"write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path Returns : None","title":"write_envelope_to_file"},{"location":"aea/api/test_tools/generic/#read_envelope_from_file","text":"read_envelope_from_file ( file_path : str ) Read an envelope from a file. :param file_path the file path. Returns : envelope","title":"read_envelope_from_file"},{"location":"aea/api/test_tools/generic/#nested_set_config","text":"nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path. Returns : None.","title":"nested_set_config"},{"location":"aea/api/test_tools/test_cases/","text":"aea.test _ tools.test _ cases This module contains test case classes based on pytest for AEA end-to-end testing. BaseAEATestCase Objects class BaseAEATestCase ( ABC ) Base class for AEA test cases. set _ agent _ context | @classmethod | set_agent_context ( cls , agent_name : str ) Set the current agent context. unset _ agent _ context | @classmethod | unset_agent_context ( cls ) Unset the current agent context. set _ config | @classmethod | set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result nested _ set _ config | @classmethod | nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config. disable _ aea _ logging | @classmethod | disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory. Returns : None run _ cli _ command | @classmethod | run_cli_command ( cls , * args : str , * , cwd : str = \".\" , ** kwargs ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CLIRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result start _ subprocess | @classmethod | start_subprocess ( cls , * args : str , * , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args Returns : subprocess object. start _ thread | @classmethod | start_thread ( cls , target : Callable , ** kwargs ) -> Thread Start python Thread. Arguments : target : target method. process : subprocess passed to thread args. Returns : None. create _ agents | @classmethod | create_agents ( cls , * agents_names : str , * , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. empty : optional boolean flag for skip adding default dependencies. Returns : None fetch _ agent | @classmethod | fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agents_name : str agent name. is_local : a flag for local folder add True by default. Returns : None difference _ to _ fetched _ agent | @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agents_name : str agent name. Returns : list of files differing in the projects delete _ agents | @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. Returns : None run _ agent | @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object. run _ interaction | @classmethod | run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object. terminate _ agents | @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , * , timeout : int = 10 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption is _ successfully _ terminated | @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) Check if all subprocesses terminated successfully. initialize _ aea | @classmethod | initialize_aea ( cls , author ) -> None Initialize AEA locally with author name. Returns : None add _ item | @classmethod | add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result remove _ item | @classmethod | remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result scaffold _ item | @classmethod | scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result fingerprint _ item | @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : public id of the item. Returns : Result eject _ item | @classmethod | eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None run _ install | @classmethod | run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result generate _ private _ key | @classmethod | generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. Returns : Result add _ private _ key | @classmethod | add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. Returns : Result remove _ private _ key | @classmethod | remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result replace _ private _ key _ in _ file | @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Returns : None :raises: exception if file does not exist generate _ wealth | @classmethod | generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : Result get _ wealth | @classmethod | get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : command line output replace _ file _ content | @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the dest file. Arguments : src : the source file. dest : the destination file. Returns : None change _ directory | @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. Returns : None send _ envelope _ to _ agent | @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) Send an envelope to an agent, using the stub connection. read _ envelope _ from _ agent | @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection. missing _ from _ output | @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings. is _ running | @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete invoke | @classmethod | invoke ( cls , * args ) Call the cli command. load _ agent _ config | @classmethod | load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test. UseOef Objects @pytest . mark . integration class UseOef () Inherit from this class to launch an OEF node. AEATestCaseEmpty Objects class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. AEATestCaseMany Objects class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test class. AEATestCase Objects class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory. setup _ class | @classmethod | setup_class ( cls ) Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) Teardown the test class.","title":"Test Cases"},{"location":"aea/api/test_tools/test_cases/#aeatest_toolstest_cases","text":"This module contains test case classes based on pytest for AEA end-to-end testing.","title":"aea.test_tools.test_cases"},{"location":"aea/api/test_tools/test_cases/#baseaeatestcase-objects","text":"class BaseAEATestCase ( ABC ) Base class for AEA test cases.","title":"BaseAEATestCase Objects"},{"location":"aea/api/test_tools/test_cases/#set_agent_context","text":"| @classmethod | set_agent_context ( cls , agent_name : str ) Set the current agent context.","title":"set_agent_context"},{"location":"aea/api/test_tools/test_cases/#unset_agent_context","text":"| @classmethod | unset_agent_context ( cls ) Unset the current agent context.","title":"unset_agent_context"},{"location":"aea/api/test_tools/test_cases/#set_config","text":"| @classmethod | set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result","title":"set_config"},{"location":"aea/api/test_tools/test_cases/#nested_set_config","text":"| @classmethod | nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config.","title":"nested_set_config"},{"location":"aea/api/test_tools/test_cases/#disable_aea_logging","text":"| @classmethod | disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory. Returns : None","title":"disable_aea_logging"},{"location":"aea/api/test_tools/test_cases/#run_cli_command","text":"| @classmethod | run_cli_command ( cls , * args : str , * , cwd : str = \".\" , ** kwargs ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CLIRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result","title":"run_cli_command"},{"location":"aea/api/test_tools/test_cases/#start_subprocess","text":"| @classmethod | start_subprocess ( cls , * args : str , * , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args Returns : subprocess object.","title":"start_subprocess"},{"location":"aea/api/test_tools/test_cases/#start_thread","text":"| @classmethod | start_thread ( cls , target : Callable , ** kwargs ) -> Thread Start python Thread. Arguments : target : target method. process : subprocess passed to thread args. Returns : None.","title":"start_thread"},{"location":"aea/api/test_tools/test_cases/#create_agents","text":"| @classmethod | create_agents ( cls , * agents_names : str , * , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. empty : optional boolean flag for skip adding default dependencies. Returns : None","title":"create_agents"},{"location":"aea/api/test_tools/test_cases/#fetch_agent","text":"| @classmethod | fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agents_name : str agent name. is_local : a flag for local folder add True by default. Returns : None","title":"fetch_agent"},{"location":"aea/api/test_tools/test_cases/#difference_to_fetched_agent","text":"| @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agents_name : str agent name. Returns : list of files differing in the projects","title":"difference_to_fetched_agent"},{"location":"aea/api/test_tools/test_cases/#delete_agents","text":"| @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. Returns : None","title":"delete_agents"},{"location":"aea/api/test_tools/test_cases/#run_agent","text":"| @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object.","title":"run_agent"},{"location":"aea/api/test_tools/test_cases/#run_interaction","text":"| @classmethod | run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object.","title":"run_interaction"},{"location":"aea/api/test_tools/test_cases/#terminate_agents","text":"| @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , * , timeout : int = 10 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption","title":"terminate_agents"},{"location":"aea/api/test_tools/test_cases/#is_successfully_terminated","text":"| @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) Check if all subprocesses terminated successfully.","title":"is_successfully_terminated"},{"location":"aea/api/test_tools/test_cases/#initialize_aea","text":"| @classmethod | initialize_aea ( cls , author ) -> None Initialize AEA locally with author name. Returns : None","title":"initialize_aea"},{"location":"aea/api/test_tools/test_cases/#add_item","text":"| @classmethod | add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result","title":"add_item"},{"location":"aea/api/test_tools/test_cases/#remove_item","text":"| @classmethod | remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result","title":"remove_item"},{"location":"aea/api/test_tools/test_cases/#scaffold_item","text":"| @classmethod | scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result","title":"scaffold_item"},{"location":"aea/api/test_tools/test_cases/#fingerprint_item","text":"| @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : public id of the item. Returns : Result","title":"fingerprint_item"},{"location":"aea/api/test_tools/test_cases/#eject_item","text":"| @classmethod | eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None","title":"eject_item"},{"location":"aea/api/test_tools/test_cases/#run_install","text":"| @classmethod | run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result","title":"run_install"},{"location":"aea/api/test_tools/test_cases/#generate_private_key","text":"| @classmethod | generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. Returns : Result","title":"generate_private_key"},{"location":"aea/api/test_tools/test_cases/#add_private_key","text":"| @classmethod | add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. Returns : Result","title":"add_private_key"},{"location":"aea/api/test_tools/test_cases/#remove_private_key","text":"| @classmethod | remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result","title":"remove_private_key"},{"location":"aea/api/test_tools/test_cases/#replace_private_key_in_file","text":"| @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Returns : None :raises: exception if file does not exist","title":"replace_private_key_in_file"},{"location":"aea/api/test_tools/test_cases/#generate_wealth","text":"| @classmethod | generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : Result","title":"generate_wealth"},{"location":"aea/api/test_tools/test_cases/#get_wealth","text":"| @classmethod | get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. Returns : command line output","title":"get_wealth"},{"location":"aea/api/test_tools/test_cases/#replace_file_content","text":"| @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the dest file. Arguments : src : the source file. dest : the destination file. Returns : None","title":"replace_file_content"},{"location":"aea/api/test_tools/test_cases/#change_directory","text":"| @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. Returns : None","title":"change_directory"},{"location":"aea/api/test_tools/test_cases/#send_envelope_to_agent","text":"| @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) Send an envelope to an agent, using the stub connection.","title":"send_envelope_to_agent"},{"location":"aea/api/test_tools/test_cases/#read_envelope_from_agent","text":"| @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection.","title":"read_envelope_from_agent"},{"location":"aea/api/test_tools/test_cases/#missing_from_output","text":"| @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings.","title":"missing_from_output"},{"location":"aea/api/test_tools/test_cases/#is_running","text":"| @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete","title":"is_running"},{"location":"aea/api/test_tools/test_cases/#invoke","text":"| @classmethod | invoke ( cls , * args ) Call the cli command.","title":"invoke"},{"location":"aea/api/test_tools/test_cases/#load_agent_config","text":"| @classmethod | load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration.","title":"load_agent_config"},{"location":"aea/api/test_tools/test_cases/#setup_class","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class","text":"| @classmethod | teardown_class ( cls ) Teardown the test.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#useoef-objects","text":"@pytest . mark . integration class UseOef () Inherit from this class to launch an OEF node.","title":"UseOef Objects"},{"location":"aea/api/test_tools/test_cases/#aeatestcaseempty-objects","text":"class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project.","title":"AEATestCaseEmpty Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_1","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcasemany-objects","text":"class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects.","title":"AEATestCaseMany Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_2","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_1","text":"| @classmethod | teardown_class ( cls ) Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcase-objects","text":"class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory.","title":"AEATestCase Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_3","text":"| @classmethod | setup_class ( cls ) Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_2","text":"| @classmethod | teardown_class ( cls ) Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_skill/","text":"aea.test _ tools.test _ skill This module contains test case classes based on pytest for AEA skill testing. BaseSkillTestCase Objects class BaseSkillTestCase () A class to test a skill. skill | @property | skill () -> Skill Get the skill. get _ quantity _ in _ outbox | get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox. get _ message _ from _ outbox | get_message_from_outbox () -> Optional [ Message ] Get message from outbox. drop _ messages _ from _ outbox | drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox. get _ quantity _ in _ decision _ maker _ inbox | get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox. get _ message _ from _ decision _ maker _ inbox | get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox. drop _ messages _ from _ decision _ maker _ inbox | drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox. assert _ quantity _ in _ outbox | assert_quantity_in_outbox ( expected_quantity ) -> None Assert the quantity of messages in the outbox. assert _ quantity _ in _ decision _ making _ queue | assert_quantity_in_decision_making_queue ( expected_quantity ) -> None Assert the quantity of messages in the decision maker queue. message _ has _ attributes | @staticmethod | message_has_attributes ( actual_message : Message , message_type : Type [ Message ], ** kwargs , ,) -> Tuple [ bool , str ] Evaluates whether a message's attributes match the expected attributes provided. Arguments : actual_message : the actual message message_type : the expected message type kwargs : other expected message attributes Returns : boolean result of the evaluation and accompanied message build _ incoming _ message | build_incoming_message ( message_type : Type [ Message ], performative : Message . Performative , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Address = COUNTERPARTY_ADDRESS , ** kwargs , ,) -> Message Quickly create an incoming message with the provided attributes. For any attribute not provided, the corresponding default value in message is used. Arguments : message_type : the type of the message dialogue_reference : the dialogue_reference message_id : the message_id target : the target performative : the performative to : the 'to' address sender : the 'sender' address kwargs : other attributes Returns : the created incoming message build _ incoming _ message _ for _ skill _ dialogue | build_incoming_message_for_skill_dialogue ( dialogue : Dialogue , performative : Message . Performative , message_type : Optional [ Type [ Message ]] = None , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , ** kwargs , ,) -> Message Quickly create an incoming message with the provided attributes for a dialogue. For any attribute not provided, a value based on the dialogue is used. These values are shown in parantheses in the list of parameters below. NOTE: This method must be used with care. The dialogue provided is part of the skill which is being tested. Because for any unspecified attribute, a \"correct\" value is used, the test will be, by design, insured to pass on these values. Arguments : dialogue : the dialogue to which the incoming message is intended performative : the performative of the message message_type : (the message_class of the provided dialogue) the type of the message dialogue_reference : (the dialogue_reference of the provided dialogue) the dialogue reference of the message message_id : (the id of the last message in the provided dialogue + 1) the id of the message target : (the id of the last message in the provided dialogue) the target of the message to : (the agent address associated with this skill) the receiver of the message sender : (the counterperty in the provided dialogue) the sender of the message kwargs : other attributes Returns : the created incoming message prepare _ skill _ dialogue | prepare_skill_dialogue ( dialogues : Dialogues , messages : Tuple [ DialogueMessage , ... ], counterparty : Address = COUNTERPARTY_ADDRESS ) -> Dialogue Quickly create a dialogue. The 'messages' argument is a tuple of DialogueMessages. For every DialogueMessage (performative, contents, is_incoming, target): - if 'is_incoming' is not provided: for the first message it is assumed False (outgoing), for any other message, it is the opposite of the one preceding it. - if 'target' is not provided: for the first message it is assumed 0, for any other message, it is the index of the message before it in the tuple of messages + 1. Arguments : dialogues : a dialogues class counterparty : the message_id messages : the dialogue_reference Returns : the created incoming message setup | @classmethod | setup ( cls , ** kwargs ) -> None Set up the skill test case.","title":"Test Skill"},{"location":"aea/api/test_tools/test_skill/#aeatest_toolstest_skill","text":"This module contains test case classes based on pytest for AEA skill testing.","title":"aea.test_tools.test_skill"},{"location":"aea/api/test_tools/test_skill/#baseskilltestcase-objects","text":"class BaseSkillTestCase () A class to test a skill.","title":"BaseSkillTestCase Objects"},{"location":"aea/api/test_tools/test_skill/#skill","text":"| @property | skill () -> Skill Get the skill.","title":"skill"},{"location":"aea/api/test_tools/test_skill/#get_quantity_in_outbox","text":"| get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox.","title":"get_quantity_in_outbox"},{"location":"aea/api/test_tools/test_skill/#get_message_from_outbox","text":"| get_message_from_outbox () -> Optional [ Message ] Get message from outbox.","title":"get_message_from_outbox"},{"location":"aea/api/test_tools/test_skill/#drop_messages_from_outbox","text":"| drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox.","title":"drop_messages_from_outbox"},{"location":"aea/api/test_tools/test_skill/#get_quantity_in_decision_maker_inbox","text":"| get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox.","title":"get_quantity_in_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#get_message_from_decision_maker_inbox","text":"| get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox.","title":"get_message_from_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#drop_messages_from_decision_maker_inbox","text":"| drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox.","title":"drop_messages_from_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#assert_quantity_in_outbox","text":"| assert_quantity_in_outbox ( expected_quantity ) -> None Assert the quantity of messages in the outbox.","title":"assert_quantity_in_outbox"},{"location":"aea/api/test_tools/test_skill/#assert_quantity_in_decision_making_queue","text":"| assert_quantity_in_decision_making_queue ( expected_quantity ) -> None Assert the quantity of messages in the decision maker queue.","title":"assert_quantity_in_decision_making_queue"},{"location":"aea/api/test_tools/test_skill/#message_has_attributes","text":"| @staticmethod | message_has_attributes ( actual_message : Message , message_type : Type [ Message ], ** kwargs , ,) -> Tuple [ bool , str ] Evaluates whether a message's attributes match the expected attributes provided. Arguments : actual_message : the actual message message_type : the expected message type kwargs : other expected message attributes Returns : boolean result of the evaluation and accompanied message","title":"message_has_attributes"},{"location":"aea/api/test_tools/test_skill/#build_incoming_message","text":"| build_incoming_message ( message_type : Type [ Message ], performative : Message . Performative , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Address = COUNTERPARTY_ADDRESS , ** kwargs , ,) -> Message Quickly create an incoming message with the provided attributes. For any attribute not provided, the corresponding default value in message is used. Arguments : message_type : the type of the message dialogue_reference : the dialogue_reference message_id : the message_id target : the target performative : the performative to : the 'to' address sender : the 'sender' address kwargs : other attributes Returns : the created incoming message","title":"build_incoming_message"},{"location":"aea/api/test_tools/test_skill/#build_incoming_message_for_skill_dialogue","text":"| build_incoming_message_for_skill_dialogue ( dialogue : Dialogue , performative : Message . Performative , message_type : Optional [ Type [ Message ]] = None , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , ** kwargs , ,) -> Message Quickly create an incoming message with the provided attributes for a dialogue. For any attribute not provided, a value based on the dialogue is used. These values are shown in parantheses in the list of parameters below. NOTE: This method must be used with care. The dialogue provided is part of the skill which is being tested. Because for any unspecified attribute, a \"correct\" value is used, the test will be, by design, insured to pass on these values. Arguments : dialogue : the dialogue to which the incoming message is intended performative : the performative of the message message_type : (the message_class of the provided dialogue) the type of the message dialogue_reference : (the dialogue_reference of the provided dialogue) the dialogue reference of the message message_id : (the id of the last message in the provided dialogue + 1) the id of the message target : (the id of the last message in the provided dialogue) the target of the message to : (the agent address associated with this skill) the receiver of the message sender : (the counterperty in the provided dialogue) the sender of the message kwargs : other attributes Returns : the created incoming message","title":"build_incoming_message_for_skill_dialogue"},{"location":"aea/api/test_tools/test_skill/#prepare_skill_dialogue","text":"| prepare_skill_dialogue ( dialogues : Dialogues , messages : Tuple [ DialogueMessage , ... ], counterparty : Address = COUNTERPARTY_ADDRESS ) -> Dialogue Quickly create a dialogue. The 'messages' argument is a tuple of DialogueMessages. For every DialogueMessage (performative, contents, is_incoming, target): - if 'is_incoming' is not provided: for the first message it is assumed False (outgoing), for any other message, it is the opposite of the one preceding it. - if 'target' is not provided: for the first message it is assumed 0, for any other message, it is the index of the message before it in the tuple of messages + 1. Arguments : dialogues : a dialogues class counterparty : the message_id messages : the dialogue_reference Returns : the created incoming message","title":"prepare_skill_dialogue"},{"location":"aea/api/test_tools/test_skill/#setup","text":"| @classmethod | setup ( cls , ** kwargs ) -> None Set up the skill test case.","title":"setup"},{"location":"bounty/aea-docs-bounty/","text":"Fetch.ai is running a 1 week (19th November - 26th November 2020) documentation bounty programme for https://docs.fetch.ai/aea . The following rewards are on offer: Type of issue FET reward Cap (max # of rewards issued) Unable to run a demo as specified on a page in the demo section of the documentation (Agent Framework > Demos) 200 20 Unable to import, instantiate or run code as specified on a page in the development section of the documentation (Agent Framework > Development) 100 20 The problem must be recorded on GitHub as an issue with the label documentation . Related problems on a single page count as one issue and should be reported as such. The issue must be reproducible by a developer at Fetch.ai to qualify for rewards. Ambiguous language or spelling and grammar erros in the documentation do not qualify for a bounty but we will happily fix it if reported. If the same problem is recorded twice, only the first reported issue qualifies for rewards. Once the caps are reached, no further issues reported receive any rewards (except our gratitude for helping make the docs better for all agent BUIDLers!).","title":"AEA Docs"},{"location":"i_nets/","text":"The Journey to mainnet version 2 Fetch.ai is running three themed, incentivized testnets to take us to mainnet version 2. Each testnet will run for approximately 6 weeks, and will be arranged in groups of incentives. The below diagram outlines how this will work. When each incentivized testnet is complete, it will be reset and the new one created. This will reset state, and testing and work will focus on the new functionality added. With each step along the way, we get closer and closer to a fully featured Fetch V2 mainnet. Throughout this process, Fetch.ai is running a stable testnet called Agentland. Agentland will not have its state reset, and is perfect for application and agent development and deployment. When the funky incentivized testnet is complete, mainnet v2 will be launched. Three phases of JourneyNet to Mainnet V2 The three phases are: Phase 1: incentives are agent themed with some governance Phase 2: incentives relate to the DRB, node operation and governance Phase 3: incentives designed to deliver oracles and connect worlds with trustworthy information Each phase lasts about six weeks and is sub-divided up to provide the broadest opportunities for all members of the community, as well as ensuring we focus testing efforts in the areas that ensure an on-time delivery of mainnet v2. Phase 1 's agent-focussed sub-sections are referred to as AW1, AW2, AW3 and AW4. Phase 2 's node and DRB sub-sections are referred to as BW1 to BW6. Phase 3's oracle sub-sections are referred to as OW1 upwards. More details on each of these will be announced as we get closer, and Fetch.ai may add additional sub-sections in order to test specific features, such as smart-contracts and other such technologies. They're open throughout Agent development is not limited to phase 1 of the testnet. We run a permament testnet called Agentland which is stable throughout this process. Agentland is where we are deploying and developing applications in hospitality, delivery, transportation, supply chains and more. Join us, and our increasing population of agents, to explore new applications and opportunities.","title":"Introduction"},{"location":"i_nets/#the-journey-to-mainnet-version-2","text":"Fetch.ai is running three themed, incentivized testnets to take us to mainnet version 2. Each testnet will run for approximately 6 weeks, and will be arranged in groups of incentives. The below diagram outlines how this will work. When each incentivized testnet is complete, it will be reset and the new one created. This will reset state, and testing and work will focus on the new functionality added. With each step along the way, we get closer and closer to a fully featured Fetch V2 mainnet. Throughout this process, Fetch.ai is running a stable testnet called Agentland. Agentland will not have its state reset, and is perfect for application and agent development and deployment. When the funky incentivized testnet is complete, mainnet v2 will be launched.","title":"The Journey to mainnet version 2"},{"location":"i_nets/#three-phases-of-journeynet-to-mainnet-v2","text":"The three phases are: Phase 1: incentives are agent themed with some governance Phase 2: incentives relate to the DRB, node operation and governance Phase 3: incentives designed to deliver oracles and connect worlds with trustworthy information Each phase lasts about six weeks and is sub-divided up to provide the broadest opportunities for all members of the community, as well as ensuring we focus testing efforts in the areas that ensure an on-time delivery of mainnet v2. Phase 1 's agent-focussed sub-sections are referred to as AW1, AW2, AW3 and AW4. Phase 2 's node and DRB sub-sections are referred to as BW1 to BW6. Phase 3's oracle sub-sections are referred to as OW1 upwards. More details on each of these will be announced as we get closer, and Fetch.ai may add additional sub-sections in order to test specific features, such as smart-contracts and other such technologies.","title":"Three phases of JourneyNet to Mainnet V2"},{"location":"i_nets/#theyre-open-throughout","text":"Agent development is not limited to phase 1 of the testnet. We run a permament testnet called Agentland which is stable throughout this process. Agentland is where we are deploying and developing applications in hospitality, delivery, transportation, supply chains and more. Join us, and our increasing population of agents, to explore new applications and opportunities.","title":"They're open throughout"},{"location":"i_nets/quickstart-aw1/","text":"Introduction: Agent World 1 (AW-1) - part 1, getting started Note AW-1 has finished now! Rewards are no longer available but you can still register. Agent World 1 (AW-1) is the first part of our agent-themed incentivised testnet. It allows anyone with a non-zero amount of staked FET tokens to gain some more FET token rewards by following a few simple steps and launching an agent on Agent World. In this first two week part, we get everyone up and running with the a agent framework . Rewards The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Steps 1 - 11 below 100 250 150 Tweet 0 50 100 How to qualify for incentive rewards? Note You must stake ERC20 FET tokens in order to take part and qualify. Go to staking , the process is simple and quick! You have to complete a few steps as listed below: Join our discord channel here . This allows you to ask questions throughout AW-1 and engage with the Fetch.ai developers. Download and install the AEA (Autonomous Economic Agent) Framework including its CLI on your own machine. There are three ways to do this: Direct: Ensure you have Python (3.6, 3.7 or 3.8) and Go (>= 1.14.2) installed on your machine. Run pip install aea[all] to install the framework. Ensure you have the latest version installed by executing aea --version . To upgrade from an older version use pip install --upgrade aea[all] . For more guidance (in particular Windows and Ubuntu related issues) check out the AEA quickstart's known issues section Docker: We provide a Docker image with all the needed dependencies. To use the image you will first have to pull it and than run it with your current local directory mounted as a Docker volume. This allows you to keep your agents local while working on them from within the Docker container. To pull docker pull fetchai/aea-user:latest To run the image: Linux and MacOs: docker run -it -v $(pwd):/agents --workdir=/agents fetchai/aea-user:latest Windows: docker run -it -v %cd%:/agents --workdir=/agents fetchai/aea-user:latest Once successfully logged into the Docker container, you can follow the rest of the guide the same way as if not using Docker and step Direct above. Automated: Get this script for Windows or this script for MacOs/Ubuntu and run it on your machine. The script will install the required dependencies and the framework. Create a developer account using the command below. This will enable you to download and contribute to the AEA Registry ; the package manager for AEA components. Simply run aea init and follow the steps as prompted. In the process you will set an author name; this is your developer handle . Typing aea at the command prompt will give you a list of commands that are available. Fetch the registration agent from AEA Registry via CLI: Run aea fetch fetchai/registration_aea_aw1 Enter it cd registration_aea_aw1 Install dependencies via aea install Build its components via aea build Create a test-net address for the registration agent via CLI: Run aea generate-key fetchai and aea add-key fetchai to generate and add a key pair for your AEA to transact with. Then run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate both with aea issue-certificates . Print your address for transacting aea get-address fetchai Sign the test-net address you just generated with the private key tied to your FET account on Ethereum mainnet. This is the account you use for FET staking: We recommend you use our signing app with your MetaMask wallet, alternatively use MEW or a similar wallet to sign your Fetch.ai test-net address. In your registration agent's aea-config.yaml file update the following lines: ethereum_address: PUT_YOUR_ETHEREUM_ADDRESS_HERE signature_of_fetchai_address: PUT_YOUR_SIGNATURE_HERE whitelist: [PUT_WHITELIST_ADDRESSES_HERE] (In this challenge, this variable should be set to: fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf .) Note Make sure you put strings (addresses and signatures) in quotes '' . Configure the registration agent further, to include your developer handle. Optionally, to earn more tokens, also provide a link to a tweet. To qualify, the tweet must reference your developer handle and link to incentivized testnet landing page . In your registration agent's aea-config.yaml file add the following lines: developer_handle: PUT_YOUR_DEVELOPER_HANDLE_HERE tweet: PUT_THE_LINK_TO_YOUR_TWEET_HERE The developer handle needs to be updated in two places! (You can search the file for the PUT_YOUR_DEVELOPER_HANDLE_HERE placeholder). Now, you can run your registration agent which registers the agent and the provided data on the SOEF and with the confirmation agent: Execute aea run After a while, when you see received register message success , you can stop (by pressing Ctrl-C ) the agent. You can look for your transfer on the block explorer . Note If after some time (>1 min) you get no response or the response is an error, then please make sure you have followed steps 6. and 7. correctly and that you have funds staked! You can verify that you have received funds on the test-net in AEA's wallet: Execute aea get-wealth fetchai to see your test-net wealth Use the CLI to send some funds from your registration agent to the whitelist adddress: aea transfer fetchai fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf 10 At this point you are done! We would really value your feedback. Please complete our survey here .","title":"Agent World 1"},{"location":"i_nets/quickstart-aw1/#introduction-agent-world-1-aw-1-part-1-getting-started","text":"Note AW-1 has finished now! Rewards are no longer available but you can still register. Agent World 1 (AW-1) is the first part of our agent-themed incentivised testnet. It allows anyone with a non-zero amount of staked FET tokens to gain some more FET token rewards by following a few simple steps and launching an agent on Agent World. In this first two week part, we get everyone up and running with the a agent framework .","title":"Introduction: Agent World 1 (AW-1) - part 1, getting started"},{"location":"i_nets/quickstart-aw1/#rewards","text":"The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Steps 1 - 11 below 100 250 150 Tweet 0 50 100","title":"Rewards"},{"location":"i_nets/quickstart-aw1/#how-to-qualify-for-incentive-rewards","text":"Note You must stake ERC20 FET tokens in order to take part and qualify. Go to staking , the process is simple and quick! You have to complete a few steps as listed below: Join our discord channel here . This allows you to ask questions throughout AW-1 and engage with the Fetch.ai developers. Download and install the AEA (Autonomous Economic Agent) Framework including its CLI on your own machine. There are three ways to do this: Direct: Ensure you have Python (3.6, 3.7 or 3.8) and Go (>= 1.14.2) installed on your machine. Run pip install aea[all] to install the framework. Ensure you have the latest version installed by executing aea --version . To upgrade from an older version use pip install --upgrade aea[all] . For more guidance (in particular Windows and Ubuntu related issues) check out the AEA quickstart's known issues section Docker: We provide a Docker image with all the needed dependencies. To use the image you will first have to pull it and than run it with your current local directory mounted as a Docker volume. This allows you to keep your agents local while working on them from within the Docker container. To pull docker pull fetchai/aea-user:latest To run the image: Linux and MacOs: docker run -it -v $(pwd):/agents --workdir=/agents fetchai/aea-user:latest Windows: docker run -it -v %cd%:/agents --workdir=/agents fetchai/aea-user:latest Once successfully logged into the Docker container, you can follow the rest of the guide the same way as if not using Docker and step Direct above. Automated: Get this script for Windows or this script for MacOs/Ubuntu and run it on your machine. The script will install the required dependencies and the framework. Create a developer account using the command below. This will enable you to download and contribute to the AEA Registry ; the package manager for AEA components. Simply run aea init and follow the steps as prompted. In the process you will set an author name; this is your developer handle . Typing aea at the command prompt will give you a list of commands that are available. Fetch the registration agent from AEA Registry via CLI: Run aea fetch fetchai/registration_aea_aw1 Enter it cd registration_aea_aw1 Install dependencies via aea install Build its components via aea build Create a test-net address for the registration agent via CLI: Run aea generate-key fetchai and aea add-key fetchai to generate and add a key pair for your AEA to transact with. Then run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate both with aea issue-certificates . Print your address for transacting aea get-address fetchai Sign the test-net address you just generated with the private key tied to your FET account on Ethereum mainnet. This is the account you use for FET staking: We recommend you use our signing app with your MetaMask wallet, alternatively use MEW or a similar wallet to sign your Fetch.ai test-net address. In your registration agent's aea-config.yaml file update the following lines: ethereum_address: PUT_YOUR_ETHEREUM_ADDRESS_HERE signature_of_fetchai_address: PUT_YOUR_SIGNATURE_HERE whitelist: [PUT_WHITELIST_ADDRESSES_HERE] (In this challenge, this variable should be set to: fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf .) Note Make sure you put strings (addresses and signatures) in quotes '' . Configure the registration agent further, to include your developer handle. Optionally, to earn more tokens, also provide a link to a tweet. To qualify, the tweet must reference your developer handle and link to incentivized testnet landing page . In your registration agent's aea-config.yaml file add the following lines: developer_handle: PUT_YOUR_DEVELOPER_HANDLE_HERE tweet: PUT_THE_LINK_TO_YOUR_TWEET_HERE The developer handle needs to be updated in two places! (You can search the file for the PUT_YOUR_DEVELOPER_HANDLE_HERE placeholder). Now, you can run your registration agent which registers the agent and the provided data on the SOEF and with the confirmation agent: Execute aea run After a while, when you see received register message success , you can stop (by pressing Ctrl-C ) the agent. You can look for your transfer on the block explorer . Note If after some time (>1 min) you get no response or the response is an error, then please make sure you have followed steps 6. and 7. correctly and that you have funds staked! You can verify that you have received funds on the test-net in AEA's wallet: Execute aea get-wealth fetchai to see your test-net wealth Use the CLI to send some funds from your registration agent to the whitelist adddress: aea transfer fetchai fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf 10 At this point you are done! We would really value your feedback. Please complete our survey here .","title":"How to qualify for incentive rewards?"},{"location":"i_nets/quickstart-aw2/","text":"Introduction: Agent World 2 (AW-2) - part 2, \"My first own agent\" Note AW-2 has finished now! Agent World 2 (AW-2) is the second part of our agent-themed incentivised testnet. During this part, it allows anyone with FET tokens to gain additional FET by building agents to represent mobility and climate/weather related agents in key cities around the world, such as Berlin, London, San Francisco and Shanghai. The world is full of web based APIs for collecting this data, and the agent framework supports HTTP connections to these. Rewards The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Steps 1 - 7, 10 below variable from trade 1500 60 Step 9 variable from trade 500 60 Fetch.ai reserve the right to increase the award pool for AW-2 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations. How to qualify for incentive rewards? Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Then upgrade your AEA using aea upgrade from within the project or follow the instructions here . Fetch the simple_seller_aw2 AEA from the AEA-registry and give it a suitable name: Run aea fetch fetchai/simple_seller_aw2 --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. After fetching it, enter the project: cd YOUR_AEA_NAME Then install its third-party dependencies: aea install Eject the simple_seller and simple_data_request skills so you can edit them: Run aea eject skill fetchai/simple_seller , which will eject the skill from the vendor folder to the skills folder where you can edit it. Then, run aea eject skill fetchai/simple_data_request , which will eject this skill too. Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Customize the simple_seller skill (in YOUR_AGENT_NAME/skills/simple_seller ) and the simple_data_request skill (in YOUR_AGENT_NAME/skills/simple_data_request ) to satisfy the following requirements (you may optionally customize other components of the AEA as well): The AEA must sell data offered by a public API which provides data on mobility or weather in the vicinity of either one of Berlin (Germany) [ latitude: 52.5200, longitude: 13.4050 ], London (UK) [ latitude: 51.5074, longitude: -0.1278 ], San Francisco (USA) [ latitude: 37.7749, longitude: -122.4194 ] or Shanghai (China) [ latitude: 31.2304, longitude: 121.4737 ]. Your AEA must be located in a radius no further than 50 km from the geo locations specified. You can customize the simple_data_request and simple_seller skills to satisfy this requirement. The AEA must request data from a public API. You can customize the simple_data_request skill to satisfy this requirement. The AEA must negotiate the terms using the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF. You can customize the simple_seller skill to satisfy this requirment (by default it is already satisfied). The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). You can customize the simple_seller skill to satisfy this requirement. Payment must be via a simple transfer on the incentivized testnet. You can customize the simple_seller skill to satisfy this requirment (by default this is already the case). Note To succeed, please consult the documentation on the agent framework and discuss in Discord. Run the AEA for several hours and sell data at least twice successfully. A set of buyer AEAs is continuously checking the SOEF for data to purchase. The buyer AEAs will purchase once immediately and then again after several hours. If the initial sale does not go through, your AEA is incorrectly implemented. Stop it, fix it and try again. If the initial sale does go through let the AEA run until the second sale has concluded. The buyer AEA only purchases from AEAs which implement all the requirements listed under 5. Once your AEA has successfully sold data twice, stop it and upload it to the AEA-registry: Change the author in the aea-config.yaml to your author handle (run aea init to see what it is). Run aea publish --remote from within the AEA project. You might first have to push the skills you have developed with aea push skill PUBLIC_ID . Optionally, provide feedback on AW-2 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Extra: create a buyer AEA yourself! Fetch the simple_buyer_aw2 AEA ( aea fetch fetchai/simple_buyer_aw2 ) from the AEA-registry and extend it to be a buyer for the above use-case. Then push it to the AEA-registry. (There is no need to run it at this point.) Fill in the following form, providing your developer handle and uploaded AEAs: Complete this form .","title":"Agent World 2"},{"location":"i_nets/quickstart-aw2/#introduction-agent-world-2-aw-2-part-2-my-first-own-agent","text":"Note AW-2 has finished now! Agent World 2 (AW-2) is the second part of our agent-themed incentivised testnet. During this part, it allows anyone with FET tokens to gain additional FET by building agents to represent mobility and climate/weather related agents in key cities around the world, such as Berlin, London, San Francisco and Shanghai. The world is full of web based APIs for collecting this data, and the agent framework supports HTTP connections to these.","title":"Introduction: Agent World 2 (AW-2) - part 2, \"My first own agent\""},{"location":"i_nets/quickstart-aw2/#rewards","text":"The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Steps 1 - 7, 10 below variable from trade 1500 60 Step 9 variable from trade 500 60 Fetch.ai reserve the right to increase the award pool for AW-2 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations.","title":"Rewards"},{"location":"i_nets/quickstart-aw2/#how-to-qualify-for-incentive-rewards","text":"Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Then upgrade your AEA using aea upgrade from within the project or follow the instructions here . Fetch the simple_seller_aw2 AEA from the AEA-registry and give it a suitable name: Run aea fetch fetchai/simple_seller_aw2 --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. After fetching it, enter the project: cd YOUR_AEA_NAME Then install its third-party dependencies: aea install Eject the simple_seller and simple_data_request skills so you can edit them: Run aea eject skill fetchai/simple_seller , which will eject the skill from the vendor folder to the skills folder where you can edit it. Then, run aea eject skill fetchai/simple_data_request , which will eject this skill too. Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Customize the simple_seller skill (in YOUR_AGENT_NAME/skills/simple_seller ) and the simple_data_request skill (in YOUR_AGENT_NAME/skills/simple_data_request ) to satisfy the following requirements (you may optionally customize other components of the AEA as well): The AEA must sell data offered by a public API which provides data on mobility or weather in the vicinity of either one of Berlin (Germany) [ latitude: 52.5200, longitude: 13.4050 ], London (UK) [ latitude: 51.5074, longitude: -0.1278 ], San Francisco (USA) [ latitude: 37.7749, longitude: -122.4194 ] or Shanghai (China) [ latitude: 31.2304, longitude: 121.4737 ]. Your AEA must be located in a radius no further than 50 km from the geo locations specified. You can customize the simple_data_request and simple_seller skills to satisfy this requirement. The AEA must request data from a public API. You can customize the simple_data_request skill to satisfy this requirement. The AEA must negotiate the terms using the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF. You can customize the simple_seller skill to satisfy this requirment (by default it is already satisfied). The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). You can customize the simple_seller skill to satisfy this requirement. Payment must be via a simple transfer on the incentivized testnet. You can customize the simple_seller skill to satisfy this requirment (by default this is already the case). Note To succeed, please consult the documentation on the agent framework and discuss in Discord. Run the AEA for several hours and sell data at least twice successfully. A set of buyer AEAs is continuously checking the SOEF for data to purchase. The buyer AEAs will purchase once immediately and then again after several hours. If the initial sale does not go through, your AEA is incorrectly implemented. Stop it, fix it and try again. If the initial sale does go through let the AEA run until the second sale has concluded. The buyer AEA only purchases from AEAs which implement all the requirements listed under 5. Once your AEA has successfully sold data twice, stop it and upload it to the AEA-registry: Change the author in the aea-config.yaml to your author handle (run aea init to see what it is). Run aea publish --remote from within the AEA project. You might first have to push the skills you have developed with aea push skill PUBLIC_ID . Optionally, provide feedback on AW-2 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Extra: create a buyer AEA yourself! Fetch the simple_buyer_aw2 AEA ( aea fetch fetchai/simple_buyer_aw2 ) from the AEA-registry and extend it to be a buyer for the above use-case. Then push it to the AEA-registry. (There is no need to run it at this point.) Fill in the following form, providing your developer handle and uploaded AEAs: Complete this form .","title":"How to qualify for incentive rewards?"},{"location":"i_nets/quickstart-aw3/","text":"Introduction: Agent World 3 (AW-3) - part 3, \"Many agents interacting\" Note AW-3 has finished now! Agent World 3 (AW-3) is the third part of our agent-themed incentivised testnet. It allows anyone with FET tokens to gain additional FET by re-using and adapting agents from AW-2 in order to further grow the useful population of agents. This is open to a broader range of developers, including those just starting out: it's always easier to modify an existing agent than create a new one, and AW-3 makes available all the agents from AW-2 for all to work with via the agent registry. Rewards The following table shows the incentive rewards on offer. Leaderboard Rank Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) 1st variable from trade 15,000 n/a 2nd variable from trade 10,000 n/a 3rd variable from trade 8,000 n/a 4th, 5th, 6th variable from trade 5,000 n/a 7th to 10th variable from trade 2,500 n/a 11th to 20th variable from trade 1,000 n/a Special category Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Most descriptive AEA registration on SOEF variable from trade 500 10 Most individual agents trading variable from trade 1,000 10 Fetch.ai reserve the right to increase the award pool for AW-3 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations. How to qualify for incentive rewards? Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Then upgrade your AEA using aea upgrade from within the project or follow the instructions here . Fetch a seller AEA built during AW-2 from the AEA-registry and give it a suitable name: Run aea fetch PUBLIC_ID --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. After fetching it, enter the project: cd YOUR_AEA_NAME Then install its third-party dependencies: aea install You can take any of your own PUBLIC_IDs or one from this list which is compatible with Agent World 2. We did not verify the individual projects and take no responsibility for them working. (You have the option to create your own following the AW-2 guide .) Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Configure or customize the AEA. The following requirements must be satisfied (same as AW-2) for the seller AEA: Agent must sell data offered by some public API. The data must be related to mobility or weather. The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). Agent must sell data following the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF (advertisement must include correct classification and public id of agent) Payment must be via a simple transfer on the incentivized testnet. Run agent and sell as much data to one of our buyer agents as possible. Note The competition is open until 3rd December 2020 11:59pm, anywhere on Earth. Fetch.ai's buyer agents occur randomly in one of the following locations and at random times throughout the competition. City Latitude Longitude Berlin 52.5200 13.4050 London 51.5074 -0.1278 San Francisco 37.7749 -122.4194 Shanghai 31.2304 121.4737 Rome 41.9028 12.4964 Rio De Janeiro -22.9068 -43.1729 Sydney -33.8688 151.2093 Delhi 28.7041 77.1025 Tokyo 35.6762 139.6503 Mexico City 19.4326 -99.1332 Cairo 30.0444 31.2357 Kinshasa -4.4419 15.2663 The buyer agents only purchase from registered agents (see AW-1 ). The buyer agents only purchase from agents which follow the requirements in step 3. The buyer agents update the leaderboard regularly. The leaderboard determines the winning developer (see table above). Optionally, provide feedback on AW-3 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Note You can maximize your chances of winning by running many agents (each agent must have its own private key and be registered for AW-1) and ensuring that each agent offers both data services.","title":"Agent World 3"},{"location":"i_nets/quickstart-aw3/#introduction-agent-world-3-aw-3-part-3-many-agents-interacting","text":"Note AW-3 has finished now! Agent World 3 (AW-3) is the third part of our agent-themed incentivised testnet. It allows anyone with FET tokens to gain additional FET by re-using and adapting agents from AW-2 in order to further grow the useful population of agents. This is open to a broader range of developers, including those just starting out: it's always easier to modify an existing agent than create a new one, and AW-3 makes available all the agents from AW-2 for all to work with via the agent registry.","title":"Introduction: Agent World 3 (AW-3) - part 3, \"Many agents interacting\""},{"location":"i_nets/quickstart-aw3/#rewards","text":"The following table shows the incentive rewards on offer. Leaderboard Rank Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) 1st variable from trade 15,000 n/a 2nd variable from trade 10,000 n/a 3rd variable from trade 8,000 n/a 4th, 5th, 6th variable from trade 5,000 n/a 7th to 10th variable from trade 2,500 n/a 11th to 20th variable from trade 1,000 n/a Special category Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Most descriptive AEA registration on SOEF variable from trade 500 10 Most individual agents trading variable from trade 1,000 10 Fetch.ai reserve the right to increase the award pool for AW-3 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations.","title":"Rewards"},{"location":"i_nets/quickstart-aw3/#how-to-qualify-for-incentive-rewards","text":"Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Then upgrade your AEA using aea upgrade from within the project or follow the instructions here . Fetch a seller AEA built during AW-2 from the AEA-registry and give it a suitable name: Run aea fetch PUBLIC_ID --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. After fetching it, enter the project: cd YOUR_AEA_NAME Then install its third-party dependencies: aea install You can take any of your own PUBLIC_IDs or one from this list which is compatible with Agent World 2. We did not verify the individual projects and take no responsibility for them working. (You have the option to create your own following the AW-2 guide .) Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Configure or customize the AEA. The following requirements must be satisfied (same as AW-2) for the seller AEA: Agent must sell data offered by some public API. The data must be related to mobility or weather. The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). Agent must sell data following the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF (advertisement must include correct classification and public id of agent) Payment must be via a simple transfer on the incentivized testnet. Run agent and sell as much data to one of our buyer agents as possible. Note The competition is open until 3rd December 2020 11:59pm, anywhere on Earth. Fetch.ai's buyer agents occur randomly in one of the following locations and at random times throughout the competition. City Latitude Longitude Berlin 52.5200 13.4050 London 51.5074 -0.1278 San Francisco 37.7749 -122.4194 Shanghai 31.2304 121.4737 Rome 41.9028 12.4964 Rio De Janeiro -22.9068 -43.1729 Sydney -33.8688 151.2093 Delhi 28.7041 77.1025 Tokyo 35.6762 139.6503 Mexico City 19.4326 -99.1332 Cairo 30.0444 31.2357 Kinshasa -4.4419 15.2663 The buyer agents only purchase from registered agents (see AW-1 ). The buyer agents only purchase from agents which follow the requirements in step 3. The buyer agents update the leaderboard regularly. The leaderboard determines the winning developer (see table above). Optionally, provide feedback on AW-3 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Note You can maximize your chances of winning by running many agents (each agent must have its own private key and be registered for AW-1) and ensuring that each agent offers both data services.","title":"How to qualify for incentive rewards?"},{"location":"i_nets/quickstart-aw4/","text":"Introduction: Agent World 4 (AW-4) - part 4, \"Many agents interacting\" Note AW-4 is live now! It closes on 28th February 2021 11:59pm, anywhere on Earth Agent World 4 (AW-4) is the fourth part of our agent-themed incentivised testnet. It allows anyone with FET tokens to gain additional FET by re-using and adapting agents from AW-2/3 in order to continuously have a large population of agents live and engage in exchange. Rewards The following table shows the incentive rewards on offer. Leaderboard Rank Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) 1st variable from trade 3,000 n/a 2nd variable from trade 2,000 n/a 3rd variable from trade 1,000 n/a 4th to 10th variable from trade 500 n/a Activity Reward Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Keep one agent online for one day variable from trade 0.1 5000 rewarded activities per day Per one transaction of an active agent variable from trade 0.1 5000 rewarded activities per day Fetch.ai reserve the right to increase the award pool for AW-4 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations. How to qualify for incentive rewards? Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Fetch a seller AEA built during AW-2/3 from the AEA-registry and give it a suitable name: Run aea fetch PUBLIC_ID --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. You can take any of your own public IDs or one from this list which is compatible with Agent World 2. We did not verify the individual projects and take no responsibility for them working. (You have the option to create your own following the AW-2 guide .) After fetching it, enter the project: cd YOUR_AEA_NAME Note If you are using an AEA which has been developed for a version of the AEA framework lower than 0.9.0 then please follow these steps to upgrade it: Run aea upgrade from within your AEA project. If you have any errors during this step then please log them as a GitHub issue and reach out on Discord. Additional instructions can be found here . Update the configuration of the p2p connection by running aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config '{\"delegate_uri\": null, \"entry_peers\": [\"/dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW\"], \"public_uri\": null}' from within your AEA project. If you are unsuccessful in upgrading your AEA then we suggest starting with a fresh AEA as described in the AW-2 guide . Then install its third-party dependencies: aea install Then run aea build from within your AEA project to build its dependencies. Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Configure or customize the AEA. The following requirements must be satisfied for the seller AEA (look at fetchai/simple_seller_aw2 for an example): Agent must sell data offered by some public API. The data must be related to mobility or weather. The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). The agent must have a classification with piece classification and value seller and a personality_data with piece genus and value data . Agent must sell data following the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF (advertisement must include correct classification and public id of agent) Payment must be via a simple transfer on the incentivized testnet. Run agent and sell as much data to one of our buyer agents as possible. Note The competition is open until 28th February 2021 11:59pm, anywhere on Earth. Fetch.ai's buyer agents occur randomly in one of the following locations and at random times throughout the competition. City Latitude Longitude Berlin 52.5200 13.4050 London 51.5074 -0.1278 San Francisco 37.7749 -122.4194 Shanghai 31.2304 121.4737 Rome 41.9028 12.4964 Rio De Janeiro -22.9068 -43.1729 Sydney -33.8688 151.2093 Delhi 28.7041 77.1025 Tokyo 35.6762 139.6503 Mexico City 19.4326 -99.1332 Cairo 30.0444 31.2357 Kinshasa -4.4419 15.2663 The buyer agents only purchase from registered agents (see AW-1 ). The buyer agents only purchase from agents which follow the requirements in step 3. The buyer agents update the leaderboard regularly. The leaderboard determines the winning developer (see table above). Optionally, provide feedback on AW-4 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Note You can maximize your chances of winning by running many agents (each agent must have its own private key and be registered for AW-1) and ensuring that each agent offers both data services.","title":"Agent World 4"},{"location":"i_nets/quickstart-aw4/#introduction-agent-world-4-aw-4-part-4-many-agents-interacting","text":"Note AW-4 is live now! It closes on 28th February 2021 11:59pm, anywhere on Earth Agent World 4 (AW-4) is the fourth part of our agent-themed incentivised testnet. It allows anyone with FET tokens to gain additional FET by re-using and adapting agents from AW-2/3 in order to continuously have a large population of agents live and engage in exchange.","title":"Introduction: Agent World 4 (AW-4) - part 4, \"Many agents interacting\""},{"location":"i_nets/quickstart-aw4/#rewards","text":"The following table shows the incentive rewards on offer. Leaderboard Rank Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) 1st variable from trade 3,000 n/a 2nd variable from trade 2,000 n/a 3rd variable from trade 1,000 n/a 4th to 10th variable from trade 500 n/a Activity Reward Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first serve) Keep one agent online for one day variable from trade 0.1 5000 rewarded activities per day Per one transaction of an active agent variable from trade 0.1 5000 rewarded activities per day Fetch.ai reserve the right to increase the award pool for AW-4 to reward additional agent developers, or to award specific spot rewards to particularly innovative creations.","title":"Rewards"},{"location":"i_nets/quickstart-aw4/#how-to-qualify-for-incentive-rewards","text":"Note You must complete AW-1 before continuing! You have to complete a few steps as listed below: Make sure you use the latest AEA framework version . To upgrade from an older version use pip install --upgrade aea[all] . Fetch a seller AEA built during AW-2/3 from the AEA-registry and give it a suitable name: Run aea fetch PUBLIC_ID --alias YOUR_AEA_NAME , where YOUR_AEA_NAME is replaced with a name of your choice. You can take any of your own public IDs or one from this list which is compatible with Agent World 2. We did not verify the individual projects and take no responsibility for them working. (You have the option to create your own following the AW-2 guide .) After fetching it, enter the project: cd YOUR_AEA_NAME Note If you are using an AEA which has been developed for a version of the AEA framework lower than 0.9.0 then please follow these steps to upgrade it: Run aea upgrade from within your AEA project. If you have any errors during this step then please log them as a GitHub issue and reach out on Discord. Additional instructions can be found here . Update the configuration of the p2p connection by running aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config '{\"delegate_uri\": null, \"entry_peers\": [\"/dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW\"], \"public_uri\": null}' from within your AEA project. If you are unsuccessful in upgrading your AEA then we suggest starting with a fresh AEA as described in the AW-2 guide . Then install its third-party dependencies: aea install Then run aea build from within your AEA project to build its dependencies. Ensure you use the private key from AW1. Generate a new key and add it to the AEA: aea generate-key fetchai and aea add-key fetchai Manually replace the private key you just generated in fetchai_private_key.txt with the one from AW-1. Check everything works by running aea get-address fetchai and confirming that the address matches the one you hold Agent World funds on. (This can be done by viewing the address on the block explorer or by typing aea get-wealth fetchai ). Create a proof of representation for communication on the ACN : Run aea generate-key fetchai fetchai_connnection_private_key.txt and aea add-key fetchai fetchai_connnection_private_key.txt --connection to add a key pair for your AEA to secure its communications with. Now associate this key pair with the one you use for transacting by executing aea issue-certificates . Configure or customize the AEA. The following requirements must be satisfied for the seller AEA (look at fetchai/simple_seller_aw2 for an example): Agent must sell data offered by some public API. The data must be related to mobility or weather. The advertisement must include the correct service key ( seller_service ) and value (one of weather_data or mobility_data , depending on the data your agent is offering). The agent must have a classification with piece classification and value seller and a personality_data with piece genus and value data . Agent must sell data following the fipa protocol ( fetchai/fipa ) and advertise it using oef search protocol ( fetchai/oef_search ) on the SOEF (advertisement must include correct classification and public id of agent) Payment must be via a simple transfer on the incentivized testnet. Run agent and sell as much data to one of our buyer agents as possible. Note The competition is open until 28th February 2021 11:59pm, anywhere on Earth. Fetch.ai's buyer agents occur randomly in one of the following locations and at random times throughout the competition. City Latitude Longitude Berlin 52.5200 13.4050 London 51.5074 -0.1278 San Francisco 37.7749 -122.4194 Shanghai 31.2304 121.4737 Rome 41.9028 12.4964 Rio De Janeiro -22.9068 -43.1729 Sydney -33.8688 151.2093 Delhi 28.7041 77.1025 Tokyo 35.6762 139.6503 Mexico City 19.4326 -99.1332 Cairo 30.0444 31.2357 Kinshasa -4.4419 15.2663 The buyer agents only purchase from registered agents (see AW-1 ). The buyer agents only purchase from agents which follow the requirements in step 3. The buyer agents update the leaderboard regularly. The leaderboard determines the winning developer (see table above). Optionally, provide feedback on AW-4 to improve the AEA framework and the Agent World incentivized testnet programme. Please complete our survey here . Note You can maximize your chances of winning by running many agents (each agent must have its own private key and be registered for AW-1) and ensuring that each agent offers both data services.","title":"How to qualify for incentive rewards?"},{"location":"i_nets/quickstart-bw1/","text":"Introduction: Beacon World 1 (BW-1) - part 1, Getting started with Staking and Governance Note BW-1 is live now! Beacon-world 1 (BW-1) is the second stage of our program for testing the Fetch.ai blockchain and for preparing our community for the launch of our v2.0 main-net. The goal of BW-1 is to reward users and potential validators for gaining experience with the software ecosystem around the main-network. These tasks don't require any technical knowledge or programming experience; all you need is an interest in Fetch.ai and a willingness to help shape its future direction. Rewards The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first served) Steps 1 - 4 below 100 100 300 A key responsibility of validators, developers and users is that they take part in decisions on the future directions of the project. The way that these decisions are made is known as governance and is a key element of decentralised networks. The Fetch.ai ledger uses a simple governance mechanism that was first used by Bitcoin , where a majority of miners have to make a decision on whether to perform a specific software upgrade to the network. Note To qualify for rewards, users must first stake FET ERC20 tokens on Ethereum. While not strictly necessary we also encourage people who have not already done so to try out at least the [AW-1](./quickstart-aw1/) challenge. How To Earn Rewards To earn rewards, users must complete the following tasks, which are designed to familiarise them with the tools used for sending transactions, delegating stake and voting on governance proposals. The general flow is as follows: Create a test-net address and link this to their Ethereum staking address (anyone who has completed the AW-1 task can skip this step). Send a transaction on the test-net. Delegate stake to one of the validators on the test-net. Vote on at least one governance proposal. We recommend that everyone joins our discord channel here , as this is the quickest way to answer any questions and receive support from the team and the rest of the community. There are technical and community tracks for interacting with the BW-1 test-net. We recommend that developers or anyone who is interested in running a validator node follow the technical track while non-technical users should follow the community track. Please note that a ledger nano hardware wallet is required for the community track. It's possible to follow the steps in both tracks but only one reward is available for each Ethereum staking address that is registered. Community (Non-Technical) Track Non-technical users should follow these steps: Install the Cosmos app on your Ledger nano by following these instructions . Connect your Ledger nano to the block explorer using the instructions here . Request tokens to your Ledger nano address using the token faucet . Sign the test-net address where you requested tokens in step 3 with the private key tied to your FET account on the Ethereum mainnet (this is the account you use for FET staking): We recommend you use our signing app with your MetaMask wallet, alternatively use MEW or a similar wallet to sign your Fetch.ai test-net address. To complete registration, send a transaction of 0.01 FET to this address: fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf but make sure that you add the Ethereum address you used for staking tokens in the \"memo\" field. Send a second transaction of 0.01 FET to the same address but this time add the signature in the \"memo\" field that you generated in step 4. Delegate Stake to any of the validators using the instructions here . Vote on at least one governance proposal. Technical Track Anyone interested in developing agents or operating a validator node should follow these steps: Obtain a working copy of the ledger v0.2.x software by checking out and building it from source. Import a private key from AW-1 into the fetchcli following these instructions . You can check the balance of your account by typing fetchcli query account <YOUR_ACCOUNT_ADDRESS> where <YOUR_ACCOUNT_ADDRESS> is in bech32 format and contains a fetch1... prefix. Check out the documentation for extra information Delegate some of your stake to the one of the existing validators that are running following these instructions . The full list of validators can be found on the block explorer but the table at the bottom of this page shows these for convenience. Vote on at least one governance proposal following these instructions . Validator Operator Address Bond fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 Bourne fetchvaloper12xd8rgp2u0cwp8lnj2ndulpzad3y9m9f2r8lsx Hunt fetchvaloper1vf5wsxjkmjk4uv3nm2zjplw0y2f96rsjw8k7gv Powers fetchvaloper108hhutnylgz09acca2ljde8dp6huhsu67hn8v7","title":"Beacon World 1"},{"location":"i_nets/quickstart-bw1/#introduction-beacon-world-1-bw-1-part-1-getting-started-with-staking-and-governance","text":"Note BW-1 is live now! Beacon-world 1 (BW-1) is the second stage of our program for testing the Fetch.ai blockchain and for preparing our community for the launch of our v2.0 main-net. The goal of BW-1 is to reward users and potential validators for gaining experience with the software ecosystem around the main-network. These tasks don't require any technical knowledge or programming experience; all you need is an interest in Fetch.ai and a willingness to help shape its future direction.","title":"Introduction: Beacon World 1 (BW-1) - part 1, Getting started with Staking and Governance"},{"location":"i_nets/quickstart-bw1/#rewards","text":"The following table shows the incentive rewards on offer. Action Test FET (on Agent World) FET (on Ethereum mainnet) Cap (first come first served) Steps 1 - 4 below 100 100 300 A key responsibility of validators, developers and users is that they take part in decisions on the future directions of the project. The way that these decisions are made is known as governance and is a key element of decentralised networks. The Fetch.ai ledger uses a simple governance mechanism that was first used by Bitcoin , where a majority of miners have to make a decision on whether to perform a specific software upgrade to the network. Note To qualify for rewards, users must first stake FET ERC20 tokens on Ethereum. While not strictly necessary we also encourage people who have not already done so to try out at least the [AW-1](./quickstart-aw1/) challenge.","title":"Rewards"},{"location":"i_nets/quickstart-bw1/#how-to-earn-rewards","text":"To earn rewards, users must complete the following tasks, which are designed to familiarise them with the tools used for sending transactions, delegating stake and voting on governance proposals. The general flow is as follows: Create a test-net address and link this to their Ethereum staking address (anyone who has completed the AW-1 task can skip this step). Send a transaction on the test-net. Delegate stake to one of the validators on the test-net. Vote on at least one governance proposal. We recommend that everyone joins our discord channel here , as this is the quickest way to answer any questions and receive support from the team and the rest of the community. There are technical and community tracks for interacting with the BW-1 test-net. We recommend that developers or anyone who is interested in running a validator node follow the technical track while non-technical users should follow the community track. Please note that a ledger nano hardware wallet is required for the community track. It's possible to follow the steps in both tracks but only one reward is available for each Ethereum staking address that is registered.","title":"How To Earn Rewards"},{"location":"i_nets/quickstart-bw1/#community-non-technical-track","text":"Non-technical users should follow these steps: Install the Cosmos app on your Ledger nano by following these instructions . Connect your Ledger nano to the block explorer using the instructions here . Request tokens to your Ledger nano address using the token faucet . Sign the test-net address where you requested tokens in step 3 with the private key tied to your FET account on the Ethereum mainnet (this is the account you use for FET staking): We recommend you use our signing app with your MetaMask wallet, alternatively use MEW or a similar wallet to sign your Fetch.ai test-net address. To complete registration, send a transaction of 0.01 FET to this address: fetch1a3ecdm538yt4xlz6kc39xf0h3syge0mlrr0jgf but make sure that you add the Ethereum address you used for staking tokens in the \"memo\" field. Send a second transaction of 0.01 FET to the same address but this time add the signature in the \"memo\" field that you generated in step 4. Delegate Stake to any of the validators using the instructions here . Vote on at least one governance proposal.","title":"Community (Non-Technical) Track"},{"location":"i_nets/quickstart-bw1/#technical-track","text":"Anyone interested in developing agents or operating a validator node should follow these steps: Obtain a working copy of the ledger v0.2.x software by checking out and building it from source. Import a private key from AW-1 into the fetchcli following these instructions . You can check the balance of your account by typing fetchcli query account <YOUR_ACCOUNT_ADDRESS> where <YOUR_ACCOUNT_ADDRESS> is in bech32 format and contains a fetch1... prefix. Check out the documentation for extra information Delegate some of your stake to the one of the existing validators that are running following these instructions . The full list of validators can be found on the block explorer but the table at the bottom of this page shows these for convenience. Vote on at least one governance proposal following these instructions . Validator Operator Address Bond fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 Bourne fetchvaloper12xd8rgp2u0cwp8lnj2ndulpzad3y9m9f2r8lsx Hunt fetchvaloper1vf5wsxjkmjk4uv3nm2zjplw0y2f96rsjw8k7gv Powers fetchvaloper108hhutnylgz09acca2ljde8dp6huhsu67hn8v7","title":"Technical Track"},{"location":"ledger/","text":"Mainnet v2 is approaching Fetch.ai are preparing for mainnet v2 with a series of incentivized testnets. To familiarise yourself with the new ledger architecture go here . The v1 ledger docs are available here . At this point we recommend building on v2.","title":"Introduction"},{"location":"ledger_v1/","text":"Out of date! Ledger v1 is being phased out. Please consult v2 documentation. Fetch.ai ledger The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below. Increased rate of transactions per second The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here . Custom consensus algorithm The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper . Support for on-chain ML and AI operations Coming soon.","title":"Introduction"},{"location":"ledger_v1/#fetchai-ledger","text":"The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below.","title":"Fetch.ai ledger"},{"location":"ledger_v1/#increased-rate-of-transactions-per-second","text":"The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here .","title":"Increased rate of transactions per second"},{"location":"ledger_v1/#custom-consensus-algorithm","text":"The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper .","title":"Custom consensus algorithm"},{"location":"ledger_v1/#support-for-on-chain-ml-and-ai-operations","text":"Coming soon.","title":"Support for on-chain ML and AI operations"},{"location":"ledger_v1/architecture/","text":"Architecture This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct. Sharding In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load. HTTP pages and API Note Coming soon Networking Note Coming soon","title":"Architecture"},{"location":"ledger_v1/architecture/#architecture","text":"This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct.","title":"Architecture"},{"location":"ledger_v1/architecture/#sharding","text":"In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load.","title":"Sharding"},{"location":"ledger_v1/architecture/#http-pages-and-api","text":"Note Coming soon","title":"HTTP pages and API"},{"location":"ledger_v1/architecture/#networking","text":"Note Coming soon","title":"Networking"},{"location":"ledger_v1/maths-lib-overview/","text":"etch mathematics and machine learning operations are supported by a header-only fully-templated C++ library. Detailed developer documentation for the C++ implementation of the maths libraries will be available in the Fetch Ledger section in due course. Developers should be comfortable with SFINAE. Architecture A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress. Tensor A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here . Working with the maths library When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Maths library"},{"location":"ledger_v1/maths-lib-overview/#architecture","text":"A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress.","title":"Architecture"},{"location":"ledger_v1/maths-lib-overview/#tensor","text":"A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here .","title":"Tensor"},{"location":"ledger_v1/maths-lib-overview/#working-with-the-maths-library","text":"When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Working with the maths library"},{"location":"ledger_v1/running-a-constellation/","text":"Local node From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Connect to a node on testnet From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet Compiler flags The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Running a node"},{"location":"ledger_v1/running-a-constellation/#local-node","text":"From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents.","title":"Local node"},{"location":"ledger_v1/running-a-constellation/#connect-to-a-node-on-testnet","text":"From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet","title":"Connect to a node on testnet"},{"location":"ledger_v1/running-a-constellation/#compiler-flags","text":"The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Compiler flags"},{"location":"ledger_v1/etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai Ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.ai Ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Design and test your smart contract code with the etch VM simulator before including it in a Python Ledger API script which takes care of deployment and other details. Find out how to run smart contract code with the Python Ledger API here . Note The `etch` language and the `etch` language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"Introduction"},{"location":"ledger_v1/etch-language/addresses/","text":"Address type format The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) . Create an Address function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Type size in detail There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address ) SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready. Print Address Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Address"},{"location":"ledger_v1/etch-language/addresses/#address-type-format","text":"The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) .","title":"Address type format"},{"location":"ledger_v1/etch-language/addresses/#create-an-address","text":"function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction","title":"Create an Address"},{"location":"ledger_v1/etch-language/addresses/#type-size-in-detail","text":"There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address )","title":"Type size in detail"},{"location":"ledger_v1/etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"ledger_v1/etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"ledger_v1/etch-language/addresses/#print-address","text":"Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Print Address"},{"location":"ledger_v1/etch-language/arrays/","text":"Arrays One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction Two dimensional arrays Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction Array functions Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction Pop back and front with n Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"ledger_v1/etch-language/arrays/#arrays","text":"","title":"Arrays"},{"location":"ledger_v1/etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction","title":"One dimensional arrays"},{"location":"ledger_v1/etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"ledger_v1/etch-language/arrays/#nested-arrays","text":"etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction","title":"Nested arrays"},{"location":"ledger_v1/etch-language/arrays/#array-functions","text":"","title":"Array functions"},{"location":"ledger_v1/etch-language/arrays/#count","text":"The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction","title":"Count"},{"location":"ledger_v1/etch-language/arrays/#append","text":"The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Append"},{"location":"ledger_v1/etch-language/arrays/#extend","text":"Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction","title":"Extend"},{"location":"ledger_v1/etch-language/arrays/#pop-back-and-pop-front","text":"The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction","title":"Pop back and pop front"},{"location":"ledger_v1/etch-language/arrays/#pop-back-and-front-with-n","text":"Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction","title":"Pop back and front with n"},{"location":"ledger_v1/etch-language/arrays/#reverse","text":"The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Reverse"},{"location":"ledger_v1/etch-language/arrays/#erase","text":"Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Erase"},{"location":"ledger_v1/etch-language/balance-transfer/","text":"Like Context , Block , and Transaction , the balance and transfer functions must run against a Fetch.ai Ledger node. balance() The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear transfer(target : Address, amount : UInt64) The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear Example Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here . etch smart contract code The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other. Python Ledger API wrapper code from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Balance and Transfer"},{"location":"ledger_v1/etch-language/balance-transfer/#balance","text":"The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear","title":"balance()"},{"location":"ledger_v1/etch-language/balance-transfer/#transfertarget-address-amount-uint64","text":"The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear","title":"transfer(target : Address, amount : UInt64)"},{"location":"ledger_v1/etch-language/balance-transfer/#example","text":"Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here .","title":"Example"},{"location":"ledger_v1/etch-language/balance-transfer/#etch-smart-contract-code","text":"The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other.","title":"etch smart contract code"},{"location":"ledger_v1/etch-language/balance-transfer/#python-ledger-api-wrapper-code","text":"from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Python Ledger API wrapper code"},{"location":"ledger_v1/etch-language/context/","text":"Context is an etch language type that provides access to currently invoking ledger transaction data - such as block and transaction information - coming from smart contracts running against ledger nodes. Specific annotated functions Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node. Coding with Context Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. getContext() , block() , and blockNumber() To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); Example The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Context"},{"location":"ledger_v1/etch-language/context/#specific-annotated-functions","text":"Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node.","title":"Specific annotated functions"},{"location":"ledger_v1/etch-language/context/#coding-with-context","text":"Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates.","title":"Coding with Context"},{"location":"ledger_v1/etch-language/context/#getcontext-block-and-blocknumber","text":"To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber ();","title":"getContext(), block(), and blockNumber()"},{"location":"ledger_v1/etch-language/context/#example","text":"The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Example"},{"location":"ledger_v1/etch-language/control-flow/","text":"Control flow Tip Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"ledger_v1/etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction","title":"if-else"},{"location":"ledger_v1/etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"ledger_v1/etch-language/control-flow/#for","text":"function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction","title":"for"},{"location":"ledger_v1/etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"ledger_v1/etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"ledger_v1/etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings and applying them to the SHA256() object. The example then resets the object and repeats the process with three more strings. function main () var my_string_value_1 = \"sdkjfhiuwehfesdfno ; s ; ' mADF ; LK \"; var my_string_value_2 = \"ipoiuwr8934jklnwlkj0892;m\" ; var my_string_value_3 = \"vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548\" ; // create a SHA256() context object var sha256_hash = SHA256 (); // give it your strings sha256_hash . update ( my_string_value_1 ); sha256_hash . update ( my_string_value_2 ); sha256_hash . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 1,2,3 = \" + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hash . reset (); // more strings var my_string_value_4 = \"12345fg\" ; var my_string_value_5 = \"@!#$@#%#\" ; var my_string_value_6 = \"{}:>L$%^:c\" ; // add to context sha256_hash . update ( my_string_value_4 ); sha256_hash . update ( my_string_value_5 ); sha256_hash . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 4,5,6 = \" + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"ledger_v1/etch-language/data-loaders/","text":"A DataLoader is an object used by an Optimiser for loading data into a Graph . Usually this data is a pair of Tensor types (data and label). Declare and initialise a DataLoader giving a string parameter which defines the type of input data. The common generic DataLoader takes Tensor objects. function main () var dataLoader = DataLoader ( \"tensor\" ); endfunction There are currently three flavours of DataLoader in etch . Fetch.ai developers have built specific DataLoader types for research and example purposes that take MNIST files, and csv files for a commodity application. Tensor data loader Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction isDone() and getNext() DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction Serialisation A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"DataLoader"},{"location":"ledger_v1/etch-language/data-loaders/#tensor-data-loader","text":"Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction","title":"Tensor data loader"},{"location":"ledger_v1/etch-language/data-loaders/#isdone-and-getnext","text":"DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction","title":"isDone() and getNext()"},{"location":"ledger_v1/etch-language/data-loaders/#serialisation","text":"A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"Serialisation"},{"location":"ledger_v1/etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the `etch` compiler will strip out `printLn()` statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 -30 - g557389e0 T C Copyright 2018-2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"ledger_v1/etch-language/debug/#compiling","text":"Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope.","title":"Compiling"},{"location":"ledger_v1/etch-language/debug/#system-arguments","text":"System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 -30 - g557389e0 T C Copyright 2018-2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"System arguments"},{"location":"ledger_v1/etch-language/error-checking/","text":"The following functions help with diagnosing bugs and ensuring the correct state of variables and boolean tests. Panic Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != -1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction Assert Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"ledger_v1/etch-language/error-checking/#panic","text":"Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != -1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Panic"},{"location":"ledger_v1/etch-language/error-checking/#assert","text":"Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Assert"},{"location":"ledger_v1/etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n -1 ) + fibonacci ( n -2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array<Int32>(3); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv() Type casting toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here . Getters and setters Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Functions"},{"location":"ledger_v1/etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"ledger_v1/etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"ledger_v1/etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n -1 ) + fibonacci ( n -2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"ledger_v1/etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array<Int32>(3); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"ledger_v1/etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"ledger_v1/etch-language/functions/#print","text":"printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards.","title":"Print"},{"location":"ledger_v1/etch-language/functions/#sysargs","text":"The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv()","title":"Sysargs"},{"location":"ledger_v1/etch-language/functions/#type-casting","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction","title":"Type casting"},{"location":"ledger_v1/etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here .","title":"Annotations"},{"location":"ledger_v1/etch-language/functions/#getters-and-setters","text":"Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Getters and setters"},{"location":"ledger_v1/etch-language/getstarted/","text":"Getting started Prerequisites To build with Etch, you will need a running node. Installation At the root of your ledger installation directory cd into build folder. Run make etch . Setup At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract. Hello world with Etch Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Compile and run two or more etch files It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch . Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Getting started"},{"location":"ledger_v1/etch-language/getstarted/#getting-started","text":"","title":"Getting started"},{"location":"ledger_v1/etch-language/getstarted/#prerequisites","text":"To build with Etch, you will need a running node.","title":"Prerequisites"},{"location":"ledger_v1/etch-language/getstarted/#installation","text":"At the root of your ledger installation directory cd into build folder. Run make etch .","title":"Installation"},{"location":"ledger_v1/etch-language/getstarted/#setup","text":"At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"ledger_v1/etch-language/getstarted/#hello-world-with-etch","text":"Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with Etch"},{"location":"ledger_v1/etch-language/getstarted/#compile-and-run-two-or-more-etch-files","text":"It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch .","title":"Compile and run two or more etch files"},{"location":"ledger_v1/etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"ledger_v1/etch-language/graph/","text":"Declare and initialise a Graph . function main () var graph = Graph (); endfunction A Graph is a directed acyclic computational graph used to process data through a sequence of operations. The current primary use case for these is the instantiation of neural networks. Each node in the Graph maintains responsibility for either a single operation or a layer of operations. The preferred method for training a Graph is to use a DataLoader and Optimiser . We describe these two objects in a later section. Placeholders Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction Layers Fully connected Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction 1D convolution The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction Operations Activations ReLU The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction Softmax The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction Dropout The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction Transpose The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction Exp The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction Loss functions Cross entropy loss The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction Mean square error loss The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction Serialisation For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction Serialise to string It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction Deserialise from string Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction Build a Graph example The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction Training a Graph example Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section. 1. Set input Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction 2. Evaluate The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction 3. Back propagate Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction 4. Step Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"Graph"},{"location":"ledger_v1/etch-language/graph/#placeholders","text":"Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction","title":"Placeholders"},{"location":"ledger_v1/etch-language/graph/#layers","text":"","title":"Layers"},{"location":"ledger_v1/etch-language/graph/#fully-connected","text":"Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction","title":"Fully connected"},{"location":"ledger_v1/etch-language/graph/#1d-convolution","text":"The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction","title":"1D convolution"},{"location":"ledger_v1/etch-language/graph/#operations","text":"","title":"Operations"},{"location":"ledger_v1/etch-language/graph/#activations","text":"","title":"Activations"},{"location":"ledger_v1/etch-language/graph/#relu","text":"The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction","title":"ReLU"},{"location":"ledger_v1/etch-language/graph/#softmax","text":"The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction","title":"Softmax"},{"location":"ledger_v1/etch-language/graph/#dropout","text":"The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction","title":"Dropout"},{"location":"ledger_v1/etch-language/graph/#transpose","text":"The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction","title":"Transpose"},{"location":"ledger_v1/etch-language/graph/#exp","text":"The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction","title":"Exp"},{"location":"ledger_v1/etch-language/graph/#loss-functions","text":"","title":"Loss functions"},{"location":"ledger_v1/etch-language/graph/#cross-entropy-loss","text":"The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction","title":"Cross entropy loss"},{"location":"ledger_v1/etch-language/graph/#mean-square-error-loss","text":"The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction","title":"Mean square error loss"},{"location":"ledger_v1/etch-language/graph/#serialisation","text":"For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction","title":"Serialisation"},{"location":"ledger_v1/etch-language/graph/#serialise-to-string","text":"It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction","title":"Serialise to string"},{"location":"ledger_v1/etch-language/graph/#deserialise-from-string","text":"Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction","title":"Deserialise from string"},{"location":"ledger_v1/etch-language/graph/#build-a-graph-example","text":"The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction","title":"Build a Graph example"},{"location":"ledger_v1/etch-language/graph/#training-a-graph-example","text":"Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section.","title":"Training a Graph example"},{"location":"ledger_v1/etch-language/graph/#1-set-input","text":"Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction","title":"1. Set input"},{"location":"ledger_v1/etch-language/graph/#2-evaluate","text":"The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction","title":"2. Evaluate"},{"location":"ledger_v1/etch-language/graph/#3-back-propagate","text":"Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction","title":"3. Back propagate"},{"location":"ledger_v1/etch-language/graph/#4-step","text":"Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"4. Step"},{"location":"ledger_v1/etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Xor Note Coming soon: support for `xor`.","title":"Logical operators"},{"location":"ledger_v1/etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction","title":"Equal to"},{"location":"ledger_v1/etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction","title":"Not equal to"},{"location":"ledger_v1/etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction","title":"Less than"},{"location":"ledger_v1/etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction","title":"More than"},{"location":"ledger_v1/etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"And"},{"location":"ledger_v1/etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"Or"},{"location":"ledger_v1/etch-language/logic/#xor","text":"Note Coming soon: support for `xor`.","title":"Xor"},{"location":"ledger_v1/etch-language/maths-functions/","text":"Tip `Fixed64` is the default variable data type used by the `etch` mathematics and machine learning libraries. In the current version, and further to the common mathematical operations provided by the etch language already discussed here , the following functions are available. Absolute value abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = -1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = -1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = -1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = -1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = -1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = -1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = -1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction Exponential function The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction Range restrictions Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range. Special cases Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x) Errors for x \u2208 (-10, 5) Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07 Power The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));` Special cases Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x Errors for x \u2208 (0, 100), y \u2208 (0, 10.5) Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10 Errors for x \u2208 (-10, 10), y \u2208 (-4, 4) Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10 Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction Square root The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction Special cases Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf Errors for x \u2208 (0, 5) Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09 Trigonometry Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Sin special cases Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x) Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Cos special cases Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1 Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Tan special cases Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06 ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction ASin special cases Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x) Errors for x \u2208 (-1, 1) Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09 ACos special cases Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09 ATan special cases Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x) Errors for x \u2208 (-5, 5) Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08 Hyperbolic Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2` SinH special cases Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf Errors for x \u2208 (-5, 5) Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08 CosH special cases Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2` Errors for x \u2208 (-5, 5) Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08 TanH special cases Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))` Errors for x \u2208 (-3, 3) Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09 Hyperbolic ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction ArcSin special cases Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf Errors for x \u2208 (-3, 3) Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08 ArcCos special cases Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN Errors for x \u2208 (1, 3) Fixed32 : average: 8.53834e-06 , max: 6.62567e-05 Errors for x \u2208 (1, 5) Fixed64 : average: 2.37609e-09 , max: 2.28507e-08 ArcTan special cases Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Maths functions"},{"location":"ledger_v1/etch-language/maths-functions/#absolute-value","text":"abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = -1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = -1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = -1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = -1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = -1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = -1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = -1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction","title":"Absolute value"},{"location":"ledger_v1/etch-language/maths-functions/#exponential-function","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction","title":"Exponential function"},{"location":"ledger_v1/etch-language/maths-functions/#range-restrictions","text":"Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range.","title":"Range restrictions"},{"location":"ledger_v1/etch-language/maths-functions/#special-cases","text":"Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x)","title":"Special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-10-5","text":"Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07","title":"Errors for x \u2208 (-10, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#power","text":"The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));`","title":"Power"},{"location":"ledger_v1/etch-language/maths-functions/#special-cases_1","text":"Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x","title":"Special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-0-100-y-0-105","text":"Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10","title":"Errors for x \u2208 (0, 100), y \u2208 (0, 10.5)"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-10-10-y-4-4","text":"Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10","title":"Errors for x \u2208 (-10, 10), y \u2208 (-4, 4)"},{"location":"ledger_v1/etch-language/maths-functions/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction","title":"Random (non deterministic)"},{"location":"ledger_v1/etch-language/maths-functions/#square-root","text":"The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction","title":"Square root"},{"location":"ledger_v1/etch-language/maths-functions/#special-cases_2","text":"Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf","title":"Special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-0-5","text":"Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09","title":"Errors for x \u2208 (0, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#trigonometry","text":"","title":"Trigonometry"},{"location":"ledger_v1/etch-language/maths-functions/#sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction","title":"Sin, Cos, and Tan"},{"location":"ledger_v1/etch-language/maths-functions/#sin-special-cases","text":"Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x)","title":"Sin special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger_v1/etch-language/maths-functions/#cos-special-cases","text":"Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1","title":"Cos special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2_1","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger_v1/etch-language/maths-functions/#tan-special-cases","text":"Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf","title":"Tan special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-pi2-001-pi2-001","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01)"},{"location":"ledger_v1/etch-language/maths-functions/#arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction","title":"ArcSin, ArcCos, and ArcTan"},{"location":"ledger_v1/etch-language/maths-functions/#asin-special-cases","text":"Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x)","title":"ASin special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-1-1","text":"Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger_v1/etch-language/maths-functions/#acos-special-cases","text":"Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN","title":"ACos special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-1-1_1","text":"Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger_v1/etch-language/maths-functions/#atan-special-cases","text":"Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x)","title":"ATan special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-5-5","text":"Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#hyperbolic-sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2`","title":"Hyperbolic Sin, Cos, and Tan"},{"location":"ledger_v1/etch-language/maths-functions/#sinh-special-cases","text":"Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf","title":"SinH special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-5-5_1","text":"Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#cosh-special-cases","text":"Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2`","title":"CosH special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-5-5_2","text":"Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#tanh-special-cases","text":"Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))`","title":"TanH special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-3-3","text":"Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger_v1/etch-language/maths-functions/#hyperbolic-arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Hyperbolic ArcSin, ArcCos, and ArcTan"},{"location":"ledger_v1/etch-language/maths-functions/#arcsin-special-cases","text":"Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf","title":"ArcSin special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-3-3_1","text":"Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger_v1/etch-language/maths-functions/#arccos-special-cases","text":"Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN","title":"ArcCos special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-1-3","text":"Fixed32 : average: 8.53834e-06 , max: 6.62567e-05","title":"Errors for x \u2208 (1, 3)"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-1-5","text":"Fixed64 : average: 2.37609e-09 , max: 2.28507e-08","title":"Errors for x \u2208 (1, 5)"},{"location":"ledger_v1/etch-language/maths-functions/#arctan-special-cases","text":"Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN","title":"ArcTan special cases"},{"location":"ledger_v1/etch-language/maths-functions/#errors-for-x-1-1_2","text":"Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger_v1/etch-language/model/","text":"A Model is the simplest way to build, train, and evaluate neural networks in etch . The Model type takes care of the underlying implementation details for Graph , DataLoader , and Optimiser . There are three types of Model . Sequential : trains a computational graph to predict either continuous variables or classes, and allows more control over the layers of the network. Regressor : trains a computational graph to predict continuous variables. For example, what will be the future price of a particular currency? Classifier : trains a computational graph to predict classes. For example, is this a picture of a cat or a dog? Construct a Model Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction Add Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction Compile Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction Read in input data The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Fit With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction Evaluate Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction Predict Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Model"},{"location":"ledger_v1/etch-language/model/#construct-a-model","text":"Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction","title":"Construct a Model"},{"location":"ledger_v1/etch-language/model/#add","text":"Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction","title":"Add"},{"location":"ledger_v1/etch-language/model/#compile","text":"Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction","title":"Compile"},{"location":"ledger_v1/etch-language/model/#read-in-input-data","text":"The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Read in input data"},{"location":"ledger_v1/etch-language/model/#fit","text":"With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction","title":"Fit"},{"location":"ledger_v1/etch-language/model/#evaluate","text":"Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction","title":"Evaluate"},{"location":"ledger_v1/etch-language/model/#predict","text":"Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Predict"},{"location":"ledger_v1/etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = -42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"ledger_v1/etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = -42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"ledger_v1/etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"ledger_v1/etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"ledger_v1/etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"ledger_v1/etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"ledger_v1/etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"ledger_v1/etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"ledger_v1/etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"ledger_v1/etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"ledger_v1/etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"ledger_v1/etch-language/optimiser/","text":"Use an Optimiser to run the machine learning training on a Graph and a DataLoader . Declare and initialise an Optimiser , giving it the name of the optimisation algorithm you wish to run, the Graph and the DataLoader objects, and the place-holder nodes for the input data, training data, and error data. var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input1\" , \"Input2\" , ...}, \"Label\" , \"Error\" ); To run the Optimiser , call run() with a batch size. Batch size sets the number of samples to train on in an epoch. var loss = optimiser . run ( batch_size ); Adagrad \"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction Adam \"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Momentum \"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... RMSprop \"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... SGD \"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Full optimisation example Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction Reset Graph or DataLoader Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Optimiser"},{"location":"ledger_v1/etch-language/optimiser/#adagrad","text":"\"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction","title":"Adagrad"},{"location":"ledger_v1/etch-language/optimiser/#adam","text":"\"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Adam"},{"location":"ledger_v1/etch-language/optimiser/#momentum","text":"\"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Momentum"},{"location":"ledger_v1/etch-language/optimiser/#rmsprop","text":"\"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"RMSprop"},{"location":"ledger_v1/etch-language/optimiser/#sgd","text":"\"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"SGD"},{"location":"ledger_v1/etch-language/optimiser/#full-optimisation-example","text":"Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction","title":"Full optimisation example"},{"location":"ledger_v1/etch-language/optimiser/#reset-graph-or-dataloader","text":"Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Reset Graph or DataLoader"},{"location":"ledger_v1/etch-language/persistent-globals/","text":"Persistent globals are succinct and ledger efficient persistent variable types that store data on the Fetch.ai Ledger. They are equivalent to State and ShardedState objects and are the primary mechanism for shard management. Five new keywords identify these types: persistent , sharded , use , as , and any . As etch evolves along with the Fetch.ai Ledger, persistent globals will help ensure maximum ledger storage efficiency. Recommendation Use the persistent global syntax instead of State and ShardedState syntax. Syntax Declare all persistent variables the smart contract may use at the top of the file before any function declarations. persistent Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations. sharded Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations. use Import the global persistent variables into smart contract functions with the use keyword. State For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction ShardedState For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects). as Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction any Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction Benefits Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( -10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , -10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction Limitations You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Persistent globals"},{"location":"ledger_v1/etch-language/persistent-globals/#syntax","text":"Declare all persistent variables the smart contract may use at the top of the file before any function declarations.","title":"Syntax"},{"location":"ledger_v1/etch-language/persistent-globals/#persistent","text":"Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations.","title":"persistent"},{"location":"ledger_v1/etch-language/persistent-globals/#sharded","text":"Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations.","title":"sharded"},{"location":"ledger_v1/etch-language/persistent-globals/#use","text":"Import the global persistent variables into smart contract functions with the use keyword.","title":"use"},{"location":"ledger_v1/etch-language/persistent-globals/#state","text":"For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction","title":"State"},{"location":"ledger_v1/etch-language/persistent-globals/#shardedstate","text":"For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects).","title":"ShardedState"},{"location":"ledger_v1/etch-language/persistent-globals/#as","text":"Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction","title":"as"},{"location":"ledger_v1/etch-language/persistent-globals/#any","text":"Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction","title":"any"},{"location":"ledger_v1/etch-language/persistent-globals/#benefits","text":"Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( -10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , -10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"Benefits"},{"location":"ledger_v1/etch-language/persistent-globals/#limitations","text":"You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Limitations"},{"location":"ledger_v1/etch-language/sc-annotations/","text":"Smart contract annotations Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment. @action The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction @query Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"Smart contract annotations"},{"location":"ledger_v1/etch-language/sc-annotations/#smart-contract-annotations","text":"Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error.","title":"Smart contract annotations"},{"location":"ledger_v1/etch-language/sc-annotations/#init","text":"The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment.","title":"@init"},{"location":"ledger_v1/etch-language/sc-annotations/#action","text":"The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction","title":"@action"},{"location":"ledger_v1/etch-language/sc-annotations/#query","text":"Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"@query"},{"location":"ledger_v1/etch-language/scaler/","text":"Use a Scaler to normalise data. Declare and initialise a Scaler . function main () var scaler = Scaler (); endfunction Min max The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); Scaler example The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler"},{"location":"ledger_v1/etch-language/scaler/#min-max","text":"The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor );","title":"Min max"},{"location":"ledger_v1/etch-language/scaler/#scaler-example","text":"The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler example"},{"location":"ledger_v1/etch-language/sharded-state/","text":"Warning Use persistent global syntax to build State variables. Introduction to ShardedState variables A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declaration Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Querying with default values Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction ShardedState types with Address references You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , -10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState"},{"location":"ledger_v1/etch-language/sharded-state/#introduction-to-shardedstate-variables","text":"A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger.","title":"Introduction to ShardedState variables"},{"location":"ledger_v1/etch-language/sharded-state/#declaration","text":"Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data.","title":"Declaration"},{"location":"ledger_v1/etch-language/sharded-state/#add-keyvalue-pairs","text":"Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction","title":"Add key/value pairs"},{"location":"ledger_v1/etch-language/sharded-state/#querying-with-default-values","text":"Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction","title":"Querying with default values"},{"location":"ledger_v1/etch-language/sharded-state/#shardedstate-types-with-address-references","text":"You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , -10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState types with Address references"},{"location":"ledger_v1/etch-language/states/","text":"Warning Use persistent global syntax to build State variables. Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction Default values If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error. Writing State data to the ledger The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"State"},{"location":"ledger_v1/etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction","title":"Introduction to State variables"},{"location":"ledger_v1/etch-language/states/#default-values","text":"If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"ledger_v1/etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership.","title":"Test a State exists"},{"location":"ledger_v1/etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error.","title":"State references and scope"},{"location":"ledger_v1/etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"ledger_v1/etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"ledger_v1/etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction","title":"Passing States around"},{"location":"ledger_v1/etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"Verify an Address"},{"location":"ledger_v1/etch-language/strings/","text":"Strings etch supports ASCII and UTF8 for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction String functions You can use the following utility functions for string manipulation: Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction Substring The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Strings"},{"location":"ledger_v1/etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction","title":"Concatenation"},{"location":"ledger_v1/etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"ledger_v1/etch-language/strings/#string-functions","text":"You can use the following utility functions for string manipulation:","title":"String functions"},{"location":"ledger_v1/etch-language/strings/#find","text":"The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction","title":"Find"},{"location":"ledger_v1/etch-language/strings/#length","text":"The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction","title":"Length"},{"location":"ledger_v1/etch-language/strings/#reverse","text":"The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction","title":"Reverse"},{"location":"ledger_v1/etch-language/strings/#split","text":"The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Split"},{"location":"ledger_v1/etch-language/strings/#substring","text":"The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction","title":"Substring"},{"location":"ledger_v1/etch-language/strings/#trim","text":"The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Trim"},{"location":"ledger_v1/etch-language/syn-annotations/","text":"Etch synergetic contract code includes specific function annotations. These need to be all present or absent, and only one of each type is allowed. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution. You can find an example of a synergetic contract and these annotations here .","title":"Synergetic contract annotations"},{"location":"ledger_v1/etch-language/syntax/","text":"Syntax The etch language integrates with the Fetch.ai Ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . [!comment]: (All variables in etch receive a default value at compile time.) Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Syntax"},{"location":"ledger_v1/etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . [!comment]: (All variables in etch receive a default value at compile time.)","title":"Declarations"},{"location":"ledger_v1/etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"ledger_v1/etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear","title":"Keywords"},{"location":"ledger_v1/etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"ledger_v1/etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Annotations"},{"location":"ledger_v1/etch-language/tensor/","text":"A Tensor is a vector or matrix type having multiple dimensions. In etch it is the n-dimensional matrix type used by the mathematics and machine learning libraries. Declare and initialise Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction toString Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Size Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction fromString Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction Fill Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction Fill Random The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Setters Use setAt() to insert a Fixed64 value at a specific index. 1D The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 2D The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 3D The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction 4D The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction Getters The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension. 1D function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction 2D function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction 3D function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction 4D function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction Reshape The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction Squeeze The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction Serialisation A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Tensor"},{"location":"ledger_v1/etch-language/tensor/#declare-and-initialise","text":"Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction","title":"Declare and initialise"},{"location":"ledger_v1/etch-language/tensor/#tostring","text":"Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"toString"},{"location":"ledger_v1/etch-language/tensor/#size","text":"Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction","title":"Size"},{"location":"ledger_v1/etch-language/tensor/#fromstring","text":"Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction","title":"fromString"},{"location":"ledger_v1/etch-language/tensor/#fill","text":"Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"Fill"},{"location":"ledger_v1/etch-language/tensor/#fill-random","text":"The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"Fill Random"},{"location":"ledger_v1/etch-language/tensor/#setters","text":"Use setAt() to insert a Fixed64 value at a specific index.","title":"Setters"},{"location":"ledger_v1/etch-language/tensor/#1d","text":"The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"1D"},{"location":"ledger_v1/etch-language/tensor/#2d","text":"The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"2D"},{"location":"ledger_v1/etch-language/tensor/#3d","text":"The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction","title":"3D"},{"location":"ledger_v1/etch-language/tensor/#4d","text":"The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction","title":"4D"},{"location":"ledger_v1/etch-language/tensor/#getters","text":"The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension.","title":"Getters"},{"location":"ledger_v1/etch-language/tensor/#1d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction","title":"1D"},{"location":"ledger_v1/etch-language/tensor/#2d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction","title":"2D"},{"location":"ledger_v1/etch-language/tensor/#3d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction","title":"3D"},{"location":"ledger_v1/etch-language/tensor/#4d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction","title":"4D"},{"location":"ledger_v1/etch-language/tensor/#reshape","text":"The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction","title":"Reshape"},{"location":"ledger_v1/etch-language/tensor/#squeeze","text":"The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction","title":"Squeeze"},{"location":"ledger_v1/etch-language/tensor/#serialisation","text":"A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Serialisation"},{"location":"ledger_v1/etch-language/transaction/","text":"The Transaction type provides access to data pertaining to a currently invoking transaction on a running smart contract. To access the Transaction type you need a Context . getContext() Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions. digest() The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest (); from() The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from (); transfers() transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers (); getTotalTransferAmount() The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount (); validFrom() The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom (); validUntil() The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil (); chargeRate() The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate (); chargeLimit() The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit (); contractDigest() The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest (); contractAddress() The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress (); action() The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action (); signatories() The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories (); Example Note Coming soon.","title":"Transaction"},{"location":"ledger_v1/etch-language/transaction/#getcontext","text":"Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions.","title":"getContext()"},{"location":"ledger_v1/etch-language/transaction/#digest","text":"The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest ();","title":"digest()"},{"location":"ledger_v1/etch-language/transaction/#from","text":"The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from ();","title":"from()"},{"location":"ledger_v1/etch-language/transaction/#transfers","text":"transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers ();","title":"transfers()"},{"location":"ledger_v1/etch-language/transaction/#gettotaltransferamount","text":"The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount ();","title":"getTotalTransferAmount()"},{"location":"ledger_v1/etch-language/transaction/#validfrom","text":"The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom ();","title":"validFrom()"},{"location":"ledger_v1/etch-language/transaction/#validuntil","text":"The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil ();","title":"validUntil()"},{"location":"ledger_v1/etch-language/transaction/#chargerate","text":"The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate ();","title":"chargeRate()"},{"location":"ledger_v1/etch-language/transaction/#chargelimit","text":"The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit ();","title":"chargeLimit()"},{"location":"ledger_v1/etch-language/transaction/#contractdigest","text":"The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest ();","title":"contractDigest()"},{"location":"ledger_v1/etch-language/transaction/#contractaddress","text":"The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress ();","title":"contractAddress()"},{"location":"ledger_v1/etch-language/transaction/#action","text":"The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action ();","title":"action()"},{"location":"ledger_v1/etch-language/transaction/#signatories","text":"The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories ();","title":"signatories()"},{"location":"ledger_v1/etch-language/transaction/#example","text":"Note Coming soon.","title":"Example"},{"location":"ledger_v1/etch-language/variables/","text":"Variables etch is a statically-typed programming language. The behaviour of value and reference types (primitives and non-primitives in Java) is the same as in other high level languages such as C++, Java, .Net, and Python. Declare a variable with the keyword var . Declare numeric values with literals where possible. Naming Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = -42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = -1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = -3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = -1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = -3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction 32 byte unsigned integer Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity. Fixed point decimals Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = -32.0f p32 ; var fixed64bit = -64.0f p64 ; var fixed128bit = -128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments . Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type. Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations. StructuredData StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction State A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here . Address The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here . Type casting There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes Scope etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here. Null Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Variables"},{"location":"ledger_v1/etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction","title":"Naming"},{"location":"ledger_v1/etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = -42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = -1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = -3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = -1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = -3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"ledger_v1/etch-language/variables/#32-byte-unsigned-integer","text":"Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity.","title":"32 byte unsigned integer"},{"location":"ledger_v1/etch-language/variables/#fixed-point-decimals","text":"Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = -32.0f p32 ; var fixed64bit = -64.0f p64 ; var fixed128bit = -128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments .","title":"Fixed point decimals"},{"location":"ledger_v1/etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"ledger_v1/etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"ledger_v1/etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"ledger_v1/etch-language/variables/#buffer","text":"Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type.","title":"Buffer"},{"location":"ledger_v1/etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations.","title":"Maps"},{"location":"ledger_v1/etch-language/variables/#structureddata","text":"StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction","title":"StructuredData"},{"location":"ledger_v1/etch-language/variables/#state","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"State"},{"location":"ledger_v1/etch-language/variables/#shardedstate","text":"Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here .","title":"ShardedState"},{"location":"ledger_v1/etch-language/variables/#address","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here .","title":"Address"},{"location":"ledger_v1/etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here .","title":"Mathematical, ML, and AI"},{"location":"ledger_v1/etch-language/variables/#type-casting","text":"There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"ledger_v1/etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes","title":"Data size"},{"location":"ledger_v1/etch-language/variables/#scope","text":"etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here.","title":"Scope"},{"location":"ledger_v1/etch-language/variables/#null","text":"Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"ledger_v1/etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Default values"},{"location":"ledger_v1/etch-language/examples/dft/","text":"function main () var inreal = Array < Fixed64 > ( 1000 ); var inimag = Array < Fixed64 > ( 1000 ); var outreal = Array < Fixed64 > ( 1000 ); var outimag = Array < Fixed64 > ( 1000 ); for ( i in 0 : inreal . count ()) inreal [ i ] = toFixed64 ( rand ( 0 , 1000 )); inimag [ i ] = toFixed64 ( rand ( 0 , 1000 )); endfor dft ( inreal , inimag , outreal , outimag ); //printLn(inreal); //printLn(inimag); //printLn(outreal); //printLn(outimag); endfunction function dft ( inreal : Array < Fixed64 > , inimag : Array < Fixed64 > , outreal : Array < Fixed64 > , outimag : Array < Fixed64 > ) var n = inreal . count (); var angle = 0.0f p64 ; for ( k in 0 : n ) var sumreal = 0.0f p64 ; var sumimag = 0.0f p64 ; for ( t in 0 : n ) angle = 2.0f p64 * 3.142f p64 * toFixed64 ( t ) * toFixed64 ( k ) / toFixed64 ( n ); sumreal += inreal [ t ] * cos ( angle ) + inimag [ t ] * sin ( angle ); sumimag += - inreal [ t ] * sin ( angle ) + inimag [ t ] * cos ( angle ); endfor outreal [ k ] = sumreal ; outimag [ k ] = sumimag ; endfor endfunction","title":"Discrete Fourier Transformation"},{"location":"ledger_v1/etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"ledger_v1/etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Fixed64 = 32.0f p64 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Fixed64 = toFixed64 ( pixelX ); xLocal = (( xLocal / toFixed64 ( xMax )) * 3.5f p64 ) - 2.5f p64 ; // // Now Y to -1 to 1: var yLocal : Fixed64 = toFixed64 ( pixelY ); yLocal = yLocal / toFixed64 ( yMax ); // // Now let's do the algorithm bit: var x : Fixed64 = 0.0f p64 ; var y : Fixed64 = 0.0f p64 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0f p64 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0f p64 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Fixed64 = ( toFixed64 ( iteration ) / toFixed64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"ledger_v1/etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"ledger_v1/etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"ledger_v1/etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"ledger_v1/etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () -1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print(\"Splitting \"); printLn(a_list); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n -1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi -1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Sorting algorithms"},{"location":"ledger_v1/etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () -1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"ledger_v1/etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"ledger_v1/etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print(\"Splitting \"); printLn(a_list); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"ledger_v1/etch-language/examples/sorting-algorithms/#quick-sort","text":"function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n -1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi -1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Quick sort"},{"location":"ledger_v1/installation/installation-mac/","text":"Installing and building the ledger on Mac Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"MacOS"},{"location":"ledger_v1/installation/installation-mac/#installing-and-building-the-ledger-on-mac","text":"","title":"Installing and building the ledger on Mac"},{"location":"ledger_v1/installation/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"ledger_v1/installation/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger_v1/installation/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger_v1/installation/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger_v1/installation/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"ledger_v1/installation/installation-redhat/","text":"Installing and building the ledger on Linux Redhat Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Redhat"},{"location":"ledger_v1/installation/installation-redhat/#installing-and-building-the-ledger-on-linux-redhat","text":"","title":"Installing and building the ledger on Linux Redhat"},{"location":"ledger_v1/installation/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"ledger_v1/installation/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger_v1/installation/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger_v1/installation/installation-ubuntu/","text":"Installing and building the ledger on Linux Ubuntu Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Ubuntu"},{"location":"ledger_v1/installation/installation-ubuntu/#installing-and-building-the-ledger-on-linux-ubuntu","text":"","title":"Installing and building the ledger on Linux Ubuntu"},{"location":"ledger_v1/installation/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger_v1/installation/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger_v1/installation/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger_v1/machine-learning/","text":"Machine Learning Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Introduction"},{"location":"ledger_v1/machine-learning/#machine-learning","text":"Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Machine Learning"},{"location":"ledger_v1/machine-learning/getting-started/","text":"Using the machine learning library Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here . Loading input data An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Setting up the model We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Training and evaluating the model Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate (); Making predictions on the model Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Running the script The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Getting started"},{"location":"ledger_v1/machine-learning/getting-started/#using-the-machine-learning-library","text":"Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here .","title":"Using the machine learning library"},{"location":"ledger_v1/machine-learning/getting-started/#loading-input-data","text":"An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Loading input data"},{"location":"ledger_v1/machine-learning/getting-started/#setting-up-the-model","text":"We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Setting up the model"},{"location":"ledger_v1/machine-learning/getting-started/#training-and-evaluating-the-model","text":"Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate ();","title":"Training and evaluating the model"},{"location":"ledger_v1/machine-learning/getting-started/#making-predictions-on-the-model","text":"Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Making predictions on the model"},{"location":"ledger_v1/machine-learning/getting-started/#running-the-script","text":"The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Running the script"},{"location":"ledger_v1/machine-learning/library-architecture/","text":"Machine Learning library architecture The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress. Graph Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal. Ops To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data. Layers Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function. DataLoaders DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders . Integer mathematics The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures. Notes for working with the C++ machine learning library Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Architecture"},{"location":"ledger_v1/machine-learning/library-architecture/#machine-learning-library-architecture","text":"The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress.","title":"Machine Learning library architecture"},{"location":"ledger_v1/machine-learning/library-architecture/#graph","text":"Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal.","title":"Graph"},{"location":"ledger_v1/machine-learning/library-architecture/#ops","text":"To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data.","title":"Ops"},{"location":"ledger_v1/machine-learning/library-architecture/#layers","text":"Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function.","title":"Layers"},{"location":"ledger_v1/machine-learning/library-architecture/#dataloaders","text":"DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders .","title":"DataLoaders"},{"location":"ledger_v1/machine-learning/library-architecture/#integer-mathematics","text":"The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures.","title":"Integer mathematics"},{"location":"ledger_v1/machine-learning/library-architecture/#notes-for-working-with-the-c-machine-learning-library","text":"Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Notes for working with the C++ machine learning library"},{"location":"ledger_v1/machine-learning/smart-contract-example/","text":"AI in Smart Contracts The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators Persistent storage The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here . Separately callable functions In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently. Function decorators Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added. Advanced customisation With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"AI in smart contracts"},{"location":"ledger_v1/machine-learning/smart-contract-example/#ai-in-smart-contracts","text":"The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators","title":"AI in Smart Contracts"},{"location":"ledger_v1/machine-learning/smart-contract-example/#persistent-storage","text":"The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here .","title":"Persistent storage"},{"location":"ledger_v1/machine-learning/smart-contract-example/#separately-callable-functions","text":"In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently.","title":"Separately callable functions"},{"location":"ledger_v1/machine-learning/smart-contract-example/#function-decorators","text":"Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added.","title":"Function decorators"},{"location":"ledger_v1/machine-learning/smart-contract-example/#advanced-customisation","text":"With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"Advanced customisation"},{"location":"ledger_v1/machine-learning/synergetic-contract-example/","text":"AI in Synergetic Contracts The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use. Simple Synergetic Contract Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"AI in synergetic contracts"},{"location":"ledger_v1/machine-learning/synergetic-contract-example/#ai-in-synergetic-contracts","text":"The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use.","title":"AI in Synergetic Contracts"},{"location":"ledger_v1/machine-learning/synergetic-contract-example/#simple-synergetic-contract","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"Simple Synergetic Contract"},{"location":"ledger_v1/python-ledger-api/python-api-install/","text":"Build the Python libraries like this: pip3 install -U fetchai-ledger-api Or, download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.9.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Installation"},{"location":"ledger_v1/python-ledger-api/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block Number"},{"location":"ledger_v1/smart-contracts/etch-smart-contracts/","text":"Etch smart contracts Smart contract code runs on the etch virtual machine. All ledger nodes contain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract addresses etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name. Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Smart contracts in Etch"},{"location":"ledger_v1/smart-contracts/etch-smart-contracts/#smart-contract-addresses","text":"etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name.","title":"Smart contract addresses"},{"location":"ledger_v1/smart-contracts/etch-smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Public keys Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course. Test network You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#public-keys","text":"Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course.","title":"Public keys"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"ledger_v1/smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"ledger_v1/smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code Warning Synergetic contracts are currently an experimental feature. To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = \"\"\" @problem function createProblem(data : Array<StructuredData>) : Int32 var value = 0; for (i in 0:data.count()) value += data[i].getInt32(\"value\"); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : UInt256) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State<Int32>(\"solution\"); result.set(solution); endfunction \"\"\" def main (): # create the API api = LedgerApi ( '127.0.0.1' , 8100 ) # create an entity and provide it some wealth print ( 'Setup...' ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( 'Setup...complete' ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == '__main__' : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic contracts"},{"location":"ledger_v1/smart-contracts/fees/","text":"Fetch.ai charges developers for computation and storage of data on the Fetch.ai Ledger in a manner which incentivises good coding practices. With the best use of Fetch.ai Ledger types such as State and ShardedState , you can limit the fees by distributing data storage over a minimum number of shards. Fees rise in a linear manner per number of shards up to the maximum number of shards. Note The following information details the current implementation which is likely to change. Calculating charge units Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here . Calculating total transaction fee To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Fees"},{"location":"ledger_v1/smart-contracts/fees/#calculating-charge-units","text":"Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here .","title":"Calculating charge units"},{"location":"ledger_v1/smart-contracts/fees/#calculating-total-transaction-fee","text":"To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Calculating total transaction fee"},{"location":"ledger_v1/smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"ledger_v1/smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"ledger_v1/smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Development environment"},{"location":"ledger_v1/smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"ledger_v1/smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.ai smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the distributed Fetch.ai Ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using persistent global representations of State and ShardedState data structures, and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here . Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Introduction"},{"location":"ledger_v1/smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here .","title":"The Ledger"},{"location":"ledger_v1/smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"ledger_v1/smart-contracts/static-dynamic/","text":"Static contracts A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly. Dynamic contracts A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Static and dynamic contracts"},{"location":"ledger_v1/smart-contracts/static-dynamic/#static-contracts","text":"A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly.","title":"Static contracts"},{"location":"ledger_v1/smart-contracts/static-dynamic/#dynamic-contracts","text":"A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Dynamic contracts"},{"location":"ledger_v1/smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic contracts"},{"location":"ledger_v1/smart-contracts/synergetic/#introduction-to-synergetic-contracts","text":"Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Introduction to synergetic contracts"},{"location":"ledger_v1/walkthrough/","text":"Introduction Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger_v1/walkthrough/#introduction","text":"Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger_v1/walkthrough/creating-addresses/","text":"Creating addresses In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h . Creating a new address You can use any of the following methods to create an address. Using Pocketbook Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts. Using the web testnet wallet For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice. Using the Python Ledger API Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here! Adding an address to Pocketbook We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Listing an address balance You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Creating addresses"},{"location":"ledger_v1/walkthrough/creating-addresses/#creating-addresses","text":"In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h .","title":"Creating addresses"},{"location":"ledger_v1/walkthrough/creating-addresses/#creating-a-new-address","text":"You can use any of the following methods to create an address.","title":"Creating a new address"},{"location":"ledger_v1/walkthrough/creating-addresses/#using-pocketbook","text":"Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts.","title":"Using Pocketbook"},{"location":"ledger_v1/walkthrough/creating-addresses/#using-the-web-testnet-wallet","text":"For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice.","title":"Using the web testnet wallet"},{"location":"ledger_v1/walkthrough/creating-addresses/#using-the-python-ledger-api","text":"Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here!","title":"Using the Python Ledger API"},{"location":"ledger_v1/walkthrough/creating-addresses/#adding-an-address-to-pocketbook","text":"We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Adding an address to Pocketbook"},{"location":"ledger_v1/walkthrough/creating-addresses/#listing-an-address-balance","text":"You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Listing an address balance"},{"location":"ledger_v1/walkthrough/smart-contracts/","text":"Deploying and interacting with smart contracts What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly. Interacting with an already deployed contract There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world Learn more about smart contract development You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Deploying smart contracts"},{"location":"ledger_v1/walkthrough/smart-contracts/#deploying-and-interacting-with-smart-contracts","text":"What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly.","title":"Deploying and interacting with smart contracts"},{"location":"ledger_v1/walkthrough/smart-contracts/#interacting-with-an-already-deployed-contract","text":"There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world","title":"Interacting with an already deployed contract"},{"location":"ledger_v1/walkthrough/smart-contracts/#learn-more-about-smart-contract-development","text":"You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Learn more about smart contract development"},{"location":"ledger_v1/walkthrough/testnet-tokens/","text":"Getting testnet tokens In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet. Using the token tap Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box. Transferring tokens from another account you have It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done! Asking in the developer Slack channel You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Getting testnet tokens"},{"location":"ledger_v1/walkthrough/testnet-tokens/#getting-testnet-tokens","text":"In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet.","title":"Getting testnet tokens"},{"location":"ledger_v1/walkthrough/testnet-tokens/#using-the-token-tap","text":"Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box.","title":"Using the token tap"},{"location":"ledger_v1/walkthrough/testnet-tokens/#transferring-tokens-from-another-account-you-have","text":"It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done!","title":"Transferring tokens from another account you have"},{"location":"ledger_v1/walkthrough/testnet-tokens/#asking-in-the-developer-slack-channel","text":"You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Asking in the developer Slack channel"},{"location":"ledger_v1/walkthrough/transfers-and-balances/","text":"Making transfers In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :) Using Pocketbook You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Using the Python Ledger API Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Making transfers"},{"location":"ledger_v1/walkthrough/transfers-and-balances/#making-transfers","text":"In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :)","title":"Making transfers"},{"location":"ledger_v1/walkthrough/transfers-and-balances/#using-pocketbook","text":"You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Using Pocketbook"},{"location":"ledger_v1/walkthrough/transfers-and-balances/#using-the-python-ledger-api","text":"Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Using the Python Ledger API"},{"location":"ledger_v2/","text":"Getting Ready for Mainnet V2 We are hard at work preparing for Fetch mainnet version 2, which is currently due for release in the next few months. But you can get prepared now . This documentation covers some of the things you need to know in order to prepare for and develop for this new network: Test Networks The starting point for most developers will be our Agent Land test network, since this is primarily used for agent development and testing. Agent Land is fully supported by our Agent Framework from version 0.6 and above. If you are developing autonomous economic agents using our latest framework, then moving to Agent Land is relatively straightforward, unless smart contracts are involved. Agentland and other testnets on the journey have a new address format. Here is a typical example: fetch1almpjpf769p23k0v4m5eglvzr4jupsjs66vxf4 Note These new addresses are not compatible with mainnet v1 or testnet v1. It is expected that users will create new address for agents on the network Key links and information Block explorer and token tap: https://explore-agent-land.fetch.ai/ Understanding building block relationships: https://docs.fetch.ai/aea/oef-ledger/ For more detailed information, have a look at our network information page. Other testnets There are currently three key sequential testnets planned, but more may arise and operate in parallel in order to target the testing and development of specific additional new technologies. The three main incentivised testnet phases are: Agents : a stable testnet for autonomous economic agents, featuring the core new mainnet v2 technologies that agent developers need in order to prepare. Random Beacon : a stable testnet showcasing the decentralised random beacon, vital for DeFi, gaming and a key part of our on-going unique approach to consensus. Oracles : a stable testnet for demonstrating connecting the outside world to the inside world; enabling agents to communicate reliable, trustworthy information from the environment at large. Roadmap for Smart Contracts The v2.0 main-net and our test-nets support a webassembly (WASM) virtual machine VM. When mainnet V2 is released, smart contracts will be developed using Cosmwasm, which will include the ability to develop your contracts in a variety of languages depending on your preferences, such as Rust, Go or Javascript. For more information on Cosmwasm, and Rust, which is the first language to be supported by the Cosmwasm VM, you can go to https://www.cosmwasm.com/ and https://github.com/CosmWasm/cosmwasm-template .","title":"Introduction"},{"location":"ledger_v2/#getting-ready-for-mainnet-v2","text":"We are hard at work preparing for Fetch mainnet version 2, which is currently due for release in the next few months. But you can get prepared now . This documentation covers some of the things you need to know in order to prepare for and develop for this new network:","title":"Getting Ready for Mainnet V2"},{"location":"ledger_v2/#test-networks","text":"The starting point for most developers will be our Agent Land test network, since this is primarily used for agent development and testing. Agent Land is fully supported by our Agent Framework from version 0.6 and above. If you are developing autonomous economic agents using our latest framework, then moving to Agent Land is relatively straightforward, unless smart contracts are involved. Agentland and other testnets on the journey have a new address format. Here is a typical example: fetch1almpjpf769p23k0v4m5eglvzr4jupsjs66vxf4 Note These new addresses are not compatible with mainnet v1 or testnet v1. It is expected that users will create new address for agents on the network","title":"Test Networks"},{"location":"ledger_v2/#key-links-and-information","text":"Block explorer and token tap: https://explore-agent-land.fetch.ai/ Understanding building block relationships: https://docs.fetch.ai/aea/oef-ledger/ For more detailed information, have a look at our network information page.","title":"Key links and information"},{"location":"ledger_v2/#other-testnets","text":"There are currently three key sequential testnets planned, but more may arise and operate in parallel in order to target the testing and development of specific additional new technologies. The three main incentivised testnet phases are: Agents : a stable testnet for autonomous economic agents, featuring the core new mainnet v2 technologies that agent developers need in order to prepare. Random Beacon : a stable testnet showcasing the decentralised random beacon, vital for DeFi, gaming and a key part of our on-going unique approach to consensus. Oracles : a stable testnet for demonstrating connecting the outside world to the inside world; enabling agents to communicate reliable, trustworthy information from the environment at large.","title":"Other testnets"},{"location":"ledger_v2/#roadmap-for-smart-contracts","text":"The v2.0 main-net and our test-nets support a webassembly (WASM) virtual machine VM. When mainnet V2 is released, smart contracts will be developed using Cosmwasm, which will include the ability to develop your contracts in a variety of languages depending on your preferences, such as Rust, Go or Javascript. For more information on Cosmwasm, and Rust, which is the first language to be supported by the Cosmwasm VM, you can go to https://www.cosmwasm.com/ and https://github.com/CosmWasm/cosmwasm-template .","title":"Roadmap for Smart Contracts"},{"location":"ledger_v2/block-explorer/","text":"Block Explorer Each of the networks has a dedicated block explorer web site associated with it. This is a useful tool for monitoring network activity. Logging in with the Ledger Nano Return to the block explorer landing page and click on the key button in the top right corner. You'll then be prompted to \"Sign in With Ledger\". You must accept this request on your ledger nano device. After completing this process, the key button will be replaced by a person icon with a link to your personal address page, which keeps track of the activity that you have performed on the test-net. Getting Testnet Tokens from the Faucet For networks that support it, you can obtain tokens for your account by copying the address and pasting it into the token faucet. Then, return to the main page, press the \"Get Funds\" button and paste your address in the pop-up. Afterwards you can return to your address page (via the person icon) and should observe that you have been allocated 1 TESTFET. Transferring Tokens to another Address After receiving tokens, you can send these to another address using the purple Transfer button on your address page. This will trigger a pop-up that prompts you to specify the destination address and the amount you wish to transfer. After filling in this information, you will be asked to sign the transaction using your ledger nano. The confirmation that the transaction has been broadcast gives two links that can be used to check that the transaction has been executed on the blockchain using either the transaction hash or your account page. Note: The transaction format includes a memo field that can be used to check the transaction information on the ledger nano display. Delegating Stake to a Validator You can delegate your test-net tokens to a validator who is operating the network by clicking on the Validators tab, and selecting one of the validators that you wish to delegate stake towards. In the Voting Power panel there is an option to DELEGATE tokens. Pressing this button will trigger a pop-up that prompts you to select a delegation amount and then sign the transaction with your Ledger Nano device. After delegating tokens, buttons labelled with REDELEGATE and UNDELEGATE will appear. The delegation of tokens to a validator provides you with a reward for helping to secure the network. It is also possible to delegate your tokens to a different validator using a REDELEGATE transaction. You can return any bonded tokens to your address by submitting an UNDELEGATE request, which will trigger the tokens to be returned after 21 days have elapsed. The rewards that you receive from delegating tokens to a validator are shown in the account page. These can be sent to your address by sending a WITHDRAW transaction.","title":"Block Explorer"},{"location":"ledger_v2/block-explorer/#block-explorer","text":"Each of the networks has a dedicated block explorer web site associated with it. This is a useful tool for monitoring network activity.","title":"Block Explorer"},{"location":"ledger_v2/block-explorer/#logging-in-with-the-ledger-nano","text":"Return to the block explorer landing page and click on the key button in the top right corner. You'll then be prompted to \"Sign in With Ledger\". You must accept this request on your ledger nano device. After completing this process, the key button will be replaced by a person icon with a link to your personal address page, which keeps track of the activity that you have performed on the test-net.","title":"Logging in with the Ledger Nano"},{"location":"ledger_v2/block-explorer/#getting-testnet-tokens-from-the-faucet","text":"For networks that support it, you can obtain tokens for your account by copying the address and pasting it into the token faucet. Then, return to the main page, press the \"Get Funds\" button and paste your address in the pop-up. Afterwards you can return to your address page (via the person icon) and should observe that you have been allocated 1 TESTFET.","title":"Getting Testnet Tokens from the Faucet"},{"location":"ledger_v2/block-explorer/#transferring-tokens-to-another-address","text":"After receiving tokens, you can send these to another address using the purple Transfer button on your address page. This will trigger a pop-up that prompts you to specify the destination address and the amount you wish to transfer. After filling in this information, you will be asked to sign the transaction using your ledger nano. The confirmation that the transaction has been broadcast gives two links that can be used to check that the transaction has been executed on the blockchain using either the transaction hash or your account page. Note: The transaction format includes a memo field that can be used to check the transaction information on the ledger nano display.","title":"Transferring Tokens to another Address"},{"location":"ledger_v2/block-explorer/#delegating-stake-to-a-validator","text":"You can delegate your test-net tokens to a validator who is operating the network by clicking on the Validators tab, and selecting one of the validators that you wish to delegate stake towards. In the Voting Power panel there is an option to DELEGATE tokens. Pressing this button will trigger a pop-up that prompts you to select a delegation amount and then sign the transaction with your Ledger Nano device. After delegating tokens, buttons labelled with REDELEGATE and UNDELEGATE will appear. The delegation of tokens to a validator provides you with a reward for helping to secure the network. It is also possible to delegate your tokens to a different validator using a REDELEGATE transaction. You can return any bonded tokens to your address by submitting an UNDELEGATE request, which will trigger the tokens to be returned after 21 days have elapsed. The rewards that you receive from delegating tokens to a validator are shown in the account page. These can be sent to your address by sending a WITHDRAW transaction.","title":"Delegating Stake to a Validator"},{"location":"ledger_v2/building/","text":"Building the Ledger Prerequisites Go 1.14+ (installation instructions available here ) Building the code Download the latest released version from github and build the project using the following commands: git clone https://github.com/fetchai/fetchd.git -b release/v0.2.x && cd fetchd Then build the code with the command: make build This will generate the following binaries: ./build/fetchcli - This is the command line client that is useful for interacting with the network ./build/fetchd - This is the block chain node daemon and can be configured to join the network For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command: sudo make install This will install the binaries in the directory specified by your $GOBIN environment variable.","title":"Installation"},{"location":"ledger_v2/building/#building-the-ledger","text":"","title":"Building the Ledger"},{"location":"ledger_v2/building/#prerequisites","text":"Go 1.14+ (installation instructions available here )","title":"Prerequisites"},{"location":"ledger_v2/building/#building-the-code","text":"Download the latest released version from github and build the project using the following commands: git clone https://github.com/fetchai/fetchd.git -b release/v0.2.x && cd fetchd Then build the code with the command: make build This will generate the following binaries: ./build/fetchcli - This is the command line client that is useful for interacting with the network ./build/fetchd - This is the block chain node daemon and can be configured to join the network For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command: sudo make install This will install the binaries in the directory specified by your $GOBIN environment variable.","title":"Building the code"},{"location":"ledger_v2/cli-introduction/","text":"CLI - Introduction The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here Connecting to a network While some users will want to connect a node to the network and sync the entire blockchain, for many however, it is quicker and easier to connect directly to existing publically available nodes. Connecting to Agent Land network To connect to the agent land network run the following configuration steps: fetchcli config chain-id agent-land fetchcli config trust-node false fetchcli config node https://rpc-agent-land.fetch.ai:443 Connecting to Agent World network To connect to the agent world network run the following configuration steps: fetchcli config chain-id agentworld-1 fetchcli config trust-node false fetchcli config node https://rpc-agentworld.prod.fetch-ai.com:443 Checkout the Network Information page for more detailed information on the available test networks.","title":"Introduction"},{"location":"ledger_v2/cli-introduction/#cli-introduction","text":"The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here","title":"CLI - Introduction"},{"location":"ledger_v2/cli-introduction/#connecting-to-a-network","text":"While some users will want to connect a node to the network and sync the entire blockchain, for many however, it is quicker and easier to connect directly to existing publically available nodes.","title":"Connecting to a network"},{"location":"ledger_v2/cli-introduction/#connecting-to-agent-land-network","text":"To connect to the agent land network run the following configuration steps: fetchcli config chain-id agent-land fetchcli config trust-node false fetchcli config node https://rpc-agent-land.fetch.ai:443","title":"Connecting to Agent Land network"},{"location":"ledger_v2/cli-introduction/#connecting-to-agent-world-network","text":"To connect to the agent world network run the following configuration steps: fetchcli config chain-id agentworld-1 fetchcli config trust-node false fetchcli config node https://rpc-agentworld.prod.fetch-ai.com:443 Checkout the Network Information page for more detailed information on the available test networks.","title":"Connecting to Agent World network"},{"location":"ledger_v2/cli-keys/","text":"CLI - Managing Keys Managing your keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys. Adding keys To create a new local key you need run the following command: fetchcli keys add <your_key_name> Note These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device After running the command fetchcli will print out a summary of the new key. An example of this output is shown below: - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account (keep this safe, if ever used to control main-net tokens). Looking up an address A common operation that you will want to do is to lookup the address for a specified key. This can be done quickly using the following command: fetchcli keys show -a <name of key> An example of the expected output is shown below: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 A less common operation, but still useful, would be to lookup the public key for a specified key. The can be achieved with the following command: fetchcli keys show -p <name of the key> An example of the expected output is shown below: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx Listing keys To lookup more detailed information for all keys on your system use the following command: fetchcli keys list This will output all of your keys information in a yaml format that is similar to the one generated when you first created the key. - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] Hardware Wallets Setup We recommend hardware wallets as a solution for managing private keys. The Fetch v2.0 ledger is compatible with Ledger Nano devices. To use your Ledger Nano you will need to complete the following steps: Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged. Connect your device to your PC and update the firmware to the latest version using the Ledger Live application. Install the Cosmos application using the software manager (Manager > Cosmos > Install). Adding a new key In order to use the hardware wallet address with the cli, the user must first add it via fetchcli . This process only records the public information about the key. To import the key first plug in the device and enter the device pin. Once you have unlocked the device navigate to the Cosmos app on the device and open it. To add the key use the following command: fetchcli keys add <name for the key> --ledger --index 0 Note The --ledger flag tells the command line tool to talk to the ledger device and the --index flag selects which HD index should be used. When running this command, the Ledger device will prompt you to verify the genereated address. Once you have done this you will get an output in the following form: - name: hw1 type: ledger address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2 pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h mnemonic: \"\" threshold: 0 pubkeys: [] Importing a private key generated from the Agent Framework It is also possible to import private keys from the agent framework. For example the private key that you generated for your agent as part of the AW-1 challenge. To import this key into the local keychain simply run the following command: fetchcli keys import --agent-raw-key <name of the new key> <path to the key file> For example: fetchcli keys import --agent-raw-key agent /home/user/fetchai_private_key.txt Note The --agent-raw-key flag is very important here. Also note that this flag only allows the user to import scep265k1 private keys","title":"Keys"},{"location":"ledger_v2/cli-keys/#cli-managing-keys","text":"Managing your keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys.","title":"CLI - Managing Keys"},{"location":"ledger_v2/cli-keys/#adding-keys","text":"To create a new local key you need run the following command: fetchcli keys add <your_key_name> Note These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device After running the command fetchcli will print out a summary of the new key. An example of this output is shown below: - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account (keep this safe, if ever used to control main-net tokens).","title":"Adding keys"},{"location":"ledger_v2/cli-keys/#looking-up-an-address","text":"A common operation that you will want to do is to lookup the address for a specified key. This can be done quickly using the following command: fetchcli keys show -a <name of key> An example of the expected output is shown below: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 A less common operation, but still useful, would be to lookup the public key for a specified key. The can be achieved with the following command: fetchcli keys show -p <name of the key> An example of the expected output is shown below: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx","title":"Looking up an address"},{"location":"ledger_v2/cli-keys/#listing-keys","text":"To lookup more detailed information for all keys on your system use the following command: fetchcli keys list This will output all of your keys information in a yaml format that is similar to the one generated when you first created the key. - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: []","title":"Listing keys"},{"location":"ledger_v2/cli-keys/#hardware-wallets","text":"","title":"Hardware Wallets"},{"location":"ledger_v2/cli-keys/#setup","text":"We recommend hardware wallets as a solution for managing private keys. The Fetch v2.0 ledger is compatible with Ledger Nano devices. To use your Ledger Nano you will need to complete the following steps: Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged. Connect your device to your PC and update the firmware to the latest version using the Ledger Live application. Install the Cosmos application using the software manager (Manager > Cosmos > Install).","title":"Setup"},{"location":"ledger_v2/cli-keys/#adding-a-new-key","text":"In order to use the hardware wallet address with the cli, the user must first add it via fetchcli . This process only records the public information about the key. To import the key first plug in the device and enter the device pin. Once you have unlocked the device navigate to the Cosmos app on the device and open it. To add the key use the following command: fetchcli keys add <name for the key> --ledger --index 0 Note The --ledger flag tells the command line tool to talk to the ledger device and the --index flag selects which HD index should be used. When running this command, the Ledger device will prompt you to verify the genereated address. Once you have done this you will get an output in the following form: - name: hw1 type: ledger address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2 pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h mnemonic: \"\" threshold: 0 pubkeys: []","title":"Adding a new key"},{"location":"ledger_v2/cli-keys/#importing-a-private-key-generated-from-the-agent-framework","text":"It is also possible to import private keys from the agent framework. For example the private key that you generated for your agent as part of the AW-1 challenge. To import this key into the local keychain simply run the following command: fetchcli keys import --agent-raw-key <name of the new key> <path to the key file> For example: fetchcli keys import --agent-raw-key agent /home/user/fetchai_private_key.txt Note The --agent-raw-key flag is very important here. Also note that this flag only allows the user to import scep265k1 private keys","title":"Importing a private key generated from the Agent Framework"},{"location":"ledger_v2/cli-tokens/","text":"CLI - Managing Tokens Querying your balance Once the wasm is configured for the desired network . The user can query there balance using the following command: fetchcli query account fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 If the address exists on the network then the user will expect to see an output in the following form: address: fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 coins: - denom: atestfet amount: \"1000000000000000000\" public_key: \"\" account_number: 20472 sequence: 0 Sending funds To send funds from one address to another address then you would use the tx send subcommand. As shown below: ./build/fetchcli tx send <from address or key name> <target address> <amount> In a more concrete example if the user wanted to send 100atestfet from main key/address to fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp then the following command would be used. ./build/fetchcli tx send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet When you run the command you will get a similar output and prompt. The user can check the details of the transfer and then press 'y' to confirm the transfer. {\"chain_id\":\"agent-land\",\"account_number\":\"20472\",\"sequence\":\"0\",\"fee\":{\"amount\":[],\"gas\":\"200000\"},\"msgs\":[{\"type\":\"cosmos-sdk/MsgSend\",\"value\":{\"from_address\":\"fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4\",\"to_address\":\"fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp\",\"amount\":[{\"denom\":\"atestfet\",\"amount\":\"100\"}]}}],\"memo\":\"\"} confirm transaction before signing and broadcasting [y/N]: y Once the transfer has been made a summary is presented to the user. An example is shown below: height: 0 txhash: CA7C2C842F8F577E9621C2B23A016D93B979AC1A45015807799C5AD959503FA4 codespace: \"\" code: 0 data: \"\" rawlog: '[]' logs: [] info: \"\" gaswanted: 0 gasused: 0 tx: null timestamp: \"\"","title":"Tokens"},{"location":"ledger_v2/cli-tokens/#cli-managing-tokens","text":"","title":"CLI - Managing Tokens"},{"location":"ledger_v2/cli-tokens/#querying-your-balance","text":"Once the wasm is configured for the desired network . The user can query there balance using the following command: fetchcli query account fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 If the address exists on the network then the user will expect to see an output in the following form: address: fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 coins: - denom: atestfet amount: \"1000000000000000000\" public_key: \"\" account_number: 20472 sequence: 0","title":"Querying your balance"},{"location":"ledger_v2/cli-tokens/#sending-funds","text":"To send funds from one address to another address then you would use the tx send subcommand. As shown below: ./build/fetchcli tx send <from address or key name> <target address> <amount> In a more concrete example if the user wanted to send 100atestfet from main key/address to fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp then the following command would be used. ./build/fetchcli tx send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet When you run the command you will get a similar output and prompt. The user can check the details of the transfer and then press 'y' to confirm the transfer. {\"chain_id\":\"agent-land\",\"account_number\":\"20472\",\"sequence\":\"0\",\"fee\":{\"amount\":[],\"gas\":\"200000\"},\"msgs\":[{\"type\":\"cosmos-sdk/MsgSend\",\"value\":{\"from_address\":\"fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4\",\"to_address\":\"fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp\",\"amount\":[{\"denom\":\"atestfet\",\"amount\":\"100\"}]}}],\"memo\":\"\"} confirm transaction before signing and broadcasting [y/N]: y Once the transfer has been made a summary is presented to the user. An example is shown below: height: 0 txhash: CA7C2C842F8F577E9621C2B23A016D93B979AC1A45015807799C5AD959503FA4 codespace: \"\" code: 0 data: \"\" rawlog: '[]' logs: [] info: \"\" gaswanted: 0 gasused: 0 tx: null timestamp: \"\"","title":"Sending funds"},{"location":"ledger_v2/docker-images/","text":"Docker Images For every Fetchd release a corresponding docker images is released. The full list of images and tags can be found at: https://hub.docker.com/r/fetchai/fetchd","title":"Docker Images"},{"location":"ledger_v2/docker-images/#docker-images","text":"For every Fetchd release a corresponding docker images is released. The full list of images and tags can be found at: https://hub.docker.com/r/fetchai/fetchd","title":"Docker Images"},{"location":"ledger_v2/faucet/","text":"Token Faucet For the main agent land network we have a simple token faucet implemented to allow users of the network to get started quickly. Token Faucets are network specific, depending on the network type they may or may not be deployed. Please check the networks page for specific details. The Token Faucet itself is a HTTP REST API and interaction is shown below: Making a token claim request A user must first submit a token claim request to the faucet. This request can be either URL encoded or JSON encoded. Both examples are shown below: URL: POST /claim/requests URL Encoded Headers The request must include the following headers: 'Content-Type: application/x-www-form-urlencoded cURL example curl -d 'Address=fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2' -H \"Content-Type: application/x-www-form-urlencoded\" -X POST http://127.0.0.1:5000/claim/requests JSON Encoded Headers The request must include the following headers: 'Content-Type: application/json cURL example curl -d '{\"Address\":\"fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5000/claim/requests Response In either submission case, upon successful register the API will respond with the request UID { \"uid\" : \"123e4567-e89b-12d3-a456-426614174000\" } Querying the status of a token claim request To query the status of the your token claim request the following API can be used URL: GET /claim/requests/<uid> cURL example curl http://127.0.0.1:5000/claim/requests/1a472a27-7225-4409-92be-4efd3beed995 This will respond with the status of the request claim. If the claim was successful then JSON response will resemble the following: { \"txDigest\" : \"9CA3A7D3614A37C1BB2EA6B746B402CF68D3E5A4CEBFFE1D7ADF212876DAE70B\" , \"status\" : \"completed\" , \"statusCode\" : 20 , \"lastUpdated\" : \"2020-08-11T09:48:04.596522\" } Rate limiting To prevent malicious actors, this API is rate limited and will block requests if the limits are passed. In this case the user must wait and then try again.","title":"Faucet"},{"location":"ledger_v2/faucet/#token-faucet","text":"For the main agent land network we have a simple token faucet implemented to allow users of the network to get started quickly. Token Faucets are network specific, depending on the network type they may or may not be deployed. Please check the networks page for specific details. The Token Faucet itself is a HTTP REST API and interaction is shown below:","title":"Token Faucet"},{"location":"ledger_v2/faucet/#making-a-token-claim-request","text":"A user must first submit a token claim request to the faucet. This request can be either URL encoded or JSON encoded. Both examples are shown below: URL: POST /claim/requests","title":"Making a token claim request"},{"location":"ledger_v2/faucet/#url-encoded","text":"Headers The request must include the following headers: 'Content-Type: application/x-www-form-urlencoded cURL example curl -d 'Address=fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2' -H \"Content-Type: application/x-www-form-urlencoded\" -X POST http://127.0.0.1:5000/claim/requests","title":"URL Encoded"},{"location":"ledger_v2/faucet/#json-encoded","text":"Headers The request must include the following headers: 'Content-Type: application/json cURL example curl -d '{\"Address\":\"fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5000/claim/requests","title":"JSON Encoded"},{"location":"ledger_v2/faucet/#response","text":"In either submission case, upon successful register the API will respond with the request UID { \"uid\" : \"123e4567-e89b-12d3-a456-426614174000\" }","title":"Response"},{"location":"ledger_v2/faucet/#querying-the-status-of-a-token-claim-request","text":"To query the status of the your token claim request the following API can be used URL: GET /claim/requests/<uid> cURL example curl http://127.0.0.1:5000/claim/requests/1a472a27-7225-4409-92be-4efd3beed995 This will respond with the status of the request claim. If the claim was successful then JSON response will resemble the following: { \"txDigest\" : \"9CA3A7D3614A37C1BB2EA6B746B402CF68D3E5A4CEBFFE1D7ADF212876DAE70B\" , \"status\" : \"completed\" , \"statusCode\" : 20 , \"lastUpdated\" : \"2020-08-11T09:48:04.596522\" }","title":"Querying the status of a token claim request"},{"location":"ledger_v2/faucet/#rate-limiting","text":"To prevent malicious actors, this API is rate limited and will block requests if the limits are passed. In this case the user must wait and then try again.","title":"Rate limiting"},{"location":"ledger_v2/governance/","text":"Governance In order to be able to take part in the governance you either need to be running a full validator node or you need to have have delegated stake to an existing validator Stake Delegation In order to delegate stake to a validator the following command should be used: fetchcli tx staking delegate <VALOPER_ADDRESS> <AMOUNT> --from <KEY_NAME> Where the <VALOPER_ADDRESS> begins with the prefix fetchvaloper1... and the <AMOUNT> field contains the currency denomination. For example: fetchcli tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent Proposals Overview There are three types of proposal: Text Proposals : These are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic. Parameter Proposals : These proposals are used to update the value of an existing software parameter of the network. Software Upgrade Proposals : These are used to propose an upgrade of the fetchd software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network. The Proposal Process Any FET holder can submit a proposal. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called minDeposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit period status. Then, any FET holder can increase the deposit by sending a depositTx transaction to the network. Once the deposit reaches minDeposit , the proposal enters the voting period , which lasts 2 weeks. Any bonded FET holder can then cast a vote on this proposal. The user has the following options for voting: Yes No NoWithVeto Abstain At the end of the voting period, the proposal is accepted if there are more than 50% Yes votes (excluding Abstain votes) and less than 33.33% of NoWithVeto votes (excluding Abstain votes). Generating Proposals When creating a proposal, the user will create a proposal JSON file with all the relevant information. An example of a text proposal is shown below: { \"title\" : \"Switch to semantic commit messages for fetchd\" , \"description\" : \"This proposal is advocating a switch to sematic commit messages\\nYou can find the full discussion here: https://github.com/fetchai/fetchd/issues/231\" , \"type\" : \"Text\" , \"deposit\" : \"10000000000000000000atestfet\" } It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it. Once the user has created the JSON file, to generate the text propsal on chain run the following command: fetchcli tx gov submit-proposal --proposal proposal.json --from <name of signing key> Increasing the deposit for a proposal If a user wants to increase the deposit of a proposal they would run the following command: fetchcli tx gov deposit <proposalID> 100atestfet --from <key name> For example: fetchcli tx gov deposit 2 100atestfet --from validator Listing current proposals Current proposals are visible from the block explorer and using the CLI. To get the list of current proposals and their corresponding proposal-ids the run the following command: fetchcli query gov proposals Voting on a proposal To vote for a proposal run the following command fetchcli tx gov vote <proposalID> <option> --from <delegatorKeyName> For example: fetchcli tx gov vote 5 yes --from validator Note When using CLI commands make sure that your CLI is pointing at the correct network. See the CLI introduction documentation for more details","title":"Governance"},{"location":"ledger_v2/governance/#governance","text":"In order to be able to take part in the governance you either need to be running a full validator node or you need to have have delegated stake to an existing validator","title":"Governance"},{"location":"ledger_v2/governance/#stake-delegation","text":"In order to delegate stake to a validator the following command should be used: fetchcli tx staking delegate <VALOPER_ADDRESS> <AMOUNT> --from <KEY_NAME> Where the <VALOPER_ADDRESS> begins with the prefix fetchvaloper1... and the <AMOUNT> field contains the currency denomination. For example: fetchcli tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent","title":"Stake Delegation"},{"location":"ledger_v2/governance/#proposals-overview","text":"There are three types of proposal: Text Proposals : These are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic. Parameter Proposals : These proposals are used to update the value of an existing software parameter of the network. Software Upgrade Proposals : These are used to propose an upgrade of the fetchd software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network.","title":"Proposals Overview"},{"location":"ledger_v2/governance/#the-proposal-process","text":"Any FET holder can submit a proposal. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called minDeposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit period status. Then, any FET holder can increase the deposit by sending a depositTx transaction to the network. Once the deposit reaches minDeposit , the proposal enters the voting period , which lasts 2 weeks. Any bonded FET holder can then cast a vote on this proposal. The user has the following options for voting: Yes No NoWithVeto Abstain At the end of the voting period, the proposal is accepted if there are more than 50% Yes votes (excluding Abstain votes) and less than 33.33% of NoWithVeto votes (excluding Abstain votes).","title":"The Proposal Process"},{"location":"ledger_v2/governance/#generating-proposals","text":"When creating a proposal, the user will create a proposal JSON file with all the relevant information. An example of a text proposal is shown below: { \"title\" : \"Switch to semantic commit messages for fetchd\" , \"description\" : \"This proposal is advocating a switch to sematic commit messages\\nYou can find the full discussion here: https://github.com/fetchai/fetchd/issues/231\" , \"type\" : \"Text\" , \"deposit\" : \"10000000000000000000atestfet\" } It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it. Once the user has created the JSON file, to generate the text propsal on chain run the following command: fetchcli tx gov submit-proposal --proposal proposal.json --from <name of signing key>","title":"Generating Proposals"},{"location":"ledger_v2/governance/#increasing-the-deposit-for-a-proposal","text":"If a user wants to increase the deposit of a proposal they would run the following command: fetchcli tx gov deposit <proposalID> 100atestfet --from <key name> For example: fetchcli tx gov deposit 2 100atestfet --from validator","title":"Increasing the deposit for a proposal"},{"location":"ledger_v2/governance/#listing-current-proposals","text":"Current proposals are visible from the block explorer and using the CLI. To get the list of current proposals and their corresponding proposal-ids the run the following command: fetchcli query gov proposals","title":"Listing current proposals"},{"location":"ledger_v2/governance/#voting-on-a-proposal","text":"To vote for a proposal run the following command fetchcli tx gov vote <proposalID> <option> --from <delegatorKeyName> For example: fetchcli tx gov vote 5 yes --from validator Note When using CLI commands make sure that your CLI is pointing at the correct network. See the CLI introduction documentation for more details","title":"Voting on a proposal"},{"location":"ledger_v2/networks/","text":"Networks Agent Land Agent Land is our stable, public testnet for the Fetch Ledger v2. As such most developers will be interacting with this testnet. This is specifically designed and supported for autonomous economic agent development. There are other testnets, such as those supporting our unique DRB (decentralized random beacon) and other exciting technologies. When we come to the mainnet, all of these testnets will become one: a single network supporting all the new features. Parameter Value Chain ID agent-land Denomination atestfet Decimals 18 Version v0.2.x RPC Endpoint https://rpc-agent-land.fetch.ai:443 REST Endpoint https://rest-agent-land.fetch.ai:443 Block Explorer https://explore-agent-land.fetch.ai Token Faucet Use block explorer You can read more detailed information on Github . Incentivized Testnet Phase 1: Agent World The Agent World incentivized test network is phase 1 of our journey to Mainnet v2. Check out the Incentivised Testnets for more information. Parameter Value Chain ID agentworld-1 Denomination atestfet Decimals 18 Version v0.2.x RPC Endpoint https://rpc-agentworld.fetch.ai:443 REST Endpoint https://rest-agentworld.fetch.ai:443 Block Explorer https://explore-agentworld.fetch.ai/ Token Faucet n/a Incentivized Testnet Phase 2: Beacon World Currently, Beacon World network is invite only. It will be open to all developers when we reach phase 2 of the incentivized testnet. If you have a specific need to participate in it earlier, please do contact us at developer@fetch.ai . Parameter Value Chain ID beaconworld-1 Denomination atestfet Decimals 18 Version v0.3.x RPC Endpoint n/a REST Endpoint n/a Block Explorer n/a Token Faucet n/a","title":"Networks"},{"location":"ledger_v2/networks/#networks","text":"","title":"Networks"},{"location":"ledger_v2/networks/#agent-land","text":"Agent Land is our stable, public testnet for the Fetch Ledger v2. As such most developers will be interacting with this testnet. This is specifically designed and supported for autonomous economic agent development. There are other testnets, such as those supporting our unique DRB (decentralized random beacon) and other exciting technologies. When we come to the mainnet, all of these testnets will become one: a single network supporting all the new features. Parameter Value Chain ID agent-land Denomination atestfet Decimals 18 Version v0.2.x RPC Endpoint https://rpc-agent-land.fetch.ai:443 REST Endpoint https://rest-agent-land.fetch.ai:443 Block Explorer https://explore-agent-land.fetch.ai Token Faucet Use block explorer You can read more detailed information on Github .","title":"Agent Land"},{"location":"ledger_v2/networks/#incentivized-testnet-phase-1-agent-world","text":"The Agent World incentivized test network is phase 1 of our journey to Mainnet v2. Check out the Incentivised Testnets for more information. Parameter Value Chain ID agentworld-1 Denomination atestfet Decimals 18 Version v0.2.x RPC Endpoint https://rpc-agentworld.fetch.ai:443 REST Endpoint https://rest-agentworld.fetch.ai:443 Block Explorer https://explore-agentworld.fetch.ai/ Token Faucet n/a","title":"Incentivized Testnet Phase 1: Agent World"},{"location":"ledger_v2/networks/#incentivized-testnet-phase-2-beacon-world","text":"Currently, Beacon World network is invite only. It will be open to all developers when we reach phase 2 of the incentivized testnet. If you have a specific need to participate in it earlier, please do contact us at developer@fetch.ai . Parameter Value Chain ID beaconworld-1 Denomination atestfet Decimals 18 Version v0.3.x RPC Endpoint n/a REST Endpoint n/a Block Explorer n/a Token Faucet n/a","title":"Incentivized Testnet Phase 2: Beacon World"},{"location":"ledger_v2/python-examples/","text":"Python examples using Agent Land In this section, we look at some Python that you can use to create addresses, fund them, and submit transactions to the network. It's super-simple to do: from aea.crypto.fetchai import FetchAICrypto , FetchAIApi , FetchAIFaucetApi # Get a new address: fetch_crypto = FetchAICrypto () address = fetch_crypto # This is relatively slow, so if you need to stock up a number of # addresses, it\u2019s best to get it ONCE, then distribute yourself: # for rapid tests: FetchAIFaucetApi () . get_wealth ( address ) balance = FetchAIApi () . get_balance ( address ) print ( f \u201d Our address { address } has a balance of { balance } \u201d ) As you can see, it\u2019s pretty straightforward. The above works in standalone code, and is supported in the agent framework. Here is a code fragment that shows the construction, signing and submission of a transaction: from aea.crypto.fetchai import FetchAICrypto , FetchAIApi , FetchAIFaucetApi # ... code, etc... def test_construct_sign_and_submit_transfer_transaction (): \"\"\"Test the construction, signing and submitting of a transfer transaction.\"\"\" account = FetchAICrypto () balance = get_wealth ( account . address ) assert balance > 0 , \"Failed to fund account.\" fc2 = FetchAICrypto () fetchai_api = FetchAIApi ( ** FETCHAI_TESTNET_CONFIG ) amount = 10000 assert amount < balance , \"Not enough funds.\" transfer_transaction = fetchai_api . get_transfer_transaction ( sender_address = account . address , destination_address = fc2 . address , amount = amount , tx_fee = 1000 , tx_nonce = \"something\" , ) assert ( isinstance ( transfer_transaction , dict ) and len ( transfer_transaction ) == 6 ), \"Incorrect transfer_transaction constructed.\" signed_transaction = account . sign_transaction ( transfer_transaction ) assert ( isinstance ( signed_transaction , dict ) and len ( signed_transaction [ \"tx\" ]) == 4 and isinstance ( signed_transaction [ \"tx\" ][ \"signatures\" ], list ) ), \"Incorrect signed_transaction constructed.\" transaction_digest = fetchai_api . send_signed_transaction ( signed_transaction ) assert transaction_digest is not None , \"Failed to submit transfer transaction!\" # Now let's wait around for a while for this transaction to go through\" not_settled = True elapsed_time = 0 while not_settled and elapsed_time < 20 : elapsed_time += 1 time . sleep ( 2 ) transaction_receipt = fetchai_api . get_transaction_receipt ( transaction_digest ) if transaction_receipt is None : continue is_settled = fetchai_api . is_transaction_settled ( transaction_receipt ) not_settled = not is_settled assert transaction_receipt is not None , \"Failed to retrieve transaction receipt.\" assert is_settled , \"Failed to verify tx!\" tx = fetchai_api . get_transaction ( transaction_digest ) is_valid = fetchai_api . is_transaction_valid ( tx , fc2 . address , account . address , \"\" , amount ) assert is_valid , \"Failed to settle tx correctly!\" assert tx == transaction_receipt , \"Should be same!\"","title":"Python Examples"},{"location":"ledger_v2/python-examples/#python-examples-using-agent-land","text":"In this section, we look at some Python that you can use to create addresses, fund them, and submit transactions to the network. It's super-simple to do: from aea.crypto.fetchai import FetchAICrypto , FetchAIApi , FetchAIFaucetApi # Get a new address: fetch_crypto = FetchAICrypto () address = fetch_crypto # This is relatively slow, so if you need to stock up a number of # addresses, it\u2019s best to get it ONCE, then distribute yourself: # for rapid tests: FetchAIFaucetApi () . get_wealth ( address ) balance = FetchAIApi () . get_balance ( address ) print ( f \u201d Our address { address } has a balance of { balance } \u201d ) As you can see, it\u2019s pretty straightforward. The above works in standalone code, and is supported in the agent framework. Here is a code fragment that shows the construction, signing and submission of a transaction: from aea.crypto.fetchai import FetchAICrypto , FetchAIApi , FetchAIFaucetApi # ... code, etc... def test_construct_sign_and_submit_transfer_transaction (): \"\"\"Test the construction, signing and submitting of a transfer transaction.\"\"\" account = FetchAICrypto () balance = get_wealth ( account . address ) assert balance > 0 , \"Failed to fund account.\" fc2 = FetchAICrypto () fetchai_api = FetchAIApi ( ** FETCHAI_TESTNET_CONFIG ) amount = 10000 assert amount < balance , \"Not enough funds.\" transfer_transaction = fetchai_api . get_transfer_transaction ( sender_address = account . address , destination_address = fc2 . address , amount = amount , tx_fee = 1000 , tx_nonce = \"something\" , ) assert ( isinstance ( transfer_transaction , dict ) and len ( transfer_transaction ) == 6 ), \"Incorrect transfer_transaction constructed.\" signed_transaction = account . sign_transaction ( transfer_transaction ) assert ( isinstance ( signed_transaction , dict ) and len ( signed_transaction [ \"tx\" ]) == 4 and isinstance ( signed_transaction [ \"tx\" ][ \"signatures\" ], list ) ), \"Incorrect signed_transaction constructed.\" transaction_digest = fetchai_api . send_signed_transaction ( signed_transaction ) assert transaction_digest is not None , \"Failed to submit transfer transaction!\" # Now let's wait around for a while for this transaction to go through\" not_settled = True elapsed_time = 0 while not_settled and elapsed_time < 20 : elapsed_time += 1 time . sleep ( 2 ) transaction_receipt = fetchai_api . get_transaction_receipt ( transaction_digest ) if transaction_receipt is None : continue is_settled = fetchai_api . is_transaction_settled ( transaction_receipt ) not_settled = not is_settled assert transaction_receipt is not None , \"Failed to retrieve transaction receipt.\" assert is_settled , \"Failed to verify tx!\" tx = fetchai_api . get_transaction ( transaction_digest ) is_valid = fetchai_api . is_transaction_valid ( tx , fc2 . address , account . address , \"\" , amount ) assert is_valid , \"Failed to settle tx correctly!\" assert tx == transaction_receipt , \"Should be same!\"","title":"Python examples using Agent Land"},{"location":"ledger_v2/versions/","text":"Versions There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions Version Maturity Description v0.2.x Stable This is our mainline stable version of the network to support agent development v0.3.x Beta Builds upon our stable release and adds support for the random beacon consensus module v0.4.x Alpha Builds upon the random beacon consensus and adds support for aggregated signatures","title":"Versions"},{"location":"ledger_v2/versions/#versions","text":"There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions Version Maturity Description v0.2.x Stable This is our mainline stable version of the network to support agent development v0.3.x Beta Builds upon our stable release and adds support for the random beacon consensus module v0.4.x Alpha Builds upon the random beacon consensus and adds support for aggregated signatures","title":"Versions"}]}