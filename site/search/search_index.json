{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Fetch.AI documentation. Getting Started Build and install the Fetch.AI ledger constellation, etch vm, and all the libraries you need. Get hold of the Fetch.AI Python Ledger API for smart contract creation. Spin up the Fetch.AI Open Economic Framework. Open Economic Framework Learn how to create decentralised autonomous agents and interface them to the digital world. Learn how to negotiate with other autonomous agents and get things done. etch Language Guide Learn how to code in etch , the Turing complete scripting language for smart contracts running on the Fetch.AI ledger. Smart Contracts Smart contracts written in etch run with the Python Ledger API. This section has everything you need to know about running smart contracts on the Fetch.AI ledger. Tutorials Here you will find a growing list of tutorials on building smart contracts. Feel free to submit your own tutorial.","title":"Welcome to the <a href=\"https://fetch.ai/\" target=_blank>Fetch.AI</a> documentation."},{"location":"#welcome-to-the-fetchai-documentation","text":"Getting Started Build and install the Fetch.AI ledger constellation, etch vm, and all the libraries you need. Get hold of the Fetch.AI Python Ledger API for smart contract creation. Spin up the Fetch.AI Open Economic Framework. Open Economic Framework Learn how to create decentralised autonomous agents and interface them to the digital world. Learn how to negotiate with other autonomous agents and get things done. etch Language Guide Learn how to code in etch , the Turing complete scripting language for smart contracts running on the Fetch.AI ledger. Smart Contracts Smart contracts written in etch run with the Python Ledger API. This section has everything you need to know about running smart contracts on the Fetch.AI ledger. Tutorials Here you will find a growing list of tutorials on building smart contracts. Feel free to submit your own tutorial.","title":"Welcome to the Fetch.AI"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( Hello World, how are you? ( + toString ( i ) + ) ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = ; if ( colourIndex 2 ) insertCharacter = ; elseif ( colourIndex 8 ) insertCharacter = ; elseif ( colourIndex 20 ) insertCharacter = * ; else insertCharacter = @ ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( Hello World, how are you? ( + toString ( i ) + ) ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = ; if ( colourIndex 2 ) insertCharacter = ; elseif ( colourIndex 8 ) insertCharacter = ; elseif ( colourIndex 20 ) insertCharacter = * ; else insertCharacter = @ ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI Constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.AI ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Please note: The etch language and the etch language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"What's etch?"},{"location":"etch-language/ML-AI/","text":"Machine learning and AI Note Coming soon: Tensors. Graphs. Graph operations (MatMul, convolution, etc.). Activations (relu, sigmoid, softmax, etc.). Loss Functions (MeanSquareError, CrossEntropy, KLDivergence, etc.). DataLoaders.","title":"Machine learning and AI"},{"location":"etch-language/addresses/","text":"Address The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK). And in etch , you can instantiate an Address like this: function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); endfunction SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Addresses"},{"location":"etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"etch-language/arrays/","text":"Arrays Warning Array ranges are wholly inclusive in etch . One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print one element of the array printLn ( toString ( myArray [ 3 ])); // print ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // print descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction Two dimensional arrays Declare a 4x4 2d array like this: function main () // build a 4x4 grid var grid = Array Array Int32 ( 4 ); for ( row in 0 : 3 ) grid [ row ] = Array Int32 ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : 3 ) for ( column in 0 : 3 ) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports arrays of arrays of arrays, etc. function main () var ref_array = Array Array Array String ( 2 ); ref_array [ 0 ] = Array Array String ( 2 ); ref_array [ 1 ] = Array Array String ( 2 ); ref_array [ 0 ][ 0 ] = Array String ( 1 ); ref_array [ 0 ][ 1 ] = Array String ( 1 ); ref_array [ 1 ][ 0 ] = Array String ( 2 ); ref_array [ 1 ][ 1 ] = Array String ( 2 ); endfunction Utility functions You can use the following utility functions to manipulate arrays: count() append() extend() popBack() and popFront() reverse() erase() Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array Int32 ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array Array UInt32 ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array UInt32 ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append( hello ); // error: unable to find matching function for append printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array Array Int32 ( 3 ); var count = 1 ; for ( i in 0 : 2 ) my2dArray [ i ] = Array Int32 ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( ); my2dArray . append ( Array Int32 ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : 3 ) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order. Array types must be the same. function main () var data1 = Array Int32 ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array Int32 ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array. Fails if the array is empty. function main () var myArray = Array Int32 ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + removed from the end of myArray ); printLn (( toString ( frontItem )) + removed from the start of myArray ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array Array Int32 ( 3 ); var count = 1 ; for ( i in 0 : 2 ) my2dArray [ i ] = Array Int32 ( 3 ); for ( j in 0 : 2 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( Remove back and front arrays ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( Left with ); for ( row in 0 : my2dArray . count () - 1 ) printLn ( my2dArray [ row ]); endfor endfunction Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( Items removed from end: ); printLn ( backItems ); printLn ( Items removed from start: ); printLn ( frontItems ); printLn ( Remaining array: ); printLn ( myArray ); endfunction function main () var my2dArray = Array Array Int32 ( 5 ); var count = 11 ; for ( i in 0 : 4 ) my2dArray [ i ] = Array Int32 ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); var frontArray = my2dArray . popFront ( 2 ); printLn ( Removed back arrays: ); for ( k in 0 : 1 ) printLn ( backArray [ k ]); endfor printLn ( Removed front arrays: ); for ( l in 0 : 1 ) printLn ( frontArray [ l ]); endfor printLn ( Remaining array(s) : ) ; for ( m in 0 : 0 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array Int32 ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array Array Int32 ( 5 ); var count = 101 ; for ( i in 0 : 4 ) my2dArray [ i ] = Array Int32 ( 5 ); for ( j in 0 : 4 ) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( Reversed: ); for ( k in 0 : 4 ) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print one element of the array printLn ( toString ( myArray [ 3 ])); // print ascending for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor // print descending for ( j in 4 : 0 :- 1 ) printLn ( toString ( myArray [ j ])); endfor endfunction","title":"One dimensional arrays"},{"location":"etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 2d array like this: function main () // build a 4x4 grid var grid = Array Array Int32 ( 4 ); for ( row in 0 : 3 ) grid [ row ] = Array Int32 ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : 3 ) for ( column in 0 : 3 ) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"etch-language/arrays/#nested-arrays","text":"etch supports arrays of arrays of arrays, etc. function main () var ref_array = Array Array Array String ( 2 ); ref_array [ 0 ] = Array Array String ( 2 ); ref_array [ 1 ] = Array Array String ( 2 ); ref_array [ 0 ][ 0 ] = Array String ( 1 ); ref_array [ 0 ][ 1 ] = Array String ( 1 ); ref_array [ 1 ][ 0 ] = Array String ( 2 ); ref_array [ 1 ][ 1 ] = Array String ( 2 ); endfunction","title":"Nested arrays"},{"location":"etch-language/arrays/#utility-functions","text":"You can use the following utility functions to manipulate arrays: count() append() extend() popBack() and popFront() reverse() erase()","title":"Utility functions"},{"location":"etch-language/control-flow/","text":"Control flow Warning Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( they are equal ); elseif ( x y ) printLn ( x is more than y ); else if ( x y ) printLn ( x is more than y ); else printLn ( y is more than x ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State Int32 ( account1 ); var y = State Int32 ( account2 ); x . set ( 5 ); y . set ( 8 ); if ( x . get () y . get ()) printLn ( object x is greater than object y ); else printLn ( object x is less than or equal to object y ); endif endfunction while function main () var i = 0 ; while ( i 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for Warning for loop range is inclusive. function main () // ascending printLn ( Ascending and inclusive for loop ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( Descending and inclusive for loop ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( Ascending and inclusive stepwise ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( Descending and inclusive stepwise ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( they are equal ); elseif ( x y ) printLn ( x is more than y ); else if ( x y ) printLn ( x is more than y ); else printLn ( y is more than x ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State Int32 ( account1 ); var y = State Int32 ( account2 ); x . set ( 5 ); y . set ( 8 ); if ( x . get () y . get ()) printLn ( object x is greater than object y ); else printLn ( object x is less than or equal to object y ); endif endfunction","title":"if-else"},{"location":"etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"etch-language/control-flow/#for","text":"Warning for loop range is inclusive. function main () // ascending printLn ( Ascending and inclusive for loop ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // descending printLn ( Descending and inclusive for loop ); for ( j in 5 : 0 :- 1 ) printLn ( toString ( j )); endfor // stepwise ascent printLn ( Ascending and inclusive stepwise ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor // stepwise descent printLn ( Descending and inclusive stepwise ); for ( l in 10 : 0 :- 2 ) printLn ( toString ( l )); endfor endfunction","title":"for"},{"location":"etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. function main () // create a SHA256 object var sha_obj = SHA256 (); // finalise and print it var print_sha = s . final (); printLn ( toString ( print_sha )); endfunction Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( hello ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings into the context object. function main () var my_string_value_1 = sdkjfhiuwehfesdfno ; s ; mADF ; LK ; var my_string_value_2 = ipoiuwr8934jklnwlkj0892;m ; var my_string_value_3 = vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548 ; // create a SHA256() context object var sha256_hasher_context = SHA256 (); // give it your strings sha256_hasher_context . update ( my_string_value_1 ); sha256_hasher_context . update ( my_string_value_2 ); sha256_hasher_context . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hasher_context . final (); printLn ( Hash of my concatenated string 1,2,3 = + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hasher_context . reset (); // more strings var my_string_value_4 = 12345fg ; var my_string_value_5 = @!#$@#%# ; var my_string_value_6 = {}: L$%^:c ; // add to context sha256_hasher_context . update ( my_string_value_4 ); sha256_hasher_context . update ( my_string_value_5 ); sha256_hasher_context . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hasher_context . final (); printLn ( Hash of my concatenated string 4,5,6 = + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the etch compiler will strip out printLn() statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions - awaiting clarification . Member access support issues with dot operator - awaiting clarification . while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give us access to compiler argument count and values. In the following code, first we print the number of compiler arguments, then we list them. function main () var message : String ; printLn ( System args: + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc () - 1 ) message = toString ( i ) + = + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the vm-lang executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./vm-lang sysargs-examples.etch -- hello You should see the following output: F E \u2571 vm - lang v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / vm - lang 1 = hello etch features like this are useful for experimentation and debugging in a dev environment. For example, you can use these system arguments to load machine learning training data. System arguments should not be included in smart contract code. For smart contracts, there are more flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"etch-language/error-checking/","text":"Forcing runtime errors You can force runtime errors with panic() . Use panic for unrecoverable states. It terminates the progam immediately and provides optional feedback. For example: function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( this is a terrible mistake! ); endif printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending etch in C++.","title":"Extending etch in C++"},{"location":"etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( hello ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n = 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array Int32 ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array Int32 ) // value = Array Int32 ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with accessing the internal state of object types such as Array . function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array Int32 ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array String ( 2 ); myArray [ 0 ] = hello ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array String ) var newArray = Array String ( 2 ); newArray = myArray ; newArray [ 0 ] = goodbye ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Often, if the variable is a string, you don't have to cast it before printing, otherwise you should cast it with toString() . Note etch strips out all printLn() statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to vm-lang and their value. These functions are only useful on the etch simulator outside of smart contract development. System.Argc() System.Argv() Tip etch also provides utility functions specifically for manipulating strings and arrays . Type casting functions toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toInt8 ( x ); var z = toInt16 ( x ); var a = toInt32 ( x ); var b = toInt64 ( x ); var c = toUInt8 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); var i = toFixed32 ( x ); var j = toFixed64 ( x ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. Getters and setters Getters and setters are available for State types. set() get()","title":"Functions"},{"location":"etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run from a main() function. In the example below, we declare a function myFunction() and call it from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( hello ); endfunction","title":"Writing a function"},{"location":"etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function will return an Int32 and declares this with : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n = 1 ) return n ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array Int32 ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array Int32 ) // value = Array Int32 ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with accessing the internal state of object types such as Array . function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array Int32 ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array String ( 2 ); myArray [ 0 ] = hello ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array String ) var newArray = Array String ( 2 ); newArray = myArray ; newArray [ 0 ] = goodbye ; endfunction","title":"Pass by reference"},{"location":"etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"etch-language/functions/#type-casting-functions","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toString() For example: function main () var x = 10 ; var y = toInt8 ( x ); var z = toInt16 ( x ); var a = toInt32 ( x ); var b = toInt64 ( x ); var c = toUInt8 ( x ); var d = toUInt16 ( x ); var e = toUInt32 ( x ); var f = toUInt64 ( x ); var g = toFloat32 ( x ); var h = toFloat64 ( x ); var i = toFixed32 ( x ); var j = toFixed64 ( x ); endfunction","title":"Type casting functions"},{"location":"etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts.","title":"Annotations"},{"location":"etch-language/functions/#getters-and-setters","text":"Getters and setters are available for State types. set() get()","title":"Getters and setters"},{"location":"etch-language/getstarted/","text":"Getting started Prerequisites Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here . Installation cd into build folder. Run make vm-lang . Setup cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] filename -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract. Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line. Hello world! Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( Hello world! ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Getting started"},{"location":"etch-language/getstarted/#prerequisites","text":"Get the Fetch.AI ledger code from Git. Full initial installation and build instructions are here .","title":"Prerequisites"},{"location":"etch-language/getstarted/#installation","text":"cd into build folder. Run make vm-lang .","title":"Installation"},{"location":"etch-language/getstarted/#setup","text":"cd into apps/vm-lang . Run ./vm-lang with filename, flags, and arguments: ./vm-lang [options] filename -- [script args] . For example: ./vm-lang hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"etch-language/getstarted/#hello-world","text":"Let\u2019s run our first etch program. Create a new file in the vm-lang directory and save it as hello-world.etch . Add the following code: function main () printLn ( Hello world! ); endfunction Save the file. Run ./vm-lang hello-world.etch . You should see the following output: $ . / vm - lang hello - world . etch F E \u2571 vm - lang v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Hello world!"},{"location":"etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( equal ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( not equal ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y x ) printLn ( less than ); endif if ( y = x ) printLn ( less than or equal to ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x y ) printLn ( more than ); endif if ( x = y ) printLn ( more than or equal to ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f t ) printLn ( true ); else printLn ( false ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( true ); else printLn ( false ); endif endfunction Xor Note Coming soon: support for xor . Short circuiting Currently, we don't short circuit. This may cause unexpected results. function foo () : Bool printLn ( 1 ); return true ; endfunction function bar () : Bool printLn ( 2 ); return false ; endfunction function main () if ( foo () || bar ()) printLn ( 3 ); endif endfunction","title":"Logical operators"},{"location":"etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( equal ); endif endfunction","title":"Equal to"},{"location":"etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( not equal ); endif endfunction","title":"Not equal to"},{"location":"etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y x ) printLn ( less than ); endif if ( y = x ) printLn ( less than or equal to ); endif endfunction","title":"Less than"},{"location":"etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x y ) printLn ( more than ); endif if ( x = y ) printLn ( more than or equal to ); endif endfunction","title":"More than"},{"location":"etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f t ) printLn ( true ); else printLn ( false ); endif endfunction","title":"And"},{"location":"etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( true ); else printLn ( false ); endif endfunction","title":"Or"},{"location":"etch-language/logic/#xor","text":"Note Coming soon: support for xor .","title":"Xor"},{"location":"etch-language/logic/#short-circuiting","text":"Currently, we don't short circuit. This may cause unexpected results. function foo () : Bool printLn ( 1 ); return true ; endfunction function bar () : Bool printLn ( 2 ); return false ; endfunction function main () if ( foo () || bar ()) printLn ( 3 ); endif endfunction","title":"Short circuiting"},{"location":"etch-language/maths-libs/","text":"Maths libraries and functions In the current version, release/v0.5.x , the following maths functions are available: Logarithm Natural log values are currently available for UInt256 types only. function main () var int32 = 32 ; // var logI = int32.logValue(); // error: primitive type Int32 does not support member-access operator var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); // prints -inf endfunction In a future release, log values will be available for all types as well as in base 2 and 10. Absolute value Abs() returns the absolute value of an Int32 or a Float64 . function do_abs ( value : Int32 ) printLn ( Abs of + toString ( value ) + : ); printLn ( toString ( Abs ( value ))); endfunction function do_abs ( value : Float64 ) printLn ( Abs of + toString ( value ) + : ); printLn ( toString ( Abs ( value ))); endfunction function main () // positive int 32 var x_int = 1 ; do_abs ( x_int ); // negative int 32 x_int = - 1 ; do_abs ( x_int ); // positive float 64 var x_float = 0.1123 ; do_abs ( x_float ); // negative float 64 x_float = - 7.151 ; do_abs ( x_float ); endfunction Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = Rand ( 0u8 , 1000u8 ); // error: unable to find matching function for Rand //printLn(toString(randUInt8)); // unpermitted range // var rand_test = Rand(100u16, 0u16); // runtime error: Invalid argument: Rand(a, b) must satisfy a b var randUInt16 = Rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = Rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = Rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = Rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = Rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = Rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = Rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = Rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = Rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction Exponent The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction Power The power function returns the value of the first parameter raised to the second. Currently, the power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction Square root The square root of a number is found with the sqrt() function. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction Trigonometry etch supports trigonometric functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( sin of 1 ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( sin of 0.5 ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( sin of 0 ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( cos of 1 ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( cos of 0.5 ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( cos of 0 ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( tan of 1 ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( tan of 0.5 ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( tan of 0 ); printLn ( toString ( tan ( x ))); endfunction Also ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( asin of 1 ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( asin of 0.5 ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( asin of 0 ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( acos of 1 ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( acos of 0.5 ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( acos of 0 ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( atan of 1 ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( atan of 0.5 ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( atan of 0 ); printLn ( toString ( atan ( x ))); endfunction And hyperbolic functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( sinh of 1 ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( sinh of 0.5 ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( sinh of 0 ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( cosh of 1 ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( cosh of 0.5 ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( cosh of 0 ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( tanh of 1 ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( tanh of 0.5 ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( tanh of 0 ); printLn ( toString ( tanh ( x ))); endfunction And hyperbolic ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( asinh of 1 ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( asinh of 0.5 ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( asinh of 0 ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( acosh of 1 ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( acosh of 0.5 ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( acosh of 0 ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( atanh of 1 ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( atanh of 0.5 ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( atanh of 0 ); printLn ( toString ( atanh ( x ))); endfunction","title":"Maths libraries and functions"},{"location":"etch-language/maths-libs/#logarithm","text":"Natural log values are currently available for UInt256 types only. function main () var int32 = 32 ; // var logI = int32.logValue(); // error: primitive type Int32 does not support member-access operator var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); // prints -inf endfunction In a future release, log values will be available for all types as well as in base 2 and 10.","title":"Logarithm"},{"location":"etch-language/maths-libs/#absolute-value","text":"Abs() returns the absolute value of an Int32 or a Float64 . function do_abs ( value : Int32 ) printLn ( Abs of + toString ( value ) + : ); printLn ( toString ( Abs ( value ))); endfunction function do_abs ( value : Float64 ) printLn ( Abs of + toString ( value ) + : ); printLn ( toString ( Abs ( value ))); endfunction function main () // positive int 32 var x_int = 1 ; do_abs ( x_int ); // negative int 32 x_int = - 1 ; do_abs ( x_int ); // positive float 64 var x_float = 0.1123 ; do_abs ( x_float ); // negative float 64 x_float = - 7.151 ; do_abs ( x_float ); endfunction","title":"Absolute value"},{"location":"etch-language/maths-libs/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = Rand ( 0u8 , 1000u8 ); // error: unable to find matching function for Rand //printLn(toString(randUInt8)); // unpermitted range // var rand_test = Rand(100u16, 0u16); // runtime error: Invalid argument: Rand(a, b) must satisfy a b var randUInt16 = Rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = Rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = Rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = Rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = Rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = Rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = Rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = Rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = Rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction","title":"Random (non deterministic)"},{"location":"etch-language/maths-libs/#exponent","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction","title":"Exponent"},{"location":"etch-language/maths-libs/#power","text":"The power function returns the value of the first parameter raised to the second. Currently, the power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction","title":"Power"},{"location":"etch-language/maths-libs/#square-root","text":"The square root of a number is found with the sqrt() function. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction","title":"Square root"},{"location":"etch-language/maths-libs/#trigonometry","text":"etch supports trigonometric functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( sin of 1 ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( sin of 0.5 ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( sin of 0 ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( cos of 1 ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( cos of 0.5 ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( cos of 0 ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( tan of 1 ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( tan of 0.5 ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( tan of 0 ); printLn ( toString ( tan ( x ))); endfunction Also ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( asin of 1 ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( asin of 0.5 ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( asin of 0 ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( acos of 1 ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( acos of 0.5 ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( acos of 0 ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( atan of 1 ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( atan of 0.5 ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( atan of 0 ); printLn ( toString ( atan ( x ))); endfunction And hyperbolic functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( sinh of 1 ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( sinh of 0.5 ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( sinh of 0 ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( cosh of 1 ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( cosh of 0.5 ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( cosh of 0 ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( tanh of 1 ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( tanh of 0.5 ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( tanh of 0 ); printLn ( toString ( tanh ( x ))); endfunction And hyperbolic ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( asinh of 1 ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( asinh of 0.5 ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( asinh of 0 ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( acosh of 1 ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( acosh of 0.5 ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( acosh of 0 ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( atanh of 1 ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( atanh of 0.5 ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( atanh of 0 ); printLn ( toString ( atanh ( x ))); endfunction","title":"Trigonometry"},{"location":"etch-language/operators/","text":"Operators + += == != ( ) & & - -= < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. = = 6. == != 7. 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. = = 6. == != 7. 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"etch-language/release-notes/","text":"Version 0.5.x Significant changes in this version of the etch virtual machine include the following: Integer type UInt256 included. Fixed point decimal types Fixed32 and Fixed64 included. New map type StructuredData included. Arrays now support the following functions: append() , count() , erase() , extend() , popBack() , popFront() , and reverse() . Strings now support the following functions: find() , length() , reverse() , split() , substr() , and trim() . Support for nested arrays included. Nested arrays allowed in State objects. Mathematical function abs() included. State and ShardedState ojbects improved implementation. SHA256() function included.","title":"Release notes"},{"location":"etch-language/release-notes/#version-05x","text":"Significant changes in this version of the etch virtual machine include the following: Integer type UInt256 included. Fixed point decimal types Fixed32 and Fixed64 included. New map type StructuredData included. Arrays now support the following functions: append() , count() , erase() , extend() , popBack() , popFront() , and reverse() . Strings now support the following functions: find() , length() , reverse() , split() , substr() , and trim() . Support for nested arrays included. Nested arrays allowed in State objects. Mathematical function abs() included. State and ShardedState ojbects improved implementation. SHA256() function included.","title":"Version 0.5.x"},{"location":"etch-language/sharded-state/","text":"Sharded States A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declare a ShardedState in the same way you declare a State : function main () var state = ShardedState Int32 ( account1 ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs to the ShardedState like this: function main () var myShardedState = ShardedState Int32 ( account1 ); myShardedState . set ( sales , 0 i32 ); myShardedState . set ( gross_profit , 0 i32 ); myShardedState . set ( net_profit , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState Int32 ( account1 ); state . set ( sales , 2000000 ); state . set ( gross_profit , 1800000 ); state . set ( net_profit , 1300000 ); endfunction Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. function main () var myShardedState = ShardedState Int32 ( account1 ); myShardedState . set ( sales , 0 i32 ); myShardedState . set ( gross_profit , 0 i32 ); myShardedState . set ( net_profit , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState Int32 ( account1 ); state . set ( sales , 2000000 ); state . set ( gross_profit , 1800000 ); state . set ( net_profit , 1300000 ); endfunction function query_sales () : Int32 var state = ShardedState Int32 ( account1 ); return state . get ( sales , 0 i32 ); endfunction function query_gross_profit () : Int32 var state = ShardedState Int32 ( account1 ); return state . get ( gross_profit , 0 i32 ); endfunction function query_net_profit () : Int32 var state = ShardedState Int32 ( account1 ); return state . get ( net_profit , 0 i32 ); endfunction You can of course create ShardedState types using Address types. function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var myState = ShardedState Int32 ( account ); myState . set ( balance , 100 ); myState . set ( transx1 , - 10 ); myState . set ( transx2 , 30 ); printLn ( My account balance = + toString ( myState . get ( balance ))); endfunction Writing ShardedState data to the ledger Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState Int32 ( account1 ); var y = ShardedState Int32 ( account1 ); x . set ( balance , 100 ); y . set ( balance , - 10 ); printLn ( My state value = + toString ( x . get ( balance ))); endfunction Because ShardedState uses anonymous State types to write data as soon as it is created, we can access values with keys using any var identifier. This makes the ShardedState type much more powerful than a State type.","title":"Sharded State"},{"location":"etch-language/sharded-state/#writing-shardedstate-data-to-the-ledger","text":"Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState Int32 ( account1 ); var y = ShardedState Int32 ( account1 ); x . set ( balance , 100 ); y . set ( balance , - 10 ); printLn ( My state value = + toString ( x . get ( balance ))); endfunction Because ShardedState uses anonymous State types to write data as soon as it is created, we can access values with keys using any var identifier. This makes the ShardedState type much more powerful than a State type.","title":"Writing ShardedState data to the ledger"},{"location":"etch-language/states/","text":"States Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State Int32 ( simple_state_declaration ); var myState2 = State Array Array Array String ( nested_array_state_declaration ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State UInt256 ( contract_amount ); contract_amount_state . set ( supply ); endfunction The above code creates a variable contract_amount_state which is a reference to a State Int32 called contract_amount . It then sets a value on the State . State references can be Address types. function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var supply = UInt256 ( 1000u64 ); var myState = State UInt256 ( account ); myState . set ( supply ); endfunction State references can also be strings and you can get and set values on a State object. function main () var contract_amount_state = State UInt256 ( contract_amount ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( My state value = + toString ( myState . get ())); endfunction Default values If a value has not been set on the State object and it does not already exist on the ledger, a run-time error is thrown on get() . To avoid this, use with care get( default ) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State Int32 ( contract_amount ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State Int32 ( contract_amount ); if ( contract_amount_state . existed ()) printLn ( Yes, it existed ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of who has the tokens. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var ownerState = State Int32 ( owner ); ownerState . set ( 333 ); printLn ( My state value = + toString ( ownerState . get ())); var contractState = State Int32 ( owner ); // printLn( My state value = + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. //The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and this generates a runtime error. Writing State data to the ledger The following is true for State variables with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of scope and the destructor() function has been called behind the scenes. While identifiable State variables remain in function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which do not explicitly call set() . Once control reaches the end of the function, data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var name performs an immediate data write. function main () State String ( account1 ). set ( owner1_name ); var account1 = State String ( account1 ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up with immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the scope they were created in originally has closed. function main () var myState = State Int32 ( contract_owner_balance ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State Int32 ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = balance var anotherState = State Int32 ( balance ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = balance , a value out of scope var myState = State Int32 ( balance ); // returns the 55 set in change_state() return myState . get (); endfunction Similarly, you cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State Int32 ( value ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State Int32 ( value ); return state . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( This address doesn t verify, stopping here. ); endif // Get the authorised address from the ledger var authorised_state = State Address ( owner ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( Incorrect address used to trigger ); endif // ... we re good to go, the signer of the TX is the stored authorised address... endfunction function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var authorised = State Address ( owner ); authorised . set ( owner ); doSomething ( owner ); endfunction","title":"States"},{"location":"etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State Int32 ( simple_state_declaration ); var myState2 = State Array Array Array String ( nested_array_state_declaration ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State UInt256 ( contract_amount ); contract_amount_state . set ( supply ); endfunction The above code creates a variable contract_amount_state which is a reference to a State Int32 called contract_amount . It then sets a value on the State . State references can be Address types. function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var supply = UInt256 ( 1000u64 ); var myState = State UInt256 ( account ); myState . set ( supply ); endfunction State references can also be strings and you can get and set values on a State object. function main () var contract_amount_state = State UInt256 ( contract_amount ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( My state value = + toString ( myState . get ())); endfunction","title":"Introduction to State variables"},{"location":"etch-language/states/#default-values","text":"If a value has not been set on the State object and it does not already exist on the ledger, a run-time error is thrown on get() . To avoid this, use with care get( default ) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State Int32 ( contract_amount ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State Int32 ( contract_amount ); if ( contract_amount_state . existed ()) printLn ( Yes, it existed ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of who has the tokens.","title":"Test a State exists"},{"location":"etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var ownerState = State Int32 ( owner ); ownerState . set ( 333 ); printLn ( My state value = + toString ( ownerState . get ())); var contractState = State Int32 ( owner ); // printLn( My state value = + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. //The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and this generates a runtime error.","title":"State references and scope"},{"location":"etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State variables with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of scope and the destructor() function has been called behind the scenes. While identifiable State variables remain in function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which do not explicitly call set() . Once control reaches the end of the function, data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var name performs an immediate data write. function main () State String ( account1 ). set ( owner1_name ); var account1 = State String ( account1 ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up with immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the scope they were created in originally has closed. function main () var myState = State Int32 ( contract_owner_balance ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State Int32 ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = balance var anotherState = State Int32 ( balance ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = balance , a value out of scope var myState = State Int32 ( balance ); // returns the 55 set in change_state() return myState . get (); endfunction Similarly, you cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State Int32 ( value ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State Int32 ( value ); return state . get (); endfunction","title":"Passing States around"},{"location":"etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( This address doesn t verify, stopping here. ); endif // Get the authorised address from the ledger var authorised_state = State Address ( owner ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( Incorrect address used to trigger ); endif // ... we re good to go, the signer of the TX is the stored authorised address... endfunction function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var authorised = State Address ( owner ); authorised . set ( owner ); doSomething ( owner ); endfunction","title":"Verify an Address"},{"location":"etch-language/strings/","text":"Strings etch supports ASCII for string representation. Concatenation Concatenate strings like this: function main () var myString : String = hello ; var myInferredString = hello again ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + + myString ); // printLn(toString(x)); // error: you cannot print null // var y = myString[0]; // error: currently we do not support index operators for strings endfunction Equality You can test strings for equality. function main () var myString1 : String = hello ; var myString2 : String = hello ; if ( myString1 == myString2 ) printLn ( They are equal. ); else printLn ( They are not equal. ); endif endfunction And inequality. function main () var myString1 : String = hello ; var myString2 : String = again ; if ( myString1 != myString2 ) printLn ( They are not equal. ); else printLn ( They are equal. ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 myString2 ) printLn ( myString1 is less than myString2. ); else printLn ( myString1 is not less than myString2. ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 = myString2 ) printLn ( myString1 is less than or equal to myString2. ); else printLn ( myString1 is not less or equal to than myString2. ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 myString2 ) printLn ( myString1 is greater than or equal to myString2. ); else printLn ( myString1 is not greater than or equal to myString2. ); endif endfunction And greater than or equal to also. function main () var myString1 : String = a ; var myString2 : String = a ; if ( myString1 = myString2 ) printLn ( myString1 is greater than or equal to myString2. ); else printLn ( myString1 is not greater than or equal to myString2. ); endif endfunction Utility functions You can use the following utility functions for string manipulation: find() length() reverse() substr() trim() split() Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = Hello World ; printLn ( myString . find ( o )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = Hello World ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = xyz ; myString . reverse (); printLn ( myString ); endfunction Substr The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( Hello World . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = Hello World ; myString . trim (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = xxx -- yyy -- zzz ; printLn ( text ); var output = text . split ( -- ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Strings"},{"location":"etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = hello ; var myInferredString = hello again ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + + myString ); // printLn(toString(x)); // error: you cannot print null // var y = myString[0]; // error: currently we do not support index operators for strings endfunction","title":"Concatenation"},{"location":"etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = hello ; var myString2 : String = hello ; if ( myString1 == myString2 ) printLn ( They are equal. ); else printLn ( They are not equal. ); endif endfunction And inequality. function main () var myString1 : String = hello ; var myString2 : String = again ; if ( myString1 != myString2 ) printLn ( They are not equal. ); else printLn ( They are equal. ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 myString2 ) printLn ( myString1 is less than myString2. ); else printLn ( myString1 is not less than myString2. ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 = myString2 ) printLn ( myString1 is less than or equal to myString2. ); else printLn ( myString1 is not less or equal to than myString2. ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = a ; var myString2 : String = b ; // with regards to length of string // var myString1 : String = aa ; // var myString2 : String = a ; if ( myString1 myString2 ) printLn ( myString1 is greater than or equal to myString2. ); else printLn ( myString1 is not greater than or equal to myString2. ); endif endfunction And greater than or equal to also. function main () var myString1 : String = a ; var myString2 : String = a ; if ( myString1 = myString2 ) printLn ( myString1 is greater than or equal to myString2. ); else printLn ( myString1 is not greater than or equal to myString2. ); endif endfunction","title":"Equality"},{"location":"etch-language/strings/#utility-functions","text":"You can use the following utility functions for string manipulation: find() length() reverse() substr() trim() split()","title":"Utility functions"},{"location":"etch-language/syntax/","text":"Syntax The etch language was initially integrated with the Fetch.AI C++ ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = hello ; endfunction Assign a value like this: function main () var myvariable : String = hello ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type Type Type (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ; , expected : or = Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on smart contracts .","title":"Syntax"},{"location":"etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = hello ; endfunction Assign a value like this: function main () var myvariable : String = hello ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type Type Type (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ; , expected : or = Failed to compile .","title":"Declarations"},{"location":"etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return","title":"Keywords"},{"location":"etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions in the section on smart contracts .","title":"Annotations"},{"location":"etch-language/variables/","text":"Variables etch is a statically-typed programming language. For good coding practice, you should explicitly declare all variable types. Declare a variable with the keyword var . Declare numeric values with literals where possible. You can also use an explicit type cast operation. See below for explicit type declaration rules. Naming Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at * , expected variable name // var 123 = 5; // error at 123 , expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits (1 to 8 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); // error: unable to find matching function for toString var int8b : Int8 = - 0 i8 ; printLn ( toString ( int8b )); // error: unable to find matching function for toString var int16a = 0 i16 ; printLn ( toString ( int16a )); // error: unable to find matching function for toString var int16b : Int16 = - 1 i16 ; printLn ( toString ( int16b )); // error: unable to find matching function for toString endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; printLn ( toString ( uint8a )); // error: unable to find matching function for toString var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); // error: unable to find matching function for toString var uint16a = 0u16 ; printLn ( toString ( uint16a )); // error: unable to find matching function for toString var uint16b : UInt16 = 1u16 ; printLn ( toString ( uint16b )); // error: unable to find matching function for toString endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction In the current version, UInt256 is built from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction Floats Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); endfunction Fixed Points Fixed point variables are available as Fixed32 and Fixed64 types. You must declare FixedPoint variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = 2.0f p32 ; var fixed64bit = 3.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = hello ; var myInferredString = hello again ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array Type (size) declares an array with elements of type Type and size size . function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this: var myBuffer = Buffer ( 8 ); Maps Declare the dictionary Map type with Map KeyType, ValueType () . function main () var myMap = Map String , Int32 (); myMap [ balance1 ] = 1000 ; myMap [ balance2 ] = 2000 ; myMap [ balance3 ] = 3000 ; printLn ( toString ( myMap [ balance1 ])); printLn ( toString ( myMap [ balance2 ])); printLn ( toString ( myMap [ balance3 ])); endfunction Note Coming soon: common Map operations. StructuredData types A StructuredData type is another map type containing key/value pairs. The main difference with Map is that a StructuredData type will always be able to generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( key1 , 200 i32 ); data . set ( key2 , 500u64 ); data . set ( key3 , hello world ); printLn ( toString ( data . getInt32 ( key1 ))); printLn ( toString ( data . getUInt64 ( key2 ))); printLn ( data . getString ( key3 )); endfunction States A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI ledger shards. Unique identifiers for ledger data are created at State construction time. Declare and initialise a State type with State ValueType where values set with set() are mapped to the unique ledger identifier account : var myState = State Int32 ( account ) ; Getters and setters are available for State types. function main () var myState = State Int32 ( account ); myState . set ( 10 ); printLn ( My state var value = + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState A ShardedState is also used for reading and writing data to the Fetch.AI ledger. However, it is much more efficient and powerful. ShardedState uses State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with keys and values. In the following code, we create a ShardedState , set() a key/value pair on it, and finally we print the value using get() on a key with a default value. function main () var myShardedState = ShardedState Int32 ( account1 ); myShardedState . set ( salary , 45000 i32 ); printLn ( toString ( myShardedState . get ( salary , 0 i32 ))); endfunction Find out more about etch ShardedStates here . Addresses The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); endfunction Find out more about etch Addresses here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths libraries and functions . For more details on the machine learning implementations, please check the section on machine learning and artificial intelligence . Type casting If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to Type Name to type cast. There is no implicit type casting in etch . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // float casting var float64bit = 42.0 ; // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( float64bit ); // cast to Float64 var float64variable = toFloat64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Type Memory size Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Bool 1 byte String 8 bytes + length character size (changing with UTF-8) Array 8 bytes + length x element size Map 8 bytes + n x (key + value) storage Address 32 bytes Currently, there is a 2 unit charge per 1 byte of ledger storage. Scope etch has no global variables. Null Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array Int32 = null ; var myMap : Map Int32 , Int32 = null ; var myState : State Int32 = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Variables"},{"location":"etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at * , expected variable name // var 123 = 5; // error at 123 , expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction","title":"Naming"},{"location":"etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-64 bits (1 to 8 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations including any errors on operations currently unsupported. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); // error: unable to find matching function for toString var int8b : Int8 = - 0 i8 ; printLn ( toString ( int8b )); // error: unable to find matching function for toString var int16a = 0 i16 ; printLn ( toString ( int16a )); // error: unable to find matching function for toString var int16b : Int16 = - 1 i16 ; printLn ( toString ( int16b )); // error: unable to find matching function for toString endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; printLn ( toString ( uint8a )); // error: unable to find matching function for toString var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); // error: unable to find matching function for toString var uint16a = 0u16 ; printLn ( toString ( uint16a )); // error: unable to find matching function for toString var uint16b : UInt16 = 1u16 ; printLn ( toString ( uint16b )); // error: unable to find matching function for toString endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction In the current version, UInt256 is built from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction","title":"Integers"},{"location":"etch-language/variables/#floats","text":"Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Unspecified floats default to Float64 . A Float declared with f is Float32 . Float types are declared as Float32 , Float64 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); endfunction","title":"Floats"},{"location":"etch-language/variables/#fixed-points","text":"Fixed point variables are available as Fixed32 and Fixed64 types. You must declare FixedPoint variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = 2.0f p32 ; var fixed64bit = 3.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction","title":"Fixed Points"},{"location":"etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = hello ; var myInferredString = hello again ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array Type (size) declares an array with elements of type Type and size size . function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 4 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"etch-language/variables/#buffer","text":"Create a Buffer byte array type like this: var myBuffer = Buffer ( 8 );","title":"Buffer"},{"location":"etch-language/variables/#maps","text":"Declare the dictionary Map type with Map KeyType, ValueType () . function main () var myMap = Map String , Int32 (); myMap [ balance1 ] = 1000 ; myMap [ balance2 ] = 2000 ; myMap [ balance3 ] = 3000 ; printLn ( toString ( myMap [ balance1 ])); printLn ( toString ( myMap [ balance2 ])); printLn ( toString ( myMap [ balance3 ])); endfunction Note Coming soon: common Map operations.","title":"Maps"},{"location":"etch-language/variables/#structureddata-types","text":"A StructuredData type is another map type containing key/value pairs. The main difference with Map is that a StructuredData type will always be able to generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( key1 , 200 i32 ); data . set ( key2 , 500u64 ); data . set ( key3 , hello world ); printLn ( toString ( data . getInt32 ( key1 ))); printLn ( toString ( data . getUInt64 ( key2 ))); printLn ( data . getString ( key3 )); endfunction","title":"StructuredData types"},{"location":"etch-language/variables/#states","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI ledger shards. Unique identifiers for ledger data are created at State construction time. Declare and initialise a State type with State ValueType where values set with set() are mapped to the unique ledger identifier account : var myState = State Int32 ( account ) ; Getters and setters are available for State types. function main () var myState = State Int32 ( account ); myState . set ( 10 ); printLn ( My state var value = + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"States"},{"location":"etch-language/variables/#shardedstate","text":"A ShardedState is also used for reading and writing data to the Fetch.AI ledger. However, it is much more efficient and powerful. ShardedState uses State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with keys and values. In the following code, we create a ShardedState , set() a key/value pair on it, and finally we print the value using get() on a key with a default value. function main () var myShardedState = ShardedState Int32 ( account1 ); myShardedState . set ( salary , 45000 i32 ); printLn ( toString ( myShardedState . get ( salary , 0 i32 ))); endfunction Find out more about etch ShardedStates here .","title":"ShardedState"},{"location":"etch-language/variables/#addresses","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); endfunction Find out more about etch Addresses here .","title":"Addresses"},{"location":"etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths libraries and functions . For more details on the machine learning implementations, please check the section on machine learning and artificial intelligence .","title":"Mathematical, ML, and AI"},{"location":"etch-language/variables/#type-casting","text":"If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to Type Name to type cast. There is no implicit type casting in etch . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // float casting var float64bit = 42.0 ; // cast to Int8 var intFVariable = toInt32 ( float64bit ); // cast to Float32 var float32Variable = toFloat32 ( float64bit ); // cast to Float64 var float64variable = toFloat64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Type Memory size Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Bool 1 byte String 8 bytes + length character size (changing with UTF-8) Array 8 bytes + length x element size Map 8 bytes + n x (key + value) storage Address 32 bytes Currently, there is a 2 unit charge per 1 byte of ledger storage.","title":"Data size"},{"location":"etch-language/variables/#scope","text":"etch has no global variables.","title":"Scope"},{"location":"etch-language/variables/#null","text":"Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array Int32 = null ; var myMap : Map Int32 , Int32 = null ; var myState : State Int32 = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Default values"},{"location":"etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( Hello, everyone. Let s do some drawing. ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can t *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn( A-TEST: Wish we didn t see this - + toString(i)); endfor for ( i in 0 : 1 ) // printLn( B-TEST: And this should be once, but it s twice - + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array Int32 ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we re in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop flipFlop )) var logoLine : String = ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + ; else logoLine = logoLine + * ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( Mandelbrot Set ); // // The screen size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array String ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Float64 = 32.0 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Float64 = toFloat64 ( pixelX ); xLocal = (( xLocal / toFloat64 ( xMax )) * 3.5 ) - 2.5 ; // // Now Y to -1 to 1: var yLocal : Float64 = toFloat64 ( pixelY ); yLocal = yLocal / toFloat64 ( yMax ); // // Now let s do the algorithm bit: var x : Float64 = 0.0 ; var y : Float64 = 0.0 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) = 4.0 iteration maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Float64 = ( toFloat64 ( iteration ) / toFloat64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = ; if ( colourIndex 2 ) insertCharacter = ; elseif ( colourIndex 6 ) insertCharacter = . ; elseif ( colourIndex 10 ) insertCharacter = ; elseif ( colourIndex 20 ) insertCharacter = + ; else insertCharacter = * ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + is in the list? : + toString ( found )); endfunction function linear_search ( an_array : Array Int32 , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + is in the list? : + toString ( found )); endfunction function binary_search ( an_array : Array Int32 , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start = end found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + is in the list? : + toString ( found )); endfunction function linear_search ( an_array : Array Int32 , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + is in the list? : + toString ( found )); endfunction function binary_search ( an_array : Array Int32 , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start = end found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( Unsorted: ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); bubble_sort ( myArray ); print ( Sorted: ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); endfunction function bubble_sort ( an_array : Array Int32 ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 2 ) if ( an_array [ i ] an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( Unsorted: ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); insertion_sort ( myArray ); print ( Sorted: ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); endfunction function insertion_sort ( an_array : Array Int32 ) for ( index in 1 : an_array . count () - 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position 1 ) ( an_array [ position - 1 ] currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () var a_list = Array UInt32 ( 15 ); for ( i in 0 : a_list . count () - 1 ) a_list [ i ] = Rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array UInt32 ) // print ( Splitting ); printLn ( a_list ); if ( a_list . count () 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array UInt32 ( mid ); var right_half = Array UInt32 ( a_list . count () - mid ); for ( x in 0 : mid - 1 ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count () - 1 ) right_half [ y - mid ] = a_list [ y ]; endfor // print( Left half ); printLn(left_half); // print( Right half ); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i left_half . count () j right_half . count ()) if ( left_half [ i ] right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print( Merging ); printLn(a_list); endfunction Quick sort Note Coming soon.","title":"Sorting algorithms"},{"location":"etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( Unsorted: ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); bubble_sort ( myArray ); print ( Sorted: ); for ( i in 0 : myArray . count () - 1 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); endfunction function bubble_sort ( an_array : Array Int32 ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 2 ) if ( an_array [ i ] an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array Int32 ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( Unsorted: ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); insertion_sort ( myArray ); print ( Sorted: ); for ( i in 0 : 4 ) print ( toString ( myArray [ i ]) + ); endfor printLn ( ); endfunction function insertion_sort ( an_array : Array Int32 ) for ( index in 1 : an_array . count () - 1 ) var currentvalue = an_array [ index ]; var position = index ; while (( position 1 ) ( an_array [ position - 1 ] currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () var a_list = Array UInt32 ( 15 ); for ( i in 0 : a_list . count () - 1 ) a_list [ i ] = Rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array UInt32 ) // print ( Splitting ); printLn ( a_list ); if ( a_list . count () 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array UInt32 ( mid ); var right_half = Array UInt32 ( a_list . count () - mid ); for ( x in 0 : mid - 1 ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count () - 1 ) right_half [ y - mid ] = a_list [ y ]; endfor // print( Left half ); printLn(left_half); // print( Right half ); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i left_half . count () j right_half . count ()) if ( left_half [ i ] right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print( Merging ); printLn(a_list); endfunction","title":"Merge sort"},{"location":"etch-language/examples/sorting-algorithms/#quick-sort","text":"Note Coming soon.","title":"Quick sort"},{"location":"getting-started/installation-mac/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = /usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1` Add the git alias: git config --global alias.pullall !f(){ git pull $@ git submodule sync --recursive git submodule update --init --recursive; }; f Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"MacOS"},{"location":"getting-started/installation-mac/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"getting-started/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = /usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1` Add the git alias: git config --global alias.pullall !f(){ git pull $@ git submodule sync --recursive git submodule update --init --recursive; }; f","title":"Initial setup"},{"location":"getting-started/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Build the ledger"},{"location":"getting-started/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"getting-started/installation-mac/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Run a local node"},{"location":"getting-started/installation-redhat/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Redhat is not currently supported. Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Redhat"},{"location":"getting-started/installation-redhat/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-redhat/#supported-platforms","text":"Redhat is not currently supported.","title":"Supported platforms"},{"location":"getting-started/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"getting-started/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Build the ledger"},{"location":"getting-started/installation-redhat/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Run a local node"},{"location":"getting-started/installation-ubuntu/","text":"Building the Fetch.AI components Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Ubuntu 18.04 (x86_64) Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall !f(){ git pull $@ git submodule sync --recursive git submodule update --init --recursive; }; f Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang Run a local node Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Ubuntu"},{"location":"getting-started/installation-ubuntu/#building-the-fetchai-components","text":"Currently, the Fetch.AI ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-ubuntu/#supported-platforms","text":"Ubuntu 18.04 (x86_64)","title":"Supported platforms"},{"location":"getting-started/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall !f(){ git pull $@ git submodule sync --recursive git submodule update --init --recursive; }; f","title":"Initial setup"},{"location":"getting-started/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.5.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the vm-lang library: make vm-lang","title":"Build the ledger"},{"location":"getting-started/installation-ubuntu/#run-a-local-node","text":"Go to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Run a local node"},{"location":"getting-started/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Open Economic Framework"},{"location":"getting-started/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"getting-started/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"getting-started/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"getting-started/python-api-install/","text":"Download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.5.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Python Ledger API"},{"location":"getting-started/versions/","text":"While we continue to work on developing separate applications for the Fetch.AI Ledger, Python Ledger API, and the Fetch.AI Open Economic Framework, it's important to make sure all running versions match up. For example: fetchai / ledger release / v0 .5 . x fetchai / ledger - api - py release / v0 .5 . x fetchai / oef - search - pluto master Against these, follow the documentation in line with the same versions. The documentation you are reading now is from version: fetchai / docs release / v0 .5 . x","title":"Versions"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.AI decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.AI blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"What is the OEF?"},{"location":"oef/advertising/","text":"Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( title , str , True , The title of the book. ) attr_author = AttributeSchema ( author , str , True , The author of the book. ) attr_genre = AttributeSchema ( genre , str , True , The genre of the book. ) attr_year = AttributeSchema ( year , int , True , The year of publication of the book. ) attr_avg_rat = AttributeSchema ( average_rating , float , False , The average rating of the book. ) attr_isbn = AttributeSchema ( ISBN , str , True , The ISBN. ) attr_ebook = AttributeSchema ( ebook_available , bool , False , If the book can be sold as an e-book. ) attr_bookshop = AttributeSchema ( bookshop_pos , Location , False , The location of the bookshop where you can find the book ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( book , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], A data model to describe books. ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ title : It , author : Stephen King , genre : horror , year : 1986 , average_rating : 4.5 , ISBN : 0-670-81302-8 , ebook_available : True , bookshop_pos : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ title : 1984 , author : George Orwell , genre : novel , year : 1949 , ISBN : 978-0451524935 , ebook_available : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( wind_speed , bool , is_attribute_required = True , attribute_description = Provides wind speed measurements. ) TEMPERATURE_ATTR = AttributeSchema ( temperature , bool , is_attribute_required = True , attribute_description = Provides temperature measurements. ) AIR_PRESSURE_ATTR = AttributeSchema ( air_pressure , bool , is_attribute_required = True , attribute_description = Provides air pressure measurements. ) HUMIDITY_ATTR = AttributeSchema ( humidity , bool , is_attribute_required = True , attribute_description = Provides humidity measurements. ) WEATHER_DATA_MODEL = DataModel ( weather_data , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], All possible weather data. ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { wind_speed : False , temperature : True , air_pressure : True , humidity : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( title , str , True , The title of the book. ) attr_author = AttributeSchema ( author , str , True , The author of the book. ) attr_genre = AttributeSchema ( genre , str , True , The genre of the book. ) attr_year = AttributeSchema ( year , int , True , The year of publication of the book. ) attr_avg_rat = AttributeSchema ( average_rating , float , False , The average rating of the book. ) attr_isbn = AttributeSchema ( ISBN , str , True , The ISBN. ) attr_ebook = AttributeSchema ( ebook_available , bool , False , If the book can be sold as an e-book. ) attr_bookshop = AttributeSchema ( bookshop_pos , Location , False , The location of the bookshop where you can find the book )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( book , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], A data model to describe books. ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ title : It , author : Stephen King , genre : horror , year : 1986 , average_rating : 4.5 , ISBN : 0-670-81302-8 , ebook_available : True , bookshop_pos : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ title : 1984 , author : George Orwell , genre : novel , year : 1949 , ISBN : 978-0451524935 , ebook_available : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( wind_speed , bool , is_attribute_required = True , attribute_description = Provides wind speed measurements. ) TEMPERATURE_ATTR = AttributeSchema ( temperature , bool , is_attribute_required = True , attribute_description = Provides temperature measurements. ) AIR_PRESSURE_ATTR = AttributeSchema ( air_pressure , bool , is_attribute_required = True , attribute_description = Provides air pressure measurements. ) HUMIDITY_ATTR = AttributeSchema ( humidity , bool , is_attribute_required = True , attribute_description = Provides humidity measurements. ) WEATHER_DATA_MODEL = DataModel ( weather_data , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], All possible weather data. ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { wind_speed : False , temperature : True , air_pressure : True , humidity : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) - str : Returns a 219 character public key in base58 format return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) - bytes : Sign data with your own private key. :param data: the data to sign :return: the signature digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) - bool : Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Get a public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the API.","title":"Python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register to the OEF. Agents are created with a name and public key and they connect to the OEF with an OEF host and port number. On attempting to connect to the OEF, the public key is verified. Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Get the SDK"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( author , Eq ( Stephen King )) # all the books that are not of the genre Horror Constraint ( genre , NotEq ( Horror )) # all the books published before 1990 Constraint ( year , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( year , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( average_rating , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( year , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( genre , In ([ horror , science fiction , non-fiction ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( year , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between A and B (alphanumeric order) Constraint ( title , Range (( A , B ))) # all the books that have been published between 1960 and 1970 Constraint ( genre , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( position , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ position : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ position : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( year , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 subexpressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between I and J (alphanumeric order) but not equal to It And ([ Constraint ( title , Range (( I , J ))), Constraint ( title , NotEq ( It ))]) Or Or allows you to specify a disjunction of constraints. The number of subexpressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( year , Lt ( 1960 )), Constraint ( year , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( author , Eq ( Stephen King )), Constraint ( year , Gt ( 1990 )), Constraint ( ebook_available , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( author , Eq ( Stephen King )), Constraint ( year , Gt ( 1990 )), Constraint ( ebook_available , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ author : Stephen King , year : 1991 , ebook_available : True })) # True q . check ( Description ({ author : George Orwell , year : 1948 , ebook_available : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( foo , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( author , Eq ( Stephen King )), Constraint ( year , Gt ( 1990 )), Constraint ( ebook_available , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( foo , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"smart-contracts/data-types/","text":"The etch language provides a number of object types and functions designed specifically with smart contract development in mind. We detail these in the etch language guide but here's an overview. State A State provides persistent storage for smart contracts. The data referenced by a State type resides on the ledger. State values are available for use in smart contract functions. ShardedState A ShardedState is like a State type in that data contained within a ShardedState also resides on the ledger and is available for use in smart contract functions. However, ShardedState is a map of key/value pairs so can wrap significantly more data under one reference. Address The Address data structure formats multiple cryptographic public key types and includes a number of useful functions such as verify() and existed() . Cryptographic functions Currently, we support the SHA256() function.","title":"Data types"},{"location":"smart-contracts/data-types/#state","text":"A State provides persistent storage for smart contracts. The data referenced by a State type resides on the ledger. State values are available for use in smart contract functions.","title":"State"},{"location":"smart-contracts/data-types/#shardedstate","text":"A ShardedState is like a State type in that data contained within a ShardedState also resides on the ledger and is available for use in smart contract functions. However, ShardedState is a map of key/value pairs so can wrap significantly more data under one reference.","title":"ShardedState"},{"location":"smart-contracts/data-types/#address","text":"The Address data structure formats multiple cryptographic public key types and includes a number of useful functions such as verify() and existed() .","title":"Address"},{"location":"smart-contracts/data-types/#cryptographic-functions","text":"Currently, we support the SHA256() function.","title":"Cryptographic functions"},{"location":"smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node: rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = 127.0.0.1 PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( Balance Before: , api . tokens . balance ( your_identity )) # create the balance print ( Submitting wealth creation... ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( Balance after wealth: , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( Submitting transfer... ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( Balance 1: , api . tokens . balance ( your_identity )) print ( Balance 2: , api . tokens . balance ( other_identity )) if __name__ == __main__ : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = @init function setup(owner : Address) var owner_balance = State UInt64 (owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State UInt64 (from); var to_account = State UInt64 (to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) = amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State UInt64 (address); return account.get(0u64); endfunction From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Test network You can run the examples on our test network, replacing the hostname and port. HOST: bootstrap.fetch.ai PORT: 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node: rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = 127.0.0.1 PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( Balance Before: , api . tokens . balance ( your_identity )) # create the balance print ( Submitting wealth creation... ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( Balance after wealth: , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( Submitting transfer... ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( Balance 1: , api . tokens . balance ( your_identity )) print ( Balance 2: , api . tokens . balance ( other_identity )) if __name__ == __main__ : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = @init function setup(owner : Address) var owner_balance = State UInt64 (owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State UInt64 (from); var to_account = State UInt64 (to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) = amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State UInt64 (address); return account.get(0u64); endfunction From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST: bootstrap.fetch.ai PORT: 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = @problem function createProblem(data : Array StructuredData ) : Int32 var value = 0; for (i in 0:data.count() - 1) value += data[i].getInt32( value ); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : BigUInt) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State Int32 ( solution , 0); result.set(solution); endfunction def main (): # create the API api = LedgerApi ( 127.0.0.1 , 8000 ) # create an entity and provide it some wealth print ( Setup... ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( Setup...complete ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == __main__ : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic code"},{"location":"smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State Int32 ( balance ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = hustings ; var votes_for = State Int32 ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State Int32 ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State Int32 ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State Int32 ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivize code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState Int32 ( votes_for ); fors . set ( Alice , increment ( fors . get ( Alice , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State Int32 ( balance ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = hustings ; var votes_for = State Int32 ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State Int32 ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State Int32 ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State Int32 ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivize code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState Int32 ( votes_for ); fors . set ( Alice , increment ( fors . get ( Alice , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Python environment"},{"location":"smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.AI smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the Fetch distributed ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using State data structures and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code. Fees Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Introduction"},{"location":"smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI ledger node are here . The Fetch.AI ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently.","title":"The Ledger"},{"location":"smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be better to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"smart-contracts/smart-contract-intro/#fees","text":"Fetch.AI charges developers for computation and storage of data on the ledger in a manner which incentivizes good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Fees"},{"location":"smart-contracts/smart-contracts/","text":"Etch smart contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . Smart contract code runs on the etch virtual machine. All ledger nodes maintain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract structure Smart contract functions are annotated depending on the activity they perform. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything you like. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. This happens once and once only at contract deployment. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State UInt64 ( owner ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); initialise ( owner ); endfunction @action The @action annotation signifies a function which performs a transaction. You cannot create a smart contract in etch without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State UInt64 ( from ); from_balance . set ( 1000u64 ); var to_balance = State UInt64 ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () = amount ) panic ( Argh! ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var user = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); transfer ( owner , user , 100u64 ); endfunction In the worst case, the above function needs two shards for data storage. @query Query functions are read-only functions that allow you to view data residing on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State UInt64 ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./vm-lang *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 : 8403000000000000 } Utility functions getBlockNumber() : returns the number of the current block in UInt64 . You need a node running to test this. As well as that, you can only get a result when the function is embedded within smart contract code in Python. Details for running a node are here . More details on the Python libraries for smart contracts are in the next sections.","title":"Etch smart contracts"},{"location":"smart-contracts/smart-contracts/#smart-contract-structure","text":"Smart contract functions are annotated depending on the activity they perform.","title":"Smart contract structure"},{"location":"smart-contracts/smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./vm-lang *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 : 8403000000000000 }","title":"Data confirmation"},{"location":"smart-contracts/smart-contracts/#utility-functions","text":"getBlockNumber() : returns the number of the current block in UInt64 . You need a node running to test this. As well as that, you can only get a result when the function is embedded within smart contract code in Python. Details for running a node are here . More details on the Python libraries for smart contracts are in the next sections.","title":"Utility functions"},{"location":"smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allow miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. All attempts at solving the problem form a Directed Acyclic Graph (DAG). The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Registered miners begin to solve the problem at the same time and the miner who solves the problem first wins the bounty associated with the problem. Note The winning miner is not necessarily the miner who verifies the block. Annotations etch synergetic contract code includes specific annotated functions. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution.","title":"Synergetic contracts"},{"location":"smart-contracts/synergetic/#annotations","text":"etch synergetic contract code includes specific annotated functions. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution.","title":"Annotations"},{"location":"smart-contracts/wallets/","text":"Fetch.AI wallet The Fetch.AI wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network. Fetch testnet To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens. Fetch public network Note In development.","title":"Wallets"},{"location":"smart-contracts/wallets/#fetchai-wallet","text":"The Fetch.AI wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network.","title":"Fetch.AI wallet"},{"location":"smart-contracts/wallets/#fetch-testnet","text":"To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens.","title":"Fetch testnet"},{"location":"smart-contracts/wallets/#fetch-public-network","text":"Note In development.","title":"Fetch public network"},{"location":"tutorials/erc20/","text":"Making an ERC20 contract The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Requirements The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State UInt256 ( total_supply ); supply_state.set(supply); var balance_state = State UInt256 (owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract. Queries The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State UInt256 ( total_supply ); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State UInt256 (owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance. Actions The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State UInt256 (from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance value) return false; endif var to_state = State UInt256 (to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens. Implementing allowance The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState UInt256 (spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState UInt256 (spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here .","title":"Create FET-20 contract"},{"location":"tutorials/erc20/#making-an-erc20-contract","text":"The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API.","title":"Making an ERC20 contract"},{"location":"tutorials/erc20/#requirements","text":"The ERC20 contract implements following functions: totalSupply() : UInt256 -- Get the total token supply. balanceOf(owner: Address): UInt256 -- Get the account balance of another account with address owner . transfer(to: Address, value: UInt256) : Bool -- Send value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool -- Send value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool -- Allow spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) -- Returns the amount which spender is still allowed to withdraw from owner . We will in the following implement most of these functions. As the Fetch.AI smart contracts do not have implicit addresses as in Ethereum, the function signatures are will be slightly different as will be seen below, but the overall functionality remains the same.","title":"Requirements"},{"location":"tutorials/erc20/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. This tells the ledger that this function should be invoked upon instating the contract: @init function createSupply(owner: Address, supply: UInt256) var supply_state = State UInt256 ( total_supply ); supply_state.set(supply); var balance_state = State UInt256 (owner); balance_state.set( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable such that the contract can be reused as well as to make it easy to write tests for the contract.","title":"Initialisation function"},{"location":"tutorials/erc20/#queries","text":"The ERC20 contract provides three query functions: totalSupply , balanceOf and allowance . We will define totalSupply and balanceOf in this section and dicuss allowance in a section later on. Both totalSupply and balanceOf are straightforward to implement. Total supply queries the State variable total_supply and returns it as a result: @query function totalSupply(): UInt256 var supply_state = State UInt256 ( total_supply ); return supply_state.get(0u64); endfunction balanceOf , on the other hand, makes a dynamic look up based on the address of owner : @qeury function balanceOf(owner: Address) : UInt256 var balance_state = State UInt256 (owner); if(!balance_state.existed()) return UInt256(0u64); endif return balance_state.get(UInt256(0u64)); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existance.","title":"Queries"},{"location":"tutorials/erc20/#actions","text":"The ERC20 contract defines three queries: transfer , transferFrom and approve . We will discuss approve in the next section. In Etch, transfer and transferFrom are one and the same function as Etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction needs to be checked within the @action : @action function transfer(from: Address, to: Address, value: UInt256) : Bool if(!from.signedTx()) return false; endif var from_state = State UInt256 (from); var from_balance = from_state.get( UInt256(0u64) ); if(from_balance value) return false; endif var to_state = State UInt256 (to); var to_balance = to_state.get( UInt256(0u64) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64(from_balance); var u_to = toUInt64(to_balance); var u_amount = toUInt64(value); u_from -= u_amount; u_to += u_amount; from_balance = UInt256(u_from); to_balance = UInt256(u_to); from_state.set(from_balance); to_state.set(to_balance); return true; endfunction The above demonstrates one of the simplest possible token contracts that can be implemented: It merely keeps a balance associated with each address and allows transfers from one address to the other if the address holds sufficient tokens.","title":"Actions"},{"location":"tutorials/erc20/#implementing-allowance","text":"The functions up until now constitute a basic token contract that allows creation of tokens and transfer between participants. The more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply definining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropiate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve(owner: Address, spender: Address, value: UInt256) : Bool var state = ShardedState UInt256 (spender); state.set(owner, value); return true; endfunction The above constructs object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, the StateShard does not keep a record of which entries exists and which not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight foward: @query function allowance(owner: Address, spender: Address) : UInt256 var state = ShardedState UInt256 (spender); return state.get(owner, UInt256(0u64)); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here .","title":"Implementing allowance"},{"location":"tutorials/erc721/","text":"Making an ERC721 contract In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256( hello world ); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState Address ( tokens.owner ); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State Array UInt256 (owner); // Storing the tokens on the owners address objects_state.set(tokens); Queries In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State Array UInt256 (owner); var tokens = objects_state.get( Array UInt256 (0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState Address ( tokens.owner ); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array. Actions The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic( Invalid signature from owner. ); endif var owner_state = ShardedState Address ( tokens.owner ); var owner = owner_state.get(toString(token_id)); if(owner != from) panic( Owner does not actually own the token ); endif var from_state = State Array UInt256 (from); var from_objects = from_state.get( Array UInt256 (0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic( Contract broken - token is only supposed be represented once. ); endif found = true; position = i; break; endif endfor if(!found) panic( Contract is fundamentally broken - owner has not been updated correctly ); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State Array UInt256 (to); var to_objects = to_state.get( Array UInt256 (0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here .","title":"Create FET-721 contract"},{"location":"tutorials/erc721/#making-an-erc721-contract","text":"In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in Etch. We will be using UInt256 for identifiers and SHA256 to generate the identifiers of the initial tokens. We will need two records: an Address record stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in Etch, and for the second we will use ShardedState .","title":"Making an ERC721 contract"},{"location":"tutorials/erc721/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: It generates a list of token ids. It creates a record of each token owner. It creates a record of the tokens that an owner has. The dual relationship is there to make lookups efficient, but comes at the price of twice the book keeping. As the first step we create the list of token ids: // Genereating tokens var token_id = UInt256( hello world ); for(i in 0:tokens.count()-1) var hasher = SHA256(); hasher.update(token_id); token_id = hasher.final(); tokens[i] = token_id; endfor Next we assign an owner: // Assigning owner var owner_state = ShardedState Address ( tokens.owner ); for(i in 0:tokens.count()-1) var tid = tokens[i]; owner_state.set(toString(tid), owner); endfor and finally, we store the list of tokens on the creators address: var objects_state = State Array UInt256 (owner); // Storing the tokens on the owners address objects_state.set(tokens);","title":"Initialisation function"},{"location":"tutorials/erc721/#queries","text":"In this section we will focus on the two functions which are needed to implement a wallet overview and token details view, namely balanceOf and ownerOf . Both of these functions are short and easy to implement. We first make it possible to query the balance: @query function balanceOf(owner: Address) : UInt256 var objects_state = State Array UInt256 (owner); var tokens = objects_state.get( Array UInt256 (0) ); var ret = UInt256( toUInt64(tokens.count()) ); return ret; endfunction Next, we make it possible to query the token owner. This is also a straight forward function to implement: @query function ownerOf(token_id: UInt256) : Address var owner_state = ShardedState Address ( tokens.owner ); return owner_state.get(toString(token_id)); endfunction With these two query functions, it is possible to implement a ERC-721 wallet on top of the smart ledger. It is possible to make several optimisations for these functions. For instance, by storing number of tokens separately, there would be no need to deserialize the full array.","title":"Queries"},{"location":"tutorials/erc721/#actions","text":"The standard ERC-721 contract has a number of different functions to transfer funds from one party to another. We will only implement one of these as they are all essentially variations of the same mechanism with more or less error checking built into them. We implement a single transfer function here: function transferFrom(from: Address, to: Address, token_id: UInt256) if(!from.signedTx()) panic( Invalid signature from owner. ); endif var owner_state = ShardedState Address ( tokens.owner ); var owner = owner_state.get(toString(token_id)); if(owner != from) panic( Owner does not actually own the token ); endif var from_state = State Array UInt256 (from); var from_objects = from_state.get( Array UInt256 (0) ); var found = false; var position : Int32; for(i in 0:from_objects.count()-1) var tid = from_objects[i]; if(tid == token_id) if(found) panic( Contract broken - token is only supposed be represented once. ); endif found = true; position = i; break; endif endfor if(!found) panic( Contract is fundamentally broken - owner has not been updated correctly ); endif from_objects[position] = from_objects[from_objects.count() - 1]; from_objects.popBack(); var to_state = State Array UInt256 (to); var to_objects = to_state.get( Array UInt256 (0) ); to_objects.append(token_id); // updating sender from_state.set(from_objects); // Updating receiver to_state.set(to_objects); // Updating owner owner = to; owner_state.set(toString(token_id), owner); endfunction The above implementation only requires sender to sign the transaction, but could easily be extended to also requiring the receiver to sign. The full contract can be found here .","title":"Actions"},{"location":"tutorials/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"tutorials/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"tutorials/smart-contract-in-stages/","text":"Smart contract in stages Let's look at the three Python scripts in the contract_in_stages directory. The first script 01_create_private_key.py creates an Entity object and inserts the private key from the private.key file in the same directory. Once this is done, the script gives the Entity 10000 tokens. def main (): print ( Creating private key... ) # create our first private key pair entity1 = Entity () # save the private key to disk with open ( private.key , w ) as private_key_file : entity1 . dump ( private_key_file ) print ( Creating private key...complete ) # build the ledger API api = LedgerApi ( 127.0.0.1 , 8100 ) print ( Creating initial balance... ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) print ( Creating initial balance...complete ) In the 02_create_contract.py file, we embed the etch smart contract code into the script as a string. We have an init() function which receives an Address object and sets its balance to 1000000 tokens in a State variable. The transfer() function grabs or creates the State objects from two Address objects. After a check to make sure there are enough funds in the from_account, the from_account transfers the amount to the to_account . The query() function allows you to query the balance of an Address on the ledger via a State construct. @ init function setup ( owner : Address ) var owner_balance = State UInt64 ( owner ); owner_balance . set ( 1000000u64 ); endfunction @ action function transfer ( from : Address , to : Address , amount : UInt64 ) // define the accounts var from_account = State UInt64 ( from ); var to_account = State UInt64 ( to ); // if new sets to 0u // Check if the sender has enough balance to proceed if ( from_account . get () = amount ) // update the account balances from_account . set ( from_account . get () - amount ); to_account . set ( to_account . get ( 0u64 ) + amount ); endif endfunction @ query function balance ( address : Address ) : UInt64 var account = State UInt64 ( address ); return account . get ( 0u64 ); endfunction The Python script loads the private key created in the first step, connects to the running ledger node, and deploys the contract to the ledger paying 2000 tokens to do so and designating entity1 as the owner of the contract. def main (): print ( Loading private key... ) # load up the previously created private key with open ( private.key , r ) as private_key_file : entity1 = Entity . load ( private_key_file ) print ( Loading private key...complete ) # build the ledger API api = LedgerApi ( 127.0.0.1 , 8100 ) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) print ( Deploying contract... ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) print ( Deploying contract...complete ) # save the contract to the disk with open ( sample.contract , w ) as contract_file : contract . dump ( contract_file ) In 03_transfer.py we load up the demo private key and the smart contract file. Note Remember, the smart contract is now on the ledger and can be referenced with the correct hash. We then perform a transfer using the contract code between the owner and a new user we create as entity2 . def main (): # load up the previously created private key with open ( private.key , r ) as private_key_file : entity1 = Entity . load ( private_key_file ) # load up the deployed contract with open ( sample.contract , r ) as contract_file : contract = SmartContract . load ( contract_file ) # for the purposes of this example create a second private key pair to transfer funds to entity2 = Entity () # build the ledger API api = LedgerApi ( 127.0.0.1 , 8100 ) # print the current status of all the tokens print ( -- BEFORE -- ) print_address_balances ( api , contract , [ entity1 , entity2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , transfer , fet_tx_fee , [ entity1 ], Address ( entity1 ), Address ( entity2 ), tok_transfer_amount )) print ( -- AFTER -- ) print_address_balances ( api , contract , [ entity1 , entity2 ]) You should see a result like this: -- BEFORE -- Address0: 8540 bFET 1000000 TOK Address1: 0 bFET 0 TOK -- AFTER -- Address0: 8508 bFET 999800 TOK Address1: 0 bFET 200 TOK","title":"Smart contract in stages"},{"location":"tutorials/submitting_contract/","text":"Developing smart contracts Let's develop a simple Hello world contract and submit it to a running local ledger node. Hello world with vm-lang Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = world ; var state = State String ( greetings ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State String ( greetings ); return Hello, + state . get () + ! ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != Hello, world! ) panic ( Greeting differed from expected message. ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Submitting the contract to the ledger To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( 127.0.0.1 , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , persistentGreeting )) This should produce a Hello world! message.","title":"Hello world smart contract"},{"location":"tutorials/submitting_contract/#developing-smart-contracts","text":"Let's develop a simple Hello world contract and submit it to a running local ledger node.","title":"Developing smart contracts"},{"location":"tutorials/submitting_contract/#hello-world-with-vm-lang","text":"Our demo smart contract has two functions. The initialisation function etches a {name} onto the state database. Then, a query function allows us to query the state database for the {name} . @init function createMessage ( owner : Address ) var name : String = world ; var state = State String ( greetings ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State String ( greetings ); return Hello, + state . get () + ! ; endfunction Let's use the vm-lang simulator for the development process. We need a main function that vm-lang can invoke: @testCase function main () var account = Address ( 2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9 ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != Hello, world! ) panic ( Greeting differed from expected message. ); endif printLn ( greeting ); endfunction You can test this contract with the vm-lang executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/vm-lang/vm-lang hello_world.etch This produces an output similar to: F E \u2571 vm-lang v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! vm-lang executes main as the default runner function. When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with vm-lang"},{"location":"tutorials/submitting_contract/#submitting-the-contract-to-the-ledger","text":"To submit the contract to the ledger, we use the Python API. The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect using the API and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( 127.0.0.1 , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( source ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , persistentGreeting )) This should produce a Hello world! message.","title":"Submitting the contract to the ledger"}]}